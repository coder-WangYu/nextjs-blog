"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-router";
exports.ids = ["vendor-chunks/react-router"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-router/dist/development/dom-export.js":
/*!******************************************************************!*\
  !*** ./node_modules/react-router/dist/development/dom-export.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * react-router v7.6.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ \nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\nvar __copyProps = (to, from, except, desc)=>{\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n            get: ()=>from[key],\n            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n        });\n    }\n    return to;\n};\nvar __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n        value: mod,\n        enumerable: true\n    }) : target, mod));\nvar __toCommonJS = (mod)=>__copyProps(__defProp({}, \"__esModule\", {\n        value: true\n    }), mod);\n// dom-export.ts\nvar dom_export_exports = {};\n__export(dom_export_exports, {\n    HydratedRouter: ()=>HydratedRouter,\n    RouterProvider: ()=>RouterProvider\n});\nmodule.exports = __toCommonJS(dom_export_exports);\n// lib/dom-export/dom-router-provider.tsx\nvar React = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar ReactDOM = __toESM(__webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\"));\nvar import_react_router = __webpack_require__(/*! react-router */ \"(ssr)/./node_modules/react-router/dist/development/index.js\");\nfunction RouterProvider(props) {\n    return /* @__PURE__ */ React.createElement(import_react_router.RouterProvider, {\n        flushSync: ReactDOM.flushSync,\n        ...props\n    });\n}\n// lib/dom-export/hydrated-router.tsx\nvar React2 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar import_react_router2 = __webpack_require__(/*! react-router */ \"(ssr)/./node_modules/react-router/dist/development/index.js\");\nvar ssrInfo = null;\nvar router = null;\nfunction initSsrInfo() {\n    if (!ssrInfo && window.__reactRouterContext && window.__reactRouterManifest && window.__reactRouterRouteModules) {\n        if (window.__reactRouterManifest.sri === true) {\n            const importMap = document.querySelector(\"script[rr-importmap]\");\n            if (importMap?.textContent) {\n                try {\n                    window.__reactRouterManifest.sri = JSON.parse(importMap.textContent).integrity;\n                } catch (err) {\n                    console.error(\"Failed to parse import map\", err);\n                }\n            }\n        }\n        ssrInfo = {\n            context: window.__reactRouterContext,\n            manifest: window.__reactRouterManifest,\n            routeModules: window.__reactRouterRouteModules,\n            stateDecodingPromise: void 0,\n            router: void 0,\n            routerInitialized: false\n        };\n    }\n}\nfunction createHydratedRouter({ unstable_getContext }) {\n    initSsrInfo();\n    if (!ssrInfo) {\n        throw new Error(\"You must be using the SSR features of React Router in order to skip passing a `router` prop to `<RouterProvider>`\");\n    }\n    let localSsrInfo = ssrInfo;\n    if (!ssrInfo.stateDecodingPromise) {\n        let stream = ssrInfo.context.stream;\n        (0, import_react_router2.UNSAFE_invariant)(stream, \"No stream found for single fetch decoding\");\n        ssrInfo.context.stream = void 0;\n        ssrInfo.stateDecodingPromise = (0, import_react_router2.UNSAFE_decodeViaTurboStream)(stream, window).then((value)=>{\n            ssrInfo.context.state = value.value;\n            localSsrInfo.stateDecodingPromise.value = true;\n        }).catch((e)=>{\n            localSsrInfo.stateDecodingPromise.error = e;\n        });\n    }\n    if (ssrInfo.stateDecodingPromise.error) {\n        throw ssrInfo.stateDecodingPromise.error;\n    }\n    if (!ssrInfo.stateDecodingPromise.value) {\n        throw ssrInfo.stateDecodingPromise;\n    }\n    let routes = (0, import_react_router2.UNSAFE_createClientRoutes)(ssrInfo.manifest.routes, ssrInfo.routeModules, ssrInfo.context.state, ssrInfo.context.ssr, ssrInfo.context.isSpaMode);\n    let hydrationData = void 0;\n    if (ssrInfo.context.isSpaMode) {\n        let { loaderData } = ssrInfo.context.state;\n        if (ssrInfo.manifest.routes.root?.hasLoader && loaderData && \"root\" in loaderData) {\n            hydrationData = {\n                loaderData: {\n                    root: loaderData.root\n                }\n            };\n        }\n    } else {\n        hydrationData = (0, import_react_router2.UNSAFE_getHydrationData)(ssrInfo.context.state, routes, (routeId)=>({\n                clientLoader: ssrInfo.routeModules[routeId]?.clientLoader,\n                hasLoader: ssrInfo.manifest.routes[routeId]?.hasLoader === true,\n                hasHydrateFallback: ssrInfo.routeModules[routeId]?.HydrateFallback != null\n            }), window.location, window.__reactRouterContext?.basename, ssrInfo.context.isSpaMode);\n        if (hydrationData && hydrationData.errors) {\n            hydrationData.errors = (0, import_react_router2.UNSAFE_deserializeErrors)(hydrationData.errors);\n        }\n    }\n    let router2 = (0, import_react_router2.UNSAFE_createRouter)({\n        routes,\n        history: (0, import_react_router2.UNSAFE_createBrowserHistory)(),\n        basename: ssrInfo.context.basename,\n        unstable_getContext,\n        hydrationData,\n        hydrationRouteProperties: import_react_router2.UNSAFE_hydrationRouteProperties,\n        mapRouteProperties: import_react_router2.UNSAFE_mapRouteProperties,\n        future: {\n            unstable_middleware: ssrInfo.context.future.unstable_middleware\n        },\n        dataStrategy: (0, import_react_router2.UNSAFE_getTurboStreamSingleFetchDataStrategy)(()=>router2, ssrInfo.manifest, ssrInfo.routeModules, ssrInfo.context.ssr, ssrInfo.context.basename),\n        patchRoutesOnNavigation: (0, import_react_router2.UNSAFE_getPatchRoutesOnNavigationFunction)(ssrInfo.manifest, ssrInfo.routeModules, ssrInfo.context.ssr, ssrInfo.context.routeDiscovery, ssrInfo.context.isSpaMode, ssrInfo.context.basename)\n    });\n    ssrInfo.router = router2;\n    if (router2.state.initialized) {\n        ssrInfo.routerInitialized = true;\n        router2.initialize();\n    }\n    router2.createRoutesForHMR = /* spacer so ts-ignore does not affect the right hand of the assignment */ import_react_router2.UNSAFE_createClientRoutesWithHMRRevalidationOptOut;\n    window.__reactRouterDataRouter = router2;\n    return router2;\n}\nfunction HydratedRouter(props) {\n    if (!router) {\n        router = createHydratedRouter({\n            unstable_getContext: props.unstable_getContext\n        });\n    }\n    let [criticalCss, setCriticalCss] = React2.useState( true ? ssrInfo?.context.criticalCss : 0);\n    if (true) {\n        if (ssrInfo) {\n            window.__reactRouterClearCriticalCss = ()=>setCriticalCss(void 0);\n        }\n    }\n    let [location, setLocation] = React2.useState(router.state.location);\n    React2.useLayoutEffect(()=>{\n        if (ssrInfo && ssrInfo.router && !ssrInfo.routerInitialized) {\n            ssrInfo.routerInitialized = true;\n            ssrInfo.router.initialize();\n        }\n    }, []);\n    React2.useLayoutEffect(()=>{\n        if (ssrInfo && ssrInfo.router) {\n            return ssrInfo.router.subscribe((newState)=>{\n                if (newState.location !== location) {\n                    setLocation(newState.location);\n                }\n            });\n        }\n    }, [\n        location\n    ]);\n    (0, import_react_router2.UNSAFE_invariant)(ssrInfo, \"ssrInfo unavailable for HydratedRouter\");\n    (0, import_react_router2.UNSAFE_useFogOFWarDiscovery)(router, ssrInfo.manifest, ssrInfo.routeModules, ssrInfo.context.ssr, ssrInfo.context.routeDiscovery, ssrInfo.context.isSpaMode);\n    return(// This fragment is important to ensure we match the <ServerRouter> JSX\n    // structure so that useId values hydrate correctly\n    /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement(import_react_router2.UNSAFE_FrameworkContext.Provider, {\n        value: {\n            manifest: ssrInfo.manifest,\n            routeModules: ssrInfo.routeModules,\n            future: ssrInfo.context.future,\n            criticalCss,\n            ssr: ssrInfo.context.ssr,\n            isSpaMode: ssrInfo.context.isSpaMode,\n            routeDiscovery: ssrInfo.context.routeDiscovery\n        }\n    }, /* @__PURE__ */ React2.createElement(import_react_router2.UNSAFE_RemixErrorBoundary, {\n        location\n    }, /* @__PURE__ */ React2.createElement(RouterProvider, {\n        router\n    }))), /* @__PURE__ */ React2.createElement(React2.Fragment, null)));\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2Rpc3QvZGV2ZWxvcG1lbnQvZG9tLWV4cG9ydC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7O0NBU0MsR0FDWTtBQUNiLElBQUlBLFdBQVdDLE9BQU9DLE1BQU07QUFDNUIsSUFBSUMsWUFBWUYsT0FBT0csY0FBYztBQUNyQyxJQUFJQyxtQkFBbUJKLE9BQU9LLHdCQUF3QjtBQUN0RCxJQUFJQyxvQkFBb0JOLE9BQU9PLG1CQUFtQjtBQUNsRCxJQUFJQyxlQUFlUixPQUFPUyxjQUFjO0FBQ3hDLElBQUlDLGVBQWVWLE9BQU9XLFNBQVMsQ0FBQ0MsY0FBYztBQUNsRCxJQUFJQyxXQUFXLENBQUNDLFFBQVFDO0lBQ3RCLElBQUssSUFBSUMsUUFBUUQsSUFDZmIsVUFBVVksUUFBUUUsTUFBTTtRQUFFQyxLQUFLRixHQUFHLENBQUNDLEtBQUs7UUFBRUUsWUFBWTtJQUFLO0FBQy9EO0FBQ0EsSUFBSUMsY0FBYyxDQUFDQyxJQUFJQyxNQUFNQyxRQUFRQztJQUNuQyxJQUFJRixRQUFRLE9BQU9BLFNBQVMsWUFBWSxPQUFPQSxTQUFTLFlBQVk7UUFDbEUsS0FBSyxJQUFJRyxPQUFPbEIsa0JBQWtCZSxNQUNoQyxJQUFJLENBQUNYLGFBQWFlLElBQUksQ0FBQ0wsSUFBSUksUUFBUUEsUUFBUUYsUUFDekNwQixVQUFVa0IsSUFBSUksS0FBSztZQUFFUCxLQUFLLElBQU1JLElBQUksQ0FBQ0csSUFBSTtZQUFFTixZQUFZLENBQUVLLENBQUFBLE9BQU9uQixpQkFBaUJpQixNQUFNRyxJQUFHLEtBQU1ELEtBQUtMLFVBQVU7UUFBQztJQUN0SDtJQUNBLE9BQU9FO0FBQ1Q7QUFDQSxJQUFJTSxVQUFVLENBQUNDLEtBQUtDLFlBQVlkLFNBQVlBLENBQUFBLFNBQVNhLE9BQU8sT0FBTzVCLFNBQVNTLGFBQWFtQixRQUFRLENBQUMsR0FBR1IsWUFDbkcsc0VBQXNFO0lBQ3RFLGlFQUFpRTtJQUNqRSxzRUFBc0U7SUFD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bkQsSUFBR0QscUJBQXFCaUYsMkJBQTJCLEVBQ2xEL0UsUUFDQUQsUUFBUW1CLFFBQVEsRUFDaEJuQixRQUFRb0IsWUFBWSxFQUNwQnBCLFFBQVFrQixPQUFPLENBQUNrQixHQUFHLEVBQ25CcEMsUUFBUWtCLE9BQU8sQ0FBQytDLGNBQWMsRUFDOUJqRSxRQUFRa0IsT0FBTyxDQUFDbUIsU0FBUztJQUUzQixPQUNFLHVFQUF1RTtJQUN2RSxtREFBbUQ7SUFDbkQsYUFBYSxHQUFHdkMsT0FBT0YsYUFBYSxDQUFDRSxPQUFPbUYsUUFBUSxFQUFFLE1BQU0sYUFBYSxHQUFHbkYsT0FBT0YsYUFBYSxDQUM5RkcscUJBQXFCbUYsdUJBQXVCLENBQUNDLFFBQVEsRUFDckQ7UUFDRW5HLE9BQU87WUFDTG1DLFVBQVVuQixRQUFRbUIsUUFBUTtZQUMxQkMsY0FBY3BCLFFBQVFvQixZQUFZO1lBQ2xDdUMsUUFBUTNELFFBQVFrQixPQUFPLENBQUN5QyxNQUFNO1lBQzlCWTtZQUNBbkMsS0FBS3BDLFFBQVFrQixPQUFPLENBQUNrQixHQUFHO1lBQ3hCQyxXQUFXckMsUUFBUWtCLE9BQU8sQ0FBQ21CLFNBQVM7WUFDcEM0QixnQkFBZ0JqRSxRQUFRa0IsT0FBTyxDQUFDK0MsY0FBYztRQUNoRDtJQUNGLEdBQ0EsYUFBYSxHQUFHbkUsT0FBT0YsYUFBYSxDQUFDRyxxQkFBcUJxRix5QkFBeUIsRUFBRTtRQUFFckM7SUFBUyxHQUFHLGFBQWEsR0FBR2pELE9BQU9GLGFBQWEsQ0FBQ1IsZ0JBQWdCO1FBQUVhO0lBQU8sTUFDaEssYUFBYSxHQUFHSCxPQUFPRixhQUFhLENBQUNFLE9BQU9tRixRQUFRLEVBQUU7QUFFN0Q7QUFDQSw2REFBNkQ7QUFDN0QsS0FBTTVGLENBQUFBLENBR04iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMtc2hvcC8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZGlzdC9kZXZlbG9wbWVudC9kb20tZXhwb3J0LmpzPzc0M2MiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiByZWFjdC1yb3V0ZXIgdjcuNi4yXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoXG4gIC8vIElmIHRoZSBpbXBvcnRlciBpcyBpbiBub2RlIGNvbXBhdGliaWxpdHkgbW9kZSBvciB0aGlzIGlzIG5vdCBhbiBFU01cbiAgLy8gZmlsZSB0aGF0IGhhcyBiZWVuIGNvbnZlcnRlZCB0byBhIENvbW1vbkpTIGZpbGUgdXNpbmcgYSBCYWJlbC1cbiAgLy8gY29tcGF0aWJsZSB0cmFuc2Zvcm0gKGkuZS4gXCJfX2VzTW9kdWxlXCIgaGFzIG5vdCBiZWVuIHNldCksIHRoZW4gc2V0XG4gIC8vIFwiZGVmYXVsdFwiIHRvIHRoZSBDb21tb25KUyBcIm1vZHVsZS5leHBvcnRzXCIgZm9yIG5vZGUgY29tcGF0aWJpbGl0eS5cbiAgaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQsXG4gIG1vZFxuKSk7XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcblxuLy8gZG9tLWV4cG9ydC50c1xudmFyIGRvbV9leHBvcnRfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZG9tX2V4cG9ydF9leHBvcnRzLCB7XG4gIEh5ZHJhdGVkUm91dGVyOiAoKSA9PiBIeWRyYXRlZFJvdXRlcixcbiAgUm91dGVyUHJvdmlkZXI6ICgpID0+IFJvdXRlclByb3ZpZGVyXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKGRvbV9leHBvcnRfZXhwb3J0cyk7XG5cbi8vIGxpYi9kb20tZXhwb3J0L2RvbS1yb3V0ZXItcHJvdmlkZXIudHN4XG52YXIgUmVhY3QgPSBfX3RvRVNNKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgUmVhY3RET00gPSBfX3RvRVNNKHJlcXVpcmUoXCJyZWFjdC1kb21cIikpO1xudmFyIGltcG9ydF9yZWFjdF9yb3V0ZXIgPSByZXF1aXJlKFwicmVhY3Qtcm91dGVyXCIpO1xuZnVuY3Rpb24gUm91dGVyUHJvdmlkZXIocHJvcHMpIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KGltcG9ydF9yZWFjdF9yb3V0ZXIuUm91dGVyUHJvdmlkZXIsIHsgZmx1c2hTeW5jOiBSZWFjdERPTS5mbHVzaFN5bmMsIC4uLnByb3BzIH0pO1xufVxuXG4vLyBsaWIvZG9tLWV4cG9ydC9oeWRyYXRlZC1yb3V0ZXIudHN4XG52YXIgUmVhY3QyID0gX190b0VTTShyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIGltcG9ydF9yZWFjdF9yb3V0ZXIyID0gcmVxdWlyZShcInJlYWN0LXJvdXRlclwiKTtcbnZhciBzc3JJbmZvID0gbnVsbDtcbnZhciByb3V0ZXIgPSBudWxsO1xuZnVuY3Rpb24gaW5pdFNzckluZm8oKSB7XG4gIGlmICghc3NySW5mbyAmJiB3aW5kb3cuX19yZWFjdFJvdXRlckNvbnRleHQgJiYgd2luZG93Ll9fcmVhY3RSb3V0ZXJNYW5pZmVzdCAmJiB3aW5kb3cuX19yZWFjdFJvdXRlclJvdXRlTW9kdWxlcykge1xuICAgIGlmICh3aW5kb3cuX19yZWFjdFJvdXRlck1hbmlmZXN0LnNyaSA9PT0gdHJ1ZSkge1xuICAgICAgY29uc3QgaW1wb3J0TWFwID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcInNjcmlwdFtyci1pbXBvcnRtYXBdXCIpO1xuICAgICAgaWYgKGltcG9ydE1hcD8udGV4dENvbnRlbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB3aW5kb3cuX19yZWFjdFJvdXRlck1hbmlmZXN0LnNyaSA9IEpTT04ucGFyc2UoXG4gICAgICAgICAgICBpbXBvcnRNYXAudGV4dENvbnRlbnRcbiAgICAgICAgICApLmludGVncml0eTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBwYXJzZSBpbXBvcnQgbWFwXCIsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc3NySW5mbyA9IHtcbiAgICAgIGNvbnRleHQ6IHdpbmRvdy5fX3JlYWN0Um91dGVyQ29udGV4dCxcbiAgICAgIG1hbmlmZXN0OiB3aW5kb3cuX19yZWFjdFJvdXRlck1hbmlmZXN0LFxuICAgICAgcm91dGVNb2R1bGVzOiB3aW5kb3cuX19yZWFjdFJvdXRlclJvdXRlTW9kdWxlcyxcbiAgICAgIHN0YXRlRGVjb2RpbmdQcm9taXNlOiB2b2lkIDAsXG4gICAgICByb3V0ZXI6IHZvaWQgMCxcbiAgICAgIHJvdXRlckluaXRpYWxpemVkOiBmYWxzZVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGVkUm91dGVyKHtcbiAgdW5zdGFibGVfZ2V0Q29udGV4dFxufSkge1xuICBpbml0U3NySW5mbygpO1xuICBpZiAoIXNzckluZm8pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIllvdSBtdXN0IGJlIHVzaW5nIHRoZSBTU1IgZmVhdHVyZXMgb2YgUmVhY3QgUm91dGVyIGluIG9yZGVyIHRvIHNraXAgcGFzc2luZyBhIGByb3V0ZXJgIHByb3AgdG8gYDxSb3V0ZXJQcm92aWRlcj5gXCJcbiAgICApO1xuICB9XG4gIGxldCBsb2NhbFNzckluZm8gPSBzc3JJbmZvO1xuICBpZiAoIXNzckluZm8uc3RhdGVEZWNvZGluZ1Byb21pc2UpIHtcbiAgICBsZXQgc3RyZWFtID0gc3NySW5mby5jb250ZXh0LnN0cmVhbTtcbiAgICAoMCwgaW1wb3J0X3JlYWN0X3JvdXRlcjIuVU5TQUZFX2ludmFyaWFudCkoc3RyZWFtLCBcIk5vIHN0cmVhbSBmb3VuZCBmb3Igc2luZ2xlIGZldGNoIGRlY29kaW5nXCIpO1xuICAgIHNzckluZm8uY29udGV4dC5zdHJlYW0gPSB2b2lkIDA7XG4gICAgc3NySW5mby5zdGF0ZURlY29kaW5nUHJvbWlzZSA9ICgwLCBpbXBvcnRfcmVhY3Rfcm91dGVyMi5VTlNBRkVfZGVjb2RlVmlhVHVyYm9TdHJlYW0pKHN0cmVhbSwgd2luZG93KS50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgc3NySW5mby5jb250ZXh0LnN0YXRlID0gdmFsdWUudmFsdWU7XG4gICAgICBsb2NhbFNzckluZm8uc3RhdGVEZWNvZGluZ1Byb21pc2UudmFsdWUgPSB0cnVlO1xuICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICBsb2NhbFNzckluZm8uc3RhdGVEZWNvZGluZ1Byb21pc2UuZXJyb3IgPSBlO1xuICAgIH0pO1xuICB9XG4gIGlmIChzc3JJbmZvLnN0YXRlRGVjb2RpbmdQcm9taXNlLmVycm9yKSB7XG4gICAgdGhyb3cgc3NySW5mby5zdGF0ZURlY29kaW5nUHJvbWlzZS5lcnJvcjtcbiAgfVxuICBpZiAoIXNzckluZm8uc3RhdGVEZWNvZGluZ1Byb21pc2UudmFsdWUpIHtcbiAgICB0aHJvdyBzc3JJbmZvLnN0YXRlRGVjb2RpbmdQcm9taXNlO1xuICB9XG4gIGxldCByb3V0ZXMgPSAoMCwgaW1wb3J0X3JlYWN0X3JvdXRlcjIuVU5TQUZFX2NyZWF0ZUNsaWVudFJvdXRlcykoXG4gICAgc3NySW5mby5tYW5pZmVzdC5yb3V0ZXMsXG4gICAgc3NySW5mby5yb3V0ZU1vZHVsZXMsXG4gICAgc3NySW5mby5jb250ZXh0LnN0YXRlLFxuICAgIHNzckluZm8uY29udGV4dC5zc3IsXG4gICAgc3NySW5mby5jb250ZXh0LmlzU3BhTW9kZVxuICApO1xuICBsZXQgaHlkcmF0aW9uRGF0YSA9IHZvaWQgMDtcbiAgaWYgKHNzckluZm8uY29udGV4dC5pc1NwYU1vZGUpIHtcbiAgICBsZXQgeyBsb2FkZXJEYXRhIH0gPSBzc3JJbmZvLmNvbnRleHQuc3RhdGU7XG4gICAgaWYgKHNzckluZm8ubWFuaWZlc3Qucm91dGVzLnJvb3Q/Lmhhc0xvYWRlciAmJiBsb2FkZXJEYXRhICYmIFwicm9vdFwiIGluIGxvYWRlckRhdGEpIHtcbiAgICAgIGh5ZHJhdGlvbkRhdGEgPSB7XG4gICAgICAgIGxvYWRlckRhdGE6IHtcbiAgICAgICAgICByb290OiBsb2FkZXJEYXRhLnJvb3RcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaHlkcmF0aW9uRGF0YSA9ICgwLCBpbXBvcnRfcmVhY3Rfcm91dGVyMi5VTlNBRkVfZ2V0SHlkcmF0aW9uRGF0YSkoXG4gICAgICBzc3JJbmZvLmNvbnRleHQuc3RhdGUsXG4gICAgICByb3V0ZXMsXG4gICAgICAocm91dGVJZCkgPT4gKHtcbiAgICAgICAgY2xpZW50TG9hZGVyOiBzc3JJbmZvLnJvdXRlTW9kdWxlc1tyb3V0ZUlkXT8uY2xpZW50TG9hZGVyLFxuICAgICAgICBoYXNMb2FkZXI6IHNzckluZm8ubWFuaWZlc3Qucm91dGVzW3JvdXRlSWRdPy5oYXNMb2FkZXIgPT09IHRydWUsXG4gICAgICAgIGhhc0h5ZHJhdGVGYWxsYmFjazogc3NySW5mby5yb3V0ZU1vZHVsZXNbcm91dGVJZF0/Lkh5ZHJhdGVGYWxsYmFjayAhPSBudWxsXG4gICAgICB9KSxcbiAgICAgIHdpbmRvdy5sb2NhdGlvbixcbiAgICAgIHdpbmRvdy5fX3JlYWN0Um91dGVyQ29udGV4dD8uYmFzZW5hbWUsXG4gICAgICBzc3JJbmZvLmNvbnRleHQuaXNTcGFNb2RlXG4gICAgKTtcbiAgICBpZiAoaHlkcmF0aW9uRGF0YSAmJiBoeWRyYXRpb25EYXRhLmVycm9ycykge1xuICAgICAgaHlkcmF0aW9uRGF0YS5lcnJvcnMgPSAoMCwgaW1wb3J0X3JlYWN0X3JvdXRlcjIuVU5TQUZFX2Rlc2VyaWFsaXplRXJyb3JzKShoeWRyYXRpb25EYXRhLmVycm9ycyk7XG4gICAgfVxuICB9XG4gIGxldCByb3V0ZXIyID0gKDAsIGltcG9ydF9yZWFjdF9yb3V0ZXIyLlVOU0FGRV9jcmVhdGVSb3V0ZXIpKHtcbiAgICByb3V0ZXMsXG4gICAgaGlzdG9yeTogKDAsIGltcG9ydF9yZWFjdF9yb3V0ZXIyLlVOU0FGRV9jcmVhdGVCcm93c2VySGlzdG9yeSkoKSxcbiAgICBiYXNlbmFtZTogc3NySW5mby5jb250ZXh0LmJhc2VuYW1lLFxuICAgIHVuc3RhYmxlX2dldENvbnRleHQsXG4gICAgaHlkcmF0aW9uRGF0YSxcbiAgICBoeWRyYXRpb25Sb3V0ZVByb3BlcnRpZXM6IGltcG9ydF9yZWFjdF9yb3V0ZXIyLlVOU0FGRV9oeWRyYXRpb25Sb3V0ZVByb3BlcnRpZXMsXG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzOiBpbXBvcnRfcmVhY3Rfcm91dGVyMi5VTlNBRkVfbWFwUm91dGVQcm9wZXJ0aWVzLFxuICAgIGZ1dHVyZToge1xuICAgICAgdW5zdGFibGVfbWlkZGxld2FyZTogc3NySW5mby5jb250ZXh0LmZ1dHVyZS51bnN0YWJsZV9taWRkbGV3YXJlXG4gICAgfSxcbiAgICBkYXRhU3RyYXRlZ3k6ICgwLCBpbXBvcnRfcmVhY3Rfcm91dGVyMi5VTlNBRkVfZ2V0VHVyYm9TdHJlYW1TaW5nbGVGZXRjaERhdGFTdHJhdGVneSkoXG4gICAgICAoKSA9PiByb3V0ZXIyLFxuICAgICAgc3NySW5mby5tYW5pZmVzdCxcbiAgICAgIHNzckluZm8ucm91dGVNb2R1bGVzLFxuICAgICAgc3NySW5mby5jb250ZXh0LnNzcixcbiAgICAgIHNzckluZm8uY29udGV4dC5iYXNlbmFtZVxuICAgICksXG4gICAgcGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb246ICgwLCBpbXBvcnRfcmVhY3Rfcm91dGVyMi5VTlNBRkVfZ2V0UGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb25GdW5jdGlvbikoXG4gICAgICBzc3JJbmZvLm1hbmlmZXN0LFxuICAgICAgc3NySW5mby5yb3V0ZU1vZHVsZXMsXG4gICAgICBzc3JJbmZvLmNvbnRleHQuc3NyLFxuICAgICAgc3NySW5mby5jb250ZXh0LnJvdXRlRGlzY292ZXJ5LFxuICAgICAgc3NySW5mby5jb250ZXh0LmlzU3BhTW9kZSxcbiAgICAgIHNzckluZm8uY29udGV4dC5iYXNlbmFtZVxuICAgIClcbiAgfSk7XG4gIHNzckluZm8ucm91dGVyID0gcm91dGVyMjtcbiAgaWYgKHJvdXRlcjIuc3RhdGUuaW5pdGlhbGl6ZWQpIHtcbiAgICBzc3JJbmZvLnJvdXRlckluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICByb3V0ZXIyLmluaXRpYWxpemUoKTtcbiAgfVxuICByb3V0ZXIyLmNyZWF0ZVJvdXRlc0ZvckhNUiA9IC8qIHNwYWNlciBzbyB0cy1pZ25vcmUgZG9lcyBub3QgYWZmZWN0IHRoZSByaWdodCBoYW5kIG9mIHRoZSBhc3NpZ25tZW50ICovXG4gIGltcG9ydF9yZWFjdF9yb3V0ZXIyLlVOU0FGRV9jcmVhdGVDbGllbnRSb3V0ZXNXaXRoSE1SUmV2YWxpZGF0aW9uT3B0T3V0O1xuICB3aW5kb3cuX19yZWFjdFJvdXRlckRhdGFSb3V0ZXIgPSByb3V0ZXIyO1xuICByZXR1cm4gcm91dGVyMjtcbn1cbmZ1bmN0aW9uIEh5ZHJhdGVkUm91dGVyKHByb3BzKSB7XG4gIGlmICghcm91dGVyKSB7XG4gICAgcm91dGVyID0gY3JlYXRlSHlkcmF0ZWRSb3V0ZXIoe1xuICAgICAgdW5zdGFibGVfZ2V0Q29udGV4dDogcHJvcHMudW5zdGFibGVfZ2V0Q29udGV4dFxuICAgIH0pO1xuICB9XG4gIGxldCBbY3JpdGljYWxDc3MsIHNldENyaXRpY2FsQ3NzXSA9IFJlYWN0Mi51c2VTdGF0ZShcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiID8gc3NySW5mbz8uY29udGV4dC5jcml0aWNhbENzcyA6IHZvaWQgMFxuICApO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgIGlmIChzc3JJbmZvKSB7XG4gICAgICB3aW5kb3cuX19yZWFjdFJvdXRlckNsZWFyQ3JpdGljYWxDc3MgPSAoKSA9PiBzZXRDcml0aWNhbENzcyh2b2lkIDApO1xuICAgIH1cbiAgfVxuICBsZXQgW2xvY2F0aW9uLCBzZXRMb2NhdGlvbl0gPSBSZWFjdDIudXNlU3RhdGUocm91dGVyLnN0YXRlLmxvY2F0aW9uKTtcbiAgUmVhY3QyLnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHNzckluZm8gJiYgc3NySW5mby5yb3V0ZXIgJiYgIXNzckluZm8ucm91dGVySW5pdGlhbGl6ZWQpIHtcbiAgICAgIHNzckluZm8ucm91dGVySW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgc3NySW5mby5yb3V0ZXIuaW5pdGlhbGl6ZSgpO1xuICAgIH1cbiAgfSwgW10pO1xuICBSZWFjdDIudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoc3NySW5mbyAmJiBzc3JJbmZvLnJvdXRlcikge1xuICAgICAgcmV0dXJuIHNzckluZm8ucm91dGVyLnN1YnNjcmliZSgobmV3U3RhdGUpID0+IHtcbiAgICAgICAgaWYgKG5ld1N0YXRlLmxvY2F0aW9uICE9PSBsb2NhdGlvbikge1xuICAgICAgICAgIHNldExvY2F0aW9uKG5ld1N0YXRlLmxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbbG9jYXRpb25dKTtcbiAgKDAsIGltcG9ydF9yZWFjdF9yb3V0ZXIyLlVOU0FGRV9pbnZhcmlhbnQpKHNzckluZm8sIFwic3NySW5mbyB1bmF2YWlsYWJsZSBmb3IgSHlkcmF0ZWRSb3V0ZXJcIik7XG4gICgwLCBpbXBvcnRfcmVhY3Rfcm91dGVyMi5VTlNBRkVfdXNlRm9nT0ZXYXJEaXNjb3ZlcnkpKFxuICAgIHJvdXRlcixcbiAgICBzc3JJbmZvLm1hbmlmZXN0LFxuICAgIHNzckluZm8ucm91dGVNb2R1bGVzLFxuICAgIHNzckluZm8uY29udGV4dC5zc3IsXG4gICAgc3NySW5mby5jb250ZXh0LnJvdXRlRGlzY292ZXJ5LFxuICAgIHNzckluZm8uY29udGV4dC5pc1NwYU1vZGVcbiAgKTtcbiAgcmV0dXJuIChcbiAgICAvLyBUaGlzIGZyYWdtZW50IGlzIGltcG9ydGFudCB0byBlbnN1cmUgd2UgbWF0Y2ggdGhlIDxTZXJ2ZXJSb3V0ZXI+IEpTWFxuICAgIC8vIHN0cnVjdHVyZSBzbyB0aGF0IHVzZUlkIHZhbHVlcyBoeWRyYXRlIGNvcnJlY3RseVxuICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChSZWFjdDIuRnJhZ21lbnQsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcbiAgICAgIGltcG9ydF9yZWFjdF9yb3V0ZXIyLlVOU0FGRV9GcmFtZXdvcmtDb250ZXh0LlByb3ZpZGVyLFxuICAgICAge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIG1hbmlmZXN0OiBzc3JJbmZvLm1hbmlmZXN0LFxuICAgICAgICAgIHJvdXRlTW9kdWxlczogc3NySW5mby5yb3V0ZU1vZHVsZXMsXG4gICAgICAgICAgZnV0dXJlOiBzc3JJbmZvLmNvbnRleHQuZnV0dXJlLFxuICAgICAgICAgIGNyaXRpY2FsQ3NzLFxuICAgICAgICAgIHNzcjogc3NySW5mby5jb250ZXh0LnNzcixcbiAgICAgICAgICBpc1NwYU1vZGU6IHNzckluZm8uY29udGV4dC5pc1NwYU1vZGUsXG4gICAgICAgICAgcm91dGVEaXNjb3Zlcnk6IHNzckluZm8uY29udGV4dC5yb3V0ZURpc2NvdmVyeVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KGltcG9ydF9yZWFjdF9yb3V0ZXIyLlVOU0FGRV9SZW1peEVycm9yQm91bmRhcnksIHsgbG9jYXRpb24gfSwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFJvdXRlclByb3ZpZGVyLCB7IHJvdXRlciB9KSlcbiAgICApLCAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoUmVhY3QyLkZyYWdtZW50LCBudWxsKSlcbiAgKTtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBIeWRyYXRlZFJvdXRlcixcbiAgUm91dGVyUHJvdmlkZXJcbn0pO1xuIl0sIm5hbWVzIjpbIl9fY3JlYXRlIiwiT2JqZWN0IiwiY3JlYXRlIiwiX19kZWZQcm9wIiwiZGVmaW5lUHJvcGVydHkiLCJfX2dldE93blByb3BEZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX19nZXRPd25Qcm9wTmFtZXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiX19nZXRQcm90b09mIiwiZ2V0UHJvdG90eXBlT2YiLCJfX2hhc093blByb3AiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsIl9fZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImdldCIsImVudW1lcmFibGUiLCJfX2NvcHlQcm9wcyIsInRvIiwiZnJvbSIsImV4Y2VwdCIsImRlc2MiLCJrZXkiLCJjYWxsIiwiX190b0VTTSIsIm1vZCIsImlzTm9kZU1vZGUiLCJfX2VzTW9kdWxlIiwidmFsdWUiLCJfX3RvQ29tbW9uSlMiLCJkb21fZXhwb3J0X2V4cG9ydHMiLCJIeWRyYXRlZFJvdXRlciIsIlJvdXRlclByb3ZpZGVyIiwibW9kdWxlIiwiZXhwb3J0cyIsIlJlYWN0IiwicmVxdWlyZSIsIlJlYWN0RE9NIiwiaW1wb3J0X3JlYWN0X3JvdXRlciIsInByb3BzIiwiY3JlYXRlRWxlbWVudCIsImZsdXNoU3luYyIsIlJlYWN0MiIsImltcG9ydF9yZWFjdF9yb3V0ZXIyIiwic3NySW5mbyIsInJvdXRlciIsImluaXRTc3JJbmZvIiwid2luZG93IiwiX19yZWFjdFJvdXRlckNvbnRleHQiLCJfX3JlYWN0Um91dGVyTWFuaWZlc3QiLCJfX3JlYWN0Um91dGVyUm91dGVNb2R1bGVzIiwic3JpIiwiaW1wb3J0TWFwIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwidGV4dENvbnRlbnQiLCJKU09OIiwicGFyc2UiLCJpbnRlZ3JpdHkiLCJlcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJjb250ZXh0IiwibWFuaWZlc3QiLCJyb3V0ZU1vZHVsZXMiLCJzdGF0ZURlY29kaW5nUHJvbWlzZSIsInJvdXRlckluaXRpYWxpemVkIiwiY3JlYXRlSHlkcmF0ZWRSb3V0ZXIiLCJ1bnN0YWJsZV9nZXRDb250ZXh0IiwiRXJyb3IiLCJsb2NhbFNzckluZm8iLCJzdHJlYW0iLCJVTlNBRkVfaW52YXJpYW50IiwiVU5TQUZFX2RlY29kZVZpYVR1cmJvU3RyZWFtIiwidGhlbiIsInN0YXRlIiwiY2F0Y2giLCJlIiwicm91dGVzIiwiVU5TQUZFX2NyZWF0ZUNsaWVudFJvdXRlcyIsInNzciIsImlzU3BhTW9kZSIsImh5ZHJhdGlvbkRhdGEiLCJsb2FkZXJEYXRhIiwicm9vdCIsImhhc0xvYWRlciIsIlVOU0FGRV9nZXRIeWRyYXRpb25EYXRhIiwicm91dGVJZCIsImNsaWVudExvYWRlciIsImhhc0h5ZHJhdGVGYWxsYmFjayIsIkh5ZHJhdGVGYWxsYmFjayIsImxvY2F0aW9uIiwiYmFzZW5hbWUiLCJlcnJvcnMiLCJVTlNBRkVfZGVzZXJpYWxpemVFcnJvcnMiLCJyb3V0ZXIyIiwiVU5TQUZFX2NyZWF0ZVJvdXRlciIsImhpc3RvcnkiLCJVTlNBRkVfY3JlYXRlQnJvd3Nlckhpc3RvcnkiLCJoeWRyYXRpb25Sb3V0ZVByb3BlcnRpZXMiLCJVTlNBRkVfaHlkcmF0aW9uUm91dGVQcm9wZXJ0aWVzIiwibWFwUm91dGVQcm9wZXJ0aWVzIiwiVU5TQUZFX21hcFJvdXRlUHJvcGVydGllcyIsImZ1dHVyZSIsInVuc3RhYmxlX21pZGRsZXdhcmUiLCJkYXRhU3RyYXRlZ3kiLCJVTlNBRkVfZ2V0VHVyYm9TdHJlYW1TaW5nbGVGZXRjaERhdGFTdHJhdGVneSIsInBhdGNoUm91dGVzT25OYXZpZ2F0aW9uIiwiVU5TQUZFX2dldFBhdGNoUm91dGVzT25OYXZpZ2F0aW9uRnVuY3Rpb24iLCJyb3V0ZURpc2NvdmVyeSIsImluaXRpYWxpemVkIiwiaW5pdGlhbGl6ZSIsImNyZWF0ZVJvdXRlc0ZvckhNUiIsIlVOU0FGRV9jcmVhdGVDbGllbnRSb3V0ZXNXaXRoSE1SUmV2YWxpZGF0aW9uT3B0T3V0IiwiX19yZWFjdFJvdXRlckRhdGFSb3V0ZXIiLCJjcml0aWNhbENzcyIsInNldENyaXRpY2FsQ3NzIiwidXNlU3RhdGUiLCJwcm9jZXNzIiwiX19yZWFjdFJvdXRlckNsZWFyQ3JpdGljYWxDc3MiLCJzZXRMb2NhdGlvbiIsInVzZUxheW91dEVmZmVjdCIsInN1YnNjcmliZSIsIm5ld1N0YXRlIiwiVU5TQUZFX3VzZUZvZ09GV2FyRGlzY292ZXJ5IiwiRnJhZ21lbnQiLCJVTlNBRkVfRnJhbWV3b3JrQ29udGV4dCIsIlByb3ZpZGVyIiwiVU5TQUZFX1JlbWl4RXJyb3JCb3VuZGFyeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-router/dist/development/dom-export.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-router/dist/development/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-router/dist/development/index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * react-router v7.6.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ \nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __typeError = (msg)=>{\n    throw TypeError(msg);\n};\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\nvar __copyProps = (to, from, except, desc)=>{\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n            get: ()=>from[key],\n            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n        });\n    }\n    return to;\n};\nvar __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n        value: mod,\n        enumerable: true\n    }) : target, mod));\nvar __toCommonJS = (mod)=>__copyProps(__defProp({}, \"__esModule\", {\n        value: true\n    }), mod);\nvar __accessCheck = (obj, member, msg)=>member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter)=>(__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value)=>member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n// index.ts\nvar react_router_exports = {};\n__export(react_router_exports, {\n    Await: ()=>Await,\n    BrowserRouter: ()=>BrowserRouter,\n    Form: ()=>Form,\n    HashRouter: ()=>HashRouter,\n    IDLE_BLOCKER: ()=>IDLE_BLOCKER,\n    IDLE_FETCHER: ()=>IDLE_FETCHER,\n    IDLE_NAVIGATION: ()=>IDLE_NAVIGATION,\n    Link: ()=>Link,\n    Links: ()=>Links,\n    MemoryRouter: ()=>MemoryRouter,\n    Meta: ()=>Meta,\n    NavLink: ()=>NavLink,\n    Navigate: ()=>Navigate,\n    NavigationType: ()=>Action,\n    Outlet: ()=>Outlet,\n    PrefetchPageLinks: ()=>PrefetchPageLinks,\n    Route: ()=>Route,\n    Router: ()=>Router,\n    RouterProvider: ()=>RouterProvider,\n    Routes: ()=>Routes,\n    Scripts: ()=>Scripts,\n    ScrollRestoration: ()=>ScrollRestoration,\n    ServerRouter: ()=>ServerRouter,\n    StaticRouter: ()=>StaticRouter,\n    StaticRouterProvider: ()=>StaticRouterProvider,\n    UNSAFE_DataRouterContext: ()=>DataRouterContext,\n    UNSAFE_DataRouterStateContext: ()=>DataRouterStateContext,\n    UNSAFE_ErrorResponseImpl: ()=>ErrorResponseImpl,\n    UNSAFE_FetchersContext: ()=>FetchersContext,\n    UNSAFE_FrameworkContext: ()=>FrameworkContext,\n    UNSAFE_LocationContext: ()=>LocationContext,\n    UNSAFE_NavigationContext: ()=>NavigationContext,\n    UNSAFE_RemixErrorBoundary: ()=>RemixErrorBoundary,\n    UNSAFE_RouteContext: ()=>RouteContext,\n    UNSAFE_ServerMode: ()=>ServerMode,\n    UNSAFE_SingleFetchRedirectSymbol: ()=>SingleFetchRedirectSymbol,\n    UNSAFE_ViewTransitionContext: ()=>ViewTransitionContext,\n    UNSAFE_createBrowserHistory: ()=>createBrowserHistory,\n    UNSAFE_createClientRoutes: ()=>createClientRoutes,\n    UNSAFE_createClientRoutesWithHMRRevalidationOptOut: ()=>createClientRoutesWithHMRRevalidationOptOut,\n    UNSAFE_createRouter: ()=>createRouter,\n    UNSAFE_decodeViaTurboStream: ()=>decodeViaTurboStream,\n    UNSAFE_deserializeErrors: ()=>deserializeErrors2,\n    UNSAFE_getHydrationData: ()=>getHydrationData,\n    UNSAFE_getPatchRoutesOnNavigationFunction: ()=>getPatchRoutesOnNavigationFunction,\n    UNSAFE_getTurboStreamSingleFetchDataStrategy: ()=>getTurboStreamSingleFetchDataStrategy,\n    UNSAFE_hydrationRouteProperties: ()=>hydrationRouteProperties,\n    UNSAFE_invariant: ()=>invariant,\n    UNSAFE_mapRouteProperties: ()=>mapRouteProperties,\n    UNSAFE_shouldHydrateRouteLoader: ()=>shouldHydrateRouteLoader,\n    UNSAFE_useFogOFWarDiscovery: ()=>useFogOFWarDiscovery,\n    UNSAFE_useScrollRestoration: ()=>useScrollRestoration,\n    UNSAFE_withComponentProps: ()=>withComponentProps,\n    UNSAFE_withErrorBoundaryProps: ()=>withErrorBoundaryProps,\n    UNSAFE_withHydrateFallbackProps: ()=>withHydrateFallbackProps,\n    createBrowserRouter: ()=>createBrowserRouter,\n    createCookie: ()=>createCookie,\n    createCookieSessionStorage: ()=>createCookieSessionStorage,\n    createHashRouter: ()=>createHashRouter,\n    createMemoryRouter: ()=>createMemoryRouter,\n    createMemorySessionStorage: ()=>createMemorySessionStorage,\n    createPath: ()=>createPath,\n    createRequestHandler: ()=>createRequestHandler,\n    createRoutesFromChildren: ()=>createRoutesFromChildren,\n    createRoutesFromElements: ()=>createRoutesFromElements,\n    createRoutesStub: ()=>createRoutesStub,\n    createSearchParams: ()=>createSearchParams,\n    createSession: ()=>createSession,\n    createSessionStorage: ()=>createSessionStorage,\n    createStaticHandler: ()=>createStaticHandler2,\n    createStaticRouter: ()=>createStaticRouter,\n    data: ()=>data,\n    generatePath: ()=>generatePath,\n    href: ()=>href,\n    isCookie: ()=>isCookie,\n    isRouteErrorResponse: ()=>isRouteErrorResponse,\n    isSession: ()=>isSession,\n    matchPath: ()=>matchPath,\n    matchRoutes: ()=>matchRoutes,\n    parsePath: ()=>parsePath,\n    redirect: ()=>redirect,\n    redirectDocument: ()=>redirectDocument,\n    renderMatches: ()=>renderMatches,\n    replace: ()=>replace,\n    resolvePath: ()=>resolvePath,\n    unstable_HistoryRouter: ()=>HistoryRouter,\n    unstable_RouterContextProvider: ()=>unstable_RouterContextProvider,\n    unstable_createContext: ()=>unstable_createContext,\n    unstable_setDevServerHooks: ()=>setDevServerHooks,\n    unstable_usePrompt: ()=>usePrompt,\n    useActionData: ()=>useActionData,\n    useAsyncError: ()=>useAsyncError,\n    useAsyncValue: ()=>useAsyncValue,\n    useBeforeUnload: ()=>useBeforeUnload,\n    useBlocker: ()=>useBlocker,\n    useFetcher: ()=>useFetcher,\n    useFetchers: ()=>useFetchers,\n    useFormAction: ()=>useFormAction,\n    useHref: ()=>useHref,\n    useInRouterContext: ()=>useInRouterContext,\n    useLinkClickHandler: ()=>useLinkClickHandler,\n    useLoaderData: ()=>useLoaderData,\n    useLocation: ()=>useLocation,\n    useMatch: ()=>useMatch,\n    useMatches: ()=>useMatches,\n    useNavigate: ()=>useNavigate,\n    useNavigation: ()=>useNavigation,\n    useNavigationType: ()=>useNavigationType,\n    useOutlet: ()=>useOutlet,\n    useOutletContext: ()=>useOutletContext,\n    useParams: ()=>useParams,\n    useResolvedPath: ()=>useResolvedPath,\n    useRevalidator: ()=>useRevalidator,\n    useRouteError: ()=>useRouteError,\n    useRouteLoaderData: ()=>useRouteLoaderData,\n    useRoutes: ()=>useRoutes,\n    useSearchParams: ()=>useSearchParams,\n    useSubmit: ()=>useSubmit,\n    useViewTransitionState: ()=>useViewTransitionState\n});\nmodule.exports = __toCommonJS(react_router_exports);\n// lib/router/history.ts\nvar Action = /* @__PURE__ */ ((Action2)=>{\n    Action2[\"Pop\"] = \"POP\";\n    Action2[\"Push\"] = \"PUSH\";\n    Action2[\"Replace\"] = \"REPLACE\";\n    return Action2;\n})(Action || {});\nvar PopStateEventType = \"popstate\";\nfunction createMemoryHistory(options = {}) {\n    let { initialEntries = [\n        \"/\"\n    ], initialIndex, v5Compat = false } = options;\n    let entries;\n    entries = initialEntries.map((entry, index2)=>createMemoryLocation(entry, typeof entry === \"string\" ? null : entry.state, index2 === 0 ? \"default\" : void 0));\n    let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);\n    let action = \"POP\" /* Pop */ ;\n    let listener = null;\n    function clampIndex(n) {\n        return Math.min(Math.max(n, 0), entries.length - 1);\n    }\n    function getCurrentLocation() {\n        return entries[index];\n    }\n    function createMemoryLocation(to, state = null, key) {\n        let location = createLocation(entries ? getCurrentLocation().pathname : \"/\", to, state, key);\n        warning(location.pathname.charAt(0) === \"/\", `relative pathnames are not supported in memory history: ${JSON.stringify(to)}`);\n        return location;\n    }\n    function createHref2(to) {\n        return typeof to === \"string\" ? to : createPath(to);\n    }\n    let history = {\n        get index () {\n            return index;\n        },\n        get action () {\n            return action;\n        },\n        get location () {\n            return getCurrentLocation();\n        },\n        createHref: createHref2,\n        createURL (to) {\n            return new URL(createHref2(to), \"http://localhost\");\n        },\n        encodeLocation (to) {\n            let path = typeof to === \"string\" ? parsePath(to) : to;\n            return {\n                pathname: path.pathname || \"\",\n                search: path.search || \"\",\n                hash: path.hash || \"\"\n            };\n        },\n        push (to, state) {\n            action = \"PUSH\" /* Push */ ;\n            let nextLocation = createMemoryLocation(to, state);\n            index += 1;\n            entries.splice(index, entries.length, nextLocation);\n            if (v5Compat && listener) {\n                listener({\n                    action,\n                    location: nextLocation,\n                    delta: 1\n                });\n            }\n        },\n        replace (to, state) {\n            action = \"REPLACE\" /* Replace */ ;\n            let nextLocation = createMemoryLocation(to, state);\n            entries[index] = nextLocation;\n            if (v5Compat && listener) {\n                listener({\n                    action,\n                    location: nextLocation,\n                    delta: 0\n                });\n            }\n        },\n        go (delta) {\n            action = \"POP\" /* Pop */ ;\n            let nextIndex = clampIndex(index + delta);\n            let nextLocation = entries[nextIndex];\n            index = nextIndex;\n            if (listener) {\n                listener({\n                    action,\n                    location: nextLocation,\n                    delta\n                });\n            }\n        },\n        listen (fn) {\n            listener = fn;\n            return ()=>{\n                listener = null;\n            };\n        }\n    };\n    return history;\n}\nfunction createBrowserHistory(options = {}) {\n    function createBrowserLocation(window2, globalHistory) {\n        let { pathname, search, hash } = window2.location;\n        return createLocation(\"\", {\n            pathname,\n            search,\n            hash\n        }, // state defaults to `null` because `window.history.state` does\n        globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n    }\n    function createBrowserHref(window2, to) {\n        return typeof to === \"string\" ? to : createPath(to);\n    }\n    return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);\n}\nfunction createHashHistory(options = {}) {\n    function createHashLocation(window2, globalHistory) {\n        let { pathname = \"/\", search = \"\", hash = \"\" } = parsePath(window2.location.hash.substring(1));\n        if (!pathname.startsWith(\"/\") && !pathname.startsWith(\".\")) {\n            pathname = \"/\" + pathname;\n        }\n        return createLocation(\"\", {\n            pathname,\n            search,\n            hash\n        }, // state defaults to `null` because `window.history.state` does\n        globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n    }\n    function createHashHref(window2, to) {\n        let base = window2.document.querySelector(\"base\");\n        let href2 = \"\";\n        if (base && base.getAttribute(\"href\")) {\n            let url = window2.location.href;\n            let hashIndex = url.indexOf(\"#\");\n            href2 = hashIndex === -1 ? url : url.slice(0, hashIndex);\n        }\n        return href2 + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n    }\n    function validateHashLocation(location, to) {\n        warning(location.pathname.charAt(0) === \"/\", `relative pathnames are not supported in hash history.push(${JSON.stringify(to)})`);\n    }\n    return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);\n}\nfunction invariant(value, message) {\n    if (value === false || value === null || typeof value === \"undefined\") {\n        throw new Error(message);\n    }\n}\nfunction warning(cond, message) {\n    if (!cond) {\n        if (typeof console !== \"undefined\") console.warn(message);\n        try {\n            throw new Error(message);\n        } catch (e) {}\n    }\n}\nfunction createKey() {\n    return Math.random().toString(36).substring(2, 10);\n}\nfunction getHistoryState(location, index) {\n    return {\n        usr: location.state,\n        key: location.key,\n        idx: index\n    };\n}\nfunction createLocation(current, to, state = null, key) {\n    let location = {\n        pathname: typeof current === \"string\" ? current : current.pathname,\n        search: \"\",\n        hash: \"\",\n        ...typeof to === \"string\" ? parsePath(to) : to,\n        state,\n        // TODO: This could be cleaned up.  push/replace should probably just take\n        // full Locations now and avoid the need to run through this flow at all\n        // But that's a pretty big refactor to the current test suite so going to\n        // keep as is for the time being and just let any incoming keys take precedence\n        key: to && to.key || key || createKey()\n    };\n    return location;\n}\nfunction createPath({ pathname = \"/\", search = \"\", hash = \"\" }) {\n    if (search && search !== \"?\") pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n    if (hash && hash !== \"#\") pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n    return pathname;\n}\nfunction parsePath(path) {\n    let parsedPath = {};\n    if (path) {\n        let hashIndex = path.indexOf(\"#\");\n        if (hashIndex >= 0) {\n            parsedPath.hash = path.substring(hashIndex);\n            path = path.substring(0, hashIndex);\n        }\n        let searchIndex = path.indexOf(\"?\");\n        if (searchIndex >= 0) {\n            parsedPath.search = path.substring(searchIndex);\n            path = path.substring(0, searchIndex);\n        }\n        if (path) {\n            parsedPath.pathname = path;\n        }\n    }\n    return parsedPath;\n}\nfunction getUrlBasedHistory(getLocation, createHref2, validateLocation, options = {}) {\n    let { window: window2 = document.defaultView, v5Compat = false } = options;\n    let globalHistory = window2.history;\n    let action = \"POP\" /* Pop */ ;\n    let listener = null;\n    let index = getIndex();\n    if (index == null) {\n        index = 0;\n        globalHistory.replaceState({\n            ...globalHistory.state,\n            idx: index\n        }, \"\");\n    }\n    function getIndex() {\n        let state = globalHistory.state || {\n            idx: null\n        };\n        return state.idx;\n    }\n    function handlePop() {\n        action = \"POP\" /* Pop */ ;\n        let nextIndex = getIndex();\n        let delta = nextIndex == null ? null : nextIndex - index;\n        index = nextIndex;\n        if (listener) {\n            listener({\n                action,\n                location: history.location,\n                delta\n            });\n        }\n    }\n    function push(to, state) {\n        action = \"PUSH\" /* Push */ ;\n        let location = createLocation(history.location, to, state);\n        if (validateLocation) validateLocation(location, to);\n        index = getIndex() + 1;\n        let historyState = getHistoryState(location, index);\n        let url = history.createHref(location);\n        try {\n            globalHistory.pushState(historyState, \"\", url);\n        } catch (error) {\n            if (error instanceof DOMException && error.name === \"DataCloneError\") {\n                throw error;\n            }\n            window2.location.assign(url);\n        }\n        if (v5Compat && listener) {\n            listener({\n                action,\n                location: history.location,\n                delta: 1\n            });\n        }\n    }\n    function replace2(to, state) {\n        action = \"REPLACE\" /* Replace */ ;\n        let location = createLocation(history.location, to, state);\n        if (validateLocation) validateLocation(location, to);\n        index = getIndex();\n        let historyState = getHistoryState(location, index);\n        let url = history.createHref(location);\n        globalHistory.replaceState(historyState, \"\", url);\n        if (v5Compat && listener) {\n            listener({\n                action,\n                location: history.location,\n                delta: 0\n            });\n        }\n    }\n    function createURL(to) {\n        return createBrowserURLImpl(to);\n    }\n    let history = {\n        get action () {\n            return action;\n        },\n        get location () {\n            return getLocation(window2, globalHistory);\n        },\n        listen (fn) {\n            if (listener) {\n                throw new Error(\"A history only accepts one active listener\");\n            }\n            window2.addEventListener(PopStateEventType, handlePop);\n            listener = fn;\n            return ()=>{\n                window2.removeEventListener(PopStateEventType, handlePop);\n                listener = null;\n            };\n        },\n        createHref (to) {\n            return createHref2(window2, to);\n        },\n        createURL,\n        encodeLocation (to) {\n            let url = createURL(to);\n            return {\n                pathname: url.pathname,\n                search: url.search,\n                hash: url.hash\n            };\n        },\n        push,\n        replace: replace2,\n        go (n) {\n            return globalHistory.go(n);\n        }\n    };\n    return history;\n}\nfunction createBrowserURLImpl(to, isAbsolute = false) {\n    let base = \"http://localhost\";\n    if (false) {}\n    invariant(base, \"No window.location.(origin|href) available to create URL\");\n    let href2 = typeof to === \"string\" ? to : createPath(to);\n    href2 = href2.replace(/ $/, \"%20\");\n    if (!isAbsolute && href2.startsWith(\"//\")) {\n        href2 = base + href2;\n    }\n    return new URL(href2, base);\n}\n// lib/router/utils.ts\nfunction unstable_createContext(defaultValue) {\n    return {\n        defaultValue\n    };\n}\nvar _map;\nvar unstable_RouterContextProvider = class {\n    constructor(init){\n        __privateAdd(this, _map, /* @__PURE__ */ new Map());\n        if (init) {\n            for (let [context, value] of init){\n                this.set(context, value);\n            }\n        }\n    }\n    get(context) {\n        if (__privateGet(this, _map).has(context)) {\n            return __privateGet(this, _map).get(context);\n        }\n        if (context.defaultValue !== void 0) {\n            return context.defaultValue;\n        }\n        throw new Error(\"No value found for context\");\n    }\n    set(context, value) {\n        __privateGet(this, _map).set(context, value);\n    }\n};\n_map = new WeakMap();\nvar unsupportedLazyRouteObjectKeys = /* @__PURE__ */ new Set([\n    \"lazy\",\n    \"caseSensitive\",\n    \"path\",\n    \"id\",\n    \"index\",\n    \"children\"\n]);\nfunction isUnsupportedLazyRouteObjectKey(key) {\n    return unsupportedLazyRouteObjectKeys.has(key);\n}\nvar unsupportedLazyRouteFunctionKeys = /* @__PURE__ */ new Set([\n    \"lazy\",\n    \"caseSensitive\",\n    \"path\",\n    \"id\",\n    \"index\",\n    \"unstable_middleware\",\n    \"children\"\n]);\nfunction isUnsupportedLazyRouteFunctionKey(key) {\n    return unsupportedLazyRouteFunctionKeys.has(key);\n}\nfunction isIndexRoute(route) {\n    return route.index === true;\n}\nfunction convertRoutesToDataRoutes(routes, mapRouteProperties2, parentPath = [], manifest = {}) {\n    return routes.map((route, index)=>{\n        let treePath = [\n            ...parentPath,\n            String(index)\n        ];\n        let id = typeof route.id === \"string\" ? route.id : treePath.join(\"-\");\n        invariant(route.index !== true || !route.children, `Cannot specify children on an index route`);\n        invariant(!manifest[id], `Found a route id collision on id \"${id}\".  Route id's must be globally unique within Data Router usages`);\n        if (isIndexRoute(route)) {\n            let indexRoute = {\n                ...route,\n                ...mapRouteProperties2(route),\n                id\n            };\n            manifest[id] = indexRoute;\n            return indexRoute;\n        } else {\n            let pathOrLayoutRoute = {\n                ...route,\n                ...mapRouteProperties2(route),\n                id,\n                children: void 0\n            };\n            manifest[id] = pathOrLayoutRoute;\n            if (route.children) {\n                pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties2, treePath, manifest);\n            }\n            return pathOrLayoutRoute;\n        }\n    });\n}\nfunction matchRoutes(routes, locationArg, basename = \"/\") {\n    return matchRoutesImpl(routes, locationArg, basename, false);\n}\nfunction matchRoutesImpl(routes, locationArg, basename, allowPartial) {\n    let location = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n    let pathname = stripBasename(location.pathname || \"/\", basename);\n    if (pathname == null) {\n        return null;\n    }\n    let branches = flattenRoutes(routes);\n    rankRouteBranches(branches);\n    let matches = null;\n    for(let i = 0; matches == null && i < branches.length; ++i){\n        let decoded = decodePath(pathname);\n        matches = matchRouteBranch(branches[i], decoded, allowPartial);\n    }\n    return matches;\n}\nfunction convertRouteMatchToUiMatch(match, loaderData) {\n    let { route, pathname, params } = match;\n    return {\n        id: route.id,\n        pathname,\n        params,\n        data: loaderData[route.id],\n        handle: route.handle\n    };\n}\nfunction flattenRoutes(routes, branches = [], parentsMeta = [], parentPath = \"\") {\n    let flattenRoute = (route, index, relativePath)=>{\n        let meta = {\n            relativePath: relativePath === void 0 ? route.path || \"\" : relativePath,\n            caseSensitive: route.caseSensitive === true,\n            childrenIndex: index,\n            route\n        };\n        if (meta.relativePath.startsWith(\"/\")) {\n            invariant(meta.relativePath.startsWith(parentPath), `Absolute route path \"${meta.relativePath}\" nested under path \"${parentPath}\" is not valid. An absolute child route path must start with the combined path of all its parent routes.`);\n            meta.relativePath = meta.relativePath.slice(parentPath.length);\n        }\n        let path = joinPaths([\n            parentPath,\n            meta.relativePath\n        ]);\n        let routesMeta = parentsMeta.concat(meta);\n        if (route.children && route.children.length > 0) {\n            invariant(// Our types know better, but runtime JS may not!\n            // @ts-expect-error\n            route.index !== true, `Index routes must not have child routes. Please remove all child routes from route path \"${path}\".`);\n            flattenRoutes(route.children, branches, routesMeta, path);\n        }\n        if (route.path == null && !route.index) {\n            return;\n        }\n        branches.push({\n            path,\n            score: computeScore(path, route.index),\n            routesMeta\n        });\n    };\n    routes.forEach((route, index)=>{\n        if (route.path === \"\" || !route.path?.includes(\"?\")) {\n            flattenRoute(route, index);\n        } else {\n            for (let exploded of explodeOptionalSegments(route.path)){\n                flattenRoute(route, index, exploded);\n            }\n        }\n    });\n    return branches;\n}\nfunction explodeOptionalSegments(path) {\n    let segments = path.split(\"/\");\n    if (segments.length === 0) return [];\n    let [first, ...rest] = segments;\n    let isOptional = first.endsWith(\"?\");\n    let required = first.replace(/\\?$/, \"\");\n    if (rest.length === 0) {\n        return isOptional ? [\n            required,\n            \"\"\n        ] : [\n            required\n        ];\n    }\n    let restExploded = explodeOptionalSegments(rest.join(\"/\"));\n    let result = [];\n    result.push(...restExploded.map((subpath)=>subpath === \"\" ? required : [\n            required,\n            subpath\n        ].join(\"/\")));\n    if (isOptional) {\n        result.push(...restExploded);\n    }\n    return result.map((exploded)=>path.startsWith(\"/\") && exploded === \"\" ? \"/\" : exploded);\n}\nfunction rankRouteBranches(branches) {\n    branches.sort((a, b)=>a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map((meta)=>meta.childrenIndex), b.routesMeta.map((meta)=>meta.childrenIndex)));\n}\nvar paramRe = /^:[\\w-]+$/;\nvar dynamicSegmentValue = 3;\nvar indexRouteValue = 2;\nvar emptySegmentValue = 1;\nvar staticSegmentValue = 10;\nvar splatPenalty = -2;\nvar isSplat = (s)=>s === \"*\";\nfunction computeScore(path, index) {\n    let segments = path.split(\"/\");\n    let initialScore = segments.length;\n    if (segments.some(isSplat)) {\n        initialScore += splatPenalty;\n    }\n    if (index) {\n        initialScore += indexRouteValue;\n    }\n    return segments.filter((s)=>!isSplat(s)).reduce((score, segment)=>score + (paramRe.test(segment) ? dynamicSegmentValue : segment === \"\" ? emptySegmentValue : staticSegmentValue), initialScore);\n}\nfunction compareIndexes(a, b) {\n    let siblings = a.length === b.length && a.slice(0, -1).every((n, i)=>n === b[i]);\n    return siblings ? // If two routes are siblings, we should try to match the earlier sibling\n    // first. This allows people to have fine-grained control over the matching\n    // behavior by simply putting routes with identical paths in the order they\n    // want them tried.\n    a[a.length - 1] - b[b.length - 1] : // Otherwise, it doesn't really make sense to rank non-siblings by index,\n    // so they sort equally.\n    0;\n}\nfunction matchRouteBranch(branch, pathname, allowPartial = false) {\n    let { routesMeta } = branch;\n    let matchedParams = {};\n    let matchedPathname = \"/\";\n    let matches = [];\n    for(let i = 0; i < routesMeta.length; ++i){\n        let meta = routesMeta[i];\n        let end = i === routesMeta.length - 1;\n        let remainingPathname = matchedPathname === \"/\" ? pathname : pathname.slice(matchedPathname.length) || \"/\";\n        let match = matchPath({\n            path: meta.relativePath,\n            caseSensitive: meta.caseSensitive,\n            end\n        }, remainingPathname);\n        let route = meta.route;\n        if (!match && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {\n            match = matchPath({\n                path: meta.relativePath,\n                caseSensitive: meta.caseSensitive,\n                end: false\n            }, remainingPathname);\n        }\n        if (!match) {\n            return null;\n        }\n        Object.assign(matchedParams, match.params);\n        matches.push({\n            // TODO: Can this as be avoided?\n            params: matchedParams,\n            pathname: joinPaths([\n                matchedPathname,\n                match.pathname\n            ]),\n            pathnameBase: normalizePathname(joinPaths([\n                matchedPathname,\n                match.pathnameBase\n            ])),\n            route\n        });\n        if (match.pathnameBase !== \"/\") {\n            matchedPathname = joinPaths([\n                matchedPathname,\n                match.pathnameBase\n            ]);\n        }\n    }\n    return matches;\n}\nfunction generatePath(originalPath, params = {}) {\n    let path = originalPath;\n    if (path.endsWith(\"*\") && path !== \"*\" && !path.endsWith(\"/*\")) {\n        warning(false, `Route path \"${path}\" will be treated as if it were \"${path.replace(/\\*$/, \"/*\")}\" because the \\`*\\` character must always follow a \\`/\\` in the pattern. To get rid of this warning, please change the route path to \"${path.replace(/\\*$/, \"/*\")}\".`);\n        path = path.replace(/\\*$/, \"/*\");\n    }\n    const prefix = path.startsWith(\"/\") ? \"/\" : \"\";\n    const stringify2 = (p)=>p == null ? \"\" : typeof p === \"string\" ? p : String(p);\n    const segments = path.split(/\\/+/).map((segment, index, array)=>{\n        const isLastSegment = index === array.length - 1;\n        if (isLastSegment && segment === \"*\") {\n            const star = \"*\";\n            return stringify2(params[star]);\n        }\n        const keyMatch = segment.match(/^:([\\w-]+)(\\??)$/);\n        if (keyMatch) {\n            const [, key, optional] = keyMatch;\n            let param = params[key];\n            invariant(optional === \"?\" || param != null, `Missing \":${key}\" param`);\n            return stringify2(param);\n        }\n        return segment.replace(/\\?$/g, \"\");\n    }).filter((segment)=>!!segment);\n    return prefix + segments.join(\"/\");\n}\nfunction matchPath(pattern, pathname) {\n    if (typeof pattern === \"string\") {\n        pattern = {\n            path: pattern,\n            caseSensitive: false,\n            end: true\n        };\n    }\n    let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);\n    let match = pathname.match(matcher);\n    if (!match) return null;\n    let matchedPathname = match[0];\n    let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n    let captureGroups = match.slice(1);\n    let params = compiledParams.reduce((memo2, { paramName, isOptional }, index)=>{\n        if (paramName === \"*\") {\n            let splatValue = captureGroups[index] || \"\";\n            pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\\/+$/, \"$1\");\n        }\n        const value = captureGroups[index];\n        if (isOptional && !value) {\n            memo2[paramName] = void 0;\n        } else {\n            memo2[paramName] = (value || \"\").replace(/%2F/g, \"/\");\n        }\n        return memo2;\n    }, {});\n    return {\n        params,\n        pathname: matchedPathname,\n        pathnameBase,\n        pattern\n    };\n}\nfunction compilePath(path, caseSensitive = false, end = true) {\n    warning(path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"), `Route path \"${path}\" will be treated as if it were \"${path.replace(/\\*$/, \"/*\")}\" because the \\`*\\` character must always follow a \\`/\\` in the pattern. To get rid of this warning, please change the route path to \"${path.replace(/\\*$/, \"/*\")}\".`);\n    let params = [];\n    let regexpSource = \"^\" + path.replace(/\\/*\\*?$/, \"\").replace(/^\\/*/, \"/\").replace(/[\\\\.*+^${}|()[\\]]/g, \"\\\\$&\").replace(/\\/:([\\w-]+)(\\?)?/g, (_, paramName, isOptional)=>{\n        params.push({\n            paramName,\n            isOptional: isOptional != null\n        });\n        return isOptional ? \"/?([^\\\\/]+)?\" : \"/([^\\\\/]+)\";\n    });\n    if (path.endsWith(\"*\")) {\n        params.push({\n            paramName: \"*\"\n        });\n        regexpSource += path === \"*\" || path === \"/*\" ? \"(.*)$\" : \"(?:\\\\/(.+)|\\\\/*)$\";\n    } else if (end) {\n        regexpSource += \"\\\\/*$\";\n    } else if (path !== \"\" && path !== \"/\") {\n        regexpSource += \"(?:(?=\\\\/|$))\";\n    } else {}\n    let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : \"i\");\n    return [\n        matcher,\n        params\n    ];\n}\nfunction decodePath(value) {\n    try {\n        return value.split(\"/\").map((v)=>decodeURIComponent(v).replace(/\\//g, \"%2F\")).join(\"/\");\n    } catch (error) {\n        warning(false, `The URL path \"${value}\" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${error}).`);\n        return value;\n    }\n}\nfunction stripBasename(pathname, basename) {\n    if (basename === \"/\") return pathname;\n    if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n        return null;\n    }\n    let startIndex = basename.endsWith(\"/\") ? basename.length - 1 : basename.length;\n    let nextChar = pathname.charAt(startIndex);\n    if (nextChar && nextChar !== \"/\") {\n        return null;\n    }\n    return pathname.slice(startIndex) || \"/\";\n}\nfunction resolvePath(to, fromPathname = \"/\") {\n    let { pathname: toPathname, search = \"\", hash = \"\" } = typeof to === \"string\" ? parsePath(to) : to;\n    let pathname = toPathname ? toPathname.startsWith(\"/\") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;\n    return {\n        pathname,\n        search: normalizeSearch(search),\n        hash: normalizeHash(hash)\n    };\n}\nfunction resolvePathname(relativePath, fromPathname) {\n    let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n    let relativeSegments = relativePath.split(\"/\");\n    relativeSegments.forEach((segment)=>{\n        if (segment === \"..\") {\n            if (segments.length > 1) segments.pop();\n        } else if (segment !== \".\") {\n            segments.push(segment);\n        }\n    });\n    return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\nfunction getInvalidPathError(char, field, dest, path) {\n    return `Cannot include a '${char}' character in a manually specified \\`to.${field}\\` field [${JSON.stringify(path)}].  Please separate it out to the \\`to.${dest}\\` field. Alternatively you may provide the full path as a string in <Link to=\"...\"> and the router will parse it for you.`;\n}\nfunction getPathContributingMatches(matches) {\n    return matches.filter((match, index)=>index === 0 || match.route.path && match.route.path.length > 0);\n}\nfunction getResolveToMatches(matches) {\n    let pathMatches = getPathContributingMatches(matches);\n    return pathMatches.map((match, idx)=>idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase);\n}\nfunction resolveTo(toArg, routePathnames, locationPathname, isPathRelative = false) {\n    let to;\n    if (typeof toArg === \"string\") {\n        to = parsePath(toArg);\n    } else {\n        to = {\n            ...toArg\n        };\n        invariant(!to.pathname || !to.pathname.includes(\"?\"), getInvalidPathError(\"?\", \"pathname\", \"search\", to));\n        invariant(!to.pathname || !to.pathname.includes(\"#\"), getInvalidPathError(\"#\", \"pathname\", \"hash\", to));\n        invariant(!to.search || !to.search.includes(\"#\"), getInvalidPathError(\"#\", \"search\", \"hash\", to));\n    }\n    let isEmptyPath = toArg === \"\" || to.pathname === \"\";\n    let toPathname = isEmptyPath ? \"/\" : to.pathname;\n    let from;\n    if (toPathname == null) {\n        from = locationPathname;\n    } else {\n        let routePathnameIndex = routePathnames.length - 1;\n        if (!isPathRelative && toPathname.startsWith(\"..\")) {\n            let toSegments = toPathname.split(\"/\");\n            while(toSegments[0] === \"..\"){\n                toSegments.shift();\n                routePathnameIndex -= 1;\n            }\n            to.pathname = toSegments.join(\"/\");\n        }\n        from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n    }\n    let path = resolvePath(to, from);\n    let hasExplicitTrailingSlash = toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\");\n    let hasCurrentTrailingSlash = (isEmptyPath || toPathname === \".\") && locationPathname.endsWith(\"/\");\n    if (!path.pathname.endsWith(\"/\") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {\n        path.pathname += \"/\";\n    }\n    return path;\n}\nvar joinPaths = (paths)=>paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\nvar normalizePathname = (pathname)=>pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\nvar normalizeSearch = (search)=>!search || search === \"?\" ? \"\" : search.startsWith(\"?\") ? search : \"?\" + search;\nvar normalizeHash = (hash)=>!hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\nvar DataWithResponseInit = class {\n    constructor(data2, init){\n        this.type = \"DataWithResponseInit\";\n        this.data = data2;\n        this.init = init || null;\n    }\n};\nfunction data(data2, init) {\n    return new DataWithResponseInit(data2, typeof init === \"number\" ? {\n        status: init\n    } : init);\n}\nvar redirect = (url, init = 302)=>{\n    let responseInit = init;\n    if (typeof responseInit === \"number\") {\n        responseInit = {\n            status: responseInit\n        };\n    } else if (typeof responseInit.status === \"undefined\") {\n        responseInit.status = 302;\n    }\n    let headers = new Headers(responseInit.headers);\n    headers.set(\"Location\", url);\n    return new Response(null, {\n        ...responseInit,\n        headers\n    });\n};\nvar redirectDocument = (url, init)=>{\n    let response = redirect(url, init);\n    response.headers.set(\"X-Remix-Reload-Document\", \"true\");\n    return response;\n};\nvar replace = (url, init)=>{\n    let response = redirect(url, init);\n    response.headers.set(\"X-Remix-Replace\", \"true\");\n    return response;\n};\nvar ErrorResponseImpl = class {\n    constructor(status, statusText, data2, internal = false){\n        this.status = status;\n        this.statusText = statusText || \"\";\n        this.internal = internal;\n        if (data2 instanceof Error) {\n            this.data = data2.toString();\n            this.error = data2;\n        } else {\n            this.data = data2;\n        }\n    }\n};\nfunction isRouteErrorResponse(error) {\n    return error != null && typeof error.status === \"number\" && typeof error.statusText === \"string\" && typeof error.internal === \"boolean\" && \"data\" in error;\n}\n// lib/router/router.ts\nvar validMutationMethodsArr = [\n    \"POST\",\n    \"PUT\",\n    \"PATCH\",\n    \"DELETE\"\n];\nvar validMutationMethods = new Set(validMutationMethodsArr);\nvar validRequestMethodsArr = [\n    \"GET\",\n    ...validMutationMethodsArr\n];\nvar validRequestMethods = new Set(validRequestMethodsArr);\nvar redirectStatusCodes = /* @__PURE__ */ new Set([\n    301,\n    302,\n    303,\n    307,\n    308\n]);\nvar redirectPreserveMethodStatusCodes = /* @__PURE__ */ new Set([\n    307,\n    308\n]);\nvar IDLE_NAVIGATION = {\n    state: \"idle\",\n    location: void 0,\n    formMethod: void 0,\n    formAction: void 0,\n    formEncType: void 0,\n    formData: void 0,\n    json: void 0,\n    text: void 0\n};\nvar IDLE_FETCHER = {\n    state: \"idle\",\n    data: void 0,\n    formMethod: void 0,\n    formAction: void 0,\n    formEncType: void 0,\n    formData: void 0,\n    json: void 0,\n    text: void 0\n};\nvar IDLE_BLOCKER = {\n    state: \"unblocked\",\n    proceed: void 0,\n    reset: void 0,\n    location: void 0\n};\nvar ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nvar defaultMapRouteProperties = (route)=>({\n        hasErrorBoundary: Boolean(route.hasErrorBoundary)\n    });\nvar TRANSITIONS_STORAGE_KEY = \"remix-router-transitions\";\nvar ResetLoaderDataSymbol = Symbol(\"ResetLoaderData\");\nfunction createRouter(init) {\n    const routerWindow = init.window ? init.window :  false ? 0 : void 0;\n    const isBrowser2 = typeof routerWindow !== \"undefined\" && typeof routerWindow.document !== \"undefined\" && typeof routerWindow.document.createElement !== \"undefined\";\n    invariant(init.routes.length > 0, \"You must provide a non-empty routes array to createRouter\");\n    let hydrationRouteProperties2 = init.hydrationRouteProperties || [];\n    let mapRouteProperties2 = init.mapRouteProperties || defaultMapRouteProperties;\n    let manifest = {};\n    let dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties2, void 0, manifest);\n    let inFlightDataRoutes;\n    let basename = init.basename || \"/\";\n    let dataStrategyImpl = init.dataStrategy || defaultDataStrategyWithMiddleware;\n    let future = {\n        unstable_middleware: false,\n        ...init.future\n    };\n    let unlistenHistory = null;\n    let subscribers = /* @__PURE__ */ new Set();\n    let savedScrollPositions2 = null;\n    let getScrollRestorationKey2 = null;\n    let getScrollPosition = null;\n    let initialScrollRestored = init.hydrationData != null;\n    let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);\n    let initialMatchesIsFOW = false;\n    let initialErrors = null;\n    let initialized;\n    if (initialMatches == null && !init.patchRoutesOnNavigation) {\n        let error = getInternalRouterError(404, {\n            pathname: init.history.location.pathname\n        });\n        let { matches, route } = getShortCircuitMatches(dataRoutes);\n        initialized = true;\n        initialMatches = matches;\n        initialErrors = {\n            [route.id]: error\n        };\n    } else {\n        if (initialMatches && !init.hydrationData) {\n            let fogOfWar = checkFogOfWar(initialMatches, dataRoutes, init.history.location.pathname);\n            if (fogOfWar.active) {\n                initialMatches = null;\n            }\n        }\n        if (!initialMatches) {\n            initialized = false;\n            initialMatches = [];\n            let fogOfWar = checkFogOfWar(null, dataRoutes, init.history.location.pathname);\n            if (fogOfWar.active && fogOfWar.matches) {\n                initialMatchesIsFOW = true;\n                initialMatches = fogOfWar.matches;\n            }\n        } else if (initialMatches.some((m)=>m.route.lazy)) {\n            initialized = false;\n        } else if (!initialMatches.some((m)=>m.route.loader)) {\n            initialized = true;\n        } else {\n            let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;\n            let errors = init.hydrationData ? init.hydrationData.errors : null;\n            if (errors) {\n                let idx = initialMatches.findIndex((m)=>errors[m.route.id] !== void 0);\n                initialized = initialMatches.slice(0, idx + 1).every((m)=>!shouldLoadRouteOnHydration(m.route, loaderData, errors));\n            } else {\n                initialized = initialMatches.every((m)=>!shouldLoadRouteOnHydration(m.route, loaderData, errors));\n            }\n        }\n    }\n    let router;\n    let state = {\n        historyAction: init.history.action,\n        location: init.history.location,\n        matches: initialMatches,\n        initialized,\n        navigation: IDLE_NAVIGATION,\n        // Don't restore on initial updateState() if we were SSR'd\n        restoreScrollPosition: init.hydrationData != null ? false : null,\n        preventScrollReset: false,\n        revalidation: \"idle\",\n        loaderData: init.hydrationData && init.hydrationData.loaderData || {},\n        actionData: init.hydrationData && init.hydrationData.actionData || null,\n        errors: init.hydrationData && init.hydrationData.errors || initialErrors,\n        fetchers: /* @__PURE__ */ new Map(),\n        blockers: /* @__PURE__ */ new Map()\n    };\n    let pendingAction = \"POP\" /* Pop */ ;\n    let pendingPreventScrollReset = false;\n    let pendingNavigationController;\n    let pendingViewTransitionEnabled = false;\n    let appliedViewTransitions = /* @__PURE__ */ new Map();\n    let removePageHideEventListener = null;\n    let isUninterruptedRevalidation = false;\n    let isRevalidationRequired = false;\n    let cancelledFetcherLoads = /* @__PURE__ */ new Set();\n    let fetchControllers = /* @__PURE__ */ new Map();\n    let incrementingLoadId = 0;\n    let pendingNavigationLoadId = -1;\n    let fetchReloadIds = /* @__PURE__ */ new Map();\n    let fetchRedirectIds = /* @__PURE__ */ new Set();\n    let fetchLoadMatches = /* @__PURE__ */ new Map();\n    let activeFetchers = /* @__PURE__ */ new Map();\n    let fetchersQueuedForDeletion = /* @__PURE__ */ new Set();\n    let blockerFunctions = /* @__PURE__ */ new Map();\n    let unblockBlockerHistoryUpdate = void 0;\n    let pendingRevalidationDfd = null;\n    function initialize() {\n        unlistenHistory = init.history.listen(({ action: historyAction, location, delta })=>{\n            if (unblockBlockerHistoryUpdate) {\n                unblockBlockerHistoryUpdate();\n                unblockBlockerHistoryUpdate = void 0;\n                return;\n            }\n            warning(blockerFunctions.size === 0 || delta != null, \"You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.\");\n            let blockerKey = shouldBlockNavigation({\n                currentLocation: state.location,\n                nextLocation: location,\n                historyAction\n            });\n            if (blockerKey && delta != null) {\n                let nextHistoryUpdatePromise = new Promise((resolve)=>{\n                    unblockBlockerHistoryUpdate = resolve;\n                });\n                init.history.go(delta * -1);\n                updateBlocker(blockerKey, {\n                    state: \"blocked\",\n                    location,\n                    proceed () {\n                        updateBlocker(blockerKey, {\n                            state: \"proceeding\",\n                            proceed: void 0,\n                            reset: void 0,\n                            location\n                        });\n                        nextHistoryUpdatePromise.then(()=>init.history.go(delta));\n                    },\n                    reset () {\n                        let blockers = new Map(state.blockers);\n                        blockers.set(blockerKey, IDLE_BLOCKER);\n                        updateState({\n                            blockers\n                        });\n                    }\n                });\n                return;\n            }\n            return startNavigation(historyAction, location);\n        });\n        if (isBrowser2) {\n            restoreAppliedTransitions(routerWindow, appliedViewTransitions);\n            let _saveAppliedTransitions = ()=>persistAppliedTransitions(routerWindow, appliedViewTransitions);\n            routerWindow.addEventListener(\"pagehide\", _saveAppliedTransitions);\n            removePageHideEventListener = ()=>routerWindow.removeEventListener(\"pagehide\", _saveAppliedTransitions);\n        }\n        if (!state.initialized) {\n            startNavigation(\"POP\" /* Pop */ , state.location, {\n                initialHydration: true\n            });\n        }\n        return router;\n    }\n    function dispose() {\n        if (unlistenHistory) {\n            unlistenHistory();\n        }\n        if (removePageHideEventListener) {\n            removePageHideEventListener();\n        }\n        subscribers.clear();\n        pendingNavigationController && pendingNavigationController.abort();\n        state.fetchers.forEach((_, key)=>deleteFetcher(key));\n        state.blockers.forEach((_, key)=>deleteBlocker(key));\n    }\n    function subscribe(fn) {\n        subscribers.add(fn);\n        return ()=>subscribers.delete(fn);\n    }\n    function updateState(newState, opts = {}) {\n        state = {\n            ...state,\n            ...newState\n        };\n        let unmountedFetchers = [];\n        let mountedFetchers = [];\n        state.fetchers.forEach((fetcher, key)=>{\n            if (fetcher.state === \"idle\") {\n                if (fetchersQueuedForDeletion.has(key)) {\n                    unmountedFetchers.push(key);\n                } else {\n                    mountedFetchers.push(key);\n                }\n            }\n        });\n        fetchersQueuedForDeletion.forEach((key)=>{\n            if (!state.fetchers.has(key) && !fetchControllers.has(key)) {\n                unmountedFetchers.push(key);\n            }\n        });\n        [\n            ...subscribers\n        ].forEach((subscriber)=>subscriber(state, {\n                deletedFetchers: unmountedFetchers,\n                viewTransitionOpts: opts.viewTransitionOpts,\n                flushSync: opts.flushSync === true\n            }));\n        unmountedFetchers.forEach((key)=>deleteFetcher(key));\n        mountedFetchers.forEach((key)=>state.fetchers.delete(key));\n    }\n    function completeNavigation(location, newState, { flushSync } = {}) {\n        let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === \"loading\" && location.state?._isRedirect !== true;\n        let actionData;\n        if (newState.actionData) {\n            if (Object.keys(newState.actionData).length > 0) {\n                actionData = newState.actionData;\n            } else {\n                actionData = null;\n            }\n        } else if (isActionReload) {\n            actionData = state.actionData;\n        } else {\n            actionData = null;\n        }\n        let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;\n        let blockers = state.blockers;\n        if (blockers.size > 0) {\n            blockers = new Map(blockers);\n            blockers.forEach((_, k)=>blockers.set(k, IDLE_BLOCKER));\n        }\n        let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && location.state?._isRedirect !== true;\n        if (inFlightDataRoutes) {\n            dataRoutes = inFlightDataRoutes;\n            inFlightDataRoutes = void 0;\n        }\n        if (isUninterruptedRevalidation) {} else if (pendingAction === \"POP\" /* Pop */ ) {} else if (pendingAction === \"PUSH\" /* Push */ ) {\n            init.history.push(location, location.state);\n        } else if (pendingAction === \"REPLACE\" /* Replace */ ) {\n            init.history.replace(location, location.state);\n        }\n        let viewTransitionOpts;\n        if (pendingAction === \"POP\" /* Pop */ ) {\n            let priorPaths = appliedViewTransitions.get(state.location.pathname);\n            if (priorPaths && priorPaths.has(location.pathname)) {\n                viewTransitionOpts = {\n                    currentLocation: state.location,\n                    nextLocation: location\n                };\n            } else if (appliedViewTransitions.has(location.pathname)) {\n                viewTransitionOpts = {\n                    currentLocation: location,\n                    nextLocation: state.location\n                };\n            }\n        } else if (pendingViewTransitionEnabled) {\n            let toPaths = appliedViewTransitions.get(state.location.pathname);\n            if (toPaths) {\n                toPaths.add(location.pathname);\n            } else {\n                toPaths = /* @__PURE__ */ new Set([\n                    location.pathname\n                ]);\n                appliedViewTransitions.set(state.location.pathname, toPaths);\n            }\n            viewTransitionOpts = {\n                currentLocation: state.location,\n                nextLocation: location\n            };\n        }\n        updateState({\n            ...newState,\n            // matches, errors, fetchers go through as-is\n            actionData,\n            loaderData,\n            historyAction: pendingAction,\n            location,\n            initialized: true,\n            navigation: IDLE_NAVIGATION,\n            revalidation: \"idle\",\n            restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),\n            preventScrollReset,\n            blockers\n        }, {\n            viewTransitionOpts,\n            flushSync: flushSync === true\n        });\n        pendingAction = \"POP\" /* Pop */ ;\n        pendingPreventScrollReset = false;\n        pendingViewTransitionEnabled = false;\n        isUninterruptedRevalidation = false;\n        isRevalidationRequired = false;\n        pendingRevalidationDfd?.resolve();\n        pendingRevalidationDfd = null;\n    }\n    async function navigate(to, opts) {\n        if (typeof to === \"number\") {\n            init.history.go(to);\n            return;\n        }\n        let normalizedPath = normalizeTo(state.location, state.matches, basename, to, opts?.fromRouteId, opts?.relative);\n        let { path, submission, error } = normalizeNavigateOptions(false, normalizedPath, opts);\n        let currentLocation = state.location;\n        let nextLocation = createLocation(state.location, path, opts && opts.state);\n        nextLocation = {\n            ...nextLocation,\n            ...init.history.encodeLocation(nextLocation)\n        };\n        let userReplace = opts && opts.replace != null ? opts.replace : void 0;\n        let historyAction = \"PUSH\" /* Push */ ;\n        if (userReplace === true) {\n            historyAction = \"REPLACE\" /* Replace */ ;\n        } else if (userReplace === false) {} else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {\n            historyAction = \"REPLACE\" /* Replace */ ;\n        }\n        let preventScrollReset = opts && \"preventScrollReset\" in opts ? opts.preventScrollReset === true : void 0;\n        let flushSync = (opts && opts.flushSync) === true;\n        let blockerKey = shouldBlockNavigation({\n            currentLocation,\n            nextLocation,\n            historyAction\n        });\n        if (blockerKey) {\n            updateBlocker(blockerKey, {\n                state: \"blocked\",\n                location: nextLocation,\n                proceed () {\n                    updateBlocker(blockerKey, {\n                        state: \"proceeding\",\n                        proceed: void 0,\n                        reset: void 0,\n                        location: nextLocation\n                    });\n                    navigate(to, opts);\n                },\n                reset () {\n                    let blockers = new Map(state.blockers);\n                    blockers.set(blockerKey, IDLE_BLOCKER);\n                    updateState({\n                        blockers\n                    });\n                }\n            });\n            return;\n        }\n        await startNavigation(historyAction, nextLocation, {\n            submission,\n            // Send through the formData serialization error if we have one so we can\n            // render at the right error boundary after we match routes\n            pendingError: error,\n            preventScrollReset,\n            replace: opts && opts.replace,\n            enableViewTransition: opts && opts.viewTransition,\n            flushSync\n        });\n    }\n    function revalidate() {\n        if (!pendingRevalidationDfd) {\n            pendingRevalidationDfd = createDeferred();\n        }\n        interruptActiveLoads();\n        updateState({\n            revalidation: \"loading\"\n        });\n        let promise = pendingRevalidationDfd.promise;\n        if (state.navigation.state === \"submitting\") {\n            return promise;\n        }\n        if (state.navigation.state === \"idle\") {\n            startNavigation(state.historyAction, state.location, {\n                startUninterruptedRevalidation: true\n            });\n            return promise;\n        }\n        startNavigation(pendingAction || state.historyAction, state.navigation.location, {\n            overrideNavigation: state.navigation,\n            // Proxy through any rending view transition\n            enableViewTransition: pendingViewTransitionEnabled === true\n        });\n        return promise;\n    }\n    async function startNavigation(historyAction, location, opts) {\n        pendingNavigationController && pendingNavigationController.abort();\n        pendingNavigationController = null;\n        pendingAction = historyAction;\n        isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;\n        saveScrollPosition(state.location, state.matches);\n        pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n        pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let loadingNavigation = opts && opts.overrideNavigation;\n        let matches = opts?.initialHydration && state.matches && state.matches.length > 0 && !initialMatchesIsFOW ? // `matchRoutes()` has already been called if we're in here via `router.initialize()`\n        state.matches : matchRoutes(routesToUse, location, basename);\n        let flushSync = (opts && opts.flushSync) === true;\n        if (matches && state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {\n            completeNavigation(location, {\n                matches\n            }, {\n                flushSync\n            });\n            return;\n        }\n        let fogOfWar = checkFogOfWar(matches, routesToUse, location.pathname);\n        if (fogOfWar.active && fogOfWar.matches) {\n            matches = fogOfWar.matches;\n        }\n        if (!matches) {\n            let { error, notFoundMatches, route } = handleNavigational404(location.pathname);\n            completeNavigation(location, {\n                matches: notFoundMatches,\n                loaderData: {},\n                errors: {\n                    [route.id]: error\n                }\n            }, {\n                flushSync\n            });\n            return;\n        }\n        pendingNavigationController = new AbortController();\n        let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);\n        let scopedContext = new unstable_RouterContextProvider(init.unstable_getContext ? await init.unstable_getContext() : void 0);\n        let pendingActionResult;\n        if (opts && opts.pendingError) {\n            pendingActionResult = [\n                findNearestBoundary(matches).route.id,\n                {\n                    type: \"error\" /* error */ ,\n                    error: opts.pendingError\n                }\n            ];\n        } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {\n            let actionResult = await handleAction(request, location, opts.submission, matches, scopedContext, fogOfWar.active, opts && opts.initialHydration === true, {\n                replace: opts.replace,\n                flushSync\n            });\n            if (actionResult.shortCircuited) {\n                return;\n            }\n            if (actionResult.pendingActionResult) {\n                let [routeId, result] = actionResult.pendingActionResult;\n                if (isErrorResult(result) && isRouteErrorResponse(result.error) && result.error.status === 404) {\n                    pendingNavigationController = null;\n                    completeNavigation(location, {\n                        matches: actionResult.matches,\n                        loaderData: {},\n                        errors: {\n                            [routeId]: result.error\n                        }\n                    });\n                    return;\n                }\n            }\n            matches = actionResult.matches || matches;\n            pendingActionResult = actionResult.pendingActionResult;\n            loadingNavigation = getLoadingNavigation(location, opts.submission);\n            flushSync = false;\n            fogOfWar.active = false;\n            request = createClientSideRequest(init.history, request.url, request.signal);\n        }\n        let { shortCircuited, matches: updatedMatches, loaderData, errors } = await handleLoaders(request, location, matches, scopedContext, fogOfWar.active, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, opts && opts.initialHydration === true, flushSync, pendingActionResult);\n        if (shortCircuited) {\n            return;\n        }\n        pendingNavigationController = null;\n        completeNavigation(location, {\n            matches: updatedMatches || matches,\n            ...getActionDataForCommit(pendingActionResult),\n            loaderData,\n            errors\n        });\n    }\n    async function handleAction(request, location, submission, matches, scopedContext, isFogOfWar, initialHydration, opts = {}) {\n        interruptActiveLoads();\n        let navigation = getSubmittingNavigation(location, submission);\n        updateState({\n            navigation\n        }, {\n            flushSync: opts.flushSync === true\n        });\n        if (isFogOfWar) {\n            let discoverResult = await discoverRoutes(matches, location.pathname, request.signal);\n            if (discoverResult.type === \"aborted\") {\n                return {\n                    shortCircuited: true\n                };\n            } else if (discoverResult.type === \"error\") {\n                let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;\n                return {\n                    matches: discoverResult.partialMatches,\n                    pendingActionResult: [\n                        boundaryId,\n                        {\n                            type: \"error\" /* error */ ,\n                            error: discoverResult.error\n                        }\n                    ]\n                };\n            } else if (!discoverResult.matches) {\n                let { notFoundMatches, error, route } = handleNavigational404(location.pathname);\n                return {\n                    matches: notFoundMatches,\n                    pendingActionResult: [\n                        route.id,\n                        {\n                            type: \"error\" /* error */ ,\n                            error\n                        }\n                    ]\n                };\n            } else {\n                matches = discoverResult.matches;\n            }\n        }\n        let result;\n        let actionMatch = getTargetMatch(matches, location);\n        if (!actionMatch.route.action && !actionMatch.route.lazy) {\n            result = {\n                type: \"error\" /* error */ ,\n                error: getInternalRouterError(405, {\n                    method: request.method,\n                    pathname: location.pathname,\n                    routeId: actionMatch.route.id\n                })\n            };\n        } else {\n            let dsMatches = getTargetedDataStrategyMatches(mapRouteProperties2, manifest, request, matches, actionMatch, initialHydration ? [] : hydrationRouteProperties2, scopedContext);\n            let results = await callDataStrategy(request, dsMatches, scopedContext, null);\n            result = results[actionMatch.route.id];\n            if (!result) {\n                for (let match of matches){\n                    if (results[match.route.id]) {\n                        result = results[match.route.id];\n                        break;\n                    }\n                }\n            }\n            if (request.signal.aborted) {\n                return {\n                    shortCircuited: true\n                };\n            }\n        }\n        if (isRedirectResult(result)) {\n            let replace2;\n            if (opts && opts.replace != null) {\n                replace2 = opts.replace;\n            } else {\n                let location2 = normalizeRedirectLocation(result.response.headers.get(\"Location\"), new URL(request.url), basename);\n                replace2 = location2 === state.location.pathname + state.location.search;\n            }\n            await startRedirectNavigation(request, result, true, {\n                submission,\n                replace: replace2\n            });\n            return {\n                shortCircuited: true\n            };\n        }\n        if (isErrorResult(result)) {\n            let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n            if ((opts && opts.replace) !== true) {\n                pendingAction = \"PUSH\" /* Push */ ;\n            }\n            return {\n                matches,\n                pendingActionResult: [\n                    boundaryMatch.route.id,\n                    result,\n                    actionMatch.route.id\n                ]\n            };\n        }\n        return {\n            matches,\n            pendingActionResult: [\n                actionMatch.route.id,\n                result\n            ]\n        };\n    }\n    async function handleLoaders(request, location, matches, scopedContext, isFogOfWar, overrideNavigation, submission, fetcherSubmission, replace2, initialHydration, flushSync, pendingActionResult) {\n        let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);\n        let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);\n        let shouldUpdateNavigationState = !isUninterruptedRevalidation && !initialHydration;\n        if (isFogOfWar) {\n            if (shouldUpdateNavigationState) {\n                let actionData = getUpdatedActionData(pendingActionResult);\n                updateState({\n                    navigation: loadingNavigation,\n                    ...actionData !== void 0 ? {\n                        actionData\n                    } : {}\n                }, {\n                    flushSync\n                });\n            }\n            let discoverResult = await discoverRoutes(matches, location.pathname, request.signal);\n            if (discoverResult.type === \"aborted\") {\n                return {\n                    shortCircuited: true\n                };\n            } else if (discoverResult.type === \"error\") {\n                let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;\n                return {\n                    matches: discoverResult.partialMatches,\n                    loaderData: {},\n                    errors: {\n                        [boundaryId]: discoverResult.error\n                    }\n                };\n            } else if (!discoverResult.matches) {\n                let { error, notFoundMatches, route } = handleNavigational404(location.pathname);\n                return {\n                    matches: notFoundMatches,\n                    loaderData: {},\n                    errors: {\n                        [route.id]: error\n                    }\n                };\n            } else {\n                matches = discoverResult.matches;\n            }\n        }\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let { dsMatches, revalidatingFetchers } = getMatchesToLoad(request, scopedContext, mapRouteProperties2, manifest, init.history, state, matches, activeSubmission, location, initialHydration ? [] : hydrationRouteProperties2, initialHydration === true, isRevalidationRequired, cancelledFetcherLoads, fetchersQueuedForDeletion, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, init.patchRoutesOnNavigation != null, pendingActionResult);\n        pendingNavigationLoadId = ++incrementingLoadId;\n        if (!init.dataStrategy && !dsMatches.some((m)=>m.shouldLoad) && revalidatingFetchers.length === 0) {\n            let updatedFetchers2 = markFetchRedirectsDone();\n            completeNavigation(location, {\n                matches,\n                loaderData: {},\n                // Commit pending error if we're short circuiting\n                errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? {\n                    [pendingActionResult[0]]: pendingActionResult[1].error\n                } : null,\n                ...getActionDataForCommit(pendingActionResult),\n                ...updatedFetchers2 ? {\n                    fetchers: new Map(state.fetchers)\n                } : {}\n            }, {\n                flushSync\n            });\n            return {\n                shortCircuited: true\n            };\n        }\n        if (shouldUpdateNavigationState) {\n            let updates = {};\n            if (!isFogOfWar) {\n                updates.navigation = loadingNavigation;\n                let actionData = getUpdatedActionData(pendingActionResult);\n                if (actionData !== void 0) {\n                    updates.actionData = actionData;\n                }\n            }\n            if (revalidatingFetchers.length > 0) {\n                updates.fetchers = getUpdatedRevalidatingFetchers(revalidatingFetchers);\n            }\n            updateState(updates, {\n                flushSync\n            });\n        }\n        revalidatingFetchers.forEach((rf)=>{\n            abortFetcher(rf.key);\n            if (rf.controller) {\n                fetchControllers.set(rf.key, rf.controller);\n            }\n        });\n        let abortPendingFetchRevalidations = ()=>revalidatingFetchers.forEach((f)=>abortFetcher(f.key));\n        if (pendingNavigationController) {\n            pendingNavigationController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n        }\n        let { loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(dsMatches, revalidatingFetchers, request, scopedContext);\n        if (request.signal.aborted) {\n            return {\n                shortCircuited: true\n            };\n        }\n        if (pendingNavigationController) {\n            pendingNavigationController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n        }\n        revalidatingFetchers.forEach((rf)=>fetchControllers.delete(rf.key));\n        let redirect2 = findRedirect(loaderResults);\n        if (redirect2) {\n            await startRedirectNavigation(request, redirect2.result, true, {\n                replace: replace2\n            });\n            return {\n                shortCircuited: true\n            };\n        }\n        redirect2 = findRedirect(fetcherResults);\n        if (redirect2) {\n            fetchRedirectIds.add(redirect2.key);\n            await startRedirectNavigation(request, redirect2.result, true, {\n                replace: replace2\n            });\n            return {\n                shortCircuited: true\n            };\n        }\n        let { loaderData, errors } = processLoaderData(state, matches, loaderResults, pendingActionResult, revalidatingFetchers, fetcherResults);\n        if (initialHydration && state.errors) {\n            errors = {\n                ...state.errors,\n                ...errors\n            };\n        }\n        let updatedFetchers = markFetchRedirectsDone();\n        let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n        let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;\n        return {\n            matches,\n            loaderData,\n            errors,\n            ...shouldUpdateFetchers ? {\n                fetchers: new Map(state.fetchers)\n            } : {}\n        };\n    }\n    function getUpdatedActionData(pendingActionResult) {\n        if (pendingActionResult && !isErrorResult(pendingActionResult[1])) {\n            return {\n                [pendingActionResult[0]]: pendingActionResult[1].data\n            };\n        } else if (state.actionData) {\n            if (Object.keys(state.actionData).length === 0) {\n                return null;\n            } else {\n                return state.actionData;\n            }\n        }\n    }\n    function getUpdatedRevalidatingFetchers(revalidatingFetchers) {\n        revalidatingFetchers.forEach((rf)=>{\n            let fetcher = state.fetchers.get(rf.key);\n            let revalidatingFetcher = getLoadingFetcher(void 0, fetcher ? fetcher.data : void 0);\n            state.fetchers.set(rf.key, revalidatingFetcher);\n        });\n        return new Map(state.fetchers);\n    }\n    async function fetch2(key, routeId, href2, opts) {\n        abortFetcher(key);\n        let flushSync = (opts && opts.flushSync) === true;\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let normalizedPath = normalizeTo(state.location, state.matches, basename, href2, routeId, opts?.relative);\n        let matches = matchRoutes(routesToUse, normalizedPath, basename);\n        let fogOfWar = checkFogOfWar(matches, routesToUse, normalizedPath);\n        if (fogOfWar.active && fogOfWar.matches) {\n            matches = fogOfWar.matches;\n        }\n        if (!matches) {\n            setFetcherError(key, routeId, getInternalRouterError(404, {\n                pathname: normalizedPath\n            }), {\n                flushSync\n            });\n            return;\n        }\n        let { path, submission, error } = normalizeNavigateOptions(true, normalizedPath, opts);\n        if (error) {\n            setFetcherError(key, routeId, error, {\n                flushSync\n            });\n            return;\n        }\n        let match = getTargetMatch(matches, path);\n        let scopedContext = new unstable_RouterContextProvider(init.unstable_getContext ? await init.unstable_getContext() : void 0);\n        let preventScrollReset = (opts && opts.preventScrollReset) === true;\n        if (submission && isMutationMethod(submission.formMethod)) {\n            await handleFetcherAction(key, routeId, path, match, matches, scopedContext, fogOfWar.active, flushSync, preventScrollReset, submission);\n            return;\n        }\n        fetchLoadMatches.set(key, {\n            routeId,\n            path\n        });\n        await handleFetcherLoader(key, routeId, path, match, matches, scopedContext, fogOfWar.active, flushSync, preventScrollReset, submission);\n    }\n    async function handleFetcherAction(key, routeId, path, match, requestMatches, scopedContext, isFogOfWar, flushSync, preventScrollReset, submission) {\n        interruptActiveLoads();\n        fetchLoadMatches.delete(key);\n        function detectAndHandle405Error(m) {\n            if (!m.route.action && !m.route.lazy) {\n                let error = getInternalRouterError(405, {\n                    method: submission.formMethod,\n                    pathname: path,\n                    routeId\n                });\n                setFetcherError(key, routeId, error, {\n                    flushSync\n                });\n                return true;\n            }\n            return false;\n        }\n        if (!isFogOfWar && detectAndHandle405Error(match)) {\n            return;\n        }\n        let existingFetcher = state.fetchers.get(key);\n        updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {\n            flushSync\n        });\n        let abortController = new AbortController();\n        let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);\n        if (isFogOfWar) {\n            let discoverResult = await discoverRoutes(requestMatches, path, fetchRequest.signal, key);\n            if (discoverResult.type === \"aborted\") {\n                return;\n            } else if (discoverResult.type === \"error\") {\n                setFetcherError(key, routeId, discoverResult.error, {\n                    flushSync\n                });\n                return;\n            } else if (!discoverResult.matches) {\n                setFetcherError(key, routeId, getInternalRouterError(404, {\n                    pathname: path\n                }), {\n                    flushSync\n                });\n                return;\n            } else {\n                requestMatches = discoverResult.matches;\n                match = getTargetMatch(requestMatches, path);\n                if (detectAndHandle405Error(match)) {\n                    return;\n                }\n            }\n        }\n        fetchControllers.set(key, abortController);\n        let originatingLoadId = incrementingLoadId;\n        let fetchMatches = getTargetedDataStrategyMatches(mapRouteProperties2, manifest, fetchRequest, requestMatches, match, hydrationRouteProperties2, scopedContext);\n        let actionResults = await callDataStrategy(fetchRequest, fetchMatches, scopedContext, key);\n        let actionResult = actionResults[match.route.id];\n        if (fetchRequest.signal.aborted) {\n            if (fetchControllers.get(key) === abortController) {\n                fetchControllers.delete(key);\n            }\n            return;\n        }\n        if (fetchersQueuedForDeletion.has(key)) {\n            if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {\n                updateFetcherState(key, getDoneFetcher(void 0));\n                return;\n            }\n        } else {\n            if (isRedirectResult(actionResult)) {\n                fetchControllers.delete(key);\n                if (pendingNavigationLoadId > originatingLoadId) {\n                    updateFetcherState(key, getDoneFetcher(void 0));\n                    return;\n                } else {\n                    fetchRedirectIds.add(key);\n                    updateFetcherState(key, getLoadingFetcher(submission));\n                    return startRedirectNavigation(fetchRequest, actionResult, false, {\n                        fetcherSubmission: submission,\n                        preventScrollReset\n                    });\n                }\n            }\n            if (isErrorResult(actionResult)) {\n                setFetcherError(key, routeId, actionResult.error);\n                return;\n            }\n        }\n        let nextLocation = state.navigation.location || state.location;\n        let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let matches = state.navigation.state !== \"idle\" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;\n        invariant(matches, \"Didn't find any matches after fetcher action\");\n        let loadId = ++incrementingLoadId;\n        fetchReloadIds.set(key, loadId);\n        let loadFetcher = getLoadingFetcher(submission, actionResult.data);\n        state.fetchers.set(key, loadFetcher);\n        let { dsMatches, revalidatingFetchers } = getMatchesToLoad(revalidationRequest, scopedContext, mapRouteProperties2, manifest, init.history, state, matches, submission, nextLocation, hydrationRouteProperties2, false, isRevalidationRequired, cancelledFetcherLoads, fetchersQueuedForDeletion, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, init.patchRoutesOnNavigation != null, [\n            match.route.id,\n            actionResult\n        ]);\n        revalidatingFetchers.filter((rf)=>rf.key !== key).forEach((rf)=>{\n            let staleKey = rf.key;\n            let existingFetcher2 = state.fetchers.get(staleKey);\n            let revalidatingFetcher = getLoadingFetcher(void 0, existingFetcher2 ? existingFetcher2.data : void 0);\n            state.fetchers.set(staleKey, revalidatingFetcher);\n            abortFetcher(staleKey);\n            if (rf.controller) {\n                fetchControllers.set(staleKey, rf.controller);\n            }\n        });\n        updateState({\n            fetchers: new Map(state.fetchers)\n        });\n        let abortPendingFetchRevalidations = ()=>revalidatingFetchers.forEach((rf)=>abortFetcher(rf.key));\n        abortController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n        let { loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(dsMatches, revalidatingFetchers, revalidationRequest, scopedContext);\n        if (abortController.signal.aborted) {\n            return;\n        }\n        abortController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n        fetchReloadIds.delete(key);\n        fetchControllers.delete(key);\n        revalidatingFetchers.forEach((r)=>fetchControllers.delete(r.key));\n        if (state.fetchers.has(key)) {\n            let doneFetcher = getDoneFetcher(actionResult.data);\n            state.fetchers.set(key, doneFetcher);\n        }\n        let redirect2 = findRedirect(loaderResults);\n        if (redirect2) {\n            return startRedirectNavigation(revalidationRequest, redirect2.result, false, {\n                preventScrollReset\n            });\n        }\n        redirect2 = findRedirect(fetcherResults);\n        if (redirect2) {\n            fetchRedirectIds.add(redirect2.key);\n            return startRedirectNavigation(revalidationRequest, redirect2.result, false, {\n                preventScrollReset\n            });\n        }\n        let { loaderData, errors } = processLoaderData(state, matches, loaderResults, void 0, revalidatingFetchers, fetcherResults);\n        abortStaleFetchLoads(loadId);\n        if (state.navigation.state === \"loading\" && loadId > pendingNavigationLoadId) {\n            invariant(pendingAction, \"Expected pending action\");\n            pendingNavigationController && pendingNavigationController.abort();\n            completeNavigation(state.navigation.location, {\n                matches,\n                loaderData,\n                errors,\n                fetchers: new Map(state.fetchers)\n            });\n        } else {\n            updateState({\n                errors,\n                loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors),\n                fetchers: new Map(state.fetchers)\n            });\n            isRevalidationRequired = false;\n        }\n    }\n    async function handleFetcherLoader(key, routeId, path, match, matches, scopedContext, isFogOfWar, flushSync, preventScrollReset, submission) {\n        let existingFetcher = state.fetchers.get(key);\n        updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : void 0), {\n            flushSync\n        });\n        let abortController = new AbortController();\n        let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);\n        if (isFogOfWar) {\n            let discoverResult = await discoverRoutes(matches, path, fetchRequest.signal, key);\n            if (discoverResult.type === \"aborted\") {\n                return;\n            } else if (discoverResult.type === \"error\") {\n                setFetcherError(key, routeId, discoverResult.error, {\n                    flushSync\n                });\n                return;\n            } else if (!discoverResult.matches) {\n                setFetcherError(key, routeId, getInternalRouterError(404, {\n                    pathname: path\n                }), {\n                    flushSync\n                });\n                return;\n            } else {\n                matches = discoverResult.matches;\n                match = getTargetMatch(matches, path);\n            }\n        }\n        fetchControllers.set(key, abortController);\n        let originatingLoadId = incrementingLoadId;\n        let dsMatches = getTargetedDataStrategyMatches(mapRouteProperties2, manifest, fetchRequest, matches, match, hydrationRouteProperties2, scopedContext);\n        let results = await callDataStrategy(fetchRequest, dsMatches, scopedContext, key);\n        let result = results[match.route.id];\n        if (fetchControllers.get(key) === abortController) {\n            fetchControllers.delete(key);\n        }\n        if (fetchRequest.signal.aborted) {\n            return;\n        }\n        if (fetchersQueuedForDeletion.has(key)) {\n            updateFetcherState(key, getDoneFetcher(void 0));\n            return;\n        }\n        if (isRedirectResult(result)) {\n            if (pendingNavigationLoadId > originatingLoadId) {\n                updateFetcherState(key, getDoneFetcher(void 0));\n                return;\n            } else {\n                fetchRedirectIds.add(key);\n                await startRedirectNavigation(fetchRequest, result, false, {\n                    preventScrollReset\n                });\n                return;\n            }\n        }\n        if (isErrorResult(result)) {\n            setFetcherError(key, routeId, result.error);\n            return;\n        }\n        updateFetcherState(key, getDoneFetcher(result.data));\n    }\n    async function startRedirectNavigation(request, redirect2, isNavigation, { submission, fetcherSubmission, preventScrollReset, replace: replace2 } = {}) {\n        if (redirect2.response.headers.has(\"X-Remix-Revalidate\")) {\n            isRevalidationRequired = true;\n        }\n        let location = redirect2.response.headers.get(\"Location\");\n        invariant(location, \"Expected a Location header on the redirect Response\");\n        location = normalizeRedirectLocation(location, new URL(request.url), basename);\n        let redirectLocation = createLocation(state.location, location, {\n            _isRedirect: true\n        });\n        if (isBrowser2) {\n            let isDocumentReload = false;\n            if (redirect2.response.headers.has(\"X-Remix-Reload-Document\")) {\n                isDocumentReload = true;\n            } else if (ABSOLUTE_URL_REGEX.test(location)) {\n                const url = createBrowserURLImpl(location, true);\n                isDocumentReload = url.origin !== routerWindow.location.origin || // Hard reload if it's an absolute URL that does not match our basename\n                stripBasename(url.pathname, basename) == null;\n            }\n            if (isDocumentReload) {\n                if (replace2) {\n                    routerWindow.location.replace(location);\n                } else {\n                    routerWindow.location.assign(location);\n                }\n                return;\n            }\n        }\n        pendingNavigationController = null;\n        let redirectNavigationType = replace2 === true || redirect2.response.headers.has(\"X-Remix-Replace\") ? \"REPLACE\" /* Replace */  : \"PUSH\" /* Push */ ;\n        let { formMethod, formAction, formEncType } = state.navigation;\n        if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {\n            submission = getSubmissionFromNavigation(state.navigation);\n        }\n        let activeSubmission = submission || fetcherSubmission;\n        if (redirectPreserveMethodStatusCodes.has(redirect2.response.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {\n            await startNavigation(redirectNavigationType, redirectLocation, {\n                submission: {\n                    ...activeSubmission,\n                    formAction: location\n                },\n                // Preserve these flags across redirects\n                preventScrollReset: preventScrollReset || pendingPreventScrollReset,\n                enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0\n            });\n        } else {\n            let overrideNavigation = getLoadingNavigation(redirectLocation, submission);\n            await startNavigation(redirectNavigationType, redirectLocation, {\n                overrideNavigation,\n                // Send fetcher submissions through for shouldRevalidate\n                fetcherSubmission,\n                // Preserve these flags across redirects\n                preventScrollReset: preventScrollReset || pendingPreventScrollReset,\n                enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0\n            });\n        }\n    }\n    async function callDataStrategy(request, matches, scopedContext, fetcherKey) {\n        let results;\n        let dataResults = {};\n        try {\n            results = await callDataStrategyImpl(dataStrategyImpl, request, matches, fetcherKey, scopedContext, false);\n        } catch (e) {\n            matches.filter((m)=>m.shouldLoad).forEach((m)=>{\n                dataResults[m.route.id] = {\n                    type: \"error\" /* error */ ,\n                    error: e\n                };\n            });\n            return dataResults;\n        }\n        if (request.signal.aborted) {\n            return dataResults;\n        }\n        for (let [routeId, result] of Object.entries(results)){\n            if (isRedirectDataStrategyResult(result)) {\n                let response = result.result;\n                dataResults[routeId] = {\n                    type: \"redirect\" /* redirect */ ,\n                    response: normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename)\n                };\n            } else {\n                dataResults[routeId] = await convertDataStrategyResultToDataResult(result);\n            }\n        }\n        return dataResults;\n    }\n    async function callLoadersAndMaybeResolveData(matches, fetchersToLoad, request, scopedContext) {\n        let loaderResultsPromise = callDataStrategy(request, matches, scopedContext, null);\n        let fetcherResultsPromise = Promise.all(fetchersToLoad.map(async (f)=>{\n            if (f.matches && f.match && f.request && f.controller) {\n                let results = await callDataStrategy(f.request, f.matches, scopedContext, f.key);\n                let result = results[f.match.route.id];\n                return {\n                    [f.key]: result\n                };\n            } else {\n                return Promise.resolve({\n                    [f.key]: {\n                        type: \"error\" /* error */ ,\n                        error: getInternalRouterError(404, {\n                            pathname: f.path\n                        })\n                    }\n                });\n            }\n        }));\n        let loaderResults = await loaderResultsPromise;\n        let fetcherResults = (await fetcherResultsPromise).reduce((acc, r)=>Object.assign(acc, r), {});\n        return {\n            loaderResults,\n            fetcherResults\n        };\n    }\n    function interruptActiveLoads() {\n        isRevalidationRequired = true;\n        fetchLoadMatches.forEach((_, key)=>{\n            if (fetchControllers.has(key)) {\n                cancelledFetcherLoads.add(key);\n            }\n            abortFetcher(key);\n        });\n    }\n    function updateFetcherState(key, fetcher, opts = {}) {\n        state.fetchers.set(key, fetcher);\n        updateState({\n            fetchers: new Map(state.fetchers)\n        }, {\n            flushSync: (opts && opts.flushSync) === true\n        });\n    }\n    function setFetcherError(key, routeId, error, opts = {}) {\n        let boundaryMatch = findNearestBoundary(state.matches, routeId);\n        deleteFetcher(key);\n        updateState({\n            errors: {\n                [boundaryMatch.route.id]: error\n            },\n            fetchers: new Map(state.fetchers)\n        }, {\n            flushSync: (opts && opts.flushSync) === true\n        });\n    }\n    function getFetcher(key) {\n        activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);\n        if (fetchersQueuedForDeletion.has(key)) {\n            fetchersQueuedForDeletion.delete(key);\n        }\n        return state.fetchers.get(key) || IDLE_FETCHER;\n    }\n    function deleteFetcher(key) {\n        let fetcher = state.fetchers.get(key);\n        if (fetchControllers.has(key) && !(fetcher && fetcher.state === \"loading\" && fetchReloadIds.has(key))) {\n            abortFetcher(key);\n        }\n        fetchLoadMatches.delete(key);\n        fetchReloadIds.delete(key);\n        fetchRedirectIds.delete(key);\n        fetchersQueuedForDeletion.delete(key);\n        cancelledFetcherLoads.delete(key);\n        state.fetchers.delete(key);\n    }\n    function queueFetcherForDeletion(key) {\n        let count = (activeFetchers.get(key) || 0) - 1;\n        if (count <= 0) {\n            activeFetchers.delete(key);\n            fetchersQueuedForDeletion.add(key);\n        } else {\n            activeFetchers.set(key, count);\n        }\n        updateState({\n            fetchers: new Map(state.fetchers)\n        });\n    }\n    function abortFetcher(key) {\n        let controller = fetchControllers.get(key);\n        if (controller) {\n            controller.abort();\n            fetchControllers.delete(key);\n        }\n    }\n    function markFetchersDone(keys) {\n        for (let key of keys){\n            let fetcher = getFetcher(key);\n            let doneFetcher = getDoneFetcher(fetcher.data);\n            state.fetchers.set(key, doneFetcher);\n        }\n    }\n    function markFetchRedirectsDone() {\n        let doneKeys = [];\n        let updatedFetchers = false;\n        for (let key of fetchRedirectIds){\n            let fetcher = state.fetchers.get(key);\n            invariant(fetcher, `Expected fetcher: ${key}`);\n            if (fetcher.state === \"loading\") {\n                fetchRedirectIds.delete(key);\n                doneKeys.push(key);\n                updatedFetchers = true;\n            }\n        }\n        markFetchersDone(doneKeys);\n        return updatedFetchers;\n    }\n    function abortStaleFetchLoads(landedId) {\n        let yeetedKeys = [];\n        for (let [key, id] of fetchReloadIds){\n            if (id < landedId) {\n                let fetcher = state.fetchers.get(key);\n                invariant(fetcher, `Expected fetcher: ${key}`);\n                if (fetcher.state === \"loading\") {\n                    abortFetcher(key);\n                    fetchReloadIds.delete(key);\n                    yeetedKeys.push(key);\n                }\n            }\n        }\n        markFetchersDone(yeetedKeys);\n        return yeetedKeys.length > 0;\n    }\n    function getBlocker(key, fn) {\n        let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n        if (blockerFunctions.get(key) !== fn) {\n            blockerFunctions.set(key, fn);\n        }\n        return blocker;\n    }\n    function deleteBlocker(key) {\n        state.blockers.delete(key);\n        blockerFunctions.delete(key);\n    }\n    function updateBlocker(key, newBlocker) {\n        let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n        invariant(blocker.state === \"unblocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"proceeding\" || blocker.state === \"blocked\" && newBlocker.state === \"unblocked\" || blocker.state === \"proceeding\" && newBlocker.state === \"unblocked\", `Invalid blocker state transition: ${blocker.state} -> ${newBlocker.state}`);\n        let blockers = new Map(state.blockers);\n        blockers.set(key, newBlocker);\n        updateState({\n            blockers\n        });\n    }\n    function shouldBlockNavigation({ currentLocation, nextLocation, historyAction }) {\n        if (blockerFunctions.size === 0) {\n            return;\n        }\n        if (blockerFunctions.size > 1) {\n            warning(false, \"A router only supports one blocker at a time\");\n        }\n        let entries = Array.from(blockerFunctions.entries());\n        let [blockerKey, blockerFunction] = entries[entries.length - 1];\n        let blocker = state.blockers.get(blockerKey);\n        if (blocker && blocker.state === \"proceeding\") {\n            return;\n        }\n        if (blockerFunction({\n            currentLocation,\n            nextLocation,\n            historyAction\n        })) {\n            return blockerKey;\n        }\n    }\n    function handleNavigational404(pathname) {\n        let error = getInternalRouterError(404, {\n            pathname\n        });\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let { matches, route } = getShortCircuitMatches(routesToUse);\n        return {\n            notFoundMatches: matches,\n            route,\n            error\n        };\n    }\n    function enableScrollRestoration(positions, getPosition, getKey) {\n        savedScrollPositions2 = positions;\n        getScrollPosition = getPosition;\n        getScrollRestorationKey2 = getKey || null;\n        if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\n            initialScrollRestored = true;\n            let y = getSavedScrollPosition(state.location, state.matches);\n            if (y != null) {\n                updateState({\n                    restoreScrollPosition: y\n                });\n            }\n        }\n        return ()=>{\n            savedScrollPositions2 = null;\n            getScrollPosition = null;\n            getScrollRestorationKey2 = null;\n        };\n    }\n    function getScrollKey(location, matches) {\n        if (getScrollRestorationKey2) {\n            let key = getScrollRestorationKey2(location, matches.map((m)=>convertRouteMatchToUiMatch(m, state.loaderData)));\n            return key || location.key;\n        }\n        return location.key;\n    }\n    function saveScrollPosition(location, matches) {\n        if (savedScrollPositions2 && getScrollPosition) {\n            let key = getScrollKey(location, matches);\n            savedScrollPositions2[key] = getScrollPosition();\n        }\n    }\n    function getSavedScrollPosition(location, matches) {\n        if (savedScrollPositions2) {\n            let key = getScrollKey(location, matches);\n            let y = savedScrollPositions2[key];\n            if (typeof y === \"number\") {\n                return y;\n            }\n        }\n        return null;\n    }\n    function checkFogOfWar(matches, routesToUse, pathname) {\n        if (init.patchRoutesOnNavigation) {\n            if (!matches) {\n                let fogMatches = matchRoutesImpl(routesToUse, pathname, basename, true);\n                return {\n                    active: true,\n                    matches: fogMatches || []\n                };\n            } else {\n                if (Object.keys(matches[0].params).length > 0) {\n                    let partialMatches = matchRoutesImpl(routesToUse, pathname, basename, true);\n                    return {\n                        active: true,\n                        matches: partialMatches\n                    };\n                }\n            }\n        }\n        return {\n            active: false,\n            matches: null\n        };\n    }\n    async function discoverRoutes(matches, pathname, signal, fetcherKey) {\n        if (!init.patchRoutesOnNavigation) {\n            return {\n                type: \"success\",\n                matches\n            };\n        }\n        let partialMatches = matches;\n        while(true){\n            let isNonHMR = inFlightDataRoutes == null;\n            let routesToUse = inFlightDataRoutes || dataRoutes;\n            let localManifest = manifest;\n            try {\n                await init.patchRoutesOnNavigation({\n                    signal,\n                    path: pathname,\n                    matches: partialMatches,\n                    fetcherKey,\n                    patch: (routeId, children)=>{\n                        if (signal.aborted) return;\n                        patchRoutesImpl(routeId, children, routesToUse, localManifest, mapRouteProperties2);\n                    }\n                });\n            } catch (e) {\n                return {\n                    type: \"error\",\n                    error: e,\n                    partialMatches\n                };\n            } finally{\n                if (isNonHMR && !signal.aborted) {\n                    dataRoutes = [\n                        ...dataRoutes\n                    ];\n                }\n            }\n            if (signal.aborted) {\n                return {\n                    type: \"aborted\"\n                };\n            }\n            let newMatches = matchRoutes(routesToUse, pathname, basename);\n            if (newMatches) {\n                return {\n                    type: \"success\",\n                    matches: newMatches\n                };\n            }\n            let newPartialMatches = matchRoutesImpl(routesToUse, pathname, basename, true);\n            if (!newPartialMatches || partialMatches.length === newPartialMatches.length && partialMatches.every((m, i)=>m.route.id === newPartialMatches[i].route.id)) {\n                return {\n                    type: \"success\",\n                    matches: null\n                };\n            }\n            partialMatches = newPartialMatches;\n        }\n    }\n    function _internalSetRoutes(newRoutes) {\n        manifest = {};\n        inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties2, void 0, manifest);\n    }\n    function patchRoutes(routeId, children) {\n        let isNonHMR = inFlightDataRoutes == null;\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties2);\n        if (isNonHMR) {\n            dataRoutes = [\n                ...dataRoutes\n            ];\n            updateState({});\n        }\n    }\n    router = {\n        get basename () {\n            return basename;\n        },\n        get future () {\n            return future;\n        },\n        get state () {\n            return state;\n        },\n        get routes () {\n            return dataRoutes;\n        },\n        get window () {\n            return routerWindow;\n        },\n        initialize,\n        subscribe,\n        enableScrollRestoration,\n        navigate,\n        fetch: fetch2,\n        revalidate,\n        // Passthrough to history-aware createHref used by useHref so we get proper\n        // hash-aware URLs in DOM paths\n        createHref: (to)=>init.history.createHref(to),\n        encodeLocation: (to)=>init.history.encodeLocation(to),\n        getFetcher,\n        deleteFetcher: queueFetcherForDeletion,\n        dispose,\n        getBlocker,\n        deleteBlocker,\n        patchRoutes,\n        _internalFetchControllers: fetchControllers,\n        // TODO: Remove setRoutes, it's temporary to avoid dealing with\n        // updating the tree while validating the update algorithm.\n        _internalSetRoutes\n    };\n    return router;\n}\nfunction createStaticHandler(routes, opts) {\n    invariant(routes.length > 0, \"You must provide a non-empty routes array to createStaticHandler\");\n    let manifest = {};\n    let basename = (opts ? opts.basename : null) || \"/\";\n    let mapRouteProperties2 = opts?.mapRouteProperties || defaultMapRouteProperties;\n    let dataRoutes = convertRoutesToDataRoutes(routes, mapRouteProperties2, void 0, manifest);\n    async function query(request, { requestContext, filterMatchesToLoad, skipLoaderErrorBubbling, skipRevalidation, dataStrategy, unstable_respond: respond } = {}) {\n        let url = new URL(request.url);\n        let method = request.method;\n        let location = createLocation(\"\", createPath(url), null, \"default\");\n        let matches = matchRoutes(dataRoutes, location, basename);\n        requestContext = requestContext != null ? requestContext : new unstable_RouterContextProvider();\n        if (!isValidMethod(method) && method !== \"HEAD\") {\n            let error = getInternalRouterError(405, {\n                method\n            });\n            let { matches: methodNotAllowedMatches, route } = getShortCircuitMatches(dataRoutes);\n            let staticContext = {\n                basename,\n                location,\n                matches: methodNotAllowedMatches,\n                loaderData: {},\n                actionData: null,\n                errors: {\n                    [route.id]: error\n                },\n                statusCode: error.status,\n                loaderHeaders: {},\n                actionHeaders: {}\n            };\n            return respond ? respond(staticContext) : staticContext;\n        } else if (!matches) {\n            let error = getInternalRouterError(404, {\n                pathname: location.pathname\n            });\n            let { matches: notFoundMatches, route } = getShortCircuitMatches(dataRoutes);\n            let staticContext = {\n                basename,\n                location,\n                matches: notFoundMatches,\n                loaderData: {},\n                actionData: null,\n                errors: {\n                    [route.id]: error\n                },\n                statusCode: error.status,\n                loaderHeaders: {},\n                actionHeaders: {}\n            };\n            return respond ? respond(staticContext) : staticContext;\n        }\n        if (respond && matches.some((m)=>m.route.unstable_middleware || typeof m.route.lazy === \"object\" && m.route.lazy.unstable_middleware)) {\n            invariant(requestContext instanceof unstable_RouterContextProvider, \"When using middleware in `staticHandler.query()`, any provided `requestContext` must be an instance of `unstable_RouterContextProvider`\");\n            try {\n                await loadLazyMiddlewareForMatches(matches, manifest, mapRouteProperties2);\n                let renderedStaticContext;\n                let response = await runMiddlewarePipeline({\n                    request,\n                    matches,\n                    params: matches[0].params,\n                    // If we're calling middleware then it must be enabled so we can cast\n                    // this to the proper type knowing it's not an `AppLoadContext`\n                    context: requestContext\n                }, true, async ()=>{\n                    let result2 = await queryImpl(request, location, matches, requestContext, dataStrategy || null, skipLoaderErrorBubbling === true, null, filterMatchesToLoad || null, skipRevalidation === true);\n                    if (isResponse(result2)) {\n                        return result2;\n                    }\n                    renderedStaticContext = {\n                        location,\n                        basename,\n                        ...result2\n                    };\n                    let res = await respond(renderedStaticContext);\n                    return res;\n                }, async (error, routeId)=>{\n                    if (isResponse(error)) {\n                        return error;\n                    }\n                    if (renderedStaticContext) {\n                        if (routeId in renderedStaticContext.loaderData) {\n                            renderedStaticContext.loaderData[routeId] = void 0;\n                        }\n                        return respond(getStaticContextFromError(dataRoutes, renderedStaticContext, error, skipLoaderErrorBubbling ? routeId : findNearestBoundary(matches, routeId).route.id));\n                    } else {\n                        let boundaryRouteId = skipLoaderErrorBubbling ? routeId : findNearestBoundary(matches, matches.find((m)=>m.route.id === routeId || m.route.loader)?.route.id || routeId).route.id;\n                        return respond({\n                            matches,\n                            location,\n                            basename,\n                            loaderData: {},\n                            actionData: null,\n                            errors: {\n                                [boundaryRouteId]: error\n                            },\n                            statusCode: isRouteErrorResponse(error) ? error.status : 500,\n                            actionHeaders: {},\n                            loaderHeaders: {}\n                        });\n                    }\n                });\n                invariant(isResponse(response), \"Expected a response in query()\");\n                return response;\n            } catch (e) {\n                if (isResponse(e)) {\n                    return e;\n                }\n                throw e;\n            }\n        }\n        let result = await queryImpl(request, location, matches, requestContext, dataStrategy || null, skipLoaderErrorBubbling === true, null, filterMatchesToLoad || null, skipRevalidation === true);\n        if (isResponse(result)) {\n            return result;\n        }\n        return {\n            location,\n            basename,\n            ...result\n        };\n    }\n    async function queryRoute(request, { routeId, requestContext, dataStrategy, unstable_respond: respond } = {}) {\n        let url = new URL(request.url);\n        let method = request.method;\n        let location = createLocation(\"\", createPath(url), null, \"default\");\n        let matches = matchRoutes(dataRoutes, location, basename);\n        requestContext = requestContext != null ? requestContext : new unstable_RouterContextProvider();\n        if (!isValidMethod(method) && method !== \"HEAD\" && method !== \"OPTIONS\") {\n            throw getInternalRouterError(405, {\n                method\n            });\n        } else if (!matches) {\n            throw getInternalRouterError(404, {\n                pathname: location.pathname\n            });\n        }\n        let match = routeId ? matches.find((m)=>m.route.id === routeId) : getTargetMatch(matches, location);\n        if (routeId && !match) {\n            throw getInternalRouterError(403, {\n                pathname: location.pathname,\n                routeId\n            });\n        } else if (!match) {\n            throw getInternalRouterError(404, {\n                pathname: location.pathname\n            });\n        }\n        if (respond && matches.some((m)=>m.route.unstable_middleware || typeof m.route.lazy === \"object\" && m.route.lazy.unstable_middleware)) {\n            invariant(requestContext instanceof unstable_RouterContextProvider, \"When using middleware in `staticHandler.queryRoute()`, any provided `requestContext` must be an instance of `unstable_RouterContextProvider`\");\n            await loadLazyMiddlewareForMatches(matches, manifest, mapRouteProperties2);\n            let response = await runMiddlewarePipeline({\n                request,\n                matches,\n                params: matches[0].params,\n                // If we're calling middleware then it must be enabled so we can cast\n                // this to the proper type knowing it's not an `AppLoadContext`\n                context: requestContext\n            }, true, async ()=>{\n                let result2 = await queryImpl(request, location, matches, requestContext, dataStrategy || null, false, match, null, false);\n                if (isResponse(result2)) {\n                    return respond(result2);\n                }\n                let error2 = result2.errors ? Object.values(result2.errors)[0] : void 0;\n                if (error2 !== void 0) {\n                    throw error2;\n                }\n                let value = result2.actionData ? Object.values(result2.actionData)[0] : Object.values(result2.loaderData)[0];\n                return typeof value === \"string\" ? new Response(value) : Response.json(value);\n            }, (error2)=>{\n                if (isResponse(error2)) {\n                    return respond(error2);\n                }\n                return new Response(String(error2), {\n                    status: 500,\n                    statusText: \"Unexpected Server Error\"\n                });\n            });\n            return response;\n        }\n        let result = await queryImpl(request, location, matches, requestContext, dataStrategy || null, false, match, null, false);\n        if (isResponse(result)) {\n            return result;\n        }\n        let error = result.errors ? Object.values(result.errors)[0] : void 0;\n        if (error !== void 0) {\n            throw error;\n        }\n        if (result.actionData) {\n            return Object.values(result.actionData)[0];\n        }\n        if (result.loaderData) {\n            return Object.values(result.loaderData)[0];\n        }\n        return void 0;\n    }\n    async function queryImpl(request, location, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch, filterMatchesToLoad, skipRevalidation) {\n        invariant(request.signal, \"query()/queryRoute() requests must contain an AbortController signal\");\n        try {\n            if (isMutationMethod(request.method)) {\n                let result2 = await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch != null, filterMatchesToLoad, skipRevalidation);\n                return result2;\n            }\n            let result = await loadRouteData(request, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch, filterMatchesToLoad);\n            return isResponse(result) ? result : {\n                ...result,\n                actionData: null,\n                actionHeaders: {}\n            };\n        } catch (e) {\n            if (isDataStrategyResult(e) && isResponse(e.result)) {\n                if (e.type === \"error\" /* error */ ) {\n                    throw e.result;\n                }\n                return e.result;\n            }\n            if (isRedirectResponse(e)) {\n                return e;\n            }\n            throw e;\n        }\n    }\n    async function submit(request, matches, actionMatch, requestContext, dataStrategy, skipLoaderErrorBubbling, isRouteRequest, filterMatchesToLoad, skipRevalidation) {\n        let result;\n        if (!actionMatch.route.action && !actionMatch.route.lazy) {\n            let error = getInternalRouterError(405, {\n                method: request.method,\n                pathname: new URL(request.url).pathname,\n                routeId: actionMatch.route.id\n            });\n            if (isRouteRequest) {\n                throw error;\n            }\n            result = {\n                type: \"error\" /* error */ ,\n                error\n            };\n        } else {\n            let dsMatches = getTargetedDataStrategyMatches(mapRouteProperties2, manifest, request, matches, actionMatch, [], requestContext);\n            let results = await callDataStrategy(request, dsMatches, isRouteRequest, requestContext, dataStrategy);\n            result = results[actionMatch.route.id];\n            if (request.signal.aborted) {\n                throwStaticHandlerAbortedError(request, isRouteRequest);\n            }\n        }\n        if (isRedirectResult(result)) {\n            throw new Response(null, {\n                status: result.response.status,\n                headers: {\n                    Location: result.response.headers.get(\"Location\")\n                }\n            });\n        }\n        if (isRouteRequest) {\n            if (isErrorResult(result)) {\n                throw result.error;\n            }\n            return {\n                matches: [\n                    actionMatch\n                ],\n                loaderData: {},\n                actionData: {\n                    [actionMatch.route.id]: result.data\n                },\n                errors: null,\n                // Note: statusCode + headers are unused here since queryRoute will\n                // return the raw Response or value\n                statusCode: 200,\n                loaderHeaders: {},\n                actionHeaders: {}\n            };\n        }\n        if (skipRevalidation) {\n            if (isErrorResult(result)) {\n                let boundaryMatch = skipLoaderErrorBubbling ? actionMatch : findNearestBoundary(matches, actionMatch.route.id);\n                return {\n                    statusCode: isRouteErrorResponse(result.error) ? result.error.status : result.statusCode != null ? result.statusCode : 500,\n                    actionData: null,\n                    actionHeaders: {\n                        ...result.headers ? {\n                            [actionMatch.route.id]: result.headers\n                        } : {}\n                    },\n                    matches,\n                    loaderData: {},\n                    errors: {\n                        [boundaryMatch.route.id]: result.error\n                    },\n                    loaderHeaders: {}\n                };\n            } else {\n                return {\n                    actionData: {\n                        [actionMatch.route.id]: result.data\n                    },\n                    actionHeaders: result.headers ? {\n                        [actionMatch.route.id]: result.headers\n                    } : {},\n                    matches,\n                    loaderData: {},\n                    errors: null,\n                    statusCode: result.statusCode || 200,\n                    loaderHeaders: {}\n                };\n            }\n        }\n        let loaderRequest = new Request(request.url, {\n            headers: request.headers,\n            redirect: request.redirect,\n            signal: request.signal\n        });\n        if (isErrorResult(result)) {\n            let boundaryMatch = skipLoaderErrorBubbling ? actionMatch : findNearestBoundary(matches, actionMatch.route.id);\n            let handlerContext2 = await loadRouteData(loaderRequest, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, null, filterMatchesToLoad, [\n                boundaryMatch.route.id,\n                result\n            ]);\n            return {\n                ...handlerContext2,\n                statusCode: isRouteErrorResponse(result.error) ? result.error.status : result.statusCode != null ? result.statusCode : 500,\n                actionData: null,\n                actionHeaders: {\n                    ...result.headers ? {\n                        [actionMatch.route.id]: result.headers\n                    } : {}\n                }\n            };\n        }\n        let handlerContext = await loadRouteData(loaderRequest, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, null, filterMatchesToLoad);\n        return {\n            ...handlerContext,\n            actionData: {\n                [actionMatch.route.id]: result.data\n            },\n            // action status codes take precedence over loader status codes\n            ...result.statusCode ? {\n                statusCode: result.statusCode\n            } : {},\n            actionHeaders: result.headers ? {\n                [actionMatch.route.id]: result.headers\n            } : {}\n        };\n    }\n    async function loadRouteData(request, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch, filterMatchesToLoad, pendingActionResult) {\n        let isRouteRequest = routeMatch != null;\n        if (isRouteRequest && !routeMatch?.route.loader && !routeMatch?.route.lazy) {\n            throw getInternalRouterError(400, {\n                method: request.method,\n                pathname: new URL(request.url).pathname,\n                routeId: routeMatch?.route.id\n            });\n        }\n        let dsMatches;\n        if (routeMatch) {\n            dsMatches = getTargetedDataStrategyMatches(mapRouteProperties2, manifest, request, matches, routeMatch, [], requestContext);\n        } else {\n            let maxIdx = pendingActionResult && isErrorResult(pendingActionResult[1]) ? // Up to but not including the boundary\n            matches.findIndex((m)=>m.route.id === pendingActionResult[0]) - 1 : void 0;\n            dsMatches = matches.map((match, index)=>{\n                if (maxIdx != null && index > maxIdx) {\n                    return getDataStrategyMatch(mapRouteProperties2, manifest, request, match, [], requestContext, false);\n                }\n                return getDataStrategyMatch(mapRouteProperties2, manifest, request, match, [], requestContext, (match.route.loader || match.route.lazy) != null && (!filterMatchesToLoad || filterMatchesToLoad(match)));\n            });\n        }\n        if (!dataStrategy && !dsMatches.some((m)=>m.shouldLoad)) {\n            return {\n                matches,\n                loaderData: {},\n                errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? {\n                    [pendingActionResult[0]]: pendingActionResult[1].error\n                } : null,\n                statusCode: 200,\n                loaderHeaders: {}\n            };\n        }\n        let results = await callDataStrategy(request, dsMatches, isRouteRequest, requestContext, dataStrategy);\n        if (request.signal.aborted) {\n            throwStaticHandlerAbortedError(request, isRouteRequest);\n        }\n        let handlerContext = processRouteLoaderData(matches, results, pendingActionResult, true, skipLoaderErrorBubbling);\n        return {\n            ...handlerContext,\n            matches\n        };\n    }\n    async function callDataStrategy(request, matches, isRouteRequest, requestContext, dataStrategy) {\n        let results = await callDataStrategyImpl(dataStrategy || defaultDataStrategy, request, matches, null, requestContext, true);\n        let dataResults = {};\n        await Promise.all(matches.map(async (match)=>{\n            if (!(match.route.id in results)) {\n                return;\n            }\n            let result = results[match.route.id];\n            if (isRedirectDataStrategyResult(result)) {\n                let response = result.result;\n                throw normalizeRelativeRoutingRedirectResponse(response, request, match.route.id, matches, basename);\n            }\n            if (isResponse(result.result) && isRouteRequest) {\n                throw result;\n            }\n            dataResults[match.route.id] = await convertDataStrategyResultToDataResult(result);\n        }));\n        return dataResults;\n    }\n    return {\n        dataRoutes,\n        query,\n        queryRoute\n    };\n}\nfunction getStaticContextFromError(routes, handlerContext, error, boundaryId) {\n    let errorBoundaryId = boundaryId || handlerContext._deepestRenderedBoundaryId || routes[0].id;\n    return {\n        ...handlerContext,\n        statusCode: isRouteErrorResponse(error) ? error.status : 500,\n        errors: {\n            [errorBoundaryId]: error\n        }\n    };\n}\nfunction throwStaticHandlerAbortedError(request, isRouteRequest) {\n    if (request.signal.reason !== void 0) {\n        throw request.signal.reason;\n    }\n    let method = isRouteRequest ? \"queryRoute\" : \"query\";\n    throw new Error(`${method}() call aborted without an \\`AbortSignal.reason\\`: ${request.method} ${request.url}`);\n}\nfunction isSubmissionNavigation(opts) {\n    return opts != null && (\"formData\" in opts && opts.formData != null || \"body\" in opts && opts.body !== void 0);\n}\nfunction normalizeTo(location, matches, basename, to, fromRouteId, relative) {\n    let contextualMatches;\n    let activeRouteMatch;\n    if (fromRouteId) {\n        contextualMatches = [];\n        for (let match of matches){\n            contextualMatches.push(match);\n            if (match.route.id === fromRouteId) {\n                activeRouteMatch = match;\n                break;\n            }\n        }\n    } else {\n        contextualMatches = matches;\n        activeRouteMatch = matches[matches.length - 1];\n    }\n    let path = resolveTo(to ? to : \".\", getResolveToMatches(contextualMatches), stripBasename(location.pathname, basename) || location.pathname, relative === \"path\");\n    if (to == null) {\n        path.search = location.search;\n        path.hash = location.hash;\n    }\n    if ((to == null || to === \"\" || to === \".\") && activeRouteMatch) {\n        let nakedIndex = hasNakedIndexQuery(path.search);\n        if (activeRouteMatch.route.index && !nakedIndex) {\n            path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n        } else if (!activeRouteMatch.route.index && nakedIndex) {\n            let params = new URLSearchParams(path.search);\n            let indexValues = params.getAll(\"index\");\n            params.delete(\"index\");\n            indexValues.filter((v)=>v).forEach((v)=>params.append(\"index\", v));\n            let qs = params.toString();\n            path.search = qs ? `?${qs}` : \"\";\n        }\n    }\n    if (basename !== \"/\") {\n        path.pathname = path.pathname === \"/\" ? basename : joinPaths([\n            basename,\n            path.pathname\n        ]);\n    }\n    return createPath(path);\n}\nfunction normalizeNavigateOptions(isFetcher, path, opts) {\n    if (!opts || !isSubmissionNavigation(opts)) {\n        return {\n            path\n        };\n    }\n    if (opts.formMethod && !isValidMethod(opts.formMethod)) {\n        return {\n            path,\n            error: getInternalRouterError(405, {\n                method: opts.formMethod\n            })\n        };\n    }\n    let getInvalidBodyError = ()=>({\n            path,\n            error: getInternalRouterError(400, {\n                type: \"invalid-body\"\n            })\n        });\n    let rawFormMethod = opts.formMethod || \"get\";\n    let formMethod = rawFormMethod.toUpperCase();\n    let formAction = stripHashFromPath(path);\n    if (opts.body !== void 0) {\n        if (opts.formEncType === \"text/plain\") {\n            if (!isMutationMethod(formMethod)) {\n                return getInvalidBodyError();\n            }\n            let text = typeof opts.body === \"string\" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\n            Array.from(opts.body.entries()).reduce((acc, [name, value])=>`${acc}${name}=${value}\n`, \"\") : String(opts.body);\n            return {\n                path,\n                submission: {\n                    formMethod,\n                    formAction,\n                    formEncType: opts.formEncType,\n                    formData: void 0,\n                    json: void 0,\n                    text\n                }\n            };\n        } else if (opts.formEncType === \"application/json\") {\n            if (!isMutationMethod(formMethod)) {\n                return getInvalidBodyError();\n            }\n            try {\n                let json = typeof opts.body === \"string\" ? JSON.parse(opts.body) : opts.body;\n                return {\n                    path,\n                    submission: {\n                        formMethod,\n                        formAction,\n                        formEncType: opts.formEncType,\n                        formData: void 0,\n                        json,\n                        text: void 0\n                    }\n                };\n            } catch (e) {\n                return getInvalidBodyError();\n            }\n        }\n    }\n    invariant(typeof FormData === \"function\", \"FormData is not available in this environment\");\n    let searchParams;\n    let formData;\n    if (opts.formData) {\n        searchParams = convertFormDataToSearchParams(opts.formData);\n        formData = opts.formData;\n    } else if (opts.body instanceof FormData) {\n        searchParams = convertFormDataToSearchParams(opts.body);\n        formData = opts.body;\n    } else if (opts.body instanceof URLSearchParams) {\n        searchParams = opts.body;\n        formData = convertSearchParamsToFormData(searchParams);\n    } else if (opts.body == null) {\n        searchParams = new URLSearchParams();\n        formData = new FormData();\n    } else {\n        try {\n            searchParams = new URLSearchParams(opts.body);\n            formData = convertSearchParamsToFormData(searchParams);\n        } catch (e) {\n            return getInvalidBodyError();\n        }\n    }\n    let submission = {\n        formMethod,\n        formAction,\n        formEncType: opts && opts.formEncType || \"application/x-www-form-urlencoded\",\n        formData,\n        json: void 0,\n        text: void 0\n    };\n    if (isMutationMethod(submission.formMethod)) {\n        return {\n            path,\n            submission\n        };\n    }\n    let parsedPath = parsePath(path);\n    if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\n        searchParams.append(\"index\", \"\");\n    }\n    parsedPath.search = `?${searchParams}`;\n    return {\n        path: createPath(parsedPath),\n        submission\n    };\n}\nfunction getMatchesToLoad(request, scopedContext, mapRouteProperties2, manifest, history, state, matches, submission, location, lazyRoutePropertiesToSkip, initialHydration, isRevalidationRequired, cancelledFetcherLoads, fetchersQueuedForDeletion, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, hasPatchRoutesOnNavigation, pendingActionResult) {\n    let actionResult = pendingActionResult ? isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : pendingActionResult[1].data : void 0;\n    let currentUrl = history.createURL(state.location);\n    let nextUrl = history.createURL(location);\n    let maxIdx;\n    if (initialHydration && state.errors) {\n        let boundaryId = Object.keys(state.errors)[0];\n        maxIdx = matches.findIndex((m)=>m.route.id === boundaryId);\n    } else if (pendingActionResult && isErrorResult(pendingActionResult[1])) {\n        let boundaryId = pendingActionResult[0];\n        maxIdx = matches.findIndex((m)=>m.route.id === boundaryId) - 1;\n    }\n    let actionStatus = pendingActionResult ? pendingActionResult[1].statusCode : void 0;\n    let shouldSkipRevalidation = actionStatus && actionStatus >= 400;\n    let baseShouldRevalidateArgs = {\n        currentUrl,\n        currentParams: state.matches[0]?.params || {},\n        nextUrl,\n        nextParams: matches[0].params,\n        ...submission,\n        actionResult,\n        actionStatus\n    };\n    let dsMatches = matches.map((match, index)=>{\n        let { route } = match;\n        let forceShouldLoad = null;\n        if (maxIdx != null && index > maxIdx) {\n            forceShouldLoad = false;\n        } else if (route.lazy) {\n            forceShouldLoad = true;\n        } else if (route.loader == null) {\n            forceShouldLoad = false;\n        } else if (initialHydration) {\n            forceShouldLoad = shouldLoadRouteOnHydration(route, state.loaderData, state.errors);\n        } else if (isNewLoader(state.loaderData, state.matches[index], match)) {\n            forceShouldLoad = true;\n        }\n        if (forceShouldLoad !== null) {\n            return getDataStrategyMatch(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip, scopedContext, forceShouldLoad);\n        }\n        let defaultShouldRevalidate = shouldSkipRevalidation ? false : // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\n        isRevalidationRequired || currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders\n        currentUrl.search !== nextUrl.search || isNewRouteInstance(state.matches[index], match);\n        let shouldRevalidateArgs = {\n            ...baseShouldRevalidateArgs,\n            defaultShouldRevalidate\n        };\n        let shouldLoad = shouldRevalidateLoader(match, shouldRevalidateArgs);\n        return getDataStrategyMatch(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip, scopedContext, shouldLoad, shouldRevalidateArgs);\n    });\n    let revalidatingFetchers = [];\n    fetchLoadMatches.forEach((f, key)=>{\n        if (initialHydration || !matches.some((m)=>m.route.id === f.routeId) || fetchersQueuedForDeletion.has(key)) {\n            return;\n        }\n        let fetcher = state.fetchers.get(key);\n        let isMidInitialLoad = fetcher && fetcher.state !== \"idle\" && fetcher.data === void 0;\n        let fetcherMatches = matchRoutes(routesToUse, f.path, basename);\n        if (!fetcherMatches) {\n            if (hasPatchRoutesOnNavigation && isMidInitialLoad) {\n                return;\n            }\n            revalidatingFetchers.push({\n                key,\n                routeId: f.routeId,\n                path: f.path,\n                matches: null,\n                match: null,\n                request: null,\n                controller: null\n            });\n            return;\n        }\n        if (fetchRedirectIds.has(key)) {\n            return;\n        }\n        let fetcherMatch = getTargetMatch(fetcherMatches, f.path);\n        let fetchController = new AbortController();\n        let fetchRequest = createClientSideRequest(history, f.path, fetchController.signal);\n        let fetcherDsMatches = null;\n        if (cancelledFetcherLoads.has(key)) {\n            cancelledFetcherLoads.delete(key);\n            fetcherDsMatches = getTargetedDataStrategyMatches(mapRouteProperties2, manifest, fetchRequest, fetcherMatches, fetcherMatch, lazyRoutePropertiesToSkip, scopedContext);\n        } else if (isMidInitialLoad) {\n            if (isRevalidationRequired) {\n                fetcherDsMatches = getTargetedDataStrategyMatches(mapRouteProperties2, manifest, fetchRequest, fetcherMatches, fetcherMatch, lazyRoutePropertiesToSkip, scopedContext);\n            }\n        } else {\n            let shouldRevalidateArgs = {\n                ...baseShouldRevalidateArgs,\n                defaultShouldRevalidate: shouldSkipRevalidation ? false : isRevalidationRequired\n            };\n            if (shouldRevalidateLoader(fetcherMatch, shouldRevalidateArgs)) {\n                fetcherDsMatches = getTargetedDataStrategyMatches(mapRouteProperties2, manifest, fetchRequest, fetcherMatches, fetcherMatch, lazyRoutePropertiesToSkip, scopedContext, shouldRevalidateArgs);\n            }\n        }\n        if (fetcherDsMatches) {\n            revalidatingFetchers.push({\n                key,\n                routeId: f.routeId,\n                path: f.path,\n                matches: fetcherDsMatches,\n                match: fetcherMatch,\n                request: fetchRequest,\n                controller: fetchController\n            });\n        }\n    });\n    return {\n        dsMatches,\n        revalidatingFetchers\n    };\n}\nfunction shouldLoadRouteOnHydration(route, loaderData, errors) {\n    if (route.lazy) {\n        return true;\n    }\n    if (!route.loader) {\n        return false;\n    }\n    let hasData = loaderData != null && route.id in loaderData;\n    let hasError = errors != null && errors[route.id] !== void 0;\n    if (!hasData && hasError) {\n        return false;\n    }\n    if (typeof route.loader === \"function\" && route.loader.hydrate === true) {\n        return true;\n    }\n    return !hasData && !hasError;\n}\nfunction isNewLoader(currentLoaderData, currentMatch, match) {\n    let isNew = // [a] -> [a, b]\n    !currentMatch || // [a, b] -> [a, c]\n    match.route.id !== currentMatch.route.id;\n    let isMissingData = !currentLoaderData.hasOwnProperty(match.route.id);\n    return isNew || isMissingData;\n}\nfunction isNewRouteInstance(currentMatch, match) {\n    let currentPath = currentMatch.route.path;\n    return(// param change for this match, /users/123 -> /users/456\n    currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\n    currentPath != null && currentPath.endsWith(\"*\") && currentMatch.params[\"*\"] !== match.params[\"*\"]);\n}\nfunction shouldRevalidateLoader(loaderMatch, arg) {\n    if (loaderMatch.route.shouldRevalidate) {\n        let routeChoice = loaderMatch.route.shouldRevalidate(arg);\n        if (typeof routeChoice === \"boolean\") {\n            return routeChoice;\n        }\n    }\n    return arg.defaultShouldRevalidate;\n}\nfunction patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties2) {\n    let childrenToPatch;\n    if (routeId) {\n        let route = manifest[routeId];\n        invariant(route, `No route found to patch children into: routeId = ${routeId}`);\n        if (!route.children) {\n            route.children = [];\n        }\n        childrenToPatch = route.children;\n    } else {\n        childrenToPatch = routesToUse;\n    }\n    let uniqueChildren = children.filter((newRoute)=>!childrenToPatch.some((existingRoute)=>isSameRoute(newRoute, existingRoute)));\n    let newRoutes = convertRoutesToDataRoutes(uniqueChildren, mapRouteProperties2, [\n        routeId || \"_\",\n        \"patch\",\n        String(childrenToPatch?.length || \"0\")\n    ], manifest);\n    childrenToPatch.push(...newRoutes);\n}\nfunction isSameRoute(newRoute, existingRoute) {\n    if (\"id\" in newRoute && \"id\" in existingRoute && newRoute.id === existingRoute.id) {\n        return true;\n    }\n    if (!(newRoute.index === existingRoute.index && newRoute.path === existingRoute.path && newRoute.caseSensitive === existingRoute.caseSensitive)) {\n        return false;\n    }\n    if ((!newRoute.children || newRoute.children.length === 0) && (!existingRoute.children || existingRoute.children.length === 0)) {\n        return true;\n    }\n    return newRoute.children.every((aChild, i)=>existingRoute.children?.some((bChild)=>isSameRoute(aChild, bChild)));\n}\nvar lazyRoutePropertyCache = /* @__PURE__ */ new WeakMap();\nvar loadLazyRouteProperty = ({ key, route, manifest, mapRouteProperties: mapRouteProperties2 })=>{\n    let routeToUpdate = manifest[route.id];\n    invariant(routeToUpdate, \"No route found in manifest\");\n    if (!routeToUpdate.lazy || typeof routeToUpdate.lazy !== \"object\") {\n        return;\n    }\n    let lazyFn = routeToUpdate.lazy[key];\n    if (!lazyFn) {\n        return;\n    }\n    let cache = lazyRoutePropertyCache.get(routeToUpdate);\n    if (!cache) {\n        cache = {};\n        lazyRoutePropertyCache.set(routeToUpdate, cache);\n    }\n    let cachedPromise = cache[key];\n    if (cachedPromise) {\n        return cachedPromise;\n    }\n    let propertyPromise = (async ()=>{\n        let isUnsupported = isUnsupportedLazyRouteObjectKey(key);\n        let staticRouteValue = routeToUpdate[key];\n        let isStaticallyDefined = staticRouteValue !== void 0 && key !== \"hasErrorBoundary\";\n        if (isUnsupported) {\n            warning(!isUnsupported, \"Route property \" + key + \" is not a supported lazy route property. This property will be ignored.\");\n            cache[key] = Promise.resolve();\n        } else if (isStaticallyDefined) {\n            warning(false, `Route \"${routeToUpdate.id}\" has a static property \"${key}\" defined. The lazy property will be ignored.`);\n        } else {\n            let value = await lazyFn();\n            if (value != null) {\n                Object.assign(routeToUpdate, {\n                    [key]: value\n                });\n                Object.assign(routeToUpdate, mapRouteProperties2(routeToUpdate));\n            }\n        }\n        if (typeof routeToUpdate.lazy === \"object\") {\n            routeToUpdate.lazy[key] = void 0;\n            if (Object.values(routeToUpdate.lazy).every((value)=>value === void 0)) {\n                routeToUpdate.lazy = void 0;\n            }\n        }\n    })();\n    cache[key] = propertyPromise;\n    return propertyPromise;\n};\nvar lazyRouteFunctionCache = /* @__PURE__ */ new WeakMap();\nfunction loadLazyRoute(route, type, manifest, mapRouteProperties2, lazyRoutePropertiesToSkip) {\n    let routeToUpdate = manifest[route.id];\n    invariant(routeToUpdate, \"No route found in manifest\");\n    if (!route.lazy) {\n        return {\n            lazyRoutePromise: void 0,\n            lazyHandlerPromise: void 0\n        };\n    }\n    if (typeof route.lazy === \"function\") {\n        let cachedPromise = lazyRouteFunctionCache.get(routeToUpdate);\n        if (cachedPromise) {\n            return {\n                lazyRoutePromise: cachedPromise,\n                lazyHandlerPromise: cachedPromise\n            };\n        }\n        let lazyRoutePromise2 = (async ()=>{\n            invariant(typeof route.lazy === \"function\", \"No lazy route function found\");\n            let lazyRoute = await route.lazy();\n            let routeUpdates = {};\n            for(let lazyRouteProperty in lazyRoute){\n                let lazyValue = lazyRoute[lazyRouteProperty];\n                if (lazyValue === void 0) {\n                    continue;\n                }\n                let isUnsupported = isUnsupportedLazyRouteFunctionKey(lazyRouteProperty);\n                let staticRouteValue = routeToUpdate[lazyRouteProperty];\n                let isStaticallyDefined = staticRouteValue !== void 0 && // This property isn't static since it should always be updated based\n                // on the route updates\n                lazyRouteProperty !== \"hasErrorBoundary\";\n                if (isUnsupported) {\n                    warning(!isUnsupported, \"Route property \" + lazyRouteProperty + \" is not a supported property to be returned from a lazy route function. This property will be ignored.\");\n                } else if (isStaticallyDefined) {\n                    warning(!isStaticallyDefined, `Route \"${routeToUpdate.id}\" has a static property \"${lazyRouteProperty}\" defined but its lazy function is also returning a value for this property. The lazy route property \"${lazyRouteProperty}\" will be ignored.`);\n                } else {\n                    routeUpdates[lazyRouteProperty] = lazyValue;\n                }\n            }\n            Object.assign(routeToUpdate, routeUpdates);\n            Object.assign(routeToUpdate, {\n                // To keep things framework agnostic, we use the provided `mapRouteProperties`\n                // function to set the framework-aware properties (`element`/`hasErrorBoundary`)\n                // since the logic will differ between frameworks.\n                ...mapRouteProperties2(routeToUpdate),\n                lazy: void 0\n            });\n        })();\n        lazyRouteFunctionCache.set(routeToUpdate, lazyRoutePromise2);\n        lazyRoutePromise2.catch(()=>{});\n        return {\n            lazyRoutePromise: lazyRoutePromise2,\n            lazyHandlerPromise: lazyRoutePromise2\n        };\n    }\n    let lazyKeys = Object.keys(route.lazy);\n    let lazyPropertyPromises = [];\n    let lazyHandlerPromise = void 0;\n    for (let key of lazyKeys){\n        if (lazyRoutePropertiesToSkip && lazyRoutePropertiesToSkip.includes(key)) {\n            continue;\n        }\n        let promise = loadLazyRouteProperty({\n            key,\n            route,\n            manifest,\n            mapRouteProperties: mapRouteProperties2\n        });\n        if (promise) {\n            lazyPropertyPromises.push(promise);\n            if (key === type) {\n                lazyHandlerPromise = promise;\n            }\n        }\n    }\n    let lazyRoutePromise = lazyPropertyPromises.length > 0 ? Promise.all(lazyPropertyPromises).then(()=>{}) : void 0;\n    lazyRoutePromise?.catch(()=>{});\n    lazyHandlerPromise?.catch(()=>{});\n    return {\n        lazyRoutePromise,\n        lazyHandlerPromise\n    };\n}\nfunction isNonNullable(value) {\n    return value !== void 0;\n}\nfunction loadLazyMiddlewareForMatches(matches, manifest, mapRouteProperties2) {\n    let promises = matches.map(({ route })=>{\n        if (typeof route.lazy !== \"object\" || !route.lazy.unstable_middleware) {\n            return void 0;\n        }\n        return loadLazyRouteProperty({\n            key: \"unstable_middleware\",\n            route,\n            manifest,\n            mapRouteProperties: mapRouteProperties2\n        });\n    }).filter(isNonNullable);\n    return promises.length > 0 ? Promise.all(promises) : void 0;\n}\nasync function defaultDataStrategy(args) {\n    let matchesToLoad = args.matches.filter((m)=>m.shouldLoad);\n    let keyedResults = {};\n    let results = await Promise.all(matchesToLoad.map((m)=>m.resolve()));\n    results.forEach((result, i)=>{\n        keyedResults[matchesToLoad[i].route.id] = result;\n    });\n    return keyedResults;\n}\nasync function defaultDataStrategyWithMiddleware(args) {\n    if (!args.matches.some((m)=>m.route.unstable_middleware)) {\n        return defaultDataStrategy(args);\n    }\n    return runMiddlewarePipeline(args, false, ()=>defaultDataStrategy(args), (error, routeId)=>({\n            [routeId]: {\n                type: \"error\",\n                result: error\n            }\n        }));\n}\nasync function runMiddlewarePipeline(args, propagateResult, handler, errorHandler) {\n    let { matches, request, params, context } = args;\n    let middlewareState = {\n        handlerResult: void 0\n    };\n    try {\n        let tuples = matches.flatMap((m)=>m.route.unstable_middleware ? m.route.unstable_middleware.map((fn)=>[\n                    m.route.id,\n                    fn\n                ]) : []);\n        let result = await callRouteMiddleware({\n            request,\n            params,\n            context\n        }, tuples, propagateResult, middlewareState, handler);\n        return propagateResult ? result : middlewareState.handlerResult;\n    } catch (e) {\n        if (!middlewareState.middlewareError) {\n            throw e;\n        }\n        let result = await errorHandler(middlewareState.middlewareError.error, middlewareState.middlewareError.routeId);\n        if (propagateResult || !middlewareState.handlerResult) {\n            return result;\n        }\n        return Object.assign(middlewareState.handlerResult, result);\n    }\n}\nasync function callRouteMiddleware(args, middlewares, propagateResult, middlewareState, handler, idx = 0) {\n    let { request } = args;\n    if (request.signal.aborted) {\n        if (request.signal.reason) {\n            throw request.signal.reason;\n        }\n        throw new Error(`Request aborted without an \\`AbortSignal.reason\\`: ${request.method} ${request.url}`);\n    }\n    let tuple = middlewares[idx];\n    if (!tuple) {\n        middlewareState.handlerResult = await handler();\n        return middlewareState.handlerResult;\n    }\n    let [routeId, middleware] = tuple;\n    let nextCalled = false;\n    let nextResult = void 0;\n    let next = async ()=>{\n        if (nextCalled) {\n            throw new Error(\"You may only call `next()` once per middleware\");\n        }\n        nextCalled = true;\n        let result = await callRouteMiddleware(args, middlewares, propagateResult, middlewareState, handler, idx + 1);\n        if (propagateResult) {\n            nextResult = result;\n            return nextResult;\n        }\n    };\n    try {\n        let result = await middleware({\n            request: args.request,\n            params: args.params,\n            context: args.context\n        }, next);\n        if (nextCalled) {\n            if (result === void 0) {\n                return nextResult;\n            } else {\n                return result;\n            }\n        } else {\n            return next();\n        }\n    } catch (error) {\n        if (!middlewareState.middlewareError) {\n            middlewareState.middlewareError = {\n                routeId,\n                error\n            };\n        } else if (middlewareState.middlewareError.error !== error) {\n            middlewareState.middlewareError = {\n                routeId,\n                error\n            };\n        }\n        throw error;\n    }\n}\nfunction getDataStrategyMatchLazyPromises(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip) {\n    let lazyMiddlewarePromise = loadLazyRouteProperty({\n        key: \"unstable_middleware\",\n        route: match.route,\n        manifest,\n        mapRouteProperties: mapRouteProperties2\n    });\n    let lazyRoutePromises = loadLazyRoute(match.route, isMutationMethod(request.method) ? \"action\" : \"loader\", manifest, mapRouteProperties2, lazyRoutePropertiesToSkip);\n    return {\n        middleware: lazyMiddlewarePromise,\n        route: lazyRoutePromises.lazyRoutePromise,\n        handler: lazyRoutePromises.lazyHandlerPromise\n    };\n}\nfunction getDataStrategyMatch(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip, scopedContext, shouldLoad, unstable_shouldRevalidateArgs = null) {\n    let isUsingNewApi = false;\n    let _lazyPromises = getDataStrategyMatchLazyPromises(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip);\n    return {\n        ...match,\n        _lazyPromises,\n        shouldLoad,\n        unstable_shouldRevalidateArgs,\n        unstable_shouldCallHandler (defaultShouldRevalidate) {\n            isUsingNewApi = true;\n            if (!unstable_shouldRevalidateArgs) {\n                return shouldLoad;\n            }\n            if (typeof defaultShouldRevalidate === \"boolean\") {\n                return shouldRevalidateLoader(match, {\n                    ...unstable_shouldRevalidateArgs,\n                    defaultShouldRevalidate\n                });\n            }\n            return shouldRevalidateLoader(match, unstable_shouldRevalidateArgs);\n        },\n        resolve (handlerOverride) {\n            if (isUsingNewApi || shouldLoad || handlerOverride && request.method === \"GET\" && (match.route.lazy || match.route.loader)) {\n                return callLoaderOrAction({\n                    request,\n                    match,\n                    lazyHandlerPromise: _lazyPromises?.handler,\n                    lazyRoutePromise: _lazyPromises?.route,\n                    handlerOverride,\n                    scopedContext\n                });\n            }\n            return Promise.resolve({\n                type: \"data\" /* data */ ,\n                result: void 0\n            });\n        }\n    };\n}\nfunction getTargetedDataStrategyMatches(mapRouteProperties2, manifest, request, matches, targetMatch, lazyRoutePropertiesToSkip, scopedContext, shouldRevalidateArgs = null) {\n    return matches.map((match)=>{\n        if (match.route.id !== targetMatch.route.id) {\n            return {\n                ...match,\n                shouldLoad: false,\n                unstable_shouldRevalidateArgs: shouldRevalidateArgs,\n                unstable_shouldCallHandler: ()=>false,\n                _lazyPromises: getDataStrategyMatchLazyPromises(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip),\n                resolve: ()=>Promise.resolve({\n                        type: \"data\",\n                        result: void 0\n                    })\n            };\n        }\n        return getDataStrategyMatch(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip, scopedContext, true, shouldRevalidateArgs);\n    });\n}\nasync function callDataStrategyImpl(dataStrategyImpl, request, matches, fetcherKey, scopedContext, isStaticHandler) {\n    if (matches.some((m)=>m._lazyPromises?.middleware)) {\n        await Promise.all(matches.map((m)=>m._lazyPromises?.middleware));\n    }\n    let dataStrategyArgs = {\n        request,\n        params: matches[0].params,\n        context: scopedContext,\n        matches\n    };\n    let unstable_runClientMiddleware = isStaticHandler ? ()=>{\n        throw new Error(\"You cannot call `unstable_runClientMiddleware()` from a static handler `dataStrategy`. Middleware is run outside of `dataStrategy` during SSR in order to bubble up the Response.  You can enable middleware via the `respond` API in `query`/`queryRoute`\");\n    } : (cb)=>{\n        let typedDataStrategyArgs = dataStrategyArgs;\n        return runMiddlewarePipeline(typedDataStrategyArgs, false, ()=>cb({\n                ...typedDataStrategyArgs,\n                fetcherKey,\n                unstable_runClientMiddleware: ()=>{\n                    throw new Error(\"Cannot call `unstable_runClientMiddleware()` from within an `unstable_runClientMiddleware` handler\");\n                }\n            }), (error, routeId)=>({\n                [routeId]: {\n                    type: \"error\",\n                    result: error\n                }\n            }));\n    };\n    let results = await dataStrategyImpl({\n        ...dataStrategyArgs,\n        fetcherKey,\n        unstable_runClientMiddleware\n    });\n    try {\n        await Promise.all(matches.flatMap((m)=>[\n                m._lazyPromises?.handler,\n                m._lazyPromises?.route\n            ]));\n    } catch (e) {}\n    return results;\n}\nasync function callLoaderOrAction({ request, match, lazyHandlerPromise, lazyRoutePromise, handlerOverride, scopedContext }) {\n    let result;\n    let onReject;\n    let isAction = isMutationMethod(request.method);\n    let type = isAction ? \"action\" : \"loader\";\n    let runHandler = (handler)=>{\n        let reject;\n        let abortPromise = new Promise((_, r)=>reject = r);\n        onReject = ()=>reject();\n        request.signal.addEventListener(\"abort\", onReject);\n        let actualHandler = (ctx)=>{\n            if (typeof handler !== \"function\") {\n                return Promise.reject(new Error(`You cannot call the handler for a route which defines a boolean \"${type}\" [routeId: ${match.route.id}]`));\n            }\n            return handler({\n                request,\n                params: match.params,\n                context: scopedContext\n            }, ...ctx !== void 0 ? [\n                ctx\n            ] : []);\n        };\n        let handlerPromise = (async ()=>{\n            try {\n                let val = await (handlerOverride ? handlerOverride((ctx)=>actualHandler(ctx)) : actualHandler());\n                return {\n                    type: \"data\",\n                    result: val\n                };\n            } catch (e) {\n                return {\n                    type: \"error\",\n                    result: e\n                };\n            }\n        })();\n        return Promise.race([\n            handlerPromise,\n            abortPromise\n        ]);\n    };\n    try {\n        let handler = isAction ? match.route.action : match.route.loader;\n        if (lazyHandlerPromise || lazyRoutePromise) {\n            if (handler) {\n                let handlerError;\n                let [value] = await Promise.all([\n                    // If the handler throws, don't let it immediately bubble out,\n                    // since we need to let the lazy() execution finish so we know if this\n                    // route has a boundary that can handle the error\n                    runHandler(handler).catch((e)=>{\n                        handlerError = e;\n                    }),\n                    // Ensure all lazy route promises are resolved before continuing\n                    lazyHandlerPromise,\n                    lazyRoutePromise\n                ]);\n                if (handlerError !== void 0) {\n                    throw handlerError;\n                }\n                result = value;\n            } else {\n                await lazyHandlerPromise;\n                let handler2 = isAction ? match.route.action : match.route.loader;\n                if (handler2) {\n                    [result] = await Promise.all([\n                        runHandler(handler2),\n                        lazyRoutePromise\n                    ]);\n                } else if (type === \"action\") {\n                    let url = new URL(request.url);\n                    let pathname = url.pathname + url.search;\n                    throw getInternalRouterError(405, {\n                        method: request.method,\n                        pathname,\n                        routeId: match.route.id\n                    });\n                } else {\n                    return {\n                        type: \"data\" /* data */ ,\n                        result: void 0\n                    };\n                }\n            }\n        } else if (!handler) {\n            let url = new URL(request.url);\n            let pathname = url.pathname + url.search;\n            throw getInternalRouterError(404, {\n                pathname\n            });\n        } else {\n            result = await runHandler(handler);\n        }\n    } catch (e) {\n        return {\n            type: \"error\" /* error */ ,\n            result: e\n        };\n    } finally{\n        if (onReject) {\n            request.signal.removeEventListener(\"abort\", onReject);\n        }\n    }\n    return result;\n}\nasync function convertDataStrategyResultToDataResult(dataStrategyResult) {\n    let { result, type } = dataStrategyResult;\n    if (isResponse(result)) {\n        let data2;\n        try {\n            let contentType = result.headers.get(\"Content-Type\");\n            if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n                if (result.body == null) {\n                    data2 = null;\n                } else {\n                    data2 = await result.json();\n                }\n            } else {\n                data2 = await result.text();\n            }\n        } catch (e) {\n            return {\n                type: \"error\" /* error */ ,\n                error: e\n            };\n        }\n        if (type === \"error\" /* error */ ) {\n            return {\n                type: \"error\" /* error */ ,\n                error: new ErrorResponseImpl(result.status, result.statusText, data2),\n                statusCode: result.status,\n                headers: result.headers\n            };\n        }\n        return {\n            type: \"data\" /* data */ ,\n            data: data2,\n            statusCode: result.status,\n            headers: result.headers\n        };\n    }\n    if (type === \"error\" /* error */ ) {\n        if (isDataWithResponseInit(result)) {\n            if (result.data instanceof Error) {\n                return {\n                    type: \"error\" /* error */ ,\n                    error: result.data,\n                    statusCode: result.init?.status,\n                    headers: result.init?.headers ? new Headers(result.init.headers) : void 0\n                };\n            }\n            return {\n                type: \"error\" /* error */ ,\n                error: new ErrorResponseImpl(result.init?.status || 500, void 0, result.data),\n                statusCode: isRouteErrorResponse(result) ? result.status : void 0,\n                headers: result.init?.headers ? new Headers(result.init.headers) : void 0\n            };\n        }\n        return {\n            type: \"error\" /* error */ ,\n            error: result,\n            statusCode: isRouteErrorResponse(result) ? result.status : void 0\n        };\n    }\n    if (isDataWithResponseInit(result)) {\n        return {\n            type: \"data\" /* data */ ,\n            data: result.data,\n            statusCode: result.init?.status,\n            headers: result.init?.headers ? new Headers(result.init.headers) : void 0\n        };\n    }\n    return {\n        type: \"data\" /* data */ ,\n        data: result\n    };\n}\nfunction normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename) {\n    let location = response.headers.get(\"Location\");\n    invariant(location, \"Redirects returned/thrown from loaders/actions must have a Location header\");\n    if (!ABSOLUTE_URL_REGEX.test(location)) {\n        let trimmedMatches = matches.slice(0, matches.findIndex((m)=>m.route.id === routeId) + 1);\n        location = normalizeTo(new URL(request.url), trimmedMatches, basename, location);\n        response.headers.set(\"Location\", location);\n    }\n    return response;\n}\nfunction normalizeRedirectLocation(location, currentUrl, basename) {\n    if (ABSOLUTE_URL_REGEX.test(location)) {\n        let normalizedLocation = location;\n        let url = normalizedLocation.startsWith(\"//\") ? new URL(currentUrl.protocol + normalizedLocation) : new URL(normalizedLocation);\n        let isSameBasename = stripBasename(url.pathname, basename) != null;\n        if (url.origin === currentUrl.origin && isSameBasename) {\n            return url.pathname + url.search + url.hash;\n        }\n    }\n    return location;\n}\nfunction createClientSideRequest(history, location, signal, submission) {\n    let url = history.createURL(stripHashFromPath(location)).toString();\n    let init = {\n        signal\n    };\n    if (submission && isMutationMethod(submission.formMethod)) {\n        let { formMethod, formEncType } = submission;\n        init.method = formMethod.toUpperCase();\n        if (formEncType === \"application/json\") {\n            init.headers = new Headers({\n                \"Content-Type\": formEncType\n            });\n            init.body = JSON.stringify(submission.json);\n        } else if (formEncType === \"text/plain\") {\n            init.body = submission.text;\n        } else if (formEncType === \"application/x-www-form-urlencoded\" && submission.formData) {\n            init.body = convertFormDataToSearchParams(submission.formData);\n        } else {\n            init.body = submission.formData;\n        }\n    }\n    return new Request(url, init);\n}\nfunction convertFormDataToSearchParams(formData) {\n    let searchParams = new URLSearchParams();\n    for (let [key, value] of formData.entries()){\n        searchParams.append(key, typeof value === \"string\" ? value : value.name);\n    }\n    return searchParams;\n}\nfunction convertSearchParamsToFormData(searchParams) {\n    let formData = new FormData();\n    for (let [key, value] of searchParams.entries()){\n        formData.append(key, value);\n    }\n    return formData;\n}\nfunction processRouteLoaderData(matches, results, pendingActionResult, isStaticHandler = false, skipLoaderErrorBubbling = false) {\n    let loaderData = {};\n    let errors = null;\n    let statusCode;\n    let foundError = false;\n    let loaderHeaders = {};\n    let pendingError = pendingActionResult && isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : void 0;\n    matches.forEach((match)=>{\n        if (!(match.route.id in results)) {\n            return;\n        }\n        let id = match.route.id;\n        let result = results[id];\n        invariant(!isRedirectResult(result), \"Cannot handle redirect results in processLoaderData\");\n        if (isErrorResult(result)) {\n            let error = result.error;\n            if (pendingError !== void 0) {\n                error = pendingError;\n                pendingError = void 0;\n            }\n            errors = errors || {};\n            if (skipLoaderErrorBubbling) {\n                errors[id] = error;\n            } else {\n                let boundaryMatch = findNearestBoundary(matches, id);\n                if (errors[boundaryMatch.route.id] == null) {\n                    errors[boundaryMatch.route.id] = error;\n                }\n            }\n            if (!isStaticHandler) {\n                loaderData[id] = ResetLoaderDataSymbol;\n            }\n            if (!foundError) {\n                foundError = true;\n                statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;\n            }\n            if (result.headers) {\n                loaderHeaders[id] = result.headers;\n            }\n        } else {\n            loaderData[id] = result.data;\n            if (result.statusCode && result.statusCode !== 200 && !foundError) {\n                statusCode = result.statusCode;\n            }\n            if (result.headers) {\n                loaderHeaders[id] = result.headers;\n            }\n        }\n    });\n    if (pendingError !== void 0 && pendingActionResult) {\n        errors = {\n            [pendingActionResult[0]]: pendingError\n        };\n        if (pendingActionResult[2]) {\n            loaderData[pendingActionResult[2]] = void 0;\n        }\n    }\n    return {\n        loaderData,\n        errors,\n        statusCode: statusCode || 200,\n        loaderHeaders\n    };\n}\nfunction processLoaderData(state, matches, results, pendingActionResult, revalidatingFetchers, fetcherResults) {\n    let { loaderData, errors } = processRouteLoaderData(matches, results, pendingActionResult);\n    revalidatingFetchers.filter((f)=>!f.matches || f.matches.some((m)=>m.shouldLoad)).forEach((rf)=>{\n        let { key, match, controller } = rf;\n        let result = fetcherResults[key];\n        invariant(result, \"Did not find corresponding fetcher result\");\n        if (controller && controller.signal.aborted) {\n            return;\n        } else if (isErrorResult(result)) {\n            let boundaryMatch = findNearestBoundary(state.matches, match?.route.id);\n            if (!(errors && errors[boundaryMatch.route.id])) {\n                errors = {\n                    ...errors,\n                    [boundaryMatch.route.id]: result.error\n                };\n            }\n            state.fetchers.delete(key);\n        } else if (isRedirectResult(result)) {\n            invariant(false, \"Unhandled fetcher revalidation redirect\");\n        } else {\n            let doneFetcher = getDoneFetcher(result.data);\n            state.fetchers.set(key, doneFetcher);\n        }\n    });\n    return {\n        loaderData,\n        errors\n    };\n}\nfunction mergeLoaderData(loaderData, newLoaderData, matches, errors) {\n    let mergedLoaderData = Object.entries(newLoaderData).filter(([, v])=>v !== ResetLoaderDataSymbol).reduce((merged, [k, v])=>{\n        merged[k] = v;\n        return merged;\n    }, {});\n    for (let match of matches){\n        let id = match.route.id;\n        if (!newLoaderData.hasOwnProperty(id) && loaderData.hasOwnProperty(id) && match.route.loader) {\n            mergedLoaderData[id] = loaderData[id];\n        }\n        if (errors && errors.hasOwnProperty(id)) {\n            break;\n        }\n    }\n    return mergedLoaderData;\n}\nfunction getActionDataForCommit(pendingActionResult) {\n    if (!pendingActionResult) {\n        return {};\n    }\n    return isErrorResult(pendingActionResult[1]) ? {\n        // Clear out prior actionData on errors\n        actionData: {}\n    } : {\n        actionData: {\n            [pendingActionResult[0]]: pendingActionResult[1].data\n        }\n    };\n}\nfunction findNearestBoundary(matches, routeId) {\n    let eligibleMatches = routeId ? matches.slice(0, matches.findIndex((m)=>m.route.id === routeId) + 1) : [\n        ...matches\n    ];\n    return eligibleMatches.reverse().find((m)=>m.route.hasErrorBoundary === true) || matches[0];\n}\nfunction getShortCircuitMatches(routes) {\n    let route = routes.length === 1 ? routes[0] : routes.find((r)=>r.index || !r.path || r.path === \"/\") || {\n        id: `__shim-error-route__`\n    };\n    return {\n        matches: [\n            {\n                params: {},\n                pathname: \"\",\n                pathnameBase: \"\",\n                route\n            }\n        ],\n        route\n    };\n}\nfunction getInternalRouterError(status, { pathname, routeId, method, type, message } = {}) {\n    let statusText = \"Unknown Server Error\";\n    let errorMessage = \"Unknown @remix-run/router error\";\n    if (status === 400) {\n        statusText = \"Bad Request\";\n        if (method && pathname && routeId) {\n            errorMessage = `You made a ${method} request to \"${pathname}\" but did not provide a \\`loader\\` for route \"${routeId}\", so there is no way to handle the request.`;\n        } else if (type === \"invalid-body\") {\n            errorMessage = \"Unable to encode submission body\";\n        }\n    } else if (status === 403) {\n        statusText = \"Forbidden\";\n        errorMessage = `Route \"${routeId}\" does not match URL \"${pathname}\"`;\n    } else if (status === 404) {\n        statusText = \"Not Found\";\n        errorMessage = `No route matches URL \"${pathname}\"`;\n    } else if (status === 405) {\n        statusText = \"Method Not Allowed\";\n        if (method && pathname && routeId) {\n            errorMessage = `You made a ${method.toUpperCase()} request to \"${pathname}\" but did not provide an \\`action\\` for route \"${routeId}\", so there is no way to handle the request.`;\n        } else if (method) {\n            errorMessage = `Invalid request method \"${method.toUpperCase()}\"`;\n        }\n    }\n    return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);\n}\nfunction findRedirect(results) {\n    let entries = Object.entries(results);\n    for(let i = entries.length - 1; i >= 0; i--){\n        let [key, result] = entries[i];\n        if (isRedirectResult(result)) {\n            return {\n                key,\n                result\n            };\n        }\n    }\n}\nfunction stripHashFromPath(path) {\n    let parsedPath = typeof path === \"string\" ? parsePath(path) : path;\n    return createPath({\n        ...parsedPath,\n        hash: \"\"\n    });\n}\nfunction isHashChangeOnly(a, b) {\n    if (a.pathname !== b.pathname || a.search !== b.search) {\n        return false;\n    }\n    if (a.hash === \"\") {\n        return b.hash !== \"\";\n    } else if (a.hash === b.hash) {\n        return true;\n    } else if (b.hash !== \"\") {\n        return true;\n    }\n    return false;\n}\nfunction isDataStrategyResult(result) {\n    return result != null && typeof result === \"object\" && \"type\" in result && \"result\" in result && (result.type === \"data\" /* data */  || result.type === \"error\" /* error */ );\n}\nfunction isRedirectDataStrategyResult(result) {\n    return isResponse(result.result) && redirectStatusCodes.has(result.result.status);\n}\nfunction isErrorResult(result) {\n    return result.type === \"error\" /* error */ ;\n}\nfunction isRedirectResult(result) {\n    return (result && result.type) === \"redirect\" /* redirect */ ;\n}\nfunction isDataWithResponseInit(value) {\n    return typeof value === \"object\" && value != null && \"type\" in value && \"data\" in value && \"init\" in value && value.type === \"DataWithResponseInit\";\n}\nfunction isResponse(value) {\n    return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nfunction isRedirectStatusCode(statusCode) {\n    return redirectStatusCodes.has(statusCode);\n}\nfunction isRedirectResponse(result) {\n    return isResponse(result) && isRedirectStatusCode(result.status) && result.headers.has(\"Location\");\n}\nfunction isValidMethod(method) {\n    return validRequestMethods.has(method.toUpperCase());\n}\nfunction isMutationMethod(method) {\n    return validMutationMethods.has(method.toUpperCase());\n}\nfunction hasNakedIndexQuery(search) {\n    return new URLSearchParams(search).getAll(\"index\").some((v)=>v === \"\");\n}\nfunction getTargetMatch(matches, location) {\n    let search = typeof location === \"string\" ? parsePath(location).search : location.search;\n    if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || \"\")) {\n        return matches[matches.length - 1];\n    }\n    let pathMatches = getPathContributingMatches(matches);\n    return pathMatches[pathMatches.length - 1];\n}\nfunction getSubmissionFromNavigation(navigation) {\n    let { formMethod, formAction, formEncType, text, formData, json } = navigation;\n    if (!formMethod || !formAction || !formEncType) {\n        return;\n    }\n    if (text != null) {\n        return {\n            formMethod,\n            formAction,\n            formEncType,\n            formData: void 0,\n            json: void 0,\n            text\n        };\n    } else if (formData != null) {\n        return {\n            formMethod,\n            formAction,\n            formEncType,\n            formData,\n            json: void 0,\n            text: void 0\n        };\n    } else if (json !== void 0) {\n        return {\n            formMethod,\n            formAction,\n            formEncType,\n            formData: void 0,\n            json,\n            text: void 0\n        };\n    }\n}\nfunction getLoadingNavigation(location, submission) {\n    if (submission) {\n        let navigation = {\n            state: \"loading\",\n            location,\n            formMethod: submission.formMethod,\n            formAction: submission.formAction,\n            formEncType: submission.formEncType,\n            formData: submission.formData,\n            json: submission.json,\n            text: submission.text\n        };\n        return navigation;\n    } else {\n        let navigation = {\n            state: \"loading\",\n            location,\n            formMethod: void 0,\n            formAction: void 0,\n            formEncType: void 0,\n            formData: void 0,\n            json: void 0,\n            text: void 0\n        };\n        return navigation;\n    }\n}\nfunction getSubmittingNavigation(location, submission) {\n    let navigation = {\n        state: \"submitting\",\n        location,\n        formMethod: submission.formMethod,\n        formAction: submission.formAction,\n        formEncType: submission.formEncType,\n        formData: submission.formData,\n        json: submission.json,\n        text: submission.text\n    };\n    return navigation;\n}\nfunction getLoadingFetcher(submission, data2) {\n    if (submission) {\n        let fetcher = {\n            state: \"loading\",\n            formMethod: submission.formMethod,\n            formAction: submission.formAction,\n            formEncType: submission.formEncType,\n            formData: submission.formData,\n            json: submission.json,\n            text: submission.text,\n            data: data2\n        };\n        return fetcher;\n    } else {\n        let fetcher = {\n            state: \"loading\",\n            formMethod: void 0,\n            formAction: void 0,\n            formEncType: void 0,\n            formData: void 0,\n            json: void 0,\n            text: void 0,\n            data: data2\n        };\n        return fetcher;\n    }\n}\nfunction getSubmittingFetcher(submission, existingFetcher) {\n    let fetcher = {\n        state: \"submitting\",\n        formMethod: submission.formMethod,\n        formAction: submission.formAction,\n        formEncType: submission.formEncType,\n        formData: submission.formData,\n        json: submission.json,\n        text: submission.text,\n        data: existingFetcher ? existingFetcher.data : void 0\n    };\n    return fetcher;\n}\nfunction getDoneFetcher(data2) {\n    let fetcher = {\n        state: \"idle\",\n        formMethod: void 0,\n        formAction: void 0,\n        formEncType: void 0,\n        formData: void 0,\n        json: void 0,\n        text: void 0,\n        data: data2\n    };\n    return fetcher;\n}\nfunction restoreAppliedTransitions(_window, transitions) {\n    try {\n        let sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);\n        if (sessionPositions) {\n            let json = JSON.parse(sessionPositions);\n            for (let [k, v] of Object.entries(json || {})){\n                if (v && Array.isArray(v)) {\n                    transitions.set(k, new Set(v || []));\n                }\n            }\n        }\n    } catch (e) {}\n}\nfunction persistAppliedTransitions(_window, transitions) {\n    if (transitions.size > 0) {\n        let json = {};\n        for (let [k, v] of transitions){\n            json[k] = [\n                ...v\n            ];\n        }\n        try {\n            _window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(json));\n        } catch (error) {\n            warning(false, `Failed to save applied view transitions in sessionStorage (${error}).`);\n        }\n    }\n}\nfunction createDeferred() {\n    let resolve;\n    let reject;\n    let promise = new Promise((res, rej)=>{\n        resolve = async (val)=>{\n            res(val);\n            try {\n                await promise;\n            } catch (e) {}\n        };\n        reject = async (error)=>{\n            rej(error);\n            try {\n                await promise;\n            } catch (e) {}\n        };\n    });\n    return {\n        promise,\n        //@ts-ignore\n        resolve,\n        //@ts-ignore\n        reject\n    };\n}\n// lib/components.tsx\nvar React3 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\n// lib/context.ts\nvar React = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar DataRouterContext = React.createContext(null);\nDataRouterContext.displayName = \"DataRouter\";\nvar DataRouterStateContext = React.createContext(null);\nDataRouterStateContext.displayName = \"DataRouterState\";\nvar ViewTransitionContext = React.createContext({\n    isTransitioning: false\n});\nViewTransitionContext.displayName = \"ViewTransition\";\nvar FetchersContext = React.createContext(/* @__PURE__ */ new Map());\nFetchersContext.displayName = \"Fetchers\";\nvar AwaitContext = React.createContext(null);\nAwaitContext.displayName = \"Await\";\nvar NavigationContext = React.createContext(null);\nNavigationContext.displayName = \"Navigation\";\nvar LocationContext = React.createContext(null);\nLocationContext.displayName = \"Location\";\nvar RouteContext = React.createContext({\n    outlet: null,\n    matches: [],\n    isDataRoute: false\n});\nRouteContext.displayName = \"Route\";\nvar RouteErrorContext = React.createContext(null);\nRouteErrorContext.displayName = \"RouteError\";\nvar ENABLE_DEV_WARNINGS = true;\n// lib/hooks.tsx\nvar React2 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nfunction useHref(to, { relative } = {}) {\n    invariant(useInRouterContext(), // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useHref() may be used only in the context of a <Router> component.`);\n    let { basename, navigator } = React2.useContext(NavigationContext);\n    let { hash, pathname, search } = useResolvedPath(to, {\n        relative\n    });\n    let joinedPathname = pathname;\n    if (basename !== \"/\") {\n        joinedPathname = pathname === \"/\" ? basename : joinPaths([\n            basename,\n            pathname\n        ]);\n    }\n    return navigator.createHref({\n        pathname: joinedPathname,\n        search,\n        hash\n    });\n}\nfunction useInRouterContext() {\n    return React2.useContext(LocationContext) != null;\n}\nfunction useLocation() {\n    invariant(useInRouterContext(), // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useLocation() may be used only in the context of a <Router> component.`);\n    return React2.useContext(LocationContext).location;\n}\nfunction useNavigationType() {\n    return React2.useContext(LocationContext).navigationType;\n}\nfunction useMatch(pattern) {\n    invariant(useInRouterContext(), // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useMatch() may be used only in the context of a <Router> component.`);\n    let { pathname } = useLocation();\n    return React2.useMemo(()=>matchPath(pattern, decodePath(pathname)), [\n        pathname,\n        pattern\n    ]);\n}\nvar navigateEffectWarning = `You should call navigate() in a React.useEffect(), not when your component is first rendered.`;\nfunction useIsomorphicLayoutEffect(cb) {\n    let isStatic = React2.useContext(NavigationContext).static;\n    if (!isStatic) {\n        React2.useLayoutEffect(cb);\n    }\n}\nfunction useNavigate() {\n    let { isDataRoute } = React2.useContext(RouteContext);\n    return isDataRoute ? useNavigateStable() : useNavigateUnstable();\n}\nfunction useNavigateUnstable() {\n    invariant(useInRouterContext(), // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useNavigate() may be used only in the context of a <Router> component.`);\n    let dataRouterContext = React2.useContext(DataRouterContext);\n    let { basename, navigator } = React2.useContext(NavigationContext);\n    let { matches } = React2.useContext(RouteContext);\n    let { pathname: locationPathname } = useLocation();\n    let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));\n    let activeRef = React2.useRef(false);\n    useIsomorphicLayoutEffect(()=>{\n        activeRef.current = true;\n    });\n    let navigate = React2.useCallback((to, options = {})=>{\n        warning(activeRef.current, navigateEffectWarning);\n        if (!activeRef.current) return;\n        if (typeof to === \"number\") {\n            navigator.go(to);\n            return;\n        }\n        let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === \"path\");\n        if (dataRouterContext == null && basename !== \"/\") {\n            path.pathname = path.pathname === \"/\" ? basename : joinPaths([\n                basename,\n                path.pathname\n            ]);\n        }\n        (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);\n    }, [\n        basename,\n        navigator,\n        routePathnamesJson,\n        locationPathname,\n        dataRouterContext\n    ]);\n    return navigate;\n}\nvar OutletContext = React2.createContext(null);\nfunction useOutletContext() {\n    return React2.useContext(OutletContext);\n}\nfunction useOutlet(context) {\n    let outlet = React2.useContext(RouteContext).outlet;\n    if (outlet) {\n        return /* @__PURE__ */ React2.createElement(OutletContext.Provider, {\n            value: context\n        }, outlet);\n    }\n    return outlet;\n}\nfunction useParams() {\n    let { matches } = React2.useContext(RouteContext);\n    let routeMatch = matches[matches.length - 1];\n    return routeMatch ? routeMatch.params : {};\n}\nfunction useResolvedPath(to, { relative } = {}) {\n    let { matches } = React2.useContext(RouteContext);\n    let { pathname: locationPathname } = useLocation();\n    let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));\n    return React2.useMemo(()=>resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === \"path\"), [\n        to,\n        routePathnamesJson,\n        locationPathname,\n        relative\n    ]);\n}\nfunction useRoutes(routes, locationArg) {\n    return useRoutesImpl(routes, locationArg);\n}\nfunction useRoutesImpl(routes, locationArg, dataRouterState, future) {\n    invariant(useInRouterContext(), // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useRoutes() may be used only in the context of a <Router> component.`);\n    let { navigator } = React2.useContext(NavigationContext);\n    let { matches: parentMatches } = React2.useContext(RouteContext);\n    let routeMatch = parentMatches[parentMatches.length - 1];\n    let parentParams = routeMatch ? routeMatch.params : {};\n    let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n    let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n    let parentRoute = routeMatch && routeMatch.route;\n    if (ENABLE_DEV_WARNINGS) {\n        let parentPath = parentRoute && parentRoute.path || \"\";\n        warningOnce(parentPathname, !parentRoute || parentPath.endsWith(\"*\") || parentPath.endsWith(\"*?\"), `You rendered descendant <Routes> (or called \\`useRoutes()\\`) at \"${parentPathname}\" (under <Route path=\"${parentPath}\">) but the parent route path has no trailing \"*\". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.\n\nPlease change the parent <Route path=\"${parentPath}\"> to <Route path=\"${parentPath === \"/\" ? \"*\" : `${parentPath}/*`}\">.`);\n    }\n    let locationFromContext = useLocation();\n    let location;\n    if (locationArg) {\n        let parsedLocationArg = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n        invariant(parentPathnameBase === \"/\" || parsedLocationArg.pathname?.startsWith(parentPathnameBase), `When overriding the location using \\`<Routes location>\\` or \\`useRoutes(routes, location)\\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is \"${parentPathnameBase}\" but pathname \"${parsedLocationArg.pathname}\" was given in the \\`location\\` prop.`);\n        location = parsedLocationArg;\n    } else {\n        location = locationFromContext;\n    }\n    let pathname = location.pathname || \"/\";\n    let remainingPathname = pathname;\n    if (parentPathnameBase !== \"/\") {\n        let parentSegments = parentPathnameBase.replace(/^\\//, \"\").split(\"/\");\n        let segments = pathname.replace(/^\\//, \"\").split(\"/\");\n        remainingPathname = \"/\" + segments.slice(parentSegments.length).join(\"/\");\n    }\n    let matches = matchRoutes(routes, {\n        pathname: remainingPathname\n    });\n    if (ENABLE_DEV_WARNINGS) {\n        warning(parentRoute || matches != null, `No routes matched location \"${location.pathname}${location.search}${location.hash}\" `);\n        warning(matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0 || matches[matches.length - 1].route.lazy !== void 0, `Matched leaf route at location \"${location.pathname}${location.search}${location.hash}\" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an \"empty\" page.`);\n    }\n    let renderedMatches = _renderMatches(matches && matches.map((match)=>Object.assign({}, match, {\n            params: Object.assign({}, parentParams, match.params),\n            pathname: joinPaths([\n                parentPathnameBase,\n                // Re-encode pathnames that were decoded inside matchRoutes\n                navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname\n            ]),\n            pathnameBase: match.pathnameBase === \"/\" ? parentPathnameBase : joinPaths([\n                parentPathnameBase,\n                // Re-encode pathnames that were decoded inside matchRoutes\n                navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase\n            ])\n        })), parentMatches, dataRouterState, future);\n    if (locationArg && renderedMatches) {\n        return /* @__PURE__ */ React2.createElement(LocationContext.Provider, {\n            value: {\n                location: {\n                    pathname: \"/\",\n                    search: \"\",\n                    hash: \"\",\n                    state: null,\n                    key: \"default\",\n                    ...location\n                },\n                navigationType: \"POP\" /* Pop */ \n            }\n        }, renderedMatches);\n    }\n    return renderedMatches;\n}\nfunction DefaultErrorComponent() {\n    let error = useRouteError();\n    let message = isRouteErrorResponse(error) ? `${error.status} ${error.statusText}` : error instanceof Error ? error.message : JSON.stringify(error);\n    let stack = error instanceof Error ? error.stack : null;\n    let lightgrey = \"rgba(200,200,200, 0.5)\";\n    let preStyles = {\n        padding: \"0.5rem\",\n        backgroundColor: lightgrey\n    };\n    let codeStyles = {\n        padding: \"2px 4px\",\n        backgroundColor: lightgrey\n    };\n    let devInfo = null;\n    if (ENABLE_DEV_WARNINGS) {\n        console.error(\"Error handled by React Router default ErrorBoundary:\", error);\n        devInfo = /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement(\"p\", null, \"\\uD83D\\uDCBF Hey developer \\uD83D\\uDC4B\"), /* @__PURE__ */ React2.createElement(\"p\", null, \"You can provide a way better UX than this when your app throws errors by providing your own \", /* @__PURE__ */ React2.createElement(\"code\", {\n            style: codeStyles\n        }, \"ErrorBoundary\"), \" or\", \" \", /* @__PURE__ */ React2.createElement(\"code\", {\n            style: codeStyles\n        }, \"errorElement\"), \" prop on your route.\"));\n    }\n    return /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement(\"h2\", null, \"Unexpected Application Error!\"), /* @__PURE__ */ React2.createElement(\"h3\", {\n        style: {\n            fontStyle: \"italic\"\n        }\n    }, message), stack ? /* @__PURE__ */ React2.createElement(\"pre\", {\n        style: preStyles\n    }, stack) : null, devInfo);\n}\nvar defaultErrorElement = /* @__PURE__ */ React2.createElement(DefaultErrorComponent, null);\nvar RenderErrorBoundary = class extends React2.Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            location: props.location,\n            revalidation: props.revalidation,\n            error: props.error\n        };\n    }\n    static getDerivedStateFromError(error) {\n        return {\n            error\n        };\n    }\n    static getDerivedStateFromProps(props, state) {\n        if (state.location !== props.location || state.revalidation !== \"idle\" && props.revalidation === \"idle\") {\n            return {\n                error: props.error,\n                location: props.location,\n                revalidation: props.revalidation\n            };\n        }\n        return {\n            error: props.error !== void 0 ? props.error : state.error,\n            location: state.location,\n            revalidation: props.revalidation || state.revalidation\n        };\n    }\n    componentDidCatch(error, errorInfo) {\n        console.error(\"React Router caught the following error during render\", error, errorInfo);\n    }\n    render() {\n        return this.state.error !== void 0 ? /* @__PURE__ */ React2.createElement(RouteContext.Provider, {\n            value: this.props.routeContext\n        }, /* @__PURE__ */ React2.createElement(RouteErrorContext.Provider, {\n            value: this.state.error,\n            children: this.props.component\n        })) : this.props.children;\n    }\n};\nfunction RenderedRoute({ routeContext, match, children }) {\n    let dataRouterContext = React2.useContext(DataRouterContext);\n    if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {\n        dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;\n    }\n    return /* @__PURE__ */ React2.createElement(RouteContext.Provider, {\n        value: routeContext\n    }, children);\n}\nfunction _renderMatches(matches, parentMatches = [], dataRouterState = null, future = null) {\n    if (matches == null) {\n        if (!dataRouterState) {\n            return null;\n        }\n        if (dataRouterState.errors) {\n            matches = dataRouterState.matches;\n        } else if (parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {\n            matches = dataRouterState.matches;\n        } else {\n            return null;\n        }\n    }\n    let renderedMatches = matches;\n    let errors = dataRouterState?.errors;\n    if (errors != null) {\n        let errorIndex = renderedMatches.findIndex((m)=>m.route.id && errors?.[m.route.id] !== void 0);\n        invariant(errorIndex >= 0, `Could not find a matching route for errors on route IDs: ${Object.keys(errors).join(\",\")}`);\n        renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));\n    }\n    let renderFallback = false;\n    let fallbackIndex = -1;\n    if (dataRouterState) {\n        for(let i = 0; i < renderedMatches.length; i++){\n            let match = renderedMatches[i];\n            if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {\n                fallbackIndex = i;\n            }\n            if (match.route.id) {\n                let { loaderData, errors: errors2 } = dataRouterState;\n                let needsToRunLoader = match.route.loader && !loaderData.hasOwnProperty(match.route.id) && (!errors2 || errors2[match.route.id] === void 0);\n                if (match.route.lazy || needsToRunLoader) {\n                    renderFallback = true;\n                    if (fallbackIndex >= 0) {\n                        renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);\n                    } else {\n                        renderedMatches = [\n                            renderedMatches[0]\n                        ];\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    return renderedMatches.reduceRight((outlet, match, index)=>{\n        let error;\n        let shouldRenderHydrateFallback = false;\n        let errorElement = null;\n        let hydrateFallbackElement = null;\n        if (dataRouterState) {\n            error = errors && match.route.id ? errors[match.route.id] : void 0;\n            errorElement = match.route.errorElement || defaultErrorElement;\n            if (renderFallback) {\n                if (fallbackIndex < 0 && index === 0) {\n                    warningOnce(\"route-fallback\", false, \"No `HydrateFallback` element provided to render during initial hydration\");\n                    shouldRenderHydrateFallback = true;\n                    hydrateFallbackElement = null;\n                } else if (fallbackIndex === index) {\n                    shouldRenderHydrateFallback = true;\n                    hydrateFallbackElement = match.route.hydrateFallbackElement || null;\n                }\n            }\n        }\n        let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));\n        let getChildren = ()=>{\n            let children;\n            if (error) {\n                children = errorElement;\n            } else if (shouldRenderHydrateFallback) {\n                children = hydrateFallbackElement;\n            } else if (match.route.Component) {\n                children = /* @__PURE__ */ React2.createElement(match.route.Component, null);\n            } else if (match.route.element) {\n                children = match.route.element;\n            } else {\n                children = outlet;\n            }\n            return /* @__PURE__ */ React2.createElement(RenderedRoute, {\n                match,\n                routeContext: {\n                    outlet,\n                    matches: matches2,\n                    isDataRoute: dataRouterState != null\n                },\n                children\n            });\n        };\n        return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /* @__PURE__ */ React2.createElement(RenderErrorBoundary, {\n            location: dataRouterState.location,\n            revalidation: dataRouterState.revalidation,\n            component: errorElement,\n            error,\n            children: getChildren(),\n            routeContext: {\n                outlet: null,\n                matches: matches2,\n                isDataRoute: true\n            }\n        }) : getChildren();\n    }, null);\n}\nfunction getDataRouterConsoleError(hookName) {\n    return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;\n}\nfunction useDataRouterContext(hookName) {\n    let ctx = React2.useContext(DataRouterContext);\n    invariant(ctx, getDataRouterConsoleError(hookName));\n    return ctx;\n}\nfunction useDataRouterState(hookName) {\n    let state = React2.useContext(DataRouterStateContext);\n    invariant(state, getDataRouterConsoleError(hookName));\n    return state;\n}\nfunction useRouteContext(hookName) {\n    let route = React2.useContext(RouteContext);\n    invariant(route, getDataRouterConsoleError(hookName));\n    return route;\n}\nfunction useCurrentRouteId(hookName) {\n    let route = useRouteContext(hookName);\n    let thisRoute = route.matches[route.matches.length - 1];\n    invariant(thisRoute.route.id, `${hookName} can only be used on routes that contain a unique \"id\"`);\n    return thisRoute.route.id;\n}\nfunction useRouteId() {\n    return useCurrentRouteId(\"useRouteId\" /* UseRouteId */ );\n}\nfunction useNavigation() {\n    let state = useDataRouterState(\"useNavigation\" /* UseNavigation */ );\n    return state.navigation;\n}\nfunction useRevalidator() {\n    let dataRouterContext = useDataRouterContext(\"useRevalidator\" /* UseRevalidator */ );\n    let state = useDataRouterState(\"useRevalidator\" /* UseRevalidator */ );\n    let revalidate = React2.useCallback(async ()=>{\n        await dataRouterContext.router.revalidate();\n    }, [\n        dataRouterContext.router\n    ]);\n    return React2.useMemo(()=>({\n            revalidate,\n            state: state.revalidation\n        }), [\n        revalidate,\n        state.revalidation\n    ]);\n}\nfunction useMatches() {\n    let { matches, loaderData } = useDataRouterState(\"useMatches\" /* UseMatches */ );\n    return React2.useMemo(()=>matches.map((m)=>convertRouteMatchToUiMatch(m, loaderData)), [\n        matches,\n        loaderData\n    ]);\n}\nfunction useLoaderData() {\n    let state = useDataRouterState(\"useLoaderData\" /* UseLoaderData */ );\n    let routeId = useCurrentRouteId(\"useLoaderData\" /* UseLoaderData */ );\n    return state.loaderData[routeId];\n}\nfunction useRouteLoaderData(routeId) {\n    let state = useDataRouterState(\"useRouteLoaderData\" /* UseRouteLoaderData */ );\n    return state.loaderData[routeId];\n}\nfunction useActionData() {\n    let state = useDataRouterState(\"useActionData\" /* UseActionData */ );\n    let routeId = useCurrentRouteId(\"useLoaderData\" /* UseLoaderData */ );\n    return state.actionData ? state.actionData[routeId] : void 0;\n}\nfunction useRouteError() {\n    let error = React2.useContext(RouteErrorContext);\n    let state = useDataRouterState(\"useRouteError\" /* UseRouteError */ );\n    let routeId = useCurrentRouteId(\"useRouteError\" /* UseRouteError */ );\n    if (error !== void 0) {\n        return error;\n    }\n    return state.errors?.[routeId];\n}\nfunction useAsyncValue() {\n    let value = React2.useContext(AwaitContext);\n    return value?._data;\n}\nfunction useAsyncError() {\n    let value = React2.useContext(AwaitContext);\n    return value?._error;\n}\nvar blockerId = 0;\nfunction useBlocker(shouldBlock) {\n    let { router, basename } = useDataRouterContext(\"useBlocker\" /* UseBlocker */ );\n    let state = useDataRouterState(\"useBlocker\" /* UseBlocker */ );\n    let [blockerKey, setBlockerKey] = React2.useState(\"\");\n    let blockerFunction = React2.useCallback((arg)=>{\n        if (typeof shouldBlock !== \"function\") {\n            return !!shouldBlock;\n        }\n        if (basename === \"/\") {\n            return shouldBlock(arg);\n        }\n        let { currentLocation, nextLocation, historyAction } = arg;\n        return shouldBlock({\n            currentLocation: {\n                ...currentLocation,\n                pathname: stripBasename(currentLocation.pathname, basename) || currentLocation.pathname\n            },\n            nextLocation: {\n                ...nextLocation,\n                pathname: stripBasename(nextLocation.pathname, basename) || nextLocation.pathname\n            },\n            historyAction\n        });\n    }, [\n        basename,\n        shouldBlock\n    ]);\n    React2.useEffect(()=>{\n        let key = String(++blockerId);\n        setBlockerKey(key);\n        return ()=>router.deleteBlocker(key);\n    }, [\n        router\n    ]);\n    React2.useEffect(()=>{\n        if (blockerKey !== \"\") {\n            router.getBlocker(blockerKey, blockerFunction);\n        }\n    }, [\n        router,\n        blockerKey,\n        blockerFunction\n    ]);\n    return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : IDLE_BLOCKER;\n}\nfunction useNavigateStable() {\n    let { router } = useDataRouterContext(\"useNavigate\" /* UseNavigateStable */ );\n    let id = useCurrentRouteId(\"useNavigate\" /* UseNavigateStable */ );\n    let activeRef = React2.useRef(false);\n    useIsomorphicLayoutEffect(()=>{\n        activeRef.current = true;\n    });\n    let navigate = React2.useCallback(async (to, options = {})=>{\n        warning(activeRef.current, navigateEffectWarning);\n        if (!activeRef.current) return;\n        if (typeof to === \"number\") {\n            router.navigate(to);\n        } else {\n            await router.navigate(to, {\n                fromRouteId: id,\n                ...options\n            });\n        }\n    }, [\n        router,\n        id\n    ]);\n    return navigate;\n}\nvar alreadyWarned = {};\nfunction warningOnce(key, cond, message) {\n    if (!cond && !alreadyWarned[key]) {\n        alreadyWarned[key] = true;\n        warning(false, message);\n    }\n}\n// lib/server-runtime/warnings.ts\nvar alreadyWarned2 = {};\nfunction warnOnce(condition, message) {\n    if (!condition && !alreadyWarned2[message]) {\n        alreadyWarned2[message] = true;\n        console.warn(message);\n    }\n}\n// lib/components.tsx\nfunction mapRouteProperties(route) {\n    let updates = {\n        // Note: this check also occurs in createRoutesFromChildren so update\n        // there if you change this -- please and thank you!\n        hasErrorBoundary: route.hasErrorBoundary || route.ErrorBoundary != null || route.errorElement != null\n    };\n    if (route.Component) {\n        if (ENABLE_DEV_WARNINGS) {\n            if (route.element) {\n                warning(false, \"You should not include both `Component` and `element` on your route - `Component` will be used.\");\n            }\n        }\n        Object.assign(updates, {\n            element: React3.createElement(route.Component),\n            Component: void 0\n        });\n    }\n    if (route.HydrateFallback) {\n        if (ENABLE_DEV_WARNINGS) {\n            if (route.hydrateFallbackElement) {\n                warning(false, \"You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used.\");\n            }\n        }\n        Object.assign(updates, {\n            hydrateFallbackElement: React3.createElement(route.HydrateFallback),\n            HydrateFallback: void 0\n        });\n    }\n    if (route.ErrorBoundary) {\n        if (ENABLE_DEV_WARNINGS) {\n            if (route.errorElement) {\n                warning(false, \"You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used.\");\n            }\n        }\n        Object.assign(updates, {\n            errorElement: React3.createElement(route.ErrorBoundary),\n            ErrorBoundary: void 0\n        });\n    }\n    return updates;\n}\nvar hydrationRouteProperties = [\n    \"HydrateFallback\",\n    \"hydrateFallbackElement\"\n];\nfunction createMemoryRouter(routes, opts) {\n    return createRouter({\n        basename: opts?.basename,\n        unstable_getContext: opts?.unstable_getContext,\n        future: opts?.future,\n        history: createMemoryHistory({\n            initialEntries: opts?.initialEntries,\n            initialIndex: opts?.initialIndex\n        }),\n        hydrationData: opts?.hydrationData,\n        routes,\n        hydrationRouteProperties,\n        mapRouteProperties,\n        dataStrategy: opts?.dataStrategy,\n        patchRoutesOnNavigation: opts?.patchRoutesOnNavigation\n    }).initialize();\n}\nvar Deferred = class {\n    constructor(){\n        this.status = \"pending\";\n        this.promise = new Promise((resolve, reject)=>{\n            this.resolve = (value)=>{\n                if (this.status === \"pending\") {\n                    this.status = \"resolved\";\n                    resolve(value);\n                }\n            };\n            this.reject = (reason)=>{\n                if (this.status === \"pending\") {\n                    this.status = \"rejected\";\n                    reject(reason);\n                }\n            };\n        });\n    }\n};\nfunction RouterProvider({ router, flushSync: reactDomFlushSyncImpl }) {\n    let [state, setStateImpl] = React3.useState(router.state);\n    let [pendingState, setPendingState] = React3.useState();\n    let [vtContext, setVtContext] = React3.useState({\n        isTransitioning: false\n    });\n    let [renderDfd, setRenderDfd] = React3.useState();\n    let [transition, setTransition] = React3.useState();\n    let [interruption, setInterruption] = React3.useState();\n    let fetcherData = React3.useRef(/* @__PURE__ */ new Map());\n    let setState = React3.useCallback((newState, { deletedFetchers, flushSync, viewTransitionOpts })=>{\n        newState.fetchers.forEach((fetcher, key)=>{\n            if (fetcher.data !== void 0) {\n                fetcherData.current.set(key, fetcher.data);\n            }\n        });\n        deletedFetchers.forEach((key)=>fetcherData.current.delete(key));\n        warnOnce(flushSync === false || reactDomFlushSyncImpl != null, 'You provided the `flushSync` option to a router update, but you are not using the `<RouterProvider>` from `react-router/dom` so `ReactDOM.flushSync()` is unavailable.  Please update your app to `import { RouterProvider } from \"react-router/dom\"` and ensure you have `react-dom` installed as a dependency to use the `flushSync` option.');\n        let isViewTransitionAvailable = router.window != null && router.window.document != null && typeof router.window.document.startViewTransition === \"function\";\n        warnOnce(viewTransitionOpts == null || isViewTransitionAvailable, \"You provided the `viewTransition` option to a router update, but you do not appear to be running in a DOM environment as `window.startViewTransition` is not available.\");\n        if (!viewTransitionOpts || !isViewTransitionAvailable) {\n            if (reactDomFlushSyncImpl && flushSync) {\n                reactDomFlushSyncImpl(()=>setStateImpl(newState));\n            } else {\n                React3.startTransition(()=>setStateImpl(newState));\n            }\n            return;\n        }\n        if (reactDomFlushSyncImpl && flushSync) {\n            reactDomFlushSyncImpl(()=>{\n                if (transition) {\n                    renderDfd && renderDfd.resolve();\n                    transition.skipTransition();\n                }\n                setVtContext({\n                    isTransitioning: true,\n                    flushSync: true,\n                    currentLocation: viewTransitionOpts.currentLocation,\n                    nextLocation: viewTransitionOpts.nextLocation\n                });\n            });\n            let t = router.window.document.startViewTransition(()=>{\n                reactDomFlushSyncImpl(()=>setStateImpl(newState));\n            });\n            t.finished.finally(()=>{\n                reactDomFlushSyncImpl(()=>{\n                    setRenderDfd(void 0);\n                    setTransition(void 0);\n                    setPendingState(void 0);\n                    setVtContext({\n                        isTransitioning: false\n                    });\n                });\n            });\n            reactDomFlushSyncImpl(()=>setTransition(t));\n            return;\n        }\n        if (transition) {\n            renderDfd && renderDfd.resolve();\n            transition.skipTransition();\n            setInterruption({\n                state: newState,\n                currentLocation: viewTransitionOpts.currentLocation,\n                nextLocation: viewTransitionOpts.nextLocation\n            });\n        } else {\n            setPendingState(newState);\n            setVtContext({\n                isTransitioning: true,\n                flushSync: false,\n                currentLocation: viewTransitionOpts.currentLocation,\n                nextLocation: viewTransitionOpts.nextLocation\n            });\n        }\n    }, [\n        router.window,\n        reactDomFlushSyncImpl,\n        transition,\n        renderDfd\n    ]);\n    React3.useLayoutEffect(()=>router.subscribe(setState), [\n        router,\n        setState\n    ]);\n    React3.useEffect(()=>{\n        if (vtContext.isTransitioning && !vtContext.flushSync) {\n            setRenderDfd(new Deferred());\n        }\n    }, [\n        vtContext\n    ]);\n    React3.useEffect(()=>{\n        if (renderDfd && pendingState && router.window) {\n            let newState = pendingState;\n            let renderPromise = renderDfd.promise;\n            let transition2 = router.window.document.startViewTransition(async ()=>{\n                React3.startTransition(()=>setStateImpl(newState));\n                await renderPromise;\n            });\n            transition2.finished.finally(()=>{\n                setRenderDfd(void 0);\n                setTransition(void 0);\n                setPendingState(void 0);\n                setVtContext({\n                    isTransitioning: false\n                });\n            });\n            setTransition(transition2);\n        }\n    }, [\n        pendingState,\n        renderDfd,\n        router.window\n    ]);\n    React3.useEffect(()=>{\n        if (renderDfd && pendingState && state.location.key === pendingState.location.key) {\n            renderDfd.resolve();\n        }\n    }, [\n        renderDfd,\n        transition,\n        state.location,\n        pendingState\n    ]);\n    React3.useEffect(()=>{\n        if (!vtContext.isTransitioning && interruption) {\n            setPendingState(interruption.state);\n            setVtContext({\n                isTransitioning: true,\n                flushSync: false,\n                currentLocation: interruption.currentLocation,\n                nextLocation: interruption.nextLocation\n            });\n            setInterruption(void 0);\n        }\n    }, [\n        vtContext.isTransitioning,\n        interruption\n    ]);\n    let navigator = React3.useMemo(()=>{\n        return {\n            createHref: router.createHref,\n            encodeLocation: router.encodeLocation,\n            go: (n)=>router.navigate(n),\n            push: (to, state2, opts)=>router.navigate(to, {\n                    state: state2,\n                    preventScrollReset: opts?.preventScrollReset\n                }),\n            replace: (to, state2, opts)=>router.navigate(to, {\n                    replace: true,\n                    state: state2,\n                    preventScrollReset: opts?.preventScrollReset\n                })\n        };\n    }, [\n        router\n    ]);\n    let basename = router.basename || \"/\";\n    let dataRouterContext = React3.useMemo(()=>({\n            router,\n            navigator,\n            static: false,\n            basename\n        }), [\n        router,\n        navigator,\n        basename\n    ]);\n    return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement(DataRouterContext.Provider, {\n        value: dataRouterContext\n    }, /* @__PURE__ */ React3.createElement(DataRouterStateContext.Provider, {\n        value: state\n    }, /* @__PURE__ */ React3.createElement(FetchersContext.Provider, {\n        value: fetcherData.current\n    }, /* @__PURE__ */ React3.createElement(ViewTransitionContext.Provider, {\n        value: vtContext\n    }, /* @__PURE__ */ React3.createElement(Router, {\n        basename,\n        location: state.location,\n        navigationType: state.historyAction,\n        navigator\n    }, /* @__PURE__ */ React3.createElement(MemoizedDataRoutes, {\n        routes: router.routes,\n        future: router.future,\n        state\n    })))))), null);\n}\nvar MemoizedDataRoutes = React3.memo(DataRoutes);\nfunction DataRoutes({ routes, future, state }) {\n    return useRoutesImpl(routes, void 0, state, future);\n}\nfunction MemoryRouter({ basename, children, initialEntries, initialIndex }) {\n    let historyRef = React3.useRef();\n    if (historyRef.current == null) {\n        historyRef.current = createMemoryHistory({\n            initialEntries,\n            initialIndex,\n            v5Compat: true\n        });\n    }\n    let history = historyRef.current;\n    let [state, setStateImpl] = React3.useState({\n        action: history.action,\n        location: history.location\n    });\n    let setState = React3.useCallback((newState)=>{\n        React3.startTransition(()=>setStateImpl(newState));\n    }, [\n        setStateImpl\n    ]);\n    React3.useLayoutEffect(()=>history.listen(setState), [\n        history,\n        setState\n    ]);\n    return /* @__PURE__ */ React3.createElement(Router, {\n        basename,\n        children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\nfunction Navigate({ to, replace: replace2, state, relative }) {\n    invariant(useInRouterContext(), // TODO: This error is probably because they somehow have 2 versions of\n    // the router loaded. We can help them understand how to avoid that.\n    `<Navigate> may be used only in the context of a <Router> component.`);\n    let { static: isStatic } = React3.useContext(NavigationContext);\n    warning(!isStatic, `<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.`);\n    let { matches } = React3.useContext(RouteContext);\n    let { pathname: locationPathname } = useLocation();\n    let navigate = useNavigate();\n    let path = resolveTo(to, getResolveToMatches(matches), locationPathname, relative === \"path\");\n    let jsonPath = JSON.stringify(path);\n    React3.useEffect(()=>{\n        navigate(JSON.parse(jsonPath), {\n            replace: replace2,\n            state,\n            relative\n        });\n    }, [\n        navigate,\n        jsonPath,\n        relative,\n        replace2,\n        state\n    ]);\n    return null;\n}\nfunction Outlet(props) {\n    return useOutlet(props.context);\n}\nfunction Route(_props) {\n    invariant(false, `A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.`);\n}\nfunction Router({ basename: basenameProp = \"/\", children = null, location: locationProp, navigationType = \"POP\" /* Pop */ , navigator, static: staticProp = false }) {\n    invariant(!useInRouterContext(), `You cannot render a <Router> inside another <Router>. You should never have more than one in your app.`);\n    let basename = basenameProp.replace(/^\\/*/, \"/\");\n    let navigationContext = React3.useMemo(()=>({\n            basename,\n            navigator,\n            static: staticProp,\n            future: {}\n        }), [\n        basename,\n        navigator,\n        staticProp\n    ]);\n    if (typeof locationProp === \"string\") {\n        locationProp = parsePath(locationProp);\n    }\n    let { pathname = \"/\", search = \"\", hash = \"\", state = null, key = \"default\" } = locationProp;\n    let locationContext = React3.useMemo(()=>{\n        let trailingPathname = stripBasename(pathname, basename);\n        if (trailingPathname == null) {\n            return null;\n        }\n        return {\n            location: {\n                pathname: trailingPathname,\n                search,\n                hash,\n                state,\n                key\n            },\n            navigationType\n        };\n    }, [\n        basename,\n        pathname,\n        search,\n        hash,\n        state,\n        key,\n        navigationType\n    ]);\n    warning(locationContext != null, `<Router basename=\"${basename}\"> is not able to match the URL \"${pathname}${search}${hash}\" because it does not start with the basename, so the <Router> won't render anything.`);\n    if (locationContext == null) {\n        return null;\n    }\n    return /* @__PURE__ */ React3.createElement(NavigationContext.Provider, {\n        value: navigationContext\n    }, /* @__PURE__ */ React3.createElement(LocationContext.Provider, {\n        children,\n        value: locationContext\n    }));\n}\nfunction Routes({ children, location }) {\n    return useRoutes(createRoutesFromChildren(children), location);\n}\nfunction Await({ children, errorElement, resolve }) {\n    return /* @__PURE__ */ React3.createElement(AwaitErrorBoundary, {\n        resolve,\n        errorElement\n    }, /* @__PURE__ */ React3.createElement(ResolveAwait, null, children));\n}\nvar AwaitErrorBoundary = class extends React3.Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            error: null\n        };\n    }\n    static getDerivedStateFromError(error) {\n        return {\n            error\n        };\n    }\n    componentDidCatch(error, errorInfo) {\n        console.error(\"<Await> caught the following error during render\", error, errorInfo);\n    }\n    render() {\n        let { children, errorElement, resolve } = this.props;\n        let promise = null;\n        let status = 0 /* pending */ ;\n        if (!(resolve instanceof Promise)) {\n            status = 1 /* success */ ;\n            promise = Promise.resolve();\n            Object.defineProperty(promise, \"_tracked\", {\n                get: ()=>true\n            });\n            Object.defineProperty(promise, \"_data\", {\n                get: ()=>resolve\n            });\n        } else if (this.state.error) {\n            status = 2 /* error */ ;\n            let renderError = this.state.error;\n            promise = Promise.reject().catch(()=>{});\n            Object.defineProperty(promise, \"_tracked\", {\n                get: ()=>true\n            });\n            Object.defineProperty(promise, \"_error\", {\n                get: ()=>renderError\n            });\n        } else if (resolve._tracked) {\n            promise = resolve;\n            status = \"_error\" in promise ? 2 /* error */  : \"_data\" in promise ? 1 /* success */  : 0 /* pending */ ;\n        } else {\n            status = 0 /* pending */ ;\n            Object.defineProperty(resolve, \"_tracked\", {\n                get: ()=>true\n            });\n            promise = resolve.then((data2)=>Object.defineProperty(resolve, \"_data\", {\n                    get: ()=>data2\n                }), (error)=>Object.defineProperty(resolve, \"_error\", {\n                    get: ()=>error\n                }));\n        }\n        if (status === 2 /* error */  && !errorElement) {\n            throw promise._error;\n        }\n        if (status === 2 /* error */ ) {\n            return /* @__PURE__ */ React3.createElement(AwaitContext.Provider, {\n                value: promise,\n                children: errorElement\n            });\n        }\n        if (status === 1 /* success */ ) {\n            return /* @__PURE__ */ React3.createElement(AwaitContext.Provider, {\n                value: promise,\n                children\n            });\n        }\n        throw promise;\n    }\n};\nfunction ResolveAwait({ children }) {\n    let data2 = useAsyncValue();\n    let toRender = typeof children === \"function\" ? children(data2) : children;\n    return /* @__PURE__ */ React3.createElement(React3.Fragment, null, toRender);\n}\nfunction createRoutesFromChildren(children, parentPath = []) {\n    let routes = [];\n    React3.Children.forEach(children, (element, index)=>{\n        if (!React3.isValidElement(element)) {\n            return;\n        }\n        let treePath = [\n            ...parentPath,\n            index\n        ];\n        if (element.type === React3.Fragment) {\n            routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));\n            return;\n        }\n        invariant(element.type === Route, `[${typeof element.type === \"string\" ? element.type : element.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`);\n        invariant(!element.props.index || !element.props.children, \"An index route cannot have child routes.\");\n        let route = {\n            id: element.props.id || treePath.join(\"-\"),\n            caseSensitive: element.props.caseSensitive,\n            element: element.props.element,\n            Component: element.props.Component,\n            index: element.props.index,\n            path: element.props.path,\n            loader: element.props.loader,\n            action: element.props.action,\n            hydrateFallbackElement: element.props.hydrateFallbackElement,\n            HydrateFallback: element.props.HydrateFallback,\n            errorElement: element.props.errorElement,\n            ErrorBoundary: element.props.ErrorBoundary,\n            hasErrorBoundary: element.props.hasErrorBoundary === true || element.props.ErrorBoundary != null || element.props.errorElement != null,\n            shouldRevalidate: element.props.shouldRevalidate,\n            handle: element.props.handle,\n            lazy: element.props.lazy\n        };\n        if (element.props.children) {\n            route.children = createRoutesFromChildren(element.props.children, treePath);\n        }\n        routes.push(route);\n    });\n    return routes;\n}\nvar createRoutesFromElements = createRoutesFromChildren;\nfunction renderMatches(matches) {\n    return _renderMatches(matches);\n}\nfunction withComponentProps(Component4) {\n    return function WithComponentProps() {\n        const props = {\n            params: useParams(),\n            loaderData: useLoaderData(),\n            actionData: useActionData(),\n            matches: useMatches()\n        };\n        return React3.createElement(Component4, props);\n    };\n}\nfunction withHydrateFallbackProps(HydrateFallback) {\n    return function WithHydrateFallbackProps() {\n        const props = {\n            params: useParams(),\n            loaderData: useLoaderData(),\n            actionData: useActionData()\n        };\n        return React3.createElement(HydrateFallback, props);\n    };\n}\nfunction withErrorBoundaryProps(ErrorBoundary) {\n    return function WithErrorBoundaryProps() {\n        const props = {\n            params: useParams(),\n            loaderData: useLoaderData(),\n            actionData: useActionData(),\n            error: useRouteError()\n        };\n        return React3.createElement(ErrorBoundary, props);\n    };\n}\n// lib/dom/lib.tsx\nvar React10 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\n// lib/dom/dom.ts\nvar defaultMethod = \"get\";\nvar defaultEncType = \"application/x-www-form-urlencoded\";\nfunction isHtmlElement(object) {\n    return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\nfunction isModifiedEvent(event) {\n    return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\nfunction shouldProcessLinkClick(event, target) {\n    return event.button === 0 && // Ignore everything but left clicks\n    (!target || target === \"_self\") && // Let browser handle \"target=_blank\" etc.\n    !isModifiedEvent(event);\n}\nfunction createSearchParams(init = \"\") {\n    return new URLSearchParams(typeof init === \"string\" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo2, key)=>{\n        let value = init[key];\n        return memo2.concat(Array.isArray(value) ? value.map((v)=>[\n                key,\n                v\n            ]) : [\n            [\n                key,\n                value\n            ]\n        ]);\n    }, []));\n}\nfunction getSearchParamsForLocation(locationSearch, defaultSearchParams) {\n    let searchParams = createSearchParams(locationSearch);\n    if (defaultSearchParams) {\n        defaultSearchParams.forEach((_, key)=>{\n            if (!searchParams.has(key)) {\n                defaultSearchParams.getAll(key).forEach((value)=>{\n                    searchParams.append(key, value);\n                });\n            }\n        });\n    }\n    return searchParams;\n}\nvar _formDataSupportsSubmitter = null;\nfunction isFormDataSubmitterSupported() {\n    if (_formDataSupportsSubmitter === null) {\n        try {\n            new FormData(document.createElement(\"form\"), // @ts-expect-error if FormData supports the submitter parameter, this will throw\n            0);\n            _formDataSupportsSubmitter = false;\n        } catch (e) {\n            _formDataSupportsSubmitter = true;\n        }\n    }\n    return _formDataSupportsSubmitter;\n}\nvar supportedFormEncTypes = /* @__PURE__ */ new Set([\n    \"application/x-www-form-urlencoded\",\n    \"multipart/form-data\",\n    \"text/plain\"\n]);\nfunction getFormEncType(encType) {\n    if (encType != null && !supportedFormEncTypes.has(encType)) {\n        warning(false, `\"${encType}\" is not a valid \\`encType\\` for \\`<Form>\\`/\\`<fetcher.Form>\\` and will default to \"${defaultEncType}\"`);\n        return null;\n    }\n    return encType;\n}\nfunction getFormSubmissionInfo(target, basename) {\n    let method;\n    let action;\n    let encType;\n    let formData;\n    let body;\n    if (isFormElement(target)) {\n        let attr = target.getAttribute(\"action\");\n        action = attr ? stripBasename(attr, basename) : null;\n        method = target.getAttribute(\"method\") || defaultMethod;\n        encType = getFormEncType(target.getAttribute(\"enctype\")) || defaultEncType;\n        formData = new FormData(target);\n    } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n        let form = target.form;\n        if (form == null) {\n            throw new Error(`Cannot submit a <button> or <input type=\"submit\"> without a <form>`);\n        }\n        let attr = target.getAttribute(\"formaction\") || form.getAttribute(\"action\");\n        action = attr ? stripBasename(attr, basename) : null;\n        method = target.getAttribute(\"formmethod\") || form.getAttribute(\"method\") || defaultMethod;\n        encType = getFormEncType(target.getAttribute(\"formenctype\")) || getFormEncType(form.getAttribute(\"enctype\")) || defaultEncType;\n        formData = new FormData(form, target);\n        if (!isFormDataSubmitterSupported()) {\n            let { name, type, value } = target;\n            if (type === \"image\") {\n                let prefix = name ? `${name}.` : \"\";\n                formData.append(`${prefix}x`, \"0\");\n                formData.append(`${prefix}y`, \"0\");\n            } else if (name) {\n                formData.append(name, value);\n            }\n        }\n    } else if (isHtmlElement(target)) {\n        throw new Error(`Cannot submit element that is not <form>, <button>, or <input type=\"submit|image\">`);\n    } else {\n        method = defaultMethod;\n        action = null;\n        encType = defaultEncType;\n        body = target;\n    }\n    if (formData && encType === \"text/plain\") {\n        body = formData;\n        formData = void 0;\n    }\n    return {\n        action,\n        method: method.toLowerCase(),\n        encType,\n        formData,\n        body\n    };\n}\n// lib/dom/ssr/components.tsx\nvar React9 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\n// lib/dom/ssr/invariant.ts\nfunction invariant2(value, message) {\n    if (value === false || value === null || typeof value === \"undefined\") {\n        throw new Error(message);\n    }\n}\n// lib/dom/ssr/routeModules.ts\nasync function loadRouteModule(route, routeModulesCache) {\n    if (route.id in routeModulesCache) {\n        return routeModulesCache[route.id];\n    }\n    try {\n        let routeModule = await import(/* @vite-ignore */ /* webpackIgnore: true */ route.module);\n        routeModulesCache[route.id] = routeModule;\n        return routeModule;\n    } catch (error) {\n        console.error(`Error loading route module \\`${route.module}\\`, reloading page...`);\n        console.error(error);\n        if (window.__reactRouterContext && window.__reactRouterContext.isSpaMode && // @ts-expect-error\n        void 0) {\n            throw error;\n        }\n        window.location.reload();\n        return new Promise(()=>{});\n    }\n}\n// lib/dom/ssr/links.ts\nfunction getKeyedLinksForMatches(matches, routeModules, manifest) {\n    let descriptors = matches.map((match)=>{\n        let module2 = routeModules[match.route.id];\n        let route = manifest.routes[match.route.id];\n        return [\n            route && route.css ? route.css.map((href2)=>({\n                    rel: \"stylesheet\",\n                    href: href2\n                })) : [],\n            module2?.links?.() || []\n        ];\n    }).flat(2);\n    let preloads = getModuleLinkHrefs(matches, manifest);\n    return dedupeLinkDescriptors(descriptors, preloads);\n}\nfunction getRouteCssDescriptors(route) {\n    if (!route.css) return [];\n    return route.css.map((href2)=>({\n            rel: \"stylesheet\",\n            href: href2\n        }));\n}\nasync function prefetchRouteCss(route) {\n    if (!route.css) return;\n    let descriptors = getRouteCssDescriptors(route);\n    await Promise.all(descriptors.map(prefetchStyleLink));\n}\nasync function prefetchStyleLinks(route, routeModule) {\n    if (!route.css && !routeModule.links || !isPreloadSupported()) return;\n    let descriptors = [];\n    if (route.css) {\n        descriptors.push(...getRouteCssDescriptors(route));\n    }\n    if (routeModule.links) {\n        descriptors.push(...routeModule.links());\n    }\n    if (descriptors.length === 0) return;\n    let styleLinks = [];\n    for (let descriptor of descriptors){\n        if (!isPageLinkDescriptor(descriptor) && descriptor.rel === \"stylesheet\") {\n            styleLinks.push({\n                ...descriptor,\n                rel: \"preload\",\n                as: \"style\"\n            });\n        }\n    }\n    await Promise.all(styleLinks.map(prefetchStyleLink));\n}\nasync function prefetchStyleLink(descriptor) {\n    return new Promise((resolve)=>{\n        if (descriptor.media && !window.matchMedia(descriptor.media).matches || document.querySelector(`link[rel=\"stylesheet\"][href=\"${descriptor.href}\"]`)) {\n            return resolve();\n        }\n        let link = document.createElement(\"link\");\n        Object.assign(link, descriptor);\n        function removeLink() {\n            if (document.head.contains(link)) {\n                document.head.removeChild(link);\n            }\n        }\n        link.onload = ()=>{\n            removeLink();\n            resolve();\n        };\n        link.onerror = ()=>{\n            removeLink();\n            resolve();\n        };\n        document.head.appendChild(link);\n    });\n}\nfunction isPageLinkDescriptor(object) {\n    return object != null && typeof object.page === \"string\";\n}\nfunction isHtmlLinkDescriptor(object) {\n    if (object == null) {\n        return false;\n    }\n    if (object.href == null) {\n        return object.rel === \"preload\" && typeof object.imageSrcSet === \"string\" && typeof object.imageSizes === \"string\";\n    }\n    return typeof object.rel === \"string\" && typeof object.href === \"string\";\n}\nasync function getKeyedPrefetchLinks(matches, manifest, routeModules) {\n    let links = await Promise.all(matches.map(async (match)=>{\n        let route = manifest.routes[match.route.id];\n        if (route) {\n            let mod = await loadRouteModule(route, routeModules);\n            return mod.links ? mod.links() : [];\n        }\n        return [];\n    }));\n    return dedupeLinkDescriptors(links.flat(1).filter(isHtmlLinkDescriptor).filter((link)=>link.rel === \"stylesheet\" || link.rel === \"preload\").map((link)=>link.rel === \"stylesheet\" ? {\n            ...link,\n            rel: \"prefetch\",\n            as: \"style\"\n        } : {\n            ...link,\n            rel: \"prefetch\"\n        }));\n}\nfunction getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {\n    let isNew = (match, index)=>{\n        if (!currentMatches[index]) return true;\n        return match.route.id !== currentMatches[index].route.id;\n    };\n    let matchPathChanged = (match, index)=>{\n        return(// param change, /users/123 -> /users/456\n        currentMatches[index].pathname !== match.pathname || // splat param changed, which is not present in match.path\n        // e.g. /files/images/avatar.jpg -> files/finances.xls\n        currentMatches[index].route.path?.endsWith(\"*\") && currentMatches[index].params[\"*\"] !== match.params[\"*\"]);\n    };\n    if (mode === \"assets\") {\n        return nextMatches.filter((match, index)=>isNew(match, index) || matchPathChanged(match, index));\n    }\n    if (mode === \"data\") {\n        return nextMatches.filter((match, index)=>{\n            let manifestRoute = manifest.routes[match.route.id];\n            if (!manifestRoute || !manifestRoute.hasLoader) {\n                return false;\n            }\n            if (isNew(match, index) || matchPathChanged(match, index)) {\n                return true;\n            }\n            if (match.route.shouldRevalidate) {\n                let routeChoice = match.route.shouldRevalidate({\n                    currentUrl: new URL(location.pathname + location.search + location.hash, window.origin),\n                    currentParams: currentMatches[0]?.params || {},\n                    nextUrl: new URL(page, window.origin),\n                    nextParams: match.params,\n                    defaultShouldRevalidate: true\n                });\n                if (typeof routeChoice === \"boolean\") {\n                    return routeChoice;\n                }\n            }\n            return true;\n        });\n    }\n    return [];\n}\nfunction getModuleLinkHrefs(matches, manifest, { includeHydrateFallback } = {}) {\n    return dedupeHrefs(matches.map((match)=>{\n        let route = manifest.routes[match.route.id];\n        if (!route) return [];\n        let hrefs = [\n            route.module\n        ];\n        if (route.clientActionModule) {\n            hrefs = hrefs.concat(route.clientActionModule);\n        }\n        if (route.clientLoaderModule) {\n            hrefs = hrefs.concat(route.clientLoaderModule);\n        }\n        if (includeHydrateFallback && route.hydrateFallbackModule) {\n            hrefs = hrefs.concat(route.hydrateFallbackModule);\n        }\n        if (route.imports) {\n            hrefs = hrefs.concat(route.imports);\n        }\n        return hrefs;\n    }).flat(1));\n}\nfunction dedupeHrefs(hrefs) {\n    return [\n        ...new Set(hrefs)\n    ];\n}\nfunction sortKeys(obj) {\n    let sorted = {};\n    let keys = Object.keys(obj).sort();\n    for (let key of keys){\n        sorted[key] = obj[key];\n    }\n    return sorted;\n}\nfunction dedupeLinkDescriptors(descriptors, preloads) {\n    let set = /* @__PURE__ */ new Set();\n    let preloadsSet = new Set(preloads);\n    return descriptors.reduce((deduped, descriptor)=>{\n        let alreadyModulePreload = preloads && !isPageLinkDescriptor(descriptor) && descriptor.as === \"script\" && descriptor.href && preloadsSet.has(descriptor.href);\n        if (alreadyModulePreload) {\n            return deduped;\n        }\n        let key = JSON.stringify(sortKeys(descriptor));\n        if (!set.has(key)) {\n            set.add(key);\n            deduped.push({\n                key,\n                link: descriptor\n            });\n        }\n        return deduped;\n    }, []);\n}\nvar _isPreloadSupported;\nfunction isPreloadSupported() {\n    if (_isPreloadSupported !== void 0) {\n        return _isPreloadSupported;\n    }\n    let el = document.createElement(\"link\");\n    _isPreloadSupported = el.relList.supports(\"preload\");\n    el = null;\n    return _isPreloadSupported;\n}\n// lib/dom/ssr/markup.ts\nvar ESCAPE_LOOKUP = {\n    \"&\": \"\\\\u0026\",\n    \">\": \"\\\\u003e\",\n    \"<\": \"\\\\u003c\",\n    \"\\u2028\": \"\\\\u2028\",\n    \"\\u2029\": \"\\\\u2029\"\n};\nvar ESCAPE_REGEX = /[&><\\u2028\\u2029]/g;\nfunction escapeHtml(html) {\n    return html.replace(ESCAPE_REGEX, (match)=>ESCAPE_LOOKUP[match]);\n}\nfunction createHtml(html) {\n    return {\n        __html: html\n    };\n}\n// lib/dom/ssr/single-fetch.tsx\nvar React4 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\n// vendor/turbo-stream-v2/utils.ts\nvar HOLE = -1;\nvar NAN = -2;\nvar NEGATIVE_INFINITY = -3;\nvar NEGATIVE_ZERO = -4;\nvar NULL = -5;\nvar POSITIVE_INFINITY = -6;\nvar UNDEFINED = -7;\nvar TYPE_BIGINT = \"B\";\nvar TYPE_DATE = \"D\";\nvar TYPE_ERROR = \"E\";\nvar TYPE_MAP = \"M\";\nvar TYPE_NULL_OBJECT = \"N\";\nvar TYPE_PROMISE = \"P\";\nvar TYPE_REGEXP = \"R\";\nvar TYPE_SET = \"S\";\nvar TYPE_SYMBOL = \"Y\";\nvar TYPE_URL = \"U\";\nvar TYPE_PREVIOUS_RESOLVED = \"Z\";\nvar Deferred2 = class {\n    constructor(){\n        this.promise = new Promise((resolve, reject)=>{\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n};\nfunction createLineSplittingTransform() {\n    const decoder = new TextDecoder();\n    let leftover = \"\";\n    return new TransformStream({\n        transform (chunk, controller) {\n            const str = decoder.decode(chunk, {\n                stream: true\n            });\n            const parts = (leftover + str).split(\"\\n\");\n            leftover = parts.pop() || \"\";\n            for (const part of parts){\n                controller.enqueue(part);\n            }\n        },\n        flush (controller) {\n            if (leftover) {\n                controller.enqueue(leftover);\n            }\n        }\n    });\n}\n// vendor/turbo-stream-v2/flatten.ts\nfunction flatten(input) {\n    const { indices } = this;\n    const existing = indices.get(input);\n    if (existing) return [\n        existing\n    ];\n    if (input === void 0) return UNDEFINED;\n    if (input === null) return NULL;\n    if (Number.isNaN(input)) return NAN;\n    if (input === Number.POSITIVE_INFINITY) return POSITIVE_INFINITY;\n    if (input === Number.NEGATIVE_INFINITY) return NEGATIVE_INFINITY;\n    if (input === 0 && 1 / input < 0) return NEGATIVE_ZERO;\n    const index = this.index++;\n    indices.set(input, index);\n    stringify.call(this, input, index);\n    return index;\n}\nfunction stringify(input, index) {\n    const { deferred, plugins, postPlugins } = this;\n    const str = this.stringified;\n    const stack = [\n        [\n            input,\n            index\n        ]\n    ];\n    while(stack.length > 0){\n        const [input2, index2] = stack.pop();\n        const partsForObj = (obj)=>Object.keys(obj).map((k)=>`\"_${flatten.call(this, k)}\":${flatten.call(this, obj[k])}`).join(\",\");\n        let error = null;\n        switch(typeof input2){\n            case \"boolean\":\n            case \"number\":\n            case \"string\":\n                str[index2] = JSON.stringify(input2);\n                break;\n            case \"bigint\":\n                str[index2] = `[\"${TYPE_BIGINT}\",\"${input2}\"]`;\n                break;\n            case \"symbol\":\n                {\n                    const keyFor = Symbol.keyFor(input2);\n                    if (!keyFor) {\n                        error = new Error(\"Cannot encode symbol unless created with Symbol.for()\");\n                    } else {\n                        str[index2] = `[\"${TYPE_SYMBOL}\",${JSON.stringify(keyFor)}]`;\n                    }\n                    break;\n                }\n            case \"object\":\n                {\n                    if (!input2) {\n                        str[index2] = `${NULL}`;\n                        break;\n                    }\n                    const isArray = Array.isArray(input2);\n                    let pluginHandled = false;\n                    if (!isArray && plugins) {\n                        for (const plugin of plugins){\n                            const pluginResult = plugin(input2);\n                            if (Array.isArray(pluginResult)) {\n                                pluginHandled = true;\n                                const [pluginIdentifier, ...rest] = pluginResult;\n                                str[index2] = `[${JSON.stringify(pluginIdentifier)}`;\n                                if (rest.length > 0) {\n                                    str[index2] += `,${rest.map((v)=>flatten.call(this, v)).join(\",\")}`;\n                                }\n                                str[index2] += \"]\";\n                                break;\n                            }\n                        }\n                    }\n                    if (!pluginHandled) {\n                        let result = isArray ? \"[\" : \"{\";\n                        if (isArray) {\n                            for(let i = 0; i < input2.length; i++)result += (i ? \",\" : \"\") + (i in input2 ? flatten.call(this, input2[i]) : HOLE);\n                            str[index2] = `${result}]`;\n                        } else if (input2 instanceof Date) {\n                            str[index2] = `[\"${TYPE_DATE}\",${input2.getTime()}]`;\n                        } else if (input2 instanceof URL) {\n                            str[index2] = `[\"${TYPE_URL}\",${JSON.stringify(input2.href)}]`;\n                        } else if (input2 instanceof RegExp) {\n                            str[index2] = `[\"${TYPE_REGEXP}\",${JSON.stringify(input2.source)},${JSON.stringify(input2.flags)}]`;\n                        } else if (input2 instanceof Set) {\n                            if (input2.size > 0) {\n                                str[index2] = `[\"${TYPE_SET}\",${[\n                                    ...input2\n                                ].map((val)=>flatten.call(this, val)).join(\",\")}]`;\n                            } else {\n                                str[index2] = `[\"${TYPE_SET}\"]`;\n                            }\n                        } else if (input2 instanceof Map) {\n                            if (input2.size > 0) {\n                                str[index2] = `[\"${TYPE_MAP}\",${[\n                                    ...input2\n                                ].flatMap(([k, v])=>[\n                                        flatten.call(this, k),\n                                        flatten.call(this, v)\n                                    ]).join(\",\")}]`;\n                            } else {\n                                str[index2] = `[\"${TYPE_MAP}\"]`;\n                            }\n                        } else if (input2 instanceof Promise) {\n                            str[index2] = `[\"${TYPE_PROMISE}\",${index2}]`;\n                            deferred[index2] = input2;\n                        } else if (input2 instanceof Error) {\n                            str[index2] = `[\"${TYPE_ERROR}\",${JSON.stringify(input2.message)}`;\n                            if (input2.name !== \"Error\") {\n                                str[index2] += `,${JSON.stringify(input2.name)}`;\n                            }\n                            str[index2] += \"]\";\n                        } else if (Object.getPrototypeOf(input2) === null) {\n                            str[index2] = `[\"${TYPE_NULL_OBJECT}\",{${partsForObj(input2)}}]`;\n                        } else if (isPlainObject(input2)) {\n                            str[index2] = `{${partsForObj(input2)}}`;\n                        } else {\n                            error = new Error(\"Cannot encode object with prototype\");\n                        }\n                    }\n                    break;\n                }\n            default:\n                {\n                    const isArray = Array.isArray(input2);\n                    let pluginHandled = false;\n                    if (!isArray && plugins) {\n                        for (const plugin of plugins){\n                            const pluginResult = plugin(input2);\n                            if (Array.isArray(pluginResult)) {\n                                pluginHandled = true;\n                                const [pluginIdentifier, ...rest] = pluginResult;\n                                str[index2] = `[${JSON.stringify(pluginIdentifier)}`;\n                                if (rest.length > 0) {\n                                    str[index2] += `,${rest.map((v)=>flatten.call(this, v)).join(\",\")}`;\n                                }\n                                str[index2] += \"]\";\n                                break;\n                            }\n                        }\n                    }\n                    if (!pluginHandled) {\n                        error = new Error(\"Cannot encode function or unexpected type\");\n                    }\n                }\n        }\n        if (error) {\n            let pluginHandled = false;\n            if (postPlugins) {\n                for (const plugin of postPlugins){\n                    const pluginResult = plugin(input2);\n                    if (Array.isArray(pluginResult)) {\n                        pluginHandled = true;\n                        const [pluginIdentifier, ...rest] = pluginResult;\n                        str[index2] = `[${JSON.stringify(pluginIdentifier)}`;\n                        if (rest.length > 0) {\n                            str[index2] += `,${rest.map((v)=>flatten.call(this, v)).join(\",\")}`;\n                        }\n                        str[index2] += \"]\";\n                        break;\n                    }\n                }\n            }\n            if (!pluginHandled) {\n                throw error;\n            }\n        }\n    }\n}\nvar objectProtoNames = Object.getOwnPropertyNames(Object.prototype).sort().join(\"\\x00\");\nfunction isPlainObject(thing) {\n    const proto = Object.getPrototypeOf(thing);\n    return proto === Object.prototype || proto === null || Object.getOwnPropertyNames(proto).sort().join(\"\\x00\") === objectProtoNames;\n}\n// vendor/turbo-stream-v2/unflatten.ts\nvar globalObj =  false ? 0 : typeof globalThis !== \"undefined\" ? globalThis : void 0;\nfunction unflatten(parsed) {\n    const { hydrated, values } = this;\n    if (typeof parsed === \"number\") return hydrate.call(this, parsed);\n    if (!Array.isArray(parsed) || !parsed.length) throw new SyntaxError();\n    const startIndex = values.length;\n    for (const value of parsed){\n        values.push(value);\n    }\n    hydrated.length = values.length;\n    return hydrate.call(this, startIndex);\n}\nfunction hydrate(index) {\n    const { hydrated, values, deferred, plugins } = this;\n    let result;\n    const stack = [\n        [\n            index,\n            (v)=>{\n                result = v;\n            }\n        ]\n    ];\n    let postRun = [];\n    while(stack.length > 0){\n        const [index2, set] = stack.pop();\n        switch(index2){\n            case UNDEFINED:\n                set(void 0);\n                continue;\n            case NULL:\n                set(null);\n                continue;\n            case NAN:\n                set(NaN);\n                continue;\n            case POSITIVE_INFINITY:\n                set(Infinity);\n                continue;\n            case NEGATIVE_INFINITY:\n                set(-Infinity);\n                continue;\n            case NEGATIVE_ZERO:\n                set(-0);\n                continue;\n        }\n        if (hydrated[index2]) {\n            set(hydrated[index2]);\n            continue;\n        }\n        const value = values[index2];\n        if (!value || typeof value !== \"object\") {\n            hydrated[index2] = value;\n            set(value);\n            continue;\n        }\n        if (Array.isArray(value)) {\n            if (typeof value[0] === \"string\") {\n                const [type, b, c] = value;\n                switch(type){\n                    case TYPE_DATE:\n                        set(hydrated[index2] = new Date(b));\n                        continue;\n                    case TYPE_URL:\n                        set(hydrated[index2] = new URL(b));\n                        continue;\n                    case TYPE_BIGINT:\n                        set(hydrated[index2] = BigInt(b));\n                        continue;\n                    case TYPE_REGEXP:\n                        set(hydrated[index2] = new RegExp(b, c));\n                        continue;\n                    case TYPE_SYMBOL:\n                        set(hydrated[index2] = Symbol.for(b));\n                        continue;\n                    case TYPE_SET:\n                        const newSet = /* @__PURE__ */ new Set();\n                        hydrated[index2] = newSet;\n                        for(let i = value.length - 1; i > 0; i--)stack.push([\n                            value[i],\n                            (v)=>{\n                                newSet.add(v);\n                            }\n                        ]);\n                        set(newSet);\n                        continue;\n                    case TYPE_MAP:\n                        const map = /* @__PURE__ */ new Map();\n                        hydrated[index2] = map;\n                        for(let i = value.length - 2; i > 0; i -= 2){\n                            const r = [];\n                            stack.push([\n                                value[i + 1],\n                                (v)=>{\n                                    r[1] = v;\n                                }\n                            ]);\n                            stack.push([\n                                value[i],\n                                (k)=>{\n                                    r[0] = k;\n                                }\n                            ]);\n                            postRun.push(()=>{\n                                map.set(r[0], r[1]);\n                            });\n                        }\n                        set(map);\n                        continue;\n                    case TYPE_NULL_OBJECT:\n                        const obj = /* @__PURE__ */ Object.create(null);\n                        hydrated[index2] = obj;\n                        for (const key of Object.keys(b).reverse()){\n                            const r = [];\n                            stack.push([\n                                b[key],\n                                (v)=>{\n                                    r[1] = v;\n                                }\n                            ]);\n                            stack.push([\n                                Number(key.slice(1)),\n                                (k)=>{\n                                    r[0] = k;\n                                }\n                            ]);\n                            postRun.push(()=>{\n                                obj[r[0]] = r[1];\n                            });\n                        }\n                        set(obj);\n                        continue;\n                    case TYPE_PROMISE:\n                        if (hydrated[b]) {\n                            set(hydrated[index2] = hydrated[b]);\n                        } else {\n                            const d = new Deferred2();\n                            deferred[b] = d;\n                            set(hydrated[index2] = d.promise);\n                        }\n                        continue;\n                    case TYPE_ERROR:\n                        const [, message, errorType] = value;\n                        let error = errorType && globalObj && globalObj[errorType] ? new globalObj[errorType](message) : new Error(message);\n                        hydrated[index2] = error;\n                        set(error);\n                        continue;\n                    case TYPE_PREVIOUS_RESOLVED:\n                        set(hydrated[index2] = hydrated[b]);\n                        continue;\n                    default:\n                        if (Array.isArray(plugins)) {\n                            const r = [];\n                            const vals = value.slice(1);\n                            for(let i = 0; i < vals.length; i++){\n                                const v = vals[i];\n                                stack.push([\n                                    v,\n                                    (v2)=>{\n                                        r[i] = v2;\n                                    }\n                                ]);\n                            }\n                            postRun.push(()=>{\n                                for (const plugin of plugins){\n                                    const result2 = plugin(value[0], ...r);\n                                    if (result2) {\n                                        set(hydrated[index2] = result2.value);\n                                        return;\n                                    }\n                                }\n                                throw new SyntaxError();\n                            });\n                            continue;\n                        }\n                        throw new SyntaxError();\n                }\n            } else {\n                const array = [];\n                hydrated[index2] = array;\n                for(let i = 0; i < value.length; i++){\n                    const n = value[i];\n                    if (n !== HOLE) {\n                        stack.push([\n                            n,\n                            (v)=>{\n                                array[i] = v;\n                            }\n                        ]);\n                    }\n                }\n                set(array);\n                continue;\n            }\n        } else {\n            const object = {};\n            hydrated[index2] = object;\n            for (const key of Object.keys(value).reverse()){\n                const r = [];\n                stack.push([\n                    value[key],\n                    (v)=>{\n                        r[1] = v;\n                    }\n                ]);\n                stack.push([\n                    Number(key.slice(1)),\n                    (k)=>{\n                        r[0] = k;\n                    }\n                ]);\n                postRun.push(()=>{\n                    object[r[0]] = r[1];\n                });\n            }\n            set(object);\n            continue;\n        }\n    }\n    while(postRun.length > 0){\n        postRun.pop()();\n    }\n    return result;\n}\n// vendor/turbo-stream-v2/turbo-stream.ts\nasync function decode(readable, options) {\n    const { plugins } = options ?? {};\n    const done = new Deferred2();\n    const reader = readable.pipeThrough(createLineSplittingTransform()).getReader();\n    const decoder = {\n        values: [],\n        hydrated: [],\n        deferred: {},\n        plugins\n    };\n    const decoded = await decodeInitial.call(decoder, reader);\n    let donePromise = done.promise;\n    if (decoded.done) {\n        done.resolve();\n    } else {\n        donePromise = decodeDeferred.call(decoder, reader).then(done.resolve).catch((reason)=>{\n            for (const deferred of Object.values(decoder.deferred)){\n                deferred.reject(reason);\n            }\n            done.reject(reason);\n        });\n    }\n    return {\n        done: donePromise.then(()=>reader.closed),\n        value: decoded.value\n    };\n}\nasync function decodeInitial(reader) {\n    const read = await reader.read();\n    if (!read.value) {\n        throw new SyntaxError();\n    }\n    let line;\n    try {\n        line = JSON.parse(read.value);\n    } catch (reason) {\n        throw new SyntaxError();\n    }\n    return {\n        done: read.done,\n        value: unflatten.call(this, line)\n    };\n}\nasync function decodeDeferred(reader) {\n    let read = await reader.read();\n    while(!read.done){\n        if (!read.value) continue;\n        const line = read.value;\n        switch(line[0]){\n            case TYPE_PROMISE:\n                {\n                    const colonIndex = line.indexOf(\":\");\n                    const deferredId = Number(line.slice(1, colonIndex));\n                    const deferred = this.deferred[deferredId];\n                    if (!deferred) {\n                        throw new Error(`Deferred ID ${deferredId} not found in stream`);\n                    }\n                    const lineData = line.slice(colonIndex + 1);\n                    let jsonLine;\n                    try {\n                        jsonLine = JSON.parse(lineData);\n                    } catch (reason) {\n                        throw new SyntaxError();\n                    }\n                    const value = unflatten.call(this, jsonLine);\n                    deferred.resolve(value);\n                    break;\n                }\n            case TYPE_ERROR:\n                {\n                    const colonIndex = line.indexOf(\":\");\n                    const deferredId = Number(line.slice(1, colonIndex));\n                    const deferred = this.deferred[deferredId];\n                    if (!deferred) {\n                        throw new Error(`Deferred ID ${deferredId} not found in stream`);\n                    }\n                    const lineData = line.slice(colonIndex + 1);\n                    let jsonLine;\n                    try {\n                        jsonLine = JSON.parse(lineData);\n                    } catch (reason) {\n                        throw new SyntaxError();\n                    }\n                    const value = unflatten.call(this, jsonLine);\n                    deferred.reject(value);\n                    break;\n                }\n            default:\n                throw new SyntaxError();\n        }\n        read = await reader.read();\n    }\n}\nfunction encode(input, options) {\n    const { plugins, postPlugins, signal } = options ?? {};\n    const encoder2 = {\n        deferred: {},\n        index: 0,\n        indices: /* @__PURE__ */ new Map(),\n        stringified: [],\n        plugins,\n        postPlugins,\n        signal\n    };\n    const textEncoder = new TextEncoder();\n    let lastSentIndex = 0;\n    const readable = new ReadableStream({\n        async start (controller) {\n            const id = flatten.call(encoder2, input);\n            if (Array.isArray(id)) {\n                throw new Error(\"This should never happen\");\n            }\n            if (id < 0) {\n                controller.enqueue(textEncoder.encode(`${id}\n`));\n            } else {\n                controller.enqueue(textEncoder.encode(`[${encoder2.stringified.join(\",\")}]\n`));\n                lastSentIndex = encoder2.stringified.length - 1;\n            }\n            const seenPromises = /* @__PURE__ */ new WeakSet();\n            if (Object.keys(encoder2.deferred).length) {\n                let raceDone;\n                const racePromise = new Promise((resolve, reject)=>{\n                    raceDone = resolve;\n                    if (signal) {\n                        const rejectPromise = ()=>reject(signal.reason || new Error(\"Signal was aborted.\"));\n                        if (signal.aborted) {\n                            rejectPromise();\n                        } else {\n                            signal.addEventListener(\"abort\", (event)=>{\n                                rejectPromise();\n                            });\n                        }\n                    }\n                });\n                while(Object.keys(encoder2.deferred).length > 0){\n                    for (const [deferredId, deferred] of Object.entries(encoder2.deferred)){\n                        if (seenPromises.has(deferred)) continue;\n                        seenPromises.add(// biome-ignore lint/suspicious/noAssignInExpressions: <explanation>\n                        encoder2.deferred[Number(deferredId)] = Promise.race([\n                            racePromise,\n                            deferred\n                        ]).then((resolved)=>{\n                            const id2 = flatten.call(encoder2, resolved);\n                            if (Array.isArray(id2)) {\n                                controller.enqueue(textEncoder.encode(`${TYPE_PROMISE}${deferredId}:[[\"${TYPE_PREVIOUS_RESOLVED}\",${id2[0]}]]\n`));\n                                encoder2.index++;\n                                lastSentIndex++;\n                            } else if (id2 < 0) {\n                                controller.enqueue(textEncoder.encode(`${TYPE_PROMISE}${deferredId}:${id2}\n`));\n                            } else {\n                                const values = encoder2.stringified.slice(lastSentIndex + 1).join(\",\");\n                                controller.enqueue(textEncoder.encode(`${TYPE_PROMISE}${deferredId}:[${values}]\n`));\n                                lastSentIndex = encoder2.stringified.length - 1;\n                            }\n                        }, (reason)=>{\n                            if (!reason || typeof reason !== \"object\" || !(reason instanceof Error)) {\n                                reason = new Error(\"An unknown error occurred\");\n                            }\n                            const id2 = flatten.call(encoder2, reason);\n                            if (Array.isArray(id2)) {\n                                controller.enqueue(textEncoder.encode(`${TYPE_ERROR}${deferredId}:[[\"${TYPE_PREVIOUS_RESOLVED}\",${id2[0]}]]\n`));\n                                encoder2.index++;\n                                lastSentIndex++;\n                            } else if (id2 < 0) {\n                                controller.enqueue(textEncoder.encode(`${TYPE_ERROR}${deferredId}:${id2}\n`));\n                            } else {\n                                const values = encoder2.stringified.slice(lastSentIndex + 1).join(\",\");\n                                controller.enqueue(textEncoder.encode(`${TYPE_ERROR}${deferredId}:[${values}]\n`));\n                                lastSentIndex = encoder2.stringified.length - 1;\n                            }\n                        }).finally(()=>{\n                            delete encoder2.deferred[Number(deferredId)];\n                        }));\n                    }\n                    await Promise.race(Object.values(encoder2.deferred));\n                }\n                raceDone();\n            }\n            await Promise.all(Object.values(encoder2.deferred));\n            controller.close();\n        }\n    });\n    return readable;\n}\n// lib/dom/ssr/data.ts\nasync function createRequestInit(request) {\n    let init = {\n        signal: request.signal\n    };\n    if (request.method !== \"GET\") {\n        init.method = request.method;\n        let contentType = request.headers.get(\"Content-Type\");\n        if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n            init.headers = {\n                \"Content-Type\": contentType\n            };\n            init.body = JSON.stringify(await request.json());\n        } else if (contentType && /\\btext\\/plain\\b/.test(contentType)) {\n            init.headers = {\n                \"Content-Type\": contentType\n            };\n            init.body = await request.text();\n        } else if (contentType && /\\bapplication\\/x-www-form-urlencoded\\b/.test(contentType)) {\n            init.body = new URLSearchParams(await request.text());\n        } else {\n            init.body = await request.formData();\n        }\n    }\n    return init;\n}\n// lib/dom/ssr/single-fetch.tsx\nvar SingleFetchRedirectSymbol = Symbol(\"SingleFetchRedirect\");\nvar SingleFetchNoResultError = class extends Error {\n};\nvar SINGLE_FETCH_REDIRECT_STATUS = 202;\nvar NO_BODY_STATUS_CODES = /* @__PURE__ */ new Set([\n    100,\n    101,\n    204,\n    205\n]);\nfunction StreamTransfer({ context, identifier, reader, textDecoder, nonce }) {\n    if (!context.renderMeta || !context.renderMeta.didRenderScripts) {\n        return null;\n    }\n    if (!context.renderMeta.streamCache) {\n        context.renderMeta.streamCache = {};\n    }\n    let { streamCache } = context.renderMeta;\n    let promise = streamCache[identifier];\n    if (!promise) {\n        promise = streamCache[identifier] = reader.read().then((result)=>{\n            streamCache[identifier].result = {\n                done: result.done,\n                value: textDecoder.decode(result.value, {\n                    stream: true\n                })\n            };\n        }).catch((e)=>{\n            streamCache[identifier].error = e;\n        });\n    }\n    if (promise.error) {\n        throw promise.error;\n    }\n    if (promise.result === void 0) {\n        throw promise;\n    }\n    let { done, value } = promise.result;\n    let scriptTag = value ? /* @__PURE__ */ React4.createElement(\"script\", {\n        nonce,\n        dangerouslySetInnerHTML: {\n            __html: `window.__reactRouterContext.streamController.enqueue(${escapeHtml(JSON.stringify(value))});`\n        }\n    }) : null;\n    if (done) {\n        return /* @__PURE__ */ React4.createElement(React4.Fragment, null, scriptTag, /* @__PURE__ */ React4.createElement(\"script\", {\n            nonce,\n            dangerouslySetInnerHTML: {\n                __html: `window.__reactRouterContext.streamController.close();`\n            }\n        }));\n    } else {\n        return /* @__PURE__ */ React4.createElement(React4.Fragment, null, scriptTag, /* @__PURE__ */ React4.createElement(React4.Suspense, null, /* @__PURE__ */ React4.createElement(StreamTransfer, {\n            context,\n            identifier: identifier + 1,\n            reader,\n            textDecoder,\n            nonce\n        })));\n    }\n}\nfunction getTurboStreamSingleFetchDataStrategy(getRouter, manifest, routeModules, ssr, basename) {\n    let dataStrategy = getSingleFetchDataStrategyImpl(getRouter, (match)=>{\n        let manifestRoute = manifest.routes[match.route.id];\n        invariant2(manifestRoute, \"Route not found in manifest\");\n        let routeModule = routeModules[match.route.id];\n        return {\n            hasLoader: manifestRoute.hasLoader,\n            hasClientLoader: manifestRoute.hasClientLoader,\n            hasShouldRevalidate: Boolean(routeModule?.shouldRevalidate)\n        };\n    }, fetchAndDecodeViaTurboStream, ssr, basename);\n    return async (args)=>args.unstable_runClientMiddleware(dataStrategy);\n}\nfunction getSingleFetchDataStrategyImpl(getRouter, getRouteInfo, fetchAndDecode, ssr, basename) {\n    return async (args)=>{\n        let { request, matches, fetcherKey } = args;\n        let router = getRouter();\n        if (request.method !== \"GET\") {\n            return singleFetchActionStrategy(args, fetchAndDecode, basename);\n        }\n        let foundRevalidatingServerLoader = matches.some((m)=>{\n            let { hasLoader, hasClientLoader } = getRouteInfo(m);\n            return m.unstable_shouldCallHandler() && hasLoader && !hasClientLoader;\n        });\n        if (!ssr && !foundRevalidatingServerLoader) {\n            return nonSsrStrategy(args, getRouteInfo, fetchAndDecode, basename);\n        }\n        if (fetcherKey) {\n            return singleFetchLoaderFetcherStrategy(args, fetchAndDecode, basename);\n        }\n        return singleFetchLoaderNavigationStrategy(args, router, getRouteInfo, fetchAndDecode, ssr, basename);\n    };\n}\nasync function singleFetchActionStrategy(args, fetchAndDecode, basename) {\n    let actionMatch = args.matches.find((m)=>m.unstable_shouldCallHandler());\n    invariant2(actionMatch, \"No action match found\");\n    let actionStatus = void 0;\n    let result = await actionMatch.resolve(async (handler)=>{\n        let result2 = await handler(async ()=>{\n            let { data: data2, status } = await fetchAndDecode(args, basename, [\n                actionMatch.route.id\n            ]);\n            actionStatus = status;\n            return unwrapSingleFetchResult(data2, actionMatch.route.id);\n        });\n        return result2;\n    });\n    if (isResponse(result.result) || isRouteErrorResponse(result.result) || isDataWithResponseInit(result.result)) {\n        return {\n            [actionMatch.route.id]: result\n        };\n    }\n    return {\n        [actionMatch.route.id]: {\n            type: result.type,\n            result: data(result.result, actionStatus)\n        }\n    };\n}\nasync function nonSsrStrategy(args, getRouteInfo, fetchAndDecode, basename) {\n    let matchesToLoad = args.matches.filter((m)=>m.unstable_shouldCallHandler());\n    let results = {};\n    await Promise.all(matchesToLoad.map((m)=>m.resolve(async (handler)=>{\n            try {\n                let { hasClientLoader } = getRouteInfo(m);\n                let routeId = m.route.id;\n                let result = hasClientLoader ? await handler(async ()=>{\n                    let { data: data2 } = await fetchAndDecode(args, basename, [\n                        routeId\n                    ]);\n                    return unwrapSingleFetchResult(data2, routeId);\n                }) : await handler();\n                results[m.route.id] = {\n                    type: \"data\",\n                    result\n                };\n            } catch (e) {\n                results[m.route.id] = {\n                    type: \"error\",\n                    result: e\n                };\n            }\n        })));\n    return results;\n}\nasync function singleFetchLoaderNavigationStrategy(args, router, getRouteInfo, fetchAndDecode, ssr, basename) {\n    let routesParams = /* @__PURE__ */ new Set();\n    let foundOptOutRoute = false;\n    let routeDfds = args.matches.map(()=>createDeferred2());\n    let singleFetchDfd = createDeferred2();\n    let results = {};\n    let resolvePromise = Promise.all(args.matches.map(async (m, i)=>m.resolve(async (handler)=>{\n            routeDfds[i].resolve();\n            let routeId = m.route.id;\n            let { hasLoader, hasClientLoader, hasShouldRevalidate } = getRouteInfo(m);\n            let defaultShouldRevalidate = !m.unstable_shouldRevalidateArgs || m.unstable_shouldRevalidateArgs.actionStatus == null || m.unstable_shouldRevalidateArgs.actionStatus < 400;\n            let shouldCall = m.unstable_shouldCallHandler(defaultShouldRevalidate);\n            if (!shouldCall) {\n                foundOptOutRoute || (foundOptOutRoute = m.unstable_shouldRevalidateArgs != null && // This is a revalidation,\n                hasLoader && // for a route with a server loader,\n                hasShouldRevalidate === true);\n                return;\n            }\n            if (hasClientLoader) {\n                if (hasLoader) {\n                    foundOptOutRoute = true;\n                }\n                try {\n                    let result = await handler(async ()=>{\n                        let { data: data2 } = await fetchAndDecode(args, basename, [\n                            routeId\n                        ]);\n                        return unwrapSingleFetchResult(data2, routeId);\n                    });\n                    results[routeId] = {\n                        type: \"data\",\n                        result\n                    };\n                } catch (e) {\n                    results[routeId] = {\n                        type: \"error\",\n                        result: e\n                    };\n                }\n                return;\n            }\n            if (hasLoader) {\n                routesParams.add(routeId);\n            }\n            try {\n                let result = await handler(async ()=>{\n                    let data2 = await singleFetchDfd.promise;\n                    return unwrapSingleFetchResult(data2, routeId);\n                });\n                results[routeId] = {\n                    type: \"data\",\n                    result\n                };\n            } catch (e) {\n                results[routeId] = {\n                    type: \"error\",\n                    result: e\n                };\n            }\n        })));\n    await Promise.all(routeDfds.map((d)=>d.promise));\n    let isInitialLoad = !router.state.initialized && router.state.navigation.state === \"idle\";\n    if ((isInitialLoad || routesParams.size === 0) && !window.__reactRouterHdrActive) {\n        singleFetchDfd.resolve({\n            routes: {}\n        });\n    } else {\n        let targetRoutes = ssr && foundOptOutRoute && routesParams.size > 0 ? [\n            ...routesParams.keys()\n        ] : void 0;\n        try {\n            let data2 = await fetchAndDecode(args, basename, targetRoutes);\n            singleFetchDfd.resolve(data2.data);\n        } catch (e) {\n            singleFetchDfd.reject(e);\n        }\n    }\n    await resolvePromise;\n    await bubbleMiddlewareErrors(singleFetchDfd.promise, args.matches, routesParams, results);\n    return results;\n}\nasync function bubbleMiddlewareErrors(singleFetchPromise, matches, routesParams, results) {\n    try {\n        let middlewareError;\n        let fetchedData = await singleFetchPromise;\n        if (\"routes\" in fetchedData) {\n            for (let match of matches){\n                if (match.route.id in fetchedData.routes) {\n                    let routeResult = fetchedData.routes[match.route.id];\n                    if (\"error\" in routeResult) {\n                        middlewareError = routeResult.error;\n                        break;\n                    }\n                }\n            }\n        }\n        if (middlewareError !== void 0) {\n            Array.from(routesParams.values()).forEach((routeId)=>{\n                if (results[routeId].result instanceof SingleFetchNoResultError) {\n                    results[routeId].result = middlewareError;\n                }\n            });\n        }\n    } catch (e) {}\n}\nasync function singleFetchLoaderFetcherStrategy(args, fetchAndDecode, basename) {\n    let fetcherMatch = args.matches.find((m)=>m.unstable_shouldCallHandler());\n    invariant2(fetcherMatch, \"No fetcher match found\");\n    let routeId = fetcherMatch.route.id;\n    let result = await fetcherMatch.resolve(async (handler)=>handler(async ()=>{\n            let { data: data2 } = await fetchAndDecode(args, basename, [\n                routeId\n            ]);\n            return unwrapSingleFetchResult(data2, routeId);\n        }));\n    return {\n        [fetcherMatch.route.id]: result\n    };\n}\nfunction stripIndexParam(url) {\n    let indexValues = url.searchParams.getAll(\"index\");\n    url.searchParams.delete(\"index\");\n    let indexValuesToKeep = [];\n    for (let indexValue of indexValues){\n        if (indexValue) {\n            indexValuesToKeep.push(indexValue);\n        }\n    }\n    for (let toKeep of indexValuesToKeep){\n        url.searchParams.append(\"index\", toKeep);\n    }\n    return url;\n}\nfunction singleFetchUrl(reqUrl, basename) {\n    let url = typeof reqUrl === \"string\" ? new URL(reqUrl, // This can be called during the SSR flow via PrefetchPageLinksImpl so\n    // don't assume window is available\n     true ? \"server://singlefetch/\" : 0) : reqUrl;\n    if (url.pathname === \"/\") {\n        url.pathname = \"_root.data\";\n    } else if (basename && stripBasename(url.pathname, basename) === \"/\") {\n        url.pathname = `${basename.replace(/\\/$/, \"\")}/_root.data`;\n    } else {\n        url.pathname = `${url.pathname.replace(/\\/$/, \"\")}.data`;\n    }\n    return url;\n}\nasync function fetchAndDecodeViaTurboStream(args, basename, targetRoutes) {\n    let { request } = args;\n    let url = singleFetchUrl(request.url, basename);\n    if (request.method === \"GET\") {\n        url = stripIndexParam(url);\n        if (targetRoutes) {\n            url.searchParams.set(\"_routes\", targetRoutes.join(\",\"));\n        }\n    }\n    let res = await fetch(url, await createRequestInit(request));\n    if (res.status === 404 && !res.headers.has(\"X-Remix-Response\")) {\n        throw new ErrorResponseImpl(404, \"Not Found\", true);\n    }\n    if (res.status === 204 && res.headers.has(\"X-Remix-Redirect\")) {\n        return {\n            status: SINGLE_FETCH_REDIRECT_STATUS,\n            data: {\n                redirect: {\n                    redirect: res.headers.get(\"X-Remix-Redirect\"),\n                    status: Number(res.headers.get(\"X-Remix-Status\") || \"302\"),\n                    revalidate: res.headers.get(\"X-Remix-Revalidate\") === \"true\",\n                    reload: res.headers.get(\"X-Remix-Reload-Document\") === \"true\",\n                    replace: res.headers.get(\"X-Remix-Replace\") === \"true\"\n                }\n            }\n        };\n    }\n    if (NO_BODY_STATUS_CODES.has(res.status)) {\n        let routes = {};\n        if (targetRoutes && request.method !== \"GET\") {\n            routes[targetRoutes[0]] = {\n                data: void 0\n            };\n        }\n        return {\n            status: res.status,\n            data: {\n                routes\n            }\n        };\n    }\n    invariant2(res.body, \"No response body to decode\");\n    try {\n        let decoded = await decodeViaTurboStream(res.body, window);\n        let data2;\n        if (request.method === \"GET\") {\n            let typed = decoded.value;\n            if (SingleFetchRedirectSymbol in typed) {\n                data2 = {\n                    redirect: typed[SingleFetchRedirectSymbol]\n                };\n            } else {\n                data2 = {\n                    routes: typed\n                };\n            }\n        } else {\n            let typed = decoded.value;\n            let routeId = targetRoutes?.[0];\n            invariant2(routeId, \"No routeId found for single fetch call decoding\");\n            if (\"redirect\" in typed) {\n                data2 = {\n                    redirect: typed\n                };\n            } else {\n                data2 = {\n                    routes: {\n                        [routeId]: typed\n                    }\n                };\n            }\n        }\n        return {\n            status: res.status,\n            data: data2\n        };\n    } catch (e) {\n        throw new Error(\"Unable to decode turbo-stream response\");\n    }\n}\nfunction decodeViaTurboStream(body, global2) {\n    return decode(body, {\n        plugins: [\n            (type, ...rest)=>{\n                if (type === \"SanitizedError\") {\n                    let [name, message, stack] = rest;\n                    let Constructor = Error;\n                    if (name && name in global2 && typeof global2[name] === \"function\") {\n                        Constructor = global2[name];\n                    }\n                    let error = new Constructor(message);\n                    error.stack = stack;\n                    return {\n                        value: error\n                    };\n                }\n                if (type === \"ErrorResponse\") {\n                    let [data2, status, statusText] = rest;\n                    return {\n                        value: new ErrorResponseImpl(status, statusText, data2)\n                    };\n                }\n                if (type === \"SingleFetchRedirect\") {\n                    return {\n                        value: {\n                            [SingleFetchRedirectSymbol]: rest[0]\n                        }\n                    };\n                }\n                if (type === \"SingleFetchClassInstance\") {\n                    return {\n                        value: rest[0]\n                    };\n                }\n                if (type === \"SingleFetchFallback\") {\n                    return {\n                        value: void 0\n                    };\n                }\n            }\n        ]\n    });\n}\nfunction unwrapSingleFetchResult(result, routeId) {\n    if (\"redirect\" in result) {\n        let { redirect: location, revalidate, reload, replace: replace2, status } = result.redirect;\n        throw redirect(location, {\n            status,\n            headers: {\n                // Three R's of redirecting (lol Veep)\n                ...revalidate ? {\n                    \"X-Remix-Revalidate\": \"yes\"\n                } : null,\n                ...reload ? {\n                    \"X-Remix-Reload-Document\": \"yes\"\n                } : null,\n                ...replace2 ? {\n                    \"X-Remix-Replace\": \"yes\"\n                } : null\n            }\n        });\n    }\n    let routeResult = result.routes[routeId];\n    if (routeResult == null) {\n        throw new SingleFetchNoResultError(`No result found for routeId \"${routeId}\"`);\n    } else if (\"error\" in routeResult) {\n        throw routeResult.error;\n    } else if (\"data\" in routeResult) {\n        return routeResult.data;\n    } else {\n        throw new Error(`Invalid response found for routeId \"${routeId}\"`);\n    }\n}\nfunction createDeferred2() {\n    let resolve;\n    let reject;\n    let promise = new Promise((res, rej)=>{\n        resolve = async (val)=>{\n            res(val);\n            try {\n                await promise;\n            } catch (e) {}\n        };\n        reject = async (error)=>{\n            rej(error);\n            try {\n                await promise;\n            } catch (e) {}\n        };\n    });\n    return {\n        promise,\n        //@ts-ignore\n        resolve,\n        //@ts-ignore\n        reject\n    };\n}\n// lib/dom/ssr/fog-of-war.ts\nvar React8 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\n// lib/dom/ssr/routes.tsx\nvar React7 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\n// lib/dom/ssr/errorBoundaries.tsx\nvar React5 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar RemixErrorBoundary = class extends React5.Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            error: props.error || null,\n            location: props.location\n        };\n    }\n    static getDerivedStateFromError(error) {\n        return {\n            error\n        };\n    }\n    static getDerivedStateFromProps(props, state) {\n        if (state.location !== props.location) {\n            return {\n                error: props.error || null,\n                location: props.location\n            };\n        }\n        return {\n            error: props.error || state.error,\n            location: state.location\n        };\n    }\n    render() {\n        if (this.state.error) {\n            return /* @__PURE__ */ React5.createElement(RemixRootDefaultErrorBoundary, {\n                error: this.state.error,\n                isOutsideRemixApp: true\n            });\n        } else {\n            return this.props.children;\n        }\n    }\n};\nfunction RemixRootDefaultErrorBoundary({ error, isOutsideRemixApp }) {\n    console.error(error);\n    let heyDeveloper = /* @__PURE__ */ React5.createElement(\"script\", {\n        dangerouslySetInnerHTML: {\n            __html: `\n        console.log(\n          \"\\u{1F4BF} Hey developer \\u{1F44B}. You can provide a way better UX than this when your app throws errors. Check out https://reactrouter.com/how-to/error-boundary for more information.\"\n        );\n      `\n        }\n    });\n    if (isRouteErrorResponse(error)) {\n        return /* @__PURE__ */ React5.createElement(BoundaryShell, {\n            title: \"Unhandled Thrown Response!\"\n        }, /* @__PURE__ */ React5.createElement(\"h1\", {\n            style: {\n                fontSize: \"24px\"\n            }\n        }, error.status, \" \", error.statusText), ENABLE_DEV_WARNINGS ? heyDeveloper : null);\n    }\n    let errorInstance;\n    if (error instanceof Error) {\n        errorInstance = error;\n    } else {\n        let errorString = error == null ? \"Unknown Error\" : typeof error === \"object\" && \"toString\" in error ? error.toString() : JSON.stringify(error);\n        errorInstance = new Error(errorString);\n    }\n    return /* @__PURE__ */ React5.createElement(BoundaryShell, {\n        title: \"Application Error!\",\n        isOutsideRemixApp\n    }, /* @__PURE__ */ React5.createElement(\"h1\", {\n        style: {\n            fontSize: \"24px\"\n        }\n    }, \"Application Error\"), /* @__PURE__ */ React5.createElement(\"pre\", {\n        style: {\n            padding: \"2rem\",\n            background: \"hsla(10, 50%, 50%, 0.1)\",\n            color: \"red\",\n            overflow: \"auto\"\n        }\n    }, errorInstance.stack), heyDeveloper);\n}\nfunction BoundaryShell({ title, renderScripts, isOutsideRemixApp, children }) {\n    let { routeModules } = useFrameworkContext();\n    if (routeModules.root?.Layout && !isOutsideRemixApp) {\n        return children;\n    }\n    return /* @__PURE__ */ React5.createElement(\"html\", {\n        lang: \"en\"\n    }, /* @__PURE__ */ React5.createElement(\"head\", null, /* @__PURE__ */ React5.createElement(\"meta\", {\n        charSet: \"utf-8\"\n    }), /* @__PURE__ */ React5.createElement(\"meta\", {\n        name: \"viewport\",\n        content: \"width=device-width,initial-scale=1,viewport-fit=cover\"\n    }), /* @__PURE__ */ React5.createElement(\"title\", null, title)), /* @__PURE__ */ React5.createElement(\"body\", null, /* @__PURE__ */ React5.createElement(\"main\", {\n        style: {\n            fontFamily: \"system-ui, sans-serif\",\n            padding: \"2rem\"\n        }\n    }, children, renderScripts ? /* @__PURE__ */ React5.createElement(Scripts, null) : null)));\n}\n// lib/dom/ssr/fallback.tsx\nvar React6 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nfunction RemixRootDefaultHydrateFallback() {\n    return /* @__PURE__ */ React6.createElement(BoundaryShell, {\n        title: \"Loading...\",\n        renderScripts: true\n    }, ENABLE_DEV_WARNINGS ? /* @__PURE__ */ React6.createElement(\"script\", {\n        dangerouslySetInnerHTML: {\n            __html: `\n              console.log(\n                \"\\u{1F4BF} Hey developer \\u{1F44B}. You can provide a way better UX than this \" +\n                \"when your app is loading JS modules and/or running \\`clientLoader\\` \" +\n                \"functions. Check out https://reactrouter.com/start/framework/route-module#hydratefallback \" +\n                \"for more information.\"\n              );\n            `\n        }\n    }) : null);\n}\n// lib/dom/ssr/routes.tsx\nfunction groupRoutesByParentId(manifest) {\n    let routes = {};\n    Object.values(manifest).forEach((route)=>{\n        if (route) {\n            let parentId = route.parentId || \"\";\n            if (!routes[parentId]) {\n                routes[parentId] = [];\n            }\n            routes[parentId].push(route);\n        }\n    });\n    return routes;\n}\nfunction getRouteComponents(route, routeModule, isSpaMode) {\n    let Component4 = getRouteModuleComponent(routeModule);\n    let HydrateFallback = routeModule.HydrateFallback && (!isSpaMode || route.id === \"root\") ? routeModule.HydrateFallback : route.id === \"root\" ? RemixRootDefaultHydrateFallback : void 0;\n    let ErrorBoundary = routeModule.ErrorBoundary ? routeModule.ErrorBoundary : route.id === \"root\" ? ()=>/* @__PURE__ */ React7.createElement(RemixRootDefaultErrorBoundary, {\n            error: useRouteError()\n        }) : void 0;\n    if (route.id === \"root\" && routeModule.Layout) {\n        return {\n            ...Component4 ? {\n                element: /* @__PURE__ */ React7.createElement(routeModule.Layout, null, /* @__PURE__ */ React7.createElement(Component4, null))\n            } : {\n                Component: Component4\n            },\n            ...ErrorBoundary ? {\n                errorElement: /* @__PURE__ */ React7.createElement(routeModule.Layout, null, /* @__PURE__ */ React7.createElement(ErrorBoundary, null))\n            } : {\n                ErrorBoundary\n            },\n            ...HydrateFallback ? {\n                hydrateFallbackElement: /* @__PURE__ */ React7.createElement(routeModule.Layout, null, /* @__PURE__ */ React7.createElement(HydrateFallback, null))\n            } : {\n                HydrateFallback\n            }\n        };\n    }\n    return {\n        Component: Component4,\n        ErrorBoundary,\n        HydrateFallback\n    };\n}\nfunction createServerRoutes(manifest, routeModules, future, isSpaMode, parentId = \"\", routesByParentId = groupRoutesByParentId(manifest), spaModeLazyPromise = Promise.resolve({\n    Component: ()=>null\n})) {\n    return (routesByParentId[parentId] || []).map((route)=>{\n        let routeModule = routeModules[route.id];\n        invariant2(routeModule, \"No `routeModule` available to create server routes\");\n        let dataRoute = {\n            ...getRouteComponents(route, routeModule, isSpaMode),\n            caseSensitive: route.caseSensitive,\n            id: route.id,\n            index: route.index,\n            path: route.path,\n            handle: routeModule.handle,\n            // For SPA Mode, all routes are lazy except root.  However we tell the\n            // router root is also lazy here too since we don't need a full\n            // implementation - we just need a `lazy` prop to tell the RR rendering\n            // where to stop which is always at the root route in SPA mode\n            lazy: isSpaMode ? ()=>spaModeLazyPromise : void 0,\n            // For partial hydration rendering, we need to indicate when the route\n            // has a loader/clientLoader, but it won't ever be called during the static\n            // render, so just give it a no-op function so we can render down to the\n            // proper fallback\n            loader: route.hasLoader || route.hasClientLoader ? ()=>null : void 0\n        };\n        let children = createServerRoutes(manifest, routeModules, future, isSpaMode, route.id, routesByParentId, spaModeLazyPromise);\n        if (children.length > 0) dataRoute.children = children;\n        return dataRoute;\n    });\n}\nfunction createClientRoutesWithHMRRevalidationOptOut(needsRevalidation, manifest, routeModulesCache, initialState, ssr, isSpaMode) {\n    return createClientRoutes(manifest, routeModulesCache, initialState, ssr, isSpaMode, \"\", groupRoutesByParentId(manifest), needsRevalidation);\n}\nfunction preventInvalidServerHandlerCall(type, route) {\n    if (type === \"loader\" && !route.hasLoader || type === \"action\" && !route.hasAction) {\n        let fn = type === \"action\" ? \"serverAction()\" : \"serverLoader()\";\n        let msg = `You are trying to call ${fn} on a route that does not have a server ${type} (routeId: \"${route.id}\")`;\n        console.error(msg);\n        throw new ErrorResponseImpl(400, \"Bad Request\", new Error(msg), true);\n    }\n}\nfunction noActionDefinedError(type, routeId) {\n    let article = type === \"clientAction\" ? \"a\" : \"an\";\n    let msg = `Route \"${routeId}\" does not have ${article} ${type}, but you are trying to submit to it. To fix this, please add ${article} \\`${type}\\` function to the route`;\n    console.error(msg);\n    throw new ErrorResponseImpl(405, \"Method Not Allowed\", new Error(msg), true);\n}\nfunction createClientRoutes(manifest, routeModulesCache, initialState, ssr, isSpaMode, parentId = \"\", routesByParentId = groupRoutesByParentId(manifest), needsRevalidation) {\n    return (routesByParentId[parentId] || []).map((route)=>{\n        let routeModule = routeModulesCache[route.id];\n        function fetchServerHandler(singleFetch) {\n            invariant2(typeof singleFetch === \"function\", \"No single fetch function available for route handler\");\n            return singleFetch();\n        }\n        function fetchServerLoader(singleFetch) {\n            if (!route.hasLoader) return Promise.resolve(null);\n            return fetchServerHandler(singleFetch);\n        }\n        function fetchServerAction(singleFetch) {\n            if (!route.hasAction) {\n                throw noActionDefinedError(\"action\", route.id);\n            }\n            return fetchServerHandler(singleFetch);\n        }\n        function prefetchModule(modulePath) {\n            import(/* @vite-ignore */ /* webpackIgnore: true */ modulePath);\n        }\n        function prefetchRouteModuleChunks(route2) {\n            if (route2.clientActionModule) {\n                prefetchModule(route2.clientActionModule);\n            }\n            if (route2.clientLoaderModule) {\n                prefetchModule(route2.clientLoaderModule);\n            }\n        }\n        async function prefetchStylesAndCallHandler(handler) {\n            let cachedModule = routeModulesCache[route.id];\n            let linkPrefetchPromise = cachedModule ? prefetchStyleLinks(route, cachedModule) : Promise.resolve();\n            try {\n                return handler();\n            } finally{\n                await linkPrefetchPromise;\n            }\n        }\n        let dataRoute = {\n            id: route.id,\n            index: route.index,\n            path: route.path\n        };\n        if (routeModule) {\n            Object.assign(dataRoute, {\n                ...dataRoute,\n                ...getRouteComponents(route, routeModule, isSpaMode),\n                unstable_middleware: routeModule.unstable_clientMiddleware,\n                handle: routeModule.handle,\n                shouldRevalidate: getShouldRevalidateFunction(dataRoute.path, routeModule, route, ssr, needsRevalidation)\n            });\n            let hasInitialData = initialState && initialState.loaderData && route.id in initialState.loaderData;\n            let initialData = hasInitialData ? initialState?.loaderData?.[route.id] : void 0;\n            let hasInitialError = initialState && initialState.errors && route.id in initialState.errors;\n            let initialError = hasInitialError ? initialState?.errors?.[route.id] : void 0;\n            let isHydrationRequest = needsRevalidation == null && (routeModule.clientLoader?.hydrate === true || !route.hasLoader);\n            dataRoute.loader = async ({ request, params, context }, singleFetch)=>{\n                try {\n                    let result = await prefetchStylesAndCallHandler(async ()=>{\n                        invariant2(routeModule, \"No `routeModule` available for critical-route loader\");\n                        if (!routeModule.clientLoader) {\n                            return fetchServerLoader(singleFetch);\n                        }\n                        return routeModule.clientLoader({\n                            request,\n                            params,\n                            context,\n                            async serverLoader () {\n                                preventInvalidServerHandlerCall(\"loader\", route);\n                                if (isHydrationRequest) {\n                                    if (hasInitialData) {\n                                        return initialData;\n                                    }\n                                    if (hasInitialError) {\n                                        throw initialError;\n                                    }\n                                }\n                                return fetchServerLoader(singleFetch);\n                            }\n                        });\n                    });\n                    return result;\n                } finally{\n                    isHydrationRequest = false;\n                }\n            };\n            dataRoute.loader.hydrate = shouldHydrateRouteLoader(route.id, routeModule.clientLoader, route.hasLoader, isSpaMode);\n            dataRoute.action = ({ request, params, context }, singleFetch)=>{\n                return prefetchStylesAndCallHandler(async ()=>{\n                    invariant2(routeModule, \"No `routeModule` available for critical-route action\");\n                    if (!routeModule.clientAction) {\n                        if (isSpaMode) {\n                            throw noActionDefinedError(\"clientAction\", route.id);\n                        }\n                        return fetchServerAction(singleFetch);\n                    }\n                    return routeModule.clientAction({\n                        request,\n                        params,\n                        context,\n                        async serverAction () {\n                            preventInvalidServerHandlerCall(\"action\", route);\n                            return fetchServerAction(singleFetch);\n                        }\n                    });\n                });\n            };\n        } else {\n            if (!route.hasClientLoader) {\n                dataRoute.loader = (_, singleFetch)=>prefetchStylesAndCallHandler(()=>{\n                        return fetchServerLoader(singleFetch);\n                    });\n            }\n            if (!route.hasClientAction) {\n                dataRoute.action = (_, singleFetch)=>prefetchStylesAndCallHandler(()=>{\n                        if (isSpaMode) {\n                            throw noActionDefinedError(\"clientAction\", route.id);\n                        }\n                        return fetchServerAction(singleFetch);\n                    });\n            }\n            let lazyRoutePromise;\n            async function getLazyRoute() {\n                if (lazyRoutePromise) {\n                    return await lazyRoutePromise;\n                }\n                lazyRoutePromise = (async ()=>{\n                    if (route.clientLoaderModule || route.clientActionModule) {\n                        await new Promise((resolve)=>setTimeout(resolve, 0));\n                    }\n                    let routeModulePromise = loadRouteModuleWithBlockingLinks(route, routeModulesCache);\n                    prefetchRouteModuleChunks(route);\n                    return await routeModulePromise;\n                })();\n                return await lazyRoutePromise;\n            }\n            dataRoute.lazy = {\n                loader: route.hasClientLoader ? async ()=>{\n                    let { clientLoader } = route.clientLoaderModule ? await import(/* @vite-ignore */ /* webpackIgnore: true */ route.clientLoaderModule) : await getLazyRoute();\n                    invariant2(clientLoader, \"No `clientLoader` export found\");\n                    return (args, singleFetch)=>clientLoader({\n                            ...args,\n                            async serverLoader () {\n                                preventInvalidServerHandlerCall(\"loader\", route);\n                                return fetchServerLoader(singleFetch);\n                            }\n                        });\n                } : void 0,\n                action: route.hasClientAction ? async ()=>{\n                    let clientActionPromise = route.clientActionModule ? import(/* @vite-ignore */ /* webpackIgnore: true */ route.clientActionModule) : getLazyRoute();\n                    prefetchRouteModuleChunks(route);\n                    let { clientAction } = await clientActionPromise;\n                    invariant2(clientAction, \"No `clientAction` export found\");\n                    return (args, singleFetch)=>clientAction({\n                            ...args,\n                            async serverAction () {\n                                preventInvalidServerHandlerCall(\"action\", route);\n                                return fetchServerAction(singleFetch);\n                            }\n                        });\n                } : void 0,\n                unstable_middleware: route.hasClientMiddleware ? async ()=>{\n                    let { unstable_clientMiddleware } = route.clientMiddlewareModule ? await import(/* @vite-ignore */ /* webpackIgnore: true */ route.clientMiddlewareModule) : await getLazyRoute();\n                    invariant2(unstable_clientMiddleware, \"No `unstable_clientMiddleware` export found\");\n                    return unstable_clientMiddleware;\n                } : void 0,\n                shouldRevalidate: async ()=>{\n                    let lazyRoute = await getLazyRoute();\n                    return getShouldRevalidateFunction(dataRoute.path, lazyRoute, route, ssr, needsRevalidation);\n                },\n                handle: async ()=>(await getLazyRoute()).handle,\n                // No need to wrap these in layout since the root route is never\n                // loaded via route.lazy()\n                Component: async ()=>(await getLazyRoute()).Component,\n                ErrorBoundary: route.hasErrorBoundary ? async ()=>(await getLazyRoute()).ErrorBoundary : void 0\n            };\n        }\n        let children = createClientRoutes(manifest, routeModulesCache, initialState, ssr, isSpaMode, route.id, routesByParentId, needsRevalidation);\n        if (children.length > 0) dataRoute.children = children;\n        return dataRoute;\n    });\n}\nfunction getShouldRevalidateFunction(path, route, manifestRoute, ssr, needsRevalidation) {\n    if (needsRevalidation) {\n        return wrapShouldRevalidateForHdr(manifestRoute.id, route.shouldRevalidate, needsRevalidation);\n    }\n    if (!ssr && manifestRoute.hasLoader && !manifestRoute.hasClientLoader) {\n        let myParams = path ? compilePath(path)[1].map((p)=>p.paramName) : [];\n        const didParamsChange = (opts)=>myParams.some((p)=>opts.currentParams[p] !== opts.nextParams[p]);\n        if (route.shouldRevalidate) {\n            let fn = route.shouldRevalidate;\n            return (opts)=>fn({\n                    ...opts,\n                    defaultShouldRevalidate: didParamsChange(opts)\n                });\n        } else {\n            return (opts)=>didParamsChange(opts);\n        }\n    }\n    if (ssr && route.shouldRevalidate) {\n        let fn = route.shouldRevalidate;\n        return (opts)=>fn({\n                ...opts,\n                defaultShouldRevalidate: true\n            });\n    }\n    return route.shouldRevalidate;\n}\nfunction wrapShouldRevalidateForHdr(routeId, routeShouldRevalidate, needsRevalidation) {\n    let handledRevalidation = false;\n    return (arg)=>{\n        if (!handledRevalidation) {\n            handledRevalidation = true;\n            return needsRevalidation.has(routeId);\n        }\n        return routeShouldRevalidate ? routeShouldRevalidate(arg) : arg.defaultShouldRevalidate;\n    };\n}\nasync function loadRouteModuleWithBlockingLinks(route, routeModules) {\n    let routeModulePromise = loadRouteModule(route, routeModules);\n    let prefetchRouteCssPromise = prefetchRouteCss(route);\n    let routeModule = await routeModulePromise;\n    await Promise.all([\n        prefetchRouteCssPromise,\n        prefetchStyleLinks(route, routeModule)\n    ]);\n    return {\n        Component: getRouteModuleComponent(routeModule),\n        ErrorBoundary: routeModule.ErrorBoundary,\n        unstable_clientMiddleware: routeModule.unstable_clientMiddleware,\n        clientAction: routeModule.clientAction,\n        clientLoader: routeModule.clientLoader,\n        handle: routeModule.handle,\n        links: routeModule.links,\n        meta: routeModule.meta,\n        shouldRevalidate: routeModule.shouldRevalidate\n    };\n}\nfunction getRouteModuleComponent(routeModule) {\n    if (routeModule.default == null) return void 0;\n    let isEmptyObject = typeof routeModule.default === \"object\" && Object.keys(routeModule.default).length === 0;\n    if (!isEmptyObject) {\n        return routeModule.default;\n    }\n}\nfunction shouldHydrateRouteLoader(routeId, clientLoader, hasLoader, isSpaMode) {\n    return isSpaMode && routeId !== \"root\" || clientLoader != null && (clientLoader.hydrate === true || hasLoader !== true);\n}\n// lib/dom/ssr/fog-of-war.ts\nvar nextPaths = /* @__PURE__ */ new Set();\nvar discoveredPathsMaxSize = 1e3;\nvar discoveredPaths = /* @__PURE__ */ new Set();\nvar URL_LIMIT = 7680;\nfunction isFogOfWarEnabled(routeDiscovery, ssr) {\n    return routeDiscovery.mode === \"lazy\" && ssr === true;\n}\nfunction getPartialManifest({ sri, ...manifest }, router) {\n    let routeIds = new Set(router.state.matches.map((m)=>m.route.id));\n    let segments = router.state.location.pathname.split(\"/\").filter(Boolean);\n    let paths = [\n        \"/\"\n    ];\n    segments.pop();\n    while(segments.length > 0){\n        paths.push(`/${segments.join(\"/\")}`);\n        segments.pop();\n    }\n    paths.forEach((path)=>{\n        let matches = matchRoutes(router.routes, path, router.basename);\n        if (matches) {\n            matches.forEach((m)=>routeIds.add(m.route.id));\n        }\n    });\n    let initialRoutes = [\n        ...routeIds\n    ].reduce((acc, id)=>Object.assign(acc, {\n            [id]: manifest.routes[id]\n        }), {});\n    return {\n        ...manifest,\n        routes: initialRoutes,\n        sri: sri ? true : void 0\n    };\n}\nfunction getPatchRoutesOnNavigationFunction(manifest, routeModules, ssr, routeDiscovery, isSpaMode, basename) {\n    if (!isFogOfWarEnabled(routeDiscovery, ssr)) {\n        return void 0;\n    }\n    return async ({ path, patch, signal, fetcherKey })=>{\n        if (discoveredPaths.has(path)) {\n            return;\n        }\n        await fetchAndApplyManifestPatches([\n            path\n        ], fetcherKey ? window.location.href : path, manifest, routeModules, ssr, isSpaMode, basename, routeDiscovery.manifestPath, patch, signal);\n    };\n}\nfunction useFogOFWarDiscovery(router, manifest, routeModules, ssr, routeDiscovery, isSpaMode) {\n    React8.useEffect(()=>{\n        if (!isFogOfWarEnabled(routeDiscovery, ssr) || // @ts-expect-error - TS doesn't know about this yet\n        window.navigator?.connection?.saveData === true) {\n            return;\n        }\n        function registerElement(el) {\n            let path = el.tagName === \"FORM\" ? el.getAttribute(\"action\") : el.getAttribute(\"href\");\n            if (!path) {\n                return;\n            }\n            let pathname = el.tagName === \"A\" ? el.pathname : new URL(path, window.location.origin).pathname;\n            if (!discoveredPaths.has(pathname)) {\n                nextPaths.add(pathname);\n            }\n        }\n        async function fetchPatches() {\n            document.querySelectorAll(\"a[data-discover], form[data-discover]\").forEach(registerElement);\n            let lazyPaths = Array.from(nextPaths.keys()).filter((path)=>{\n                if (discoveredPaths.has(path)) {\n                    nextPaths.delete(path);\n                    return false;\n                }\n                return true;\n            });\n            if (lazyPaths.length === 0) {\n                return;\n            }\n            try {\n                await fetchAndApplyManifestPatches(lazyPaths, null, manifest, routeModules, ssr, isSpaMode, router.basename, routeDiscovery.manifestPath, router.patchRoutes);\n            } catch (e) {\n                console.error(\"Failed to fetch manifest patches\", e);\n            }\n        }\n        let debouncedFetchPatches = debounce(fetchPatches, 100);\n        fetchPatches();\n        let observer = new MutationObserver(()=>debouncedFetchPatches());\n        observer.observe(document.documentElement, {\n            subtree: true,\n            childList: true,\n            attributes: true,\n            attributeFilter: [\n                \"data-discover\",\n                \"href\",\n                \"action\"\n            ]\n        });\n        return ()=>observer.disconnect();\n    }, [\n        ssr,\n        isSpaMode,\n        manifest,\n        routeModules,\n        router,\n        routeDiscovery\n    ]);\n}\nfunction getManifestPath(_manifestPath, basename) {\n    let manifestPath = _manifestPath || \"/__manifest\";\n    if (basename == null) {\n        return manifestPath;\n    }\n    return `${basename}${manifestPath}`.replace(/\\/+/g, \"/\");\n}\nvar MANIFEST_VERSION_STORAGE_KEY = \"react-router-manifest-version\";\nasync function fetchAndApplyManifestPatches(paths, errorReloadPath, manifest, routeModules, ssr, isSpaMode, basename, manifestPath, patchRoutes, signal) {\n    let url = new URL(getManifestPath(manifestPath, basename), window.location.origin);\n    paths.sort().forEach((path)=>url.searchParams.append(\"p\", path));\n    url.searchParams.set(\"version\", manifest.version);\n    if (url.toString().length > URL_LIMIT) {\n        nextPaths.clear();\n        return;\n    }\n    let serverPatches;\n    try {\n        let res = await fetch(url, {\n            signal\n        });\n        if (!res.ok) {\n            throw new Error(`${res.status} ${res.statusText}`);\n        } else if (res.status === 204 && res.headers.has(\"X-Remix-Reload-Document\")) {\n            if (!errorReloadPath) {\n                console.warn(\"Detected a manifest version mismatch during eager route discovery. The next navigation/fetch to an undiscovered route will result in a new document navigation to sync up with the latest manifest.\");\n                return;\n            }\n            if (sessionStorage.getItem(MANIFEST_VERSION_STORAGE_KEY) === manifest.version) {\n                console.error(\"Unable to discover routes due to manifest version mismatch.\");\n                return;\n            }\n            sessionStorage.setItem(MANIFEST_VERSION_STORAGE_KEY, manifest.version);\n            window.location.href = errorReloadPath;\n            console.warn(\"Detected manifest version mismatch, reloading...\");\n            await new Promise(()=>{});\n        } else if (res.status >= 400) {\n            throw new Error(await res.text());\n        }\n        sessionStorage.removeItem(MANIFEST_VERSION_STORAGE_KEY);\n        serverPatches = await res.json();\n    } catch (e) {\n        if (signal?.aborted) return;\n        throw e;\n    }\n    let knownRoutes = new Set(Object.keys(manifest.routes));\n    let patches = Object.values(serverPatches).reduce((acc, route)=>{\n        if (route && !knownRoutes.has(route.id)) {\n            acc[route.id] = route;\n        }\n        return acc;\n    }, {});\n    Object.assign(manifest.routes, patches);\n    paths.forEach((p)=>addToFifoQueue(p, discoveredPaths));\n    let parentIds = /* @__PURE__ */ new Set();\n    Object.values(patches).forEach((patch)=>{\n        if (patch && (!patch.parentId || !patches[patch.parentId])) {\n            parentIds.add(patch.parentId);\n        }\n    });\n    parentIds.forEach((parentId)=>patchRoutes(parentId || null, createClientRoutes(patches, routeModules, null, ssr, isSpaMode, parentId)));\n}\nfunction addToFifoQueue(path, queue) {\n    if (queue.size >= discoveredPathsMaxSize) {\n        let first = queue.values().next().value;\n        queue.delete(first);\n    }\n    queue.add(path);\n}\nfunction debounce(callback, wait) {\n    let timeoutId;\n    return (...args)=>{\n        window.clearTimeout(timeoutId);\n        timeoutId = window.setTimeout(()=>callback(...args), wait);\n    };\n}\n// lib/dom/ssr/components.tsx\nfunction useDataRouterContext2() {\n    let context = React9.useContext(DataRouterContext);\n    invariant2(context, \"You must render this element inside a <DataRouterContext.Provider> element\");\n    return context;\n}\nfunction useDataRouterStateContext() {\n    let context = React9.useContext(DataRouterStateContext);\n    invariant2(context, \"You must render this element inside a <DataRouterStateContext.Provider> element\");\n    return context;\n}\nvar FrameworkContext = React9.createContext(void 0);\nFrameworkContext.displayName = \"FrameworkContext\";\nfunction useFrameworkContext() {\n    let context = React9.useContext(FrameworkContext);\n    invariant2(context, \"You must render this element inside a <HydratedRouter> element\");\n    return context;\n}\nfunction usePrefetchBehavior(prefetch, theirElementProps) {\n    let frameworkContext = React9.useContext(FrameworkContext);\n    let [maybePrefetch, setMaybePrefetch] = React9.useState(false);\n    let [shouldPrefetch, setShouldPrefetch] = React9.useState(false);\n    let { onFocus, onBlur, onMouseEnter, onMouseLeave, onTouchStart } = theirElementProps;\n    let ref = React9.useRef(null);\n    React9.useEffect(()=>{\n        if (prefetch === \"render\") {\n            setShouldPrefetch(true);\n        }\n        if (prefetch === \"viewport\") {\n            let callback = (entries)=>{\n                entries.forEach((entry)=>{\n                    setShouldPrefetch(entry.isIntersecting);\n                });\n            };\n            let observer = new IntersectionObserver(callback, {\n                threshold: 0.5\n            });\n            if (ref.current) observer.observe(ref.current);\n            return ()=>{\n                observer.disconnect();\n            };\n        }\n    }, [\n        prefetch\n    ]);\n    React9.useEffect(()=>{\n        if (maybePrefetch) {\n            let id = setTimeout(()=>{\n                setShouldPrefetch(true);\n            }, 100);\n            return ()=>{\n                clearTimeout(id);\n            };\n        }\n    }, [\n        maybePrefetch\n    ]);\n    let setIntent = ()=>{\n        setMaybePrefetch(true);\n    };\n    let cancelIntent = ()=>{\n        setMaybePrefetch(false);\n        setShouldPrefetch(false);\n    };\n    if (!frameworkContext) {\n        return [\n            false,\n            ref,\n            {}\n        ];\n    }\n    if (prefetch !== \"intent\") {\n        return [\n            shouldPrefetch,\n            ref,\n            {}\n        ];\n    }\n    return [\n        shouldPrefetch,\n        ref,\n        {\n            onFocus: composeEventHandlers(onFocus, setIntent),\n            onBlur: composeEventHandlers(onBlur, cancelIntent),\n            onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),\n            onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),\n            onTouchStart: composeEventHandlers(onTouchStart, setIntent)\n        }\n    ];\n}\nfunction composeEventHandlers(theirHandler, ourHandler) {\n    return (event)=>{\n        theirHandler && theirHandler(event);\n        if (!event.defaultPrevented) {\n            ourHandler(event);\n        }\n    };\n}\nfunction getActiveMatches(matches, errors, isSpaMode) {\n    if (isSpaMode && !isHydrated) {\n        return [\n            matches[0]\n        ];\n    }\n    if (errors) {\n        let errorIdx = matches.findIndex((m)=>errors[m.route.id] !== void 0);\n        return matches.slice(0, errorIdx + 1);\n    }\n    return matches;\n}\nfunction Links() {\n    let { isSpaMode, manifest, routeModules, criticalCss } = useFrameworkContext();\n    let { errors, matches: routerMatches } = useDataRouterStateContext();\n    let matches = getActiveMatches(routerMatches, errors, isSpaMode);\n    let keyedLinks = React9.useMemo(()=>getKeyedLinksForMatches(matches, routeModules, manifest), [\n        matches,\n        routeModules,\n        manifest\n    ]);\n    return /* @__PURE__ */ React9.createElement(React9.Fragment, null, typeof criticalCss === \"string\" ? /* @__PURE__ */ React9.createElement(\"style\", {\n        dangerouslySetInnerHTML: {\n            __html: criticalCss\n        }\n    }) : null, typeof criticalCss === \"object\" ? /* @__PURE__ */ React9.createElement(\"link\", {\n        rel: \"stylesheet\",\n        href: criticalCss.href\n    }) : null, keyedLinks.map(({ key, link })=>isPageLinkDescriptor(link) ? /* @__PURE__ */ React9.createElement(PrefetchPageLinks, {\n            key,\n            ...link\n        }) : /* @__PURE__ */ React9.createElement(\"link\", {\n            key,\n            ...link\n        })));\n}\nfunction PrefetchPageLinks({ page, ...dataLinkProps }) {\n    let { router } = useDataRouterContext2();\n    let matches = React9.useMemo(()=>matchRoutes(router.routes, page, router.basename), [\n        router.routes,\n        page,\n        router.basename\n    ]);\n    if (!matches) {\n        return null;\n    }\n    return /* @__PURE__ */ React9.createElement(PrefetchPageLinksImpl, {\n        page,\n        matches,\n        ...dataLinkProps\n    });\n}\nfunction useKeyedPrefetchLinks(matches) {\n    let { manifest, routeModules } = useFrameworkContext();\n    let [keyedPrefetchLinks, setKeyedPrefetchLinks] = React9.useState([]);\n    React9.useEffect(()=>{\n        let interrupted = false;\n        void getKeyedPrefetchLinks(matches, manifest, routeModules).then((links)=>{\n            if (!interrupted) {\n                setKeyedPrefetchLinks(links);\n            }\n        });\n        return ()=>{\n            interrupted = true;\n        };\n    }, [\n        matches,\n        manifest,\n        routeModules\n    ]);\n    return keyedPrefetchLinks;\n}\nfunction PrefetchPageLinksImpl({ page, matches: nextMatches, ...linkProps }) {\n    let location = useLocation();\n    let { manifest, routeModules } = useFrameworkContext();\n    let { basename } = useDataRouterContext2();\n    let { loaderData, matches } = useDataRouterStateContext();\n    let newMatchesForData = React9.useMemo(()=>getNewMatchesForLinks(page, nextMatches, matches, manifest, location, \"data\"), [\n        page,\n        nextMatches,\n        matches,\n        manifest,\n        location\n    ]);\n    let newMatchesForAssets = React9.useMemo(()=>getNewMatchesForLinks(page, nextMatches, matches, manifest, location, \"assets\"), [\n        page,\n        nextMatches,\n        matches,\n        manifest,\n        location\n    ]);\n    let dataHrefs = React9.useMemo(()=>{\n        if (page === location.pathname + location.search + location.hash) {\n            return [];\n        }\n        let routesParams = /* @__PURE__ */ new Set();\n        let foundOptOutRoute = false;\n        nextMatches.forEach((m)=>{\n            let manifestRoute = manifest.routes[m.route.id];\n            if (!manifestRoute || !manifestRoute.hasLoader) {\n                return;\n            }\n            if (!newMatchesForData.some((m2)=>m2.route.id === m.route.id) && m.route.id in loaderData && routeModules[m.route.id]?.shouldRevalidate) {\n                foundOptOutRoute = true;\n            } else if (manifestRoute.hasClientLoader) {\n                foundOptOutRoute = true;\n            } else {\n                routesParams.add(m.route.id);\n            }\n        });\n        if (routesParams.size === 0) {\n            return [];\n        }\n        let url = singleFetchUrl(page, basename);\n        if (foundOptOutRoute && routesParams.size > 0) {\n            url.searchParams.set(\"_routes\", nextMatches.filter((m)=>routesParams.has(m.route.id)).map((m)=>m.route.id).join(\",\"));\n        }\n        return [\n            url.pathname + url.search\n        ];\n    }, [\n        basename,\n        loaderData,\n        location,\n        manifest,\n        newMatchesForData,\n        nextMatches,\n        page,\n        routeModules\n    ]);\n    let moduleHrefs = React9.useMemo(()=>getModuleLinkHrefs(newMatchesForAssets, manifest), [\n        newMatchesForAssets,\n        manifest\n    ]);\n    let keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);\n    return /* @__PURE__ */ React9.createElement(React9.Fragment, null, dataHrefs.map((href2)=>/* @__PURE__ */ React9.createElement(\"link\", {\n            key: href2,\n            rel: \"prefetch\",\n            as: \"fetch\",\n            href: href2,\n            ...linkProps\n        })), moduleHrefs.map((href2)=>/* @__PURE__ */ React9.createElement(\"link\", {\n            key: href2,\n            rel: \"modulepreload\",\n            href: href2,\n            ...linkProps\n        })), keyedPrefetchLinks.map(({ key, link })=>// these don't spread `linkProps` because they are full link descriptors\n        // already with their own props\n        /* @__PURE__ */ React9.createElement(\"link\", {\n            key,\n            ...link\n        })));\n}\nfunction Meta() {\n    let { isSpaMode, routeModules } = useFrameworkContext();\n    let { errors, matches: routerMatches, loaderData } = useDataRouterStateContext();\n    let location = useLocation();\n    let _matches = getActiveMatches(routerMatches, errors, isSpaMode);\n    let error = null;\n    if (errors) {\n        error = errors[_matches[_matches.length - 1].route.id];\n    }\n    let meta = [];\n    let leafMeta = null;\n    let matches = [];\n    for(let i = 0; i < _matches.length; i++){\n        let _match = _matches[i];\n        let routeId = _match.route.id;\n        let data2 = loaderData[routeId];\n        let params = _match.params;\n        let routeModule = routeModules[routeId];\n        let routeMeta = [];\n        let match = {\n            id: routeId,\n            data: data2,\n            meta: [],\n            params: _match.params,\n            pathname: _match.pathname,\n            handle: _match.route.handle,\n            error\n        };\n        matches[i] = match;\n        if (routeModule?.meta) {\n            routeMeta = typeof routeModule.meta === \"function\" ? routeModule.meta({\n                data: data2,\n                params,\n                location,\n                matches,\n                error\n            }) : Array.isArray(routeModule.meta) ? [\n                ...routeModule.meta\n            ] : routeModule.meta;\n        } else if (leafMeta) {\n            routeMeta = [\n                ...leafMeta\n            ];\n        }\n        routeMeta = routeMeta || [];\n        if (!Array.isArray(routeMeta)) {\n            throw new Error(\"The route at \" + _match.route.path + \" returns an invalid value. All route meta functions must return an array of meta objects.\\n\\nTo reference the meta function API, see https://remix.run/route/meta\");\n        }\n        match.meta = routeMeta;\n        matches[i] = match;\n        meta = [\n            ...routeMeta\n        ];\n        leafMeta = meta;\n    }\n    return /* @__PURE__ */ React9.createElement(React9.Fragment, null, meta.flat().map((metaProps)=>{\n        if (!metaProps) {\n            return null;\n        }\n        if (\"tagName\" in metaProps) {\n            let { tagName, ...rest } = metaProps;\n            if (!isValidMetaTag(tagName)) {\n                console.warn(`A meta object uses an invalid tagName: ${tagName}. Expected either 'link' or 'meta'`);\n                return null;\n            }\n            let Comp = tagName;\n            return /* @__PURE__ */ React9.createElement(Comp, {\n                key: JSON.stringify(rest),\n                ...rest\n            });\n        }\n        if (\"title\" in metaProps) {\n            return /* @__PURE__ */ React9.createElement(\"title\", {\n                key: \"title\"\n            }, String(metaProps.title));\n        }\n        if (\"charset\" in metaProps) {\n            metaProps.charSet ?? (metaProps.charSet = metaProps.charset);\n            delete metaProps.charset;\n        }\n        if (\"charSet\" in metaProps && metaProps.charSet != null) {\n            return typeof metaProps.charSet === \"string\" ? /* @__PURE__ */ React9.createElement(\"meta\", {\n                key: \"charSet\",\n                charSet: metaProps.charSet\n            }) : null;\n        }\n        if (\"script:ld+json\" in metaProps) {\n            try {\n                let json = JSON.stringify(metaProps[\"script:ld+json\"]);\n                return /* @__PURE__ */ React9.createElement(\"script\", {\n                    key: `script:ld+json:${json}`,\n                    type: \"application/ld+json\",\n                    dangerouslySetInnerHTML: {\n                        __html: json\n                    }\n                });\n            } catch (err) {\n                return null;\n            }\n        }\n        return /* @__PURE__ */ React9.createElement(\"meta\", {\n            key: JSON.stringify(metaProps),\n            ...metaProps\n        });\n    }));\n}\nfunction isValidMetaTag(tagName) {\n    return typeof tagName === \"string\" && /^(meta|link)$/.test(tagName);\n}\nvar isHydrated = false;\nfunction Scripts(props) {\n    let { manifest, serverHandoffString, isSpaMode, renderMeta, routeDiscovery, ssr } = useFrameworkContext();\n    let { router, static: isStatic, staticContext } = useDataRouterContext2();\n    let { matches: routerMatches } = useDataRouterStateContext();\n    let enableFogOfWar = isFogOfWarEnabled(routeDiscovery, ssr);\n    if (renderMeta) {\n        renderMeta.didRenderScripts = true;\n    }\n    let matches = getActiveMatches(routerMatches, null, isSpaMode);\n    React9.useEffect(()=>{\n        isHydrated = true;\n    }, []);\n    let initialScripts = React9.useMemo(()=>{\n        let streamScript = \"window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());\";\n        let contextScript = staticContext ? `window.__reactRouterContext = ${serverHandoffString};${streamScript}` : \" \";\n        let routeModulesScript = !isStatic ? \" \" : `${manifest.hmr?.runtime ? `import ${JSON.stringify(manifest.hmr.runtime)};` : \"\"}${!enableFogOfWar ? `import ${JSON.stringify(manifest.url)}` : \"\"};\n${matches.map((match, routeIndex)=>{\n            let routeVarName = `route${routeIndex}`;\n            let manifestEntry = manifest.routes[match.route.id];\n            invariant2(manifestEntry, `Route ${match.route.id} not found in manifest`);\n            let { clientActionModule, clientLoaderModule, clientMiddlewareModule, hydrateFallbackModule, module: module2 } = manifestEntry;\n            let chunks = [\n                ...clientActionModule ? [\n                    {\n                        module: clientActionModule,\n                        varName: `${routeVarName}_clientAction`\n                    }\n                ] : [],\n                ...clientLoaderModule ? [\n                    {\n                        module: clientLoaderModule,\n                        varName: `${routeVarName}_clientLoader`\n                    }\n                ] : [],\n                ...clientMiddlewareModule ? [\n                    {\n                        module: clientMiddlewareModule,\n                        varName: `${routeVarName}_clientMiddleware`\n                    }\n                ] : [],\n                ...hydrateFallbackModule ? [\n                    {\n                        module: hydrateFallbackModule,\n                        varName: `${routeVarName}_HydrateFallback`\n                    }\n                ] : [],\n                {\n                    module: module2,\n                    varName: `${routeVarName}_main`\n                }\n            ];\n            if (chunks.length === 1) {\n                return `import * as ${routeVarName} from ${JSON.stringify(module2)};`;\n            }\n            let chunkImportsSnippet = chunks.map((chunk)=>`import * as ${chunk.varName} from \"${chunk.module}\";`).join(\"\\n\");\n            let mergedChunksSnippet = `const ${routeVarName} = {${chunks.map((chunk)=>`...${chunk.varName}`).join(\",\")}};`;\n            return [\n                chunkImportsSnippet,\n                mergedChunksSnippet\n            ].join(\"\\n\");\n        }).join(\"\\n\")}\n  ${enableFogOfWar ? // Inline a minimal manifest with the SSR matches\n        `window.__reactRouterManifest = ${JSON.stringify(getPartialManifest(manifest, router), null, 2)};` : \"\"}\n  window.__reactRouterRouteModules = {${matches.map((match, index)=>`${JSON.stringify(match.route.id)}:route${index}`).join(\",\")}};\n\nimport(${JSON.stringify(manifest.entry.module)});`;\n        return /* @__PURE__ */ React9.createElement(React9.Fragment, null, /* @__PURE__ */ React9.createElement(\"script\", {\n            ...props,\n            suppressHydrationWarning: true,\n            dangerouslySetInnerHTML: createHtml(contextScript),\n            type: void 0\n        }), /* @__PURE__ */ React9.createElement(\"script\", {\n            ...props,\n            suppressHydrationWarning: true,\n            dangerouslySetInnerHTML: createHtml(routeModulesScript),\n            type: \"module\",\n            async: true\n        }));\n    }, []);\n    let preloads = isHydrated ? [] : dedupe(manifest.entry.imports.concat(getModuleLinkHrefs(matches, manifest, {\n        includeHydrateFallback: true\n    })));\n    let sri = typeof manifest.sri === \"object\" ? manifest.sri : {};\n    return isHydrated ? null : /* @__PURE__ */ React9.createElement(React9.Fragment, null, typeof manifest.sri === \"object\" ? /* @__PURE__ */ React9.createElement(\"script\", {\n        \"rr-importmap\": \"\",\n        type: \"importmap\",\n        suppressHydrationWarning: true,\n        dangerouslySetInnerHTML: {\n            __html: JSON.stringify({\n                integrity: sri\n            })\n        }\n    }) : null, !enableFogOfWar ? /* @__PURE__ */ React9.createElement(\"link\", {\n        rel: \"modulepreload\",\n        href: manifest.url,\n        crossOrigin: props.crossOrigin,\n        integrity: sri[manifest.url],\n        suppressHydrationWarning: true\n    }) : null, /* @__PURE__ */ React9.createElement(\"link\", {\n        rel: \"modulepreload\",\n        href: manifest.entry.module,\n        crossOrigin: props.crossOrigin,\n        integrity: sri[manifest.entry.module],\n        suppressHydrationWarning: true\n    }), preloads.map((path)=>/* @__PURE__ */ React9.createElement(\"link\", {\n            key: path,\n            rel: \"modulepreload\",\n            href: path,\n            crossOrigin: props.crossOrigin,\n            integrity: sri[path],\n            suppressHydrationWarning: true\n        })), initialScripts);\n}\nfunction dedupe(array) {\n    return [\n        ...new Set(array)\n    ];\n}\nfunction mergeRefs(...refs) {\n    return (value)=>{\n        refs.forEach((ref)=>{\n            if (typeof ref === \"function\") {\n                ref(value);\n            } else if (ref != null) {\n                ref.current = value;\n            }\n        });\n    };\n}\n// lib/dom/lib.tsx\nvar isBrowser =  false && 0;\ntry {\n    if (isBrowser) {\n        window.__reactRouterVersion = \"7.6.2\";\n    }\n} catch (e) {}\nfunction createBrowserRouter(routes, opts) {\n    return createRouter({\n        basename: opts?.basename,\n        unstable_getContext: opts?.unstable_getContext,\n        future: opts?.future,\n        history: createBrowserHistory({\n            window: opts?.window\n        }),\n        hydrationData: opts?.hydrationData || parseHydrationData(),\n        routes,\n        mapRouteProperties,\n        hydrationRouteProperties,\n        dataStrategy: opts?.dataStrategy,\n        patchRoutesOnNavigation: opts?.patchRoutesOnNavigation,\n        window: opts?.window\n    }).initialize();\n}\nfunction createHashRouter(routes, opts) {\n    return createRouter({\n        basename: opts?.basename,\n        unstable_getContext: opts?.unstable_getContext,\n        future: opts?.future,\n        history: createHashHistory({\n            window: opts?.window\n        }),\n        hydrationData: opts?.hydrationData || parseHydrationData(),\n        routes,\n        mapRouteProperties,\n        hydrationRouteProperties,\n        dataStrategy: opts?.dataStrategy,\n        patchRoutesOnNavigation: opts?.patchRoutesOnNavigation,\n        window: opts?.window\n    }).initialize();\n}\nfunction parseHydrationData() {\n    let state = window?.__staticRouterHydrationData;\n    if (state && state.errors) {\n        state = {\n            ...state,\n            errors: deserializeErrors(state.errors)\n        };\n    }\n    return state;\n}\nfunction deserializeErrors(errors) {\n    if (!errors) return null;\n    let entries = Object.entries(errors);\n    let serialized = {};\n    for (let [key, val] of entries){\n        if (val && val.__type === \"RouteErrorResponse\") {\n            serialized[key] = new ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);\n        } else if (val && val.__type === \"Error\") {\n            if (val.__subType) {\n                let ErrorConstructor = window[val.__subType];\n                if (typeof ErrorConstructor === \"function\") {\n                    try {\n                        let error = new ErrorConstructor(val.message);\n                        error.stack = \"\";\n                        serialized[key] = error;\n                    } catch (e) {}\n                }\n            }\n            if (serialized[key] == null) {\n                let error = new Error(val.message);\n                error.stack = \"\";\n                serialized[key] = error;\n            }\n        } else {\n            serialized[key] = val;\n        }\n    }\n    return serialized;\n}\nfunction BrowserRouter({ basename, children, window: window2 }) {\n    let historyRef = React10.useRef();\n    if (historyRef.current == null) {\n        historyRef.current = createBrowserHistory({\n            window: window2,\n            v5Compat: true\n        });\n    }\n    let history = historyRef.current;\n    let [state, setStateImpl] = React10.useState({\n        action: history.action,\n        location: history.location\n    });\n    let setState = React10.useCallback((newState)=>{\n        React10.startTransition(()=>setStateImpl(newState));\n    }, [\n        setStateImpl\n    ]);\n    React10.useLayoutEffect(()=>history.listen(setState), [\n        history,\n        setState\n    ]);\n    return /* @__PURE__ */ React10.createElement(Router, {\n        basename,\n        children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\nfunction HashRouter({ basename, children, window: window2 }) {\n    let historyRef = React10.useRef();\n    if (historyRef.current == null) {\n        historyRef.current = createHashHistory({\n            window: window2,\n            v5Compat: true\n        });\n    }\n    let history = historyRef.current;\n    let [state, setStateImpl] = React10.useState({\n        action: history.action,\n        location: history.location\n    });\n    let setState = React10.useCallback((newState)=>{\n        React10.startTransition(()=>setStateImpl(newState));\n    }, [\n        setStateImpl\n    ]);\n    React10.useLayoutEffect(()=>history.listen(setState), [\n        history,\n        setState\n    ]);\n    return /* @__PURE__ */ React10.createElement(Router, {\n        basename,\n        children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\nfunction HistoryRouter({ basename, children, history }) {\n    let [state, setStateImpl] = React10.useState({\n        action: history.action,\n        location: history.location\n    });\n    let setState = React10.useCallback((newState)=>{\n        React10.startTransition(()=>setStateImpl(newState));\n    }, [\n        setStateImpl\n    ]);\n    React10.useLayoutEffect(()=>history.listen(setState), [\n        history,\n        setState\n    ]);\n    return /* @__PURE__ */ React10.createElement(Router, {\n        basename,\n        children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\nHistoryRouter.displayName = \"unstable_HistoryRouter\";\nvar ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nvar Link = React10.forwardRef(function LinkWithRef({ onClick, discover = \"render\", prefetch = \"none\", relative, reloadDocument, replace: replace2, state, target, to, preventScrollReset, viewTransition, ...rest }, forwardedRef) {\n    let { basename } = React10.useContext(NavigationContext);\n    let isAbsolute = typeof to === \"string\" && ABSOLUTE_URL_REGEX2.test(to);\n    let absoluteHref;\n    let isExternal = false;\n    if (typeof to === \"string\" && isAbsolute) {\n        absoluteHref = to;\n        if (isBrowser) {\n            try {\n                let currentUrl = new URL(window.location.href);\n                let targetUrl = to.startsWith(\"//\") ? new URL(currentUrl.protocol + to) : new URL(to);\n                let path = stripBasename(targetUrl.pathname, basename);\n                if (targetUrl.origin === currentUrl.origin && path != null) {\n                    to = path + targetUrl.search + targetUrl.hash;\n                } else {\n                    isExternal = true;\n                }\n            } catch (e) {\n                warning(false, `<Link to=\"${to}\"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`);\n            }\n        }\n    }\n    let href2 = useHref(to, {\n        relative\n    });\n    let [shouldPrefetch, prefetchRef, prefetchHandlers] = usePrefetchBehavior(prefetch, rest);\n    let internalOnClick = useLinkClickHandler(to, {\n        replace: replace2,\n        state,\n        target,\n        preventScrollReset,\n        relative,\n        viewTransition\n    });\n    function handleClick(event) {\n        if (onClick) onClick(event);\n        if (!event.defaultPrevented) {\n            internalOnClick(event);\n        }\n    }\n    let link = // eslint-disable-next-line jsx-a11y/anchor-has-content\n    /* @__PURE__ */ React10.createElement(\"a\", {\n        ...rest,\n        ...prefetchHandlers,\n        href: absoluteHref || href2,\n        onClick: isExternal || reloadDocument ? onClick : handleClick,\n        ref: mergeRefs(forwardedRef, prefetchRef),\n        target,\n        \"data-discover\": !isAbsolute && discover === \"render\" ? \"true\" : void 0\n    });\n    return shouldPrefetch && !isAbsolute ? /* @__PURE__ */ React10.createElement(React10.Fragment, null, link, /* @__PURE__ */ React10.createElement(PrefetchPageLinks, {\n        page: href2\n    })) : link;\n});\nLink.displayName = \"Link\";\nvar NavLink = React10.forwardRef(function NavLinkWithRef({ \"aria-current\": ariaCurrentProp = \"page\", caseSensitive = false, className: classNameProp = \"\", end = false, style: styleProp, to, viewTransition, children, ...rest }, ref) {\n    let path = useResolvedPath(to, {\n        relative: rest.relative\n    });\n    let location = useLocation();\n    let routerState = React10.useContext(DataRouterStateContext);\n    let { navigator, basename } = React10.useContext(NavigationContext);\n    let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useViewTransitionState(path) && viewTransition === true;\n    let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;\n    let locationPathname = location.pathname;\n    let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;\n    if (!caseSensitive) {\n        locationPathname = locationPathname.toLowerCase();\n        nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;\n        toPathname = toPathname.toLowerCase();\n    }\n    if (nextLocationPathname && basename) {\n        nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;\n    }\n    const endSlashPosition = toPathname !== \"/\" && toPathname.endsWith(\"/\") ? toPathname.length - 1 : toPathname.length;\n    let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === \"/\";\n    let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === \"/\");\n    let renderProps = {\n        isActive,\n        isPending,\n        isTransitioning\n    };\n    let ariaCurrent = isActive ? ariaCurrentProp : void 0;\n    let className;\n    if (typeof classNameProp === \"function\") {\n        className = classNameProp(renderProps);\n    } else {\n        className = [\n            classNameProp,\n            isActive ? \"active\" : null,\n            isPending ? \"pending\" : null,\n            isTransitioning ? \"transitioning\" : null\n        ].filter(Boolean).join(\" \");\n    }\n    let style = typeof styleProp === \"function\" ? styleProp(renderProps) : styleProp;\n    return /* @__PURE__ */ React10.createElement(Link, {\n        ...rest,\n        \"aria-current\": ariaCurrent,\n        className,\n        ref,\n        style,\n        to,\n        viewTransition\n    }, typeof children === \"function\" ? children(renderProps) : children);\n});\nNavLink.displayName = \"NavLink\";\nvar Form = React10.forwardRef(({ discover = \"render\", fetcherKey, navigate, reloadDocument, replace: replace2, state, method = defaultMethod, action, onSubmit, relative, preventScrollReset, viewTransition, ...props }, forwardedRef)=>{\n    let submit = useSubmit();\n    let formAction = useFormAction(action, {\n        relative\n    });\n    let formMethod = method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n    let isAbsolute = typeof action === \"string\" && ABSOLUTE_URL_REGEX2.test(action);\n    let submitHandler = (event)=>{\n        onSubmit && onSubmit(event);\n        if (event.defaultPrevented) return;\n        event.preventDefault();\n        let submitter = event.nativeEvent.submitter;\n        let submitMethod = submitter?.getAttribute(\"formmethod\") || method;\n        submit(submitter || event.currentTarget, {\n            fetcherKey,\n            method: submitMethod,\n            navigate,\n            replace: replace2,\n            state,\n            relative,\n            preventScrollReset,\n            viewTransition\n        });\n    };\n    return /* @__PURE__ */ React10.createElement(\"form\", {\n        ref: forwardedRef,\n        method: formMethod,\n        action: formAction,\n        onSubmit: reloadDocument ? onSubmit : submitHandler,\n        ...props,\n        \"data-discover\": !isAbsolute && discover === \"render\" ? \"true\" : void 0\n    });\n});\nForm.displayName = \"Form\";\nfunction ScrollRestoration({ getKey, storageKey, ...props }) {\n    let remixContext = React10.useContext(FrameworkContext);\n    let { basename } = React10.useContext(NavigationContext);\n    let location = useLocation();\n    let matches = useMatches();\n    useScrollRestoration({\n        getKey,\n        storageKey\n    });\n    let ssrKey = React10.useMemo(()=>{\n        if (!remixContext || !getKey) return null;\n        let userKey = getScrollRestorationKey(location, matches, basename, getKey);\n        return userKey !== location.key ? userKey : null;\n    }, // Nah, we only need this the first time for the SSR render\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []);\n    if (!remixContext || remixContext.isSpaMode) {\n        return null;\n    }\n    let restoreScroll = ((storageKey2, restoreKey)=>{\n        if (!window.history.state || !window.history.state.key) {\n            let key = Math.random().toString(32).slice(2);\n            window.history.replaceState({\n                key\n            }, \"\");\n        }\n        try {\n            let positions = JSON.parse(sessionStorage.getItem(storageKey2) || \"{}\");\n            let storedY = positions[restoreKey || window.history.state.key];\n            if (typeof storedY === \"number\") {\n                window.scrollTo(0, storedY);\n            }\n        } catch (error) {\n            console.error(error);\n            sessionStorage.removeItem(storageKey2);\n        }\n    }).toString();\n    return /* @__PURE__ */ React10.createElement(\"script\", {\n        ...props,\n        suppressHydrationWarning: true,\n        dangerouslySetInnerHTML: {\n            __html: `(${restoreScroll})(${JSON.stringify(storageKey || SCROLL_RESTORATION_STORAGE_KEY)}, ${JSON.stringify(ssrKey)})`\n        }\n    });\n}\nScrollRestoration.displayName = \"ScrollRestoration\";\nfunction getDataRouterConsoleError2(hookName) {\n    return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;\n}\nfunction useDataRouterContext3(hookName) {\n    let ctx = React10.useContext(DataRouterContext);\n    invariant(ctx, getDataRouterConsoleError2(hookName));\n    return ctx;\n}\nfunction useDataRouterState2(hookName) {\n    let state = React10.useContext(DataRouterStateContext);\n    invariant(state, getDataRouterConsoleError2(hookName));\n    return state;\n}\nfunction useLinkClickHandler(to, { target, replace: replaceProp, state, preventScrollReset, relative, viewTransition } = {}) {\n    let navigate = useNavigate();\n    let location = useLocation();\n    let path = useResolvedPath(to, {\n        relative\n    });\n    return React10.useCallback((event)=>{\n        if (shouldProcessLinkClick(event, target)) {\n            event.preventDefault();\n            let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);\n            navigate(to, {\n                replace: replace2,\n                state,\n                preventScrollReset,\n                relative,\n                viewTransition\n            });\n        }\n    }, [\n        location,\n        navigate,\n        path,\n        replaceProp,\n        state,\n        target,\n        to,\n        preventScrollReset,\n        relative,\n        viewTransition\n    ]);\n}\nfunction useSearchParams(defaultInit) {\n    warning(typeof URLSearchParams !== \"undefined\", `You cannot use the \\`useSearchParams\\` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params.`);\n    let defaultSearchParamsRef = React10.useRef(createSearchParams(defaultInit));\n    let hasSetSearchParamsRef = React10.useRef(false);\n    let location = useLocation();\n    let searchParams = React10.useMemo(()=>// Only merge in the defaults if we haven't yet called setSearchParams.\n        // Once we call that we want those to take precedence, otherwise you can't\n        // remove a param with setSearchParams({}) if it has an initial value\n        getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current), [\n        location.search\n    ]);\n    let navigate = useNavigate();\n    let setSearchParams = React10.useCallback((nextInit, navigateOptions)=>{\n        const newSearchParams = createSearchParams(typeof nextInit === \"function\" ? nextInit(searchParams) : nextInit);\n        hasSetSearchParamsRef.current = true;\n        navigate(\"?\" + newSearchParams, navigateOptions);\n    }, [\n        navigate,\n        searchParams\n    ]);\n    return [\n        searchParams,\n        setSearchParams\n    ];\n}\nvar fetcherId = 0;\nvar getUniqueFetcherId = ()=>`__${String(++fetcherId)}__`;\nfunction useSubmit() {\n    let { router } = useDataRouterContext3(\"useSubmit\" /* UseSubmit */ );\n    let { basename } = React10.useContext(NavigationContext);\n    let currentRouteId = useRouteId();\n    return React10.useCallback(async (target, options = {})=>{\n        let { action, method, encType, formData, body } = getFormSubmissionInfo(target, basename);\n        if (options.navigate === false) {\n            let key = options.fetcherKey || getUniqueFetcherId();\n            await router.fetch(key, currentRouteId, options.action || action, {\n                preventScrollReset: options.preventScrollReset,\n                formData,\n                body,\n                formMethod: options.method || method,\n                formEncType: options.encType || encType,\n                flushSync: options.flushSync\n            });\n        } else {\n            await router.navigate(options.action || action, {\n                preventScrollReset: options.preventScrollReset,\n                formData,\n                body,\n                formMethod: options.method || method,\n                formEncType: options.encType || encType,\n                replace: options.replace,\n                state: options.state,\n                fromRouteId: currentRouteId,\n                flushSync: options.flushSync,\n                viewTransition: options.viewTransition\n            });\n        }\n    }, [\n        router,\n        basename,\n        currentRouteId\n    ]);\n}\nfunction useFormAction(action, { relative } = {}) {\n    let { basename } = React10.useContext(NavigationContext);\n    let routeContext = React10.useContext(RouteContext);\n    invariant(routeContext, \"useFormAction must be used inside a RouteContext\");\n    let [match] = routeContext.matches.slice(-1);\n    let path = {\n        ...useResolvedPath(action ? action : \".\", {\n            relative\n        })\n    };\n    let location = useLocation();\n    if (action == null) {\n        path.search = location.search;\n        let params = new URLSearchParams(path.search);\n        let indexValues = params.getAll(\"index\");\n        let hasNakedIndexParam = indexValues.some((v)=>v === \"\");\n        if (hasNakedIndexParam) {\n            params.delete(\"index\");\n            indexValues.filter((v)=>v).forEach((v)=>params.append(\"index\", v));\n            let qs = params.toString();\n            path.search = qs ? `?${qs}` : \"\";\n        }\n    }\n    if ((!action || action === \".\") && match.route.index) {\n        path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n    }\n    if (basename !== \"/\") {\n        path.pathname = path.pathname === \"/\" ? basename : joinPaths([\n            basename,\n            path.pathname\n        ]);\n    }\n    return createPath(path);\n}\nfunction useFetcher({ key } = {}) {\n    let { router } = useDataRouterContext3(\"useFetcher\" /* UseFetcher */ );\n    let state = useDataRouterState2(\"useFetcher\" /* UseFetcher */ );\n    let fetcherData = React10.useContext(FetchersContext);\n    let route = React10.useContext(RouteContext);\n    let routeId = route.matches[route.matches.length - 1]?.route.id;\n    invariant(fetcherData, `useFetcher must be used inside a FetchersContext`);\n    invariant(route, `useFetcher must be used inside a RouteContext`);\n    invariant(routeId != null, `useFetcher can only be used on routes that contain a unique \"id\"`);\n    let defaultKey = React10.useId();\n    let [fetcherKey, setFetcherKey] = React10.useState(key || defaultKey);\n    if (key && key !== fetcherKey) {\n        setFetcherKey(key);\n    }\n    React10.useEffect(()=>{\n        router.getFetcher(fetcherKey);\n        return ()=>router.deleteFetcher(fetcherKey);\n    }, [\n        router,\n        fetcherKey\n    ]);\n    let load = React10.useCallback(async (href2, opts)=>{\n        invariant(routeId, \"No routeId available for fetcher.load()\");\n        await router.fetch(fetcherKey, routeId, href2, opts);\n    }, [\n        fetcherKey,\n        routeId,\n        router\n    ]);\n    let submitImpl = useSubmit();\n    let submit = React10.useCallback(async (target, opts)=>{\n        await submitImpl(target, {\n            ...opts,\n            navigate: false,\n            fetcherKey\n        });\n    }, [\n        fetcherKey,\n        submitImpl\n    ]);\n    let FetcherForm = React10.useMemo(()=>{\n        let FetcherForm2 = React10.forwardRef((props, ref)=>{\n            return /* @__PURE__ */ React10.createElement(Form, {\n                ...props,\n                navigate: false,\n                fetcherKey,\n                ref\n            });\n        });\n        FetcherForm2.displayName = \"fetcher.Form\";\n        return FetcherForm2;\n    }, [\n        fetcherKey\n    ]);\n    let fetcher = state.fetchers.get(fetcherKey) || IDLE_FETCHER;\n    let data2 = fetcherData.get(fetcherKey);\n    let fetcherWithComponents = React10.useMemo(()=>({\n            Form: FetcherForm,\n            submit,\n            load,\n            ...fetcher,\n            data: data2\n        }), [\n        FetcherForm,\n        submit,\n        load,\n        fetcher,\n        data2\n    ]);\n    return fetcherWithComponents;\n}\nfunction useFetchers() {\n    let state = useDataRouterState2(\"useFetchers\" /* UseFetchers */ );\n    return Array.from(state.fetchers.entries()).map(([key, fetcher])=>({\n            ...fetcher,\n            key\n        }));\n}\nvar SCROLL_RESTORATION_STORAGE_KEY = \"react-router-scroll-positions\";\nvar savedScrollPositions = {};\nfunction getScrollRestorationKey(location, matches, basename, getKey) {\n    let key = null;\n    if (getKey) {\n        if (basename !== \"/\") {\n            key = getKey({\n                ...location,\n                pathname: stripBasename(location.pathname, basename) || location.pathname\n            }, matches);\n        } else {\n            key = getKey(location, matches);\n        }\n    }\n    if (key == null) {\n        key = location.key;\n    }\n    return key;\n}\nfunction useScrollRestoration({ getKey, storageKey } = {}) {\n    let { router } = useDataRouterContext3(\"useScrollRestoration\" /* UseScrollRestoration */ );\n    let { restoreScrollPosition, preventScrollReset } = useDataRouterState2(\"useScrollRestoration\" /* UseScrollRestoration */ );\n    let { basename } = React10.useContext(NavigationContext);\n    let location = useLocation();\n    let matches = useMatches();\n    let navigation = useNavigation();\n    React10.useEffect(()=>{\n        window.history.scrollRestoration = \"manual\";\n        return ()=>{\n            window.history.scrollRestoration = \"auto\";\n        };\n    }, []);\n    usePageHide(React10.useCallback(()=>{\n        if (navigation.state === \"idle\") {\n            let key = getScrollRestorationKey(location, matches, basename, getKey);\n            savedScrollPositions[key] = window.scrollY;\n        }\n        try {\n            sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));\n        } catch (error) {\n            warning(false, `Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (${error}).`);\n        }\n        window.history.scrollRestoration = \"auto\";\n    }, [\n        navigation.state,\n        getKey,\n        basename,\n        location,\n        matches,\n        storageKey\n    ]));\n    if (typeof document !== \"undefined\") {\n        React10.useLayoutEffect(()=>{\n            try {\n                let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);\n                if (sessionPositions) {\n                    savedScrollPositions = JSON.parse(sessionPositions);\n                }\n            } catch (e) {}\n        }, [\n            storageKey\n        ]);\n        React10.useLayoutEffect(()=>{\n            let disableScrollRestoration = router?.enableScrollRestoration(savedScrollPositions, ()=>window.scrollY, getKey ? (location2, matches2)=>getScrollRestorationKey(location2, matches2, basename, getKey) : void 0);\n            return ()=>disableScrollRestoration && disableScrollRestoration();\n        }, [\n            router,\n            basename,\n            getKey\n        ]);\n        React10.useLayoutEffect(()=>{\n            if (restoreScrollPosition === false) {\n                return;\n            }\n            if (typeof restoreScrollPosition === \"number\") {\n                window.scrollTo(0, restoreScrollPosition);\n                return;\n            }\n            if (location.hash) {\n                let el = document.getElementById(decodeURIComponent(location.hash.slice(1)));\n                if (el) {\n                    el.scrollIntoView();\n                    return;\n                }\n            }\n            if (preventScrollReset === true) {\n                return;\n            }\n            window.scrollTo(0, 0);\n        }, [\n            location,\n            restoreScrollPosition,\n            preventScrollReset\n        ]);\n    }\n}\nfunction useBeforeUnload(callback, options) {\n    let { capture } = options || {};\n    React10.useEffect(()=>{\n        let opts = capture != null ? {\n            capture\n        } : void 0;\n        window.addEventListener(\"beforeunload\", callback, opts);\n        return ()=>{\n            window.removeEventListener(\"beforeunload\", callback, opts);\n        };\n    }, [\n        callback,\n        capture\n    ]);\n}\nfunction usePageHide(callback, options) {\n    let { capture } = options || {};\n    React10.useEffect(()=>{\n        let opts = capture != null ? {\n            capture\n        } : void 0;\n        window.addEventListener(\"pagehide\", callback, opts);\n        return ()=>{\n            window.removeEventListener(\"pagehide\", callback, opts);\n        };\n    }, [\n        callback,\n        capture\n    ]);\n}\nfunction usePrompt({ when, message }) {\n    let blocker = useBlocker(when);\n    React10.useEffect(()=>{\n        if (blocker.state === \"blocked\") {\n            let proceed = window.confirm(message);\n            if (proceed) {\n                setTimeout(blocker.proceed, 0);\n            } else {\n                blocker.reset();\n            }\n        }\n    }, [\n        blocker,\n        message\n    ]);\n    React10.useEffect(()=>{\n        if (blocker.state === \"blocked\" && !when) {\n            blocker.reset();\n        }\n    }, [\n        blocker,\n        when\n    ]);\n}\nfunction useViewTransitionState(to, opts = {}) {\n    let vtContext = React10.useContext(ViewTransitionContext);\n    invariant(vtContext != null, \"`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?\");\n    let { basename } = useDataRouterContext3(\"useViewTransitionState\" /* useViewTransitionState */ );\n    let path = useResolvedPath(to, {\n        relative: opts.relative\n    });\n    if (!vtContext.isTransitioning) {\n        return false;\n    }\n    let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;\n    let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;\n    return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;\n}\n// lib/dom/server.tsx\nvar React11 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nfunction StaticRouter({ basename, children, location: locationProp = \"/\" }) {\n    if (typeof locationProp === \"string\") {\n        locationProp = parsePath(locationProp);\n    }\n    let action = \"POP\" /* Pop */ ;\n    let location = {\n        pathname: locationProp.pathname || \"/\",\n        search: locationProp.search || \"\",\n        hash: locationProp.hash || \"\",\n        state: locationProp.state != null ? locationProp.state : null,\n        key: locationProp.key || \"default\"\n    };\n    let staticNavigator = getStatelessNavigator();\n    return /* @__PURE__ */ React11.createElement(Router, {\n        basename,\n        children,\n        location,\n        navigationType: action,\n        navigator: staticNavigator,\n        static: true\n    });\n}\nfunction StaticRouterProvider({ context, router, hydrate: hydrate2 = true, nonce }) {\n    invariant(router && context, \"You must provide `router` and `context` to <StaticRouterProvider>\");\n    let dataRouterContext = {\n        router,\n        navigator: getStatelessNavigator(),\n        static: true,\n        staticContext: context,\n        basename: context.basename || \"/\"\n    };\n    let fetchersContext = /* @__PURE__ */ new Map();\n    let hydrateScript = \"\";\n    if (hydrate2 !== false) {\n        let data2 = {\n            loaderData: context.loaderData,\n            actionData: context.actionData,\n            errors: serializeErrors(context.errors)\n        };\n        let json = htmlEscape(JSON.stringify(JSON.stringify(data2)));\n        hydrateScript = `window.__staticRouterHydrationData = JSON.parse(${json});`;\n    }\n    let { state } = dataRouterContext.router;\n    return /* @__PURE__ */ React11.createElement(React11.Fragment, null, /* @__PURE__ */ React11.createElement(DataRouterContext.Provider, {\n        value: dataRouterContext\n    }, /* @__PURE__ */ React11.createElement(DataRouterStateContext.Provider, {\n        value: state\n    }, /* @__PURE__ */ React11.createElement(FetchersContext.Provider, {\n        value: fetchersContext\n    }, /* @__PURE__ */ React11.createElement(ViewTransitionContext.Provider, {\n        value: {\n            isTransitioning: false\n        }\n    }, /* @__PURE__ */ React11.createElement(Router, {\n        basename: dataRouterContext.basename,\n        location: state.location,\n        navigationType: state.historyAction,\n        navigator: dataRouterContext.navigator,\n        static: dataRouterContext.static\n    }, /* @__PURE__ */ React11.createElement(DataRoutes2, {\n        routes: router.routes,\n        future: router.future,\n        state\n    })))))), hydrateScript ? /* @__PURE__ */ React11.createElement(\"script\", {\n        suppressHydrationWarning: true,\n        nonce,\n        dangerouslySetInnerHTML: {\n            __html: hydrateScript\n        }\n    }) : null);\n}\nfunction DataRoutes2({ routes, future, state }) {\n    return useRoutesImpl(routes, void 0, state, future);\n}\nfunction serializeErrors(errors) {\n    if (!errors) return null;\n    let entries = Object.entries(errors);\n    let serialized = {};\n    for (let [key, val] of entries){\n        if (isRouteErrorResponse(val)) {\n            serialized[key] = {\n                ...val,\n                __type: \"RouteErrorResponse\"\n            };\n        } else if (val instanceof Error) {\n            serialized[key] = {\n                message: val.message,\n                __type: \"Error\",\n                // If this is a subclass (i.e., ReferenceError), send up the type so we\n                // can re-create the same type during hydration.\n                ...val.name !== \"Error\" ? {\n                    __subType: val.name\n                } : {}\n            };\n        } else {\n            serialized[key] = val;\n        }\n    }\n    return serialized;\n}\nfunction getStatelessNavigator() {\n    return {\n        createHref,\n        encodeLocation,\n        push (to) {\n            throw new Error(`You cannot use navigator.push() on the server because it is a stateless environment. This error was probably triggered when you did a \\`navigate(${JSON.stringify(to)})\\` somewhere in your app.`);\n        },\n        replace (to) {\n            throw new Error(`You cannot use navigator.replace() on the server because it is a stateless environment. This error was probably triggered when you did a \\`navigate(${JSON.stringify(to)}, { replace: true })\\` somewhere in your app.`);\n        },\n        go (delta) {\n            throw new Error(`You cannot use navigator.go() on the server because it is a stateless environment. This error was probably triggered when you did a \\`navigate(${delta})\\` somewhere in your app.`);\n        },\n        back () {\n            throw new Error(`You cannot use navigator.back() on the server because it is a stateless environment.`);\n        },\n        forward () {\n            throw new Error(`You cannot use navigator.forward() on the server because it is a stateless environment.`);\n        }\n    };\n}\nfunction createStaticHandler2(routes, opts) {\n    return createStaticHandler(routes, {\n        ...opts,\n        mapRouteProperties\n    });\n}\nfunction createStaticRouter(routes, context, opts = {}) {\n    let manifest = {};\n    let dataRoutes = convertRoutesToDataRoutes(routes, mapRouteProperties, void 0, manifest);\n    let matches = context.matches.map((match)=>{\n        let route = manifest[match.route.id] || match.route;\n        return {\n            ...match,\n            route\n        };\n    });\n    let msg = (method)=>`You cannot use router.${method}() on the server because it is a stateless environment`;\n    return {\n        get basename () {\n            return context.basename;\n        },\n        get future () {\n            return {\n                unstable_middleware: false,\n                ...opts?.future\n            };\n        },\n        get state () {\n            return {\n                historyAction: \"POP\" /* Pop */ ,\n                location: context.location,\n                matches,\n                loaderData: context.loaderData,\n                actionData: context.actionData,\n                errors: context.errors,\n                initialized: true,\n                navigation: IDLE_NAVIGATION,\n                restoreScrollPosition: null,\n                preventScrollReset: false,\n                revalidation: \"idle\",\n                fetchers: /* @__PURE__ */ new Map(),\n                blockers: /* @__PURE__ */ new Map()\n            };\n        },\n        get routes () {\n            return dataRoutes;\n        },\n        get window () {\n            return void 0;\n        },\n        initialize () {\n            throw msg(\"initialize\");\n        },\n        subscribe () {\n            throw msg(\"subscribe\");\n        },\n        enableScrollRestoration () {\n            throw msg(\"enableScrollRestoration\");\n        },\n        navigate () {\n            throw msg(\"navigate\");\n        },\n        fetch () {\n            throw msg(\"fetch\");\n        },\n        revalidate () {\n            throw msg(\"revalidate\");\n        },\n        createHref,\n        encodeLocation,\n        getFetcher () {\n            return IDLE_FETCHER;\n        },\n        deleteFetcher () {\n            throw msg(\"deleteFetcher\");\n        },\n        dispose () {\n            throw msg(\"dispose\");\n        },\n        getBlocker () {\n            return IDLE_BLOCKER;\n        },\n        deleteBlocker () {\n            throw msg(\"deleteBlocker\");\n        },\n        patchRoutes () {\n            throw msg(\"patchRoutes\");\n        },\n        _internalFetchControllers: /* @__PURE__ */ new Map(),\n        _internalSetRoutes () {\n            throw msg(\"_internalSetRoutes\");\n        }\n    };\n}\nfunction createHref(to) {\n    return typeof to === \"string\" ? to : createPath(to);\n}\nfunction encodeLocation(to) {\n    let href2 = typeof to === \"string\" ? to : createPath(to);\n    href2 = href2.replace(/ $/, \"%20\");\n    let encoded = ABSOLUTE_URL_REGEX3.test(href2) ? new URL(href2) : new URL(href2, \"http://localhost\");\n    return {\n        pathname: encoded.pathname,\n        search: encoded.search,\n        hash: encoded.hash\n    };\n}\nvar ABSOLUTE_URL_REGEX3 = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nvar ESCAPE_LOOKUP2 = {\n    \"&\": \"\\\\u0026\",\n    \">\": \"\\\\u003e\",\n    \"<\": \"\\\\u003c\",\n    \"\\u2028\": \"\\\\u2028\",\n    \"\\u2029\": \"\\\\u2029\"\n};\nvar ESCAPE_REGEX2 = /[&><\\u2028\\u2029]/g;\nfunction htmlEscape(str) {\n    return str.replace(ESCAPE_REGEX2, (match)=>ESCAPE_LOOKUP2[match]);\n}\n// lib/dom/ssr/server.tsx\nvar React12 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nfunction ServerRouter({ context, url, nonce }) {\n    if (typeof url === \"string\") {\n        url = new URL(url);\n    }\n    let { manifest, routeModules, criticalCss, serverHandoffString } = context;\n    let routes = createServerRoutes(manifest.routes, routeModules, context.future, context.isSpaMode);\n    context.staticHandlerContext.loaderData = {\n        ...context.staticHandlerContext.loaderData\n    };\n    for (let match of context.staticHandlerContext.matches){\n        let routeId = match.route.id;\n        let route = routeModules[routeId];\n        let manifestRoute = context.manifest.routes[routeId];\n        if (route && manifestRoute && shouldHydrateRouteLoader(routeId, route.clientLoader, manifestRoute.hasLoader, context.isSpaMode) && (route.HydrateFallback || !manifestRoute.hasLoader)) {\n            delete context.staticHandlerContext.loaderData[routeId];\n        }\n    }\n    let router = createStaticRouter(routes, context.staticHandlerContext);\n    return /* @__PURE__ */ React12.createElement(React12.Fragment, null, /* @__PURE__ */ React12.createElement(FrameworkContext.Provider, {\n        value: {\n            manifest,\n            routeModules,\n            criticalCss,\n            serverHandoffString,\n            future: context.future,\n            ssr: context.ssr,\n            isSpaMode: context.isSpaMode,\n            routeDiscovery: context.routeDiscovery,\n            serializeError: context.serializeError,\n            renderMeta: context.renderMeta\n        }\n    }, /* @__PURE__ */ React12.createElement(RemixErrorBoundary, {\n        location: router.state.location\n    }, /* @__PURE__ */ React12.createElement(StaticRouterProvider, {\n        router,\n        context: context.staticHandlerContext,\n        hydrate: false\n    }))), context.serverHandoffStream ? /* @__PURE__ */ React12.createElement(React12.Suspense, null, /* @__PURE__ */ React12.createElement(StreamTransfer, {\n        context,\n        identifier: 0,\n        reader: context.serverHandoffStream.getReader(),\n        textDecoder: new TextDecoder(),\n        nonce\n    })) : null);\n}\n// lib/dom/ssr/routes-test-stub.tsx\nvar React13 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nfunction createRoutesStub(routes, unstable_getContext) {\n    return function RoutesTestStub({ initialEntries, initialIndex, hydrationData, future }) {\n        let routerRef = React13.useRef();\n        let remixContextRef = React13.useRef();\n        if (routerRef.current == null) {\n            remixContextRef.current = {\n                future: {\n                    unstable_subResourceIntegrity: future?.unstable_subResourceIntegrity === true,\n                    unstable_middleware: future?.unstable_middleware === true\n                },\n                manifest: {\n                    routes: {},\n                    entry: {\n                        imports: [],\n                        module: \"\"\n                    },\n                    url: \"\",\n                    version: \"\"\n                },\n                routeModules: {},\n                ssr: false,\n                isSpaMode: false,\n                routeDiscovery: {\n                    mode: \"lazy\",\n                    manifestPath: \"/__manifest\"\n                }\n            };\n            let patched = processRoutes(// @ts-expect-error `StubRouteObject` is stricter about `loader`/`action`\n            // types compared to `AgnosticRouteObject`\n            convertRoutesToDataRoutes(routes, (r)=>r), remixContextRef.current.manifest, remixContextRef.current.routeModules);\n            routerRef.current = createMemoryRouter(patched, {\n                unstable_getContext,\n                initialEntries,\n                initialIndex,\n                hydrationData\n            });\n        }\n        return /* @__PURE__ */ React13.createElement(FrameworkContext.Provider, {\n            value: remixContextRef.current\n        }, /* @__PURE__ */ React13.createElement(RouterProvider, {\n            router: routerRef.current\n        }));\n    };\n}\nfunction processRoutes(routes, manifest, routeModules, parentId) {\n    return routes.map((route)=>{\n        if (!route.id) {\n            throw new Error(\"Expected a route.id in @remix-run/testing processRoutes() function\");\n        }\n        let newRoute = {\n            id: route.id,\n            path: route.path,\n            index: route.index,\n            Component: route.Component ? withComponentProps(route.Component) : void 0,\n            HydrateFallback: route.HydrateFallback ? withHydrateFallbackProps(route.HydrateFallback) : void 0,\n            ErrorBoundary: route.ErrorBoundary ? withErrorBoundaryProps(route.ErrorBoundary) : void 0,\n            action: route.action,\n            loader: route.loader,\n            handle: route.handle,\n            shouldRevalidate: route.shouldRevalidate\n        };\n        let entryRoute = {\n            id: route.id,\n            path: route.path,\n            index: route.index,\n            parentId,\n            hasAction: route.action != null,\n            hasLoader: route.loader != null,\n            // When testing routes, you should be stubbing loader/action/middleware,\n            // not trying to re-implement the full loader/clientLoader/SSR/hydration\n            // flow. That is better tested via E2E tests.\n            hasClientAction: false,\n            hasClientLoader: false,\n            hasClientMiddleware: false,\n            hasErrorBoundary: route.ErrorBoundary != null,\n            // any need for these?\n            module: \"build/stub-path-to-module.js\",\n            clientActionModule: void 0,\n            clientLoaderModule: void 0,\n            clientMiddlewareModule: void 0,\n            hydrateFallbackModule: void 0\n        };\n        manifest.routes[newRoute.id] = entryRoute;\n        routeModules[route.id] = {\n            default: newRoute.Component || Outlet,\n            ErrorBoundary: newRoute.ErrorBoundary || void 0,\n            handle: route.handle,\n            links: route.links,\n            meta: route.meta,\n            shouldRevalidate: route.shouldRevalidate\n        };\n        if (route.children) {\n            newRoute.children = processRoutes(route.children, manifest, routeModules, newRoute.id);\n        }\n        return newRoute;\n    });\n}\n// lib/server-runtime/cookies.ts\nvar import_cookie = __webpack_require__(/*! cookie */ \"(ssr)/./node_modules/cookie/dist/index.js\");\n// lib/server-runtime/crypto.ts\nvar encoder = /* @__PURE__ */ new TextEncoder();\nvar sign = async (value, secret)=>{\n    let data2 = encoder.encode(value);\n    let key = await createKey2(secret, [\n        \"sign\"\n    ]);\n    let signature = await crypto.subtle.sign(\"HMAC\", key, data2);\n    let hash = btoa(String.fromCharCode(...new Uint8Array(signature))).replace(/=+$/, \"\");\n    return value + \".\" + hash;\n};\nvar unsign = async (cookie, secret)=>{\n    let index = cookie.lastIndexOf(\".\");\n    let value = cookie.slice(0, index);\n    let hash = cookie.slice(index + 1);\n    let data2 = encoder.encode(value);\n    let key = await createKey2(secret, [\n        \"verify\"\n    ]);\n    let signature = byteStringToUint8Array(atob(hash));\n    let valid = await crypto.subtle.verify(\"HMAC\", key, signature, data2);\n    return valid ? value : false;\n};\nvar createKey2 = async (secret, usages)=>crypto.subtle.importKey(\"raw\", encoder.encode(secret), {\n        name: \"HMAC\",\n        hash: \"SHA-256\"\n    }, false, usages);\nfunction byteStringToUint8Array(byteString) {\n    let array = new Uint8Array(byteString.length);\n    for(let i = 0; i < byteString.length; i++){\n        array[i] = byteString.charCodeAt(i);\n    }\n    return array;\n}\n// lib/server-runtime/cookies.ts\nvar createCookie = (name, cookieOptions = {})=>{\n    let { secrets = [], ...options } = {\n        path: \"/\",\n        sameSite: \"lax\",\n        ...cookieOptions\n    };\n    warnOnceAboutExpiresCookie(name, options.expires);\n    return {\n        get name () {\n            return name;\n        },\n        get isSigned () {\n            return secrets.length > 0;\n        },\n        get expires () {\n            return typeof options.maxAge !== \"undefined\" ? new Date(Date.now() + options.maxAge * 1e3) : options.expires;\n        },\n        async parse (cookieHeader, parseOptions) {\n            if (!cookieHeader) return null;\n            let cookies = (0, import_cookie.parse)(cookieHeader, {\n                ...options,\n                ...parseOptions\n            });\n            if (name in cookies) {\n                let value = cookies[name];\n                if (typeof value === \"string\" && value !== \"\") {\n                    let decoded = await decodeCookieValue(value, secrets);\n                    return decoded;\n                } else {\n                    return \"\";\n                }\n            } else {\n                return null;\n            }\n        },\n        async serialize (value, serializeOptions) {\n            return (0, import_cookie.serialize)(name, value === \"\" ? \"\" : await encodeCookieValue(value, secrets), {\n                ...options,\n                ...serializeOptions\n            });\n        }\n    };\n};\nvar isCookie = (object)=>{\n    return object != null && typeof object.name === \"string\" && typeof object.isSigned === \"boolean\" && typeof object.parse === \"function\" && typeof object.serialize === \"function\";\n};\nasync function encodeCookieValue(value, secrets) {\n    let encoded = encodeData(value);\n    if (secrets.length > 0) {\n        encoded = await sign(encoded, secrets[0]);\n    }\n    return encoded;\n}\nasync function decodeCookieValue(value, secrets) {\n    if (secrets.length > 0) {\n        for (let secret of secrets){\n            let unsignedValue = await unsign(value, secret);\n            if (unsignedValue !== false) {\n                return decodeData(unsignedValue);\n            }\n        }\n        return null;\n    }\n    return decodeData(value);\n}\nfunction encodeData(value) {\n    return btoa(myUnescape(encodeURIComponent(JSON.stringify(value))));\n}\nfunction decodeData(value) {\n    try {\n        return JSON.parse(decodeURIComponent(myEscape(atob(value))));\n    } catch (error) {\n        return {};\n    }\n}\nfunction myEscape(value) {\n    let str = value.toString();\n    let result = \"\";\n    let index = 0;\n    let chr, code;\n    while(index < str.length){\n        chr = str.charAt(index++);\n        if (/[\\w*+\\-./@]/.exec(chr)) {\n            result += chr;\n        } else {\n            code = chr.charCodeAt(0);\n            if (code < 256) {\n                result += \"%\" + hex(code, 2);\n            } else {\n                result += \"%u\" + hex(code, 4).toUpperCase();\n            }\n        }\n    }\n    return result;\n}\nfunction hex(code, length) {\n    let result = code.toString(16);\n    while(result.length < length)result = \"0\" + result;\n    return result;\n}\nfunction myUnescape(value) {\n    let str = value.toString();\n    let result = \"\";\n    let index = 0;\n    let chr, part;\n    while(index < str.length){\n        chr = str.charAt(index++);\n        if (chr === \"%\") {\n            if (str.charAt(index) === \"u\") {\n                part = str.slice(index + 1, index + 5);\n                if (/^[\\da-f]{4}$/i.exec(part)) {\n                    result += String.fromCharCode(parseInt(part, 16));\n                    index += 5;\n                    continue;\n                }\n            } else {\n                part = str.slice(index, index + 2);\n                if (/^[\\da-f]{2}$/i.exec(part)) {\n                    result += String.fromCharCode(parseInt(part, 16));\n                    index += 2;\n                    continue;\n                }\n            }\n        }\n        result += chr;\n    }\n    return result;\n}\nfunction warnOnceAboutExpiresCookie(name, expires) {\n    warnOnce(!expires, `The \"${name}\" cookie has an \"expires\" property set. This will cause the expires value to not be updated when the session is committed. Instead, you should set the expires value when serializing the cookie. You can use \\`commitSession(session, { expires })\\` if using a session storage object, or \\`cookie.serialize(\"value\", { expires })\\` if you're using the cookie directly.`);\n}\n// lib/server-runtime/entry.ts\nfunction createEntryRouteModules(manifest) {\n    return Object.keys(manifest).reduce((memo2, routeId)=>{\n        let route = manifest[routeId];\n        if (route) {\n            memo2[routeId] = route.module;\n        }\n        return memo2;\n    }, {});\n}\n// lib/server-runtime/mode.ts\nvar ServerMode = /* @__PURE__ */ ((ServerMode2)=>{\n    ServerMode2[\"Development\"] = \"development\";\n    ServerMode2[\"Production\"] = \"production\";\n    ServerMode2[\"Test\"] = \"test\";\n    return ServerMode2;\n})(ServerMode || {});\nfunction isServerMode(value) {\n    return value === \"development\" /* Development */  || value === \"production\" /* Production */  || value === \"test\" /* Test */ ;\n}\n// lib/server-runtime/errors.ts\nfunction sanitizeError(error, serverMode) {\n    if (error instanceof Error && serverMode !== \"development\" /* Development */ ) {\n        let sanitized = new Error(\"Unexpected Server Error\");\n        sanitized.stack = void 0;\n        return sanitized;\n    }\n    return error;\n}\nfunction sanitizeErrors(errors, serverMode) {\n    return Object.entries(errors).reduce((acc, [routeId, error])=>{\n        return Object.assign(acc, {\n            [routeId]: sanitizeError(error, serverMode)\n        });\n    }, {});\n}\nfunction serializeError(error, serverMode) {\n    let sanitized = sanitizeError(error, serverMode);\n    return {\n        message: sanitized.message,\n        stack: sanitized.stack\n    };\n}\nfunction serializeErrors2(errors, serverMode) {\n    if (!errors) return null;\n    let entries = Object.entries(errors);\n    let serialized = {};\n    for (let [key, val] of entries){\n        if (isRouteErrorResponse(val)) {\n            serialized[key] = {\n                ...val,\n                __type: \"RouteErrorResponse\"\n            };\n        } else if (val instanceof Error) {\n            let sanitized = sanitizeError(val, serverMode);\n            serialized[key] = {\n                message: sanitized.message,\n                stack: sanitized.stack,\n                __type: \"Error\",\n                // If this is a subclass (i.e., ReferenceError), send up the type so we\n                // can re-create the same type during hydration.  This will only apply\n                // in dev mode since all production errors are sanitized to normal\n                // Error instances\n                ...sanitized.name !== \"Error\" ? {\n                    __subType: sanitized.name\n                } : {}\n            };\n        } else {\n            serialized[key] = val;\n        }\n    }\n    return serialized;\n}\n// lib/server-runtime/routeMatching.ts\nfunction matchServerRoutes(routes, pathname, basename) {\n    let matches = matchRoutes(routes, pathname, basename);\n    if (!matches) return null;\n    return matches.map((match)=>({\n            params: match.params,\n            pathname: match.pathname,\n            route: match.route\n        }));\n}\n// lib/server-runtime/data.ts\nasync function callRouteHandler(handler, args) {\n    let result = await handler({\n        request: stripRoutesParam(stripIndexParam2(args.request)),\n        params: args.params,\n        context: args.context\n    });\n    if (isDataWithResponseInit(result) && result.init && result.init.status && isRedirectStatusCode(result.init.status)) {\n        throw new Response(null, result.init);\n    }\n    return result;\n}\nfunction stripIndexParam2(request) {\n    let url = new URL(request.url);\n    let indexValues = url.searchParams.getAll(\"index\");\n    url.searchParams.delete(\"index\");\n    let indexValuesToKeep = [];\n    for (let indexValue of indexValues){\n        if (indexValue) {\n            indexValuesToKeep.push(indexValue);\n        }\n    }\n    for (let toKeep of indexValuesToKeep){\n        url.searchParams.append(\"index\", toKeep);\n    }\n    let init = {\n        method: request.method,\n        body: request.body,\n        headers: request.headers,\n        signal: request.signal\n    };\n    if (init.body) {\n        init.duplex = \"half\";\n    }\n    return new Request(url.href, init);\n}\nfunction stripRoutesParam(request) {\n    let url = new URL(request.url);\n    url.searchParams.delete(\"_routes\");\n    let init = {\n        method: request.method,\n        body: request.body,\n        headers: request.headers,\n        signal: request.signal\n    };\n    if (init.body) {\n        init.duplex = \"half\";\n    }\n    return new Request(url.href, init);\n}\n// lib/server-runtime/invariant.ts\nfunction invariant3(value, message) {\n    if (value === false || value === null || typeof value === \"undefined\") {\n        console.error(\"The following error is a bug in React Router; please open an issue! https://github.com/remix-run/react-router/issues/new/choose\");\n        throw new Error(message);\n    }\n}\n// lib/server-runtime/dev.ts\nvar globalDevServerHooksKey = \"__reactRouterDevServerHooks\";\nfunction setDevServerHooks(devServerHooks) {\n    globalThis[globalDevServerHooksKey] = devServerHooks;\n}\nfunction getDevServerHooks() {\n    return globalThis[globalDevServerHooksKey];\n}\nfunction getBuildTimeHeader(request, headerName) {\n    if (typeof process !== \"undefined\") {\n        try {\n            if (process.env?.IS_RR_BUILD_REQUEST === \"yes\") {\n                return request.headers.get(headerName);\n            }\n        } catch (e) {}\n    }\n    return null;\n}\n// lib/server-runtime/routes.ts\nfunction groupRoutesByParentId2(manifest) {\n    let routes = {};\n    Object.values(manifest).forEach((route)=>{\n        if (route) {\n            let parentId = route.parentId || \"\";\n            if (!routes[parentId]) {\n                routes[parentId] = [];\n            }\n            routes[parentId].push(route);\n        }\n    });\n    return routes;\n}\nfunction createRoutes(manifest, parentId = \"\", routesByParentId = groupRoutesByParentId2(manifest)) {\n    return (routesByParentId[parentId] || []).map((route)=>({\n            ...route,\n            children: createRoutes(manifest, route.id, routesByParentId)\n        }));\n}\nfunction createStaticHandlerDataRoutes(manifest, future, parentId = \"\", routesByParentId = groupRoutesByParentId2(manifest)) {\n    return (routesByParentId[parentId] || []).map((route)=>{\n        let commonRoute = {\n            // Always include root due to default boundaries\n            hasErrorBoundary: route.id === \"root\" || route.module.ErrorBoundary != null,\n            id: route.id,\n            path: route.path,\n            unstable_middleware: route.module.unstable_middleware,\n            // Need to use RR's version in the param typed here to permit the optional\n            // context even though we know it'll always be provided in remix\n            loader: route.module.loader ? async (args)=>{\n                let preRenderedData = getBuildTimeHeader(args.request, \"X-React-Router-Prerender-Data\");\n                if (preRenderedData != null) {\n                    let encoded = preRenderedData ? decodeURI(preRenderedData) : preRenderedData;\n                    invariant3(encoded, \"Missing prerendered data for route\");\n                    let uint8array = new TextEncoder().encode(encoded);\n                    let stream = new ReadableStream({\n                        start (controller) {\n                            controller.enqueue(uint8array);\n                            controller.close();\n                        }\n                    });\n                    let decoded = await decodeViaTurboStream(stream, global);\n                    let data2 = decoded.value;\n                    if (data2 && SingleFetchRedirectSymbol in data2) {\n                        let result = data2[SingleFetchRedirectSymbol];\n                        let init = {\n                            status: result.status\n                        };\n                        if (result.reload) {\n                            throw redirectDocument(result.redirect, init);\n                        } else if (result.replace) {\n                            throw replace(result.redirect, init);\n                        } else {\n                            throw redirect(result.redirect, init);\n                        }\n                    } else {\n                        invariant3(data2 && route.id in data2, \"Unable to decode prerendered data\");\n                        let result = data2[route.id];\n                        invariant3(\"data\" in result, \"Unable to process prerendered data\");\n                        return result.data;\n                    }\n                }\n                let val = await callRouteHandler(route.module.loader, args);\n                return val;\n            } : void 0,\n            action: route.module.action ? (args)=>callRouteHandler(route.module.action, args) : void 0,\n            handle: route.module.handle\n        };\n        return route.index ? {\n            index: true,\n            ...commonRoute\n        } : {\n            caseSensitive: route.caseSensitive,\n            children: createStaticHandlerDataRoutes(manifest, future, route.id, routesByParentId),\n            ...commonRoute\n        };\n    });\n}\n// lib/server-runtime/markup.ts\nvar ESCAPE_LOOKUP3 = {\n    \"&\": \"\\\\u0026\",\n    \">\": \"\\\\u003e\",\n    \"<\": \"\\\\u003c\",\n    \"\\u2028\": \"\\\\u2028\",\n    \"\\u2029\": \"\\\\u2029\"\n};\nvar ESCAPE_REGEX3 = /[&><\\u2028\\u2029]/g;\nfunction escapeHtml2(html) {\n    return html.replace(ESCAPE_REGEX3, (match)=>ESCAPE_LOOKUP3[match]);\n}\n// lib/server-runtime/serverHandoff.ts\nfunction createServerHandoffString(serverHandoff) {\n    return escapeHtml2(JSON.stringify(serverHandoff));\n}\n// lib/server-runtime/headers.ts\nvar import_set_cookie_parser = __webpack_require__(/*! set-cookie-parser */ \"(ssr)/./node_modules/set-cookie-parser/lib/set-cookie.js\");\nfunction getDocumentHeaders(build, context) {\n    return getDocumentHeadersImpl(context, (m)=>{\n        let route = build.routes[m.route.id];\n        invariant3(route, `Route with id \"${m.route.id}\" not found in build`);\n        return route.module.headers;\n    });\n}\nfunction getDocumentHeadersImpl(context, getRouteHeadersFn) {\n    let boundaryIdx = context.errors ? context.matches.findIndex((m)=>context.errors[m.route.id]) : -1;\n    let matches = boundaryIdx >= 0 ? context.matches.slice(0, boundaryIdx + 1) : context.matches;\n    let errorHeaders;\n    if (boundaryIdx >= 0) {\n        let { actionHeaders, actionData, loaderHeaders, loaderData } = context;\n        context.matches.slice(boundaryIdx).some((match)=>{\n            let id = match.route.id;\n            if (actionHeaders[id] && (!actionData || !actionData.hasOwnProperty(id))) {\n                errorHeaders = actionHeaders[id];\n            } else if (loaderHeaders[id] && !loaderData.hasOwnProperty(id)) {\n                errorHeaders = loaderHeaders[id];\n            }\n            return errorHeaders != null;\n        });\n    }\n    return matches.reduce((parentHeaders, match, idx)=>{\n        let { id } = match.route;\n        let loaderHeaders = context.loaderHeaders[id] || new Headers();\n        let actionHeaders = context.actionHeaders[id] || new Headers();\n        let includeErrorHeaders = errorHeaders != null && idx === matches.length - 1;\n        let includeErrorCookies = includeErrorHeaders && errorHeaders !== loaderHeaders && errorHeaders !== actionHeaders;\n        let headersFn = getRouteHeadersFn(match);\n        if (headersFn == null) {\n            let headers2 = new Headers(parentHeaders);\n            if (includeErrorCookies) {\n                prependCookies(errorHeaders, headers2);\n            }\n            prependCookies(actionHeaders, headers2);\n            prependCookies(loaderHeaders, headers2);\n            return headers2;\n        }\n        let headers = new Headers(typeof headersFn === \"function\" ? headersFn({\n            loaderHeaders,\n            parentHeaders,\n            actionHeaders,\n            errorHeaders: includeErrorHeaders ? errorHeaders : void 0\n        }) : headersFn);\n        if (includeErrorCookies) {\n            prependCookies(errorHeaders, headers);\n        }\n        prependCookies(actionHeaders, headers);\n        prependCookies(loaderHeaders, headers);\n        prependCookies(parentHeaders, headers);\n        return headers;\n    }, new Headers());\n}\nfunction prependCookies(parentHeaders, childHeaders) {\n    let parentSetCookieString = parentHeaders.get(\"Set-Cookie\");\n    if (parentSetCookieString) {\n        let cookies = (0, import_set_cookie_parser.splitCookiesString)(parentSetCookieString);\n        let childCookies = new Set(childHeaders.getSetCookie());\n        cookies.forEach((cookie)=>{\n            if (!childCookies.has(cookie)) {\n                childHeaders.append(\"Set-Cookie\", cookie);\n            }\n        });\n    }\n}\n// lib/server-runtime/single-fetch.ts\nvar SERVER_NO_BODY_STATUS_CODES = /* @__PURE__ */ new Set([\n    ...NO_BODY_STATUS_CODES,\n    304\n]);\nasync function singleFetchAction(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) {\n    try {\n        let respond2 = function(context) {\n            let headers = getDocumentHeaders(build, context);\n            if (isRedirectStatusCode(context.statusCode) && headers.has(\"Location\")) {\n                return generateSingleFetchResponse(request, build, serverMode, {\n                    result: getSingleFetchRedirect(context.statusCode, headers, build.basename),\n                    headers,\n                    status: SINGLE_FETCH_REDIRECT_STATUS\n                });\n            }\n            if (context.errors) {\n                Object.values(context.errors).forEach((err)=>{\n                    if (!isRouteErrorResponse(err) || err.error) {\n                        handleError(err);\n                    }\n                });\n                context.errors = sanitizeErrors(context.errors, serverMode);\n            }\n            let singleFetchResult;\n            if (context.errors) {\n                singleFetchResult = {\n                    error: Object.values(context.errors)[0]\n                };\n            } else {\n                singleFetchResult = {\n                    data: Object.values(context.actionData || {})[0]\n                };\n            }\n            return generateSingleFetchResponse(request, build, serverMode, {\n                result: singleFetchResult,\n                headers,\n                status: context.statusCode\n            });\n        };\n        var respond = respond2;\n        let handlerRequest = new Request(handlerUrl, {\n            method: request.method,\n            body: request.body,\n            headers: request.headers,\n            signal: request.signal,\n            ...request.body ? {\n                duplex: \"half\"\n            } : void 0\n        });\n        let result = await staticHandler.query(handlerRequest, {\n            requestContext: loadContext,\n            skipLoaderErrorBubbling: true,\n            skipRevalidation: true,\n            unstable_respond: respond2\n        });\n        if (!isResponse(result)) {\n            result = respond2(result);\n        }\n        if (isRedirectResponse(result)) {\n            return generateSingleFetchResponse(request, build, serverMode, {\n                result: getSingleFetchRedirect(result.status, result.headers, build.basename),\n                headers: result.headers,\n                status: SINGLE_FETCH_REDIRECT_STATUS\n            });\n        }\n        return result;\n    } catch (error) {\n        handleError(error);\n        return generateSingleFetchResponse(request, build, serverMode, {\n            result: {\n                error\n            },\n            headers: new Headers(),\n            status: 500\n        });\n    }\n}\nasync function singleFetchLoaders(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) {\n    try {\n        let respond2 = function(context) {\n            let headers = getDocumentHeaders(build, context);\n            if (isRedirectStatusCode(context.statusCode) && headers.has(\"Location\")) {\n                return generateSingleFetchResponse(request, build, serverMode, {\n                    result: {\n                        [SingleFetchRedirectSymbol]: getSingleFetchRedirect(context.statusCode, headers, build.basename)\n                    },\n                    headers,\n                    status: SINGLE_FETCH_REDIRECT_STATUS\n                });\n            }\n            if (context.errors) {\n                Object.values(context.errors).forEach((err)=>{\n                    if (!isRouteErrorResponse(err) || err.error) {\n                        handleError(err);\n                    }\n                });\n                context.errors = sanitizeErrors(context.errors, serverMode);\n            }\n            let results = {};\n            let loadedMatches = new Set(context.matches.filter((m)=>loadRouteIds ? loadRouteIds.has(m.route.id) : m.route.loader != null).map((m)=>m.route.id));\n            if (context.errors) {\n                for (let [id, error] of Object.entries(context.errors)){\n                    results[id] = {\n                        error\n                    };\n                }\n            }\n            for (let [id, data2] of Object.entries(context.loaderData)){\n                if (!(id in results) && loadedMatches.has(id)) {\n                    results[id] = {\n                        data: data2\n                    };\n                }\n            }\n            return generateSingleFetchResponse(request, build, serverMode, {\n                result: results,\n                headers,\n                status: context.statusCode\n            });\n        };\n        var respond = respond2;\n        let handlerRequest = new Request(handlerUrl, {\n            headers: request.headers,\n            signal: request.signal\n        });\n        let routesParam = new URL(request.url).searchParams.get(\"_routes\");\n        let loadRouteIds = routesParam ? new Set(routesParam.split(\",\")) : null;\n        let result = await staticHandler.query(handlerRequest, {\n            requestContext: loadContext,\n            filterMatchesToLoad: (m)=>!loadRouteIds || loadRouteIds.has(m.route.id),\n            skipLoaderErrorBubbling: true,\n            unstable_respond: respond2\n        });\n        if (!isResponse(result)) {\n            result = respond2(result);\n        }\n        if (isRedirectResponse(result)) {\n            return generateSingleFetchResponse(request, build, serverMode, {\n                result: {\n                    [SingleFetchRedirectSymbol]: getSingleFetchRedirect(result.status, result.headers, build.basename)\n                },\n                headers: result.headers,\n                status: SINGLE_FETCH_REDIRECT_STATUS\n            });\n        }\n        return result;\n    } catch (error) {\n        handleError(error);\n        return generateSingleFetchResponse(request, build, serverMode, {\n            result: {\n                root: {\n                    error\n                }\n            },\n            headers: new Headers(),\n            status: 500\n        });\n    }\n}\nfunction generateSingleFetchResponse(request, build, serverMode, { result, headers, status }) {\n    let resultHeaders = new Headers(headers);\n    resultHeaders.set(\"X-Remix-Response\", \"yes\");\n    if (SERVER_NO_BODY_STATUS_CODES.has(status)) {\n        return new Response(null, {\n            status,\n            headers: resultHeaders\n        });\n    }\n    resultHeaders.set(\"Content-Type\", \"text/x-script\");\n    return new Response(encodeViaTurboStream(result, request.signal, build.entry.module.streamTimeout, serverMode), {\n        status: status || 200,\n        headers: resultHeaders\n    });\n}\nfunction getSingleFetchRedirect(status, headers, basename) {\n    let redirect2 = headers.get(\"Location\");\n    if (basename) {\n        redirect2 = stripBasename(redirect2, basename) || redirect2;\n    }\n    return {\n        redirect: redirect2,\n        status,\n        revalidate: // Technically X-Remix-Revalidate isn't needed here - that was an implementation\n        // detail of ?_data requests as our way to tell the front end to revalidate when\n        // we didn't have a response body to include that information in.\n        // With single fetch, we tell the front end via this revalidate boolean field.\n        // However, we're respecting it for now because it may be something folks have\n        // used in their own responses\n        // TODO(v3): Consider removing or making this official public API\n        headers.has(\"X-Remix-Revalidate\") || headers.has(\"Set-Cookie\"),\n        reload: headers.has(\"X-Remix-Reload-Document\"),\n        replace: headers.has(\"X-Remix-Replace\")\n    };\n}\nfunction encodeViaTurboStream(data2, requestSignal, streamTimeout, serverMode) {\n    let controller = new AbortController();\n    let timeoutId = setTimeout(()=>controller.abort(new Error(\"Server Timeout\")), typeof streamTimeout === \"number\" ? streamTimeout : 4950);\n    requestSignal.addEventListener(\"abort\", ()=>clearTimeout(timeoutId));\n    return encode(data2, {\n        signal: controller.signal,\n        plugins: [\n            (value)=>{\n                if (value instanceof Error) {\n                    let { name, message, stack } = serverMode === \"production\" /* Production */  ? sanitizeError(value, serverMode) : value;\n                    return [\n                        \"SanitizedError\",\n                        name,\n                        message,\n                        stack\n                    ];\n                }\n                if (value instanceof ErrorResponseImpl) {\n                    let { data: data3, status, statusText } = value;\n                    return [\n                        \"ErrorResponse\",\n                        data3,\n                        status,\n                        statusText\n                    ];\n                }\n                if (value && typeof value === \"object\" && SingleFetchRedirectSymbol in value) {\n                    return [\n                        \"SingleFetchRedirect\",\n                        value[SingleFetchRedirectSymbol]\n                    ];\n                }\n            }\n        ],\n        postPlugins: [\n            (value)=>{\n                if (!value) return;\n                if (typeof value !== \"object\") return;\n                return [\n                    \"SingleFetchClassInstance\",\n                    Object.fromEntries(Object.entries(value))\n                ];\n            },\n            ()=>[\n                    \"SingleFetchFallback\"\n                ]\n        ]\n    });\n}\n// lib/server-runtime/server.ts\nfunction derive(build, mode) {\n    let routes = createRoutes(build.routes);\n    let dataRoutes = createStaticHandlerDataRoutes(build.routes, build.future);\n    let serverMode = isServerMode(mode) ? mode : \"production\" /* Production */ ;\n    let staticHandler = createStaticHandler(dataRoutes, {\n        basename: build.basename\n    });\n    let errorHandler = build.entry.module.handleError || ((error, { request })=>{\n        if (serverMode !== \"test\" /* Test */  && !request.signal.aborted) {\n            console.error(// @ts-expect-error This is \"private\" from users but intended for internal use\n            isRouteErrorResponse(error) && error.error ? error.error : error);\n        }\n    });\n    return {\n        routes,\n        dataRoutes,\n        serverMode,\n        staticHandler,\n        errorHandler\n    };\n}\nvar createRequestHandler = (build, mode)=>{\n    let _build;\n    let routes;\n    let serverMode;\n    let staticHandler;\n    let errorHandler;\n    return async function requestHandler(request, initialContext) {\n        _build = typeof build === \"function\" ? await build() : build;\n        if (typeof build === \"function\") {\n            let derived = derive(_build, mode);\n            routes = derived.routes;\n            serverMode = derived.serverMode;\n            staticHandler = derived.staticHandler;\n            errorHandler = derived.errorHandler;\n        } else if (!routes || !serverMode || !staticHandler || !errorHandler) {\n            let derived = derive(_build, mode);\n            routes = derived.routes;\n            serverMode = derived.serverMode;\n            staticHandler = derived.staticHandler;\n            errorHandler = derived.errorHandler;\n        }\n        let params = {};\n        let loadContext;\n        let handleError = (error)=>{\n            if (mode === \"development\" /* Development */ ) {\n                getDevServerHooks()?.processRequestError?.(error);\n            }\n            errorHandler(error, {\n                context: loadContext,\n                params,\n                request\n            });\n        };\n        if (_build.future.unstable_middleware) {\n            if (initialContext == null) {\n                loadContext = new unstable_RouterContextProvider();\n            } else {\n                try {\n                    loadContext = new unstable_RouterContextProvider(initialContext);\n                } catch (e) {\n                    let error = new Error(`Unable to create initial \\`unstable_RouterContextProvider\\` instance. Please confirm you are returning an instance of \\`Map<unstable_routerContext, unknown>\\` from your \\`getLoadContext\\` function.\n\nError: ${e instanceof Error ? e.toString() : e}`);\n                    handleError(error);\n                    return returnLastResortErrorResponse(error, serverMode);\n                }\n            }\n        } else {\n            loadContext = initialContext || {};\n        }\n        let url = new URL(request.url);\n        let normalizedBasename = _build.basename || \"/\";\n        let normalizedPath = url.pathname;\n        if (stripBasename(normalizedPath, normalizedBasename) === \"/_root.data\") {\n            normalizedPath = normalizedBasename;\n        } else if (normalizedPath.endsWith(\".data\")) {\n            normalizedPath = normalizedPath.replace(/\\.data$/, \"\");\n        }\n        if (stripBasename(normalizedPath, normalizedBasename) !== \"/\" && normalizedPath.endsWith(\"/\")) {\n            normalizedPath = normalizedPath.slice(0, -1);\n        }\n        let isSpaMode = getBuildTimeHeader(request, \"X-React-Router-SPA-Mode\") === \"yes\";\n        if (!_build.ssr) {\n            if (_build.prerender.length === 0) {\n                isSpaMode = true;\n            } else if (!_build.prerender.includes(normalizedPath) && !_build.prerender.includes(normalizedPath + \"/\")) {\n                if (url.pathname.endsWith(\".data\")) {\n                    errorHandler(new ErrorResponseImpl(404, \"Not Found\", `Refusing to SSR the path \\`${normalizedPath}\\` because \\`ssr:false\\` is set and the path is not included in the \\`prerender\\` config, so in production the path will be a 404.`), {\n                        context: loadContext,\n                        params,\n                        request\n                    });\n                    return new Response(\"Not Found\", {\n                        status: 404,\n                        statusText: \"Not Found\"\n                    });\n                } else {\n                    isSpaMode = true;\n                }\n            }\n        }\n        let manifestUrl = getManifestPath(_build.routeDiscovery.manifestPath, normalizedBasename);\n        if (url.pathname === manifestUrl) {\n            try {\n                let res = await handleManifestRequest(_build, routes, url);\n                return res;\n            } catch (e) {\n                handleError(e);\n                return new Response(\"Unknown Server Error\", {\n                    status: 500\n                });\n            }\n        }\n        let matches = matchServerRoutes(routes, normalizedPath, _build.basename);\n        if (matches && matches.length > 0) {\n            Object.assign(params, matches[0].params);\n        }\n        let response;\n        if (url.pathname.endsWith(\".data\")) {\n            let handlerUrl = new URL(request.url);\n            handlerUrl.pathname = normalizedPath;\n            let singleFetchMatches = matchServerRoutes(routes, handlerUrl.pathname, _build.basename);\n            response = await handleSingleFetchRequest(serverMode, _build, staticHandler, request, handlerUrl, loadContext, handleError);\n            if (_build.entry.module.handleDataRequest) {\n                response = await _build.entry.module.handleDataRequest(response, {\n                    context: loadContext,\n                    params: singleFetchMatches ? singleFetchMatches[0].params : {},\n                    request\n                });\n                if (isRedirectResponse(response)) {\n                    let result = getSingleFetchRedirect(response.status, response.headers, _build.basename);\n                    if (request.method === \"GET\") {\n                        result = {\n                            [SingleFetchRedirectSymbol]: result\n                        };\n                    }\n                    let headers = new Headers(response.headers);\n                    headers.set(\"Content-Type\", \"text/x-script\");\n                    return new Response(encodeViaTurboStream(result, request.signal, _build.entry.module.streamTimeout, serverMode), {\n                        status: SINGLE_FETCH_REDIRECT_STATUS,\n                        headers\n                    });\n                }\n            }\n        } else if (!isSpaMode && matches && matches[matches.length - 1].route.module.default == null && matches[matches.length - 1].route.module.ErrorBoundary == null) {\n            response = await handleResourceRequest(serverMode, _build, staticHandler, matches.slice(-1)[0].route.id, request, loadContext, handleError);\n        } else {\n            let { pathname } = url;\n            let criticalCss = void 0;\n            if (_build.unstable_getCriticalCss) {\n                criticalCss = await _build.unstable_getCriticalCss({\n                    pathname\n                });\n            } else if (mode === \"development\" /* Development */  && getDevServerHooks()?.getCriticalCss) {\n                criticalCss = await getDevServerHooks()?.getCriticalCss?.(pathname);\n            }\n            response = await handleDocumentRequest(serverMode, _build, staticHandler, request, loadContext, handleError, isSpaMode, criticalCss);\n        }\n        if (request.method === \"HEAD\") {\n            return new Response(null, {\n                headers: response.headers,\n                status: response.status,\n                statusText: response.statusText\n            });\n        }\n        return response;\n    };\n};\nasync function handleManifestRequest(build, routes, url) {\n    if (build.assets.version !== url.searchParams.get(\"version\")) {\n        return new Response(null, {\n            status: 204,\n            headers: {\n                \"X-Remix-Reload-Document\": \"true\"\n            }\n        });\n    }\n    let patches = {};\n    if (url.searchParams.has(\"p\")) {\n        let paths = /* @__PURE__ */ new Set();\n        url.searchParams.getAll(\"p\").forEach((path)=>{\n            if (!path.startsWith(\"/\")) {\n                path = `/${path}`;\n            }\n            let segments = path.split(\"/\").slice(1);\n            segments.forEach((_, i)=>{\n                let partialPath = segments.slice(0, i + 1).join(\"/\");\n                paths.add(`/${partialPath}`);\n            });\n        });\n        for (let path of paths){\n            let matches = matchServerRoutes(routes, path, build.basename);\n            if (matches) {\n                for (let match of matches){\n                    let routeId = match.route.id;\n                    let route = build.assets.routes[routeId];\n                    if (route) {\n                        patches[routeId] = route;\n                    }\n                }\n            }\n        }\n        return Response.json(patches, {\n            headers: {\n                \"Cache-Control\": \"public, max-age=31536000, immutable\"\n            }\n        });\n    }\n    return new Response(\"Invalid Request\", {\n        status: 400\n    });\n}\nasync function handleSingleFetchRequest(serverMode, build, staticHandler, request, handlerUrl, loadContext, handleError) {\n    let response = request.method !== \"GET\" ? await singleFetchAction(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) : await singleFetchLoaders(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError);\n    return response;\n}\nasync function handleDocumentRequest(serverMode, build, staticHandler, request, loadContext, handleError, isSpaMode, criticalCss) {\n    try {\n        let response = await staticHandler.query(request, {\n            requestContext: loadContext,\n            unstable_respond: build.future.unstable_middleware ? (ctx)=>renderHtml(ctx, isSpaMode) : void 0\n        });\n        return isResponse(response) ? response : renderHtml(response, isSpaMode);\n    } catch (error) {\n        handleError(error);\n        return new Response(null, {\n            status: 500\n        });\n    }\n    async function renderHtml(context, isSpaMode2) {\n        if (isResponse(context)) {\n            return context;\n        }\n        let headers = getDocumentHeaders(build, context);\n        if (SERVER_NO_BODY_STATUS_CODES.has(context.statusCode)) {\n            return new Response(null, {\n                status: context.statusCode,\n                headers\n            });\n        }\n        if (context.errors) {\n            Object.values(context.errors).forEach((err)=>{\n                if (!isRouteErrorResponse(err) || err.error) {\n                    handleError(err);\n                }\n            });\n            context.errors = sanitizeErrors(context.errors, serverMode);\n        }\n        let state = {\n            loaderData: context.loaderData,\n            actionData: context.actionData,\n            errors: serializeErrors2(context.errors, serverMode)\n        };\n        let baseServerHandoff = {\n            basename: build.basename,\n            future: build.future,\n            routeDiscovery: build.routeDiscovery,\n            ssr: build.ssr,\n            isSpaMode: isSpaMode2\n        };\n        let entryContext = {\n            manifest: build.assets,\n            routeModules: createEntryRouteModules(build.routes),\n            staticHandlerContext: context,\n            criticalCss,\n            serverHandoffString: createServerHandoffString({\n                ...baseServerHandoff,\n                criticalCss\n            }),\n            serverHandoffStream: encodeViaTurboStream(state, request.signal, build.entry.module.streamTimeout, serverMode),\n            renderMeta: {},\n            future: build.future,\n            ssr: build.ssr,\n            routeDiscovery: build.routeDiscovery,\n            isSpaMode: isSpaMode2,\n            serializeError: (err)=>serializeError(err, serverMode)\n        };\n        let handleDocumentRequestFunction = build.entry.module.default;\n        try {\n            return await handleDocumentRequestFunction(request, context.statusCode, headers, entryContext, loadContext);\n        } catch (error) {\n            handleError(error);\n            let errorForSecondRender = error;\n            if (isResponse(error)) {\n                try {\n                    let data2 = await unwrapResponse(error);\n                    errorForSecondRender = new ErrorResponseImpl(error.status, error.statusText, data2);\n                } catch (e) {}\n            }\n            context = getStaticContextFromError(staticHandler.dataRoutes, context, errorForSecondRender);\n            if (context.errors) {\n                context.errors = sanitizeErrors(context.errors, serverMode);\n            }\n            let state2 = {\n                loaderData: context.loaderData,\n                actionData: context.actionData,\n                errors: serializeErrors2(context.errors, serverMode)\n            };\n            entryContext = {\n                ...entryContext,\n                staticHandlerContext: context,\n                serverHandoffString: createServerHandoffString(baseServerHandoff),\n                serverHandoffStream: encodeViaTurboStream(state2, request.signal, build.entry.module.streamTimeout, serverMode),\n                renderMeta: {}\n            };\n            try {\n                return await handleDocumentRequestFunction(request, context.statusCode, headers, entryContext, loadContext);\n            } catch (error2) {\n                handleError(error2);\n                return returnLastResortErrorResponse(error2, serverMode);\n            }\n        }\n    }\n}\nasync function handleResourceRequest(serverMode, build, staticHandler, routeId, request, loadContext, handleError) {\n    try {\n        let response = await staticHandler.queryRoute(request, {\n            routeId,\n            requestContext: loadContext,\n            unstable_respond: build.future.unstable_middleware ? (ctx)=>ctx : void 0\n        });\n        if (isResponse(response)) {\n            return response;\n        }\n        if (typeof response === \"string\") {\n            return new Response(response);\n        }\n        return Response.json(response);\n    } catch (error) {\n        if (isResponse(error)) {\n            error.headers.set(\"X-Remix-Catch\", \"yes\");\n            return error;\n        }\n        if (isRouteErrorResponse(error)) {\n            if (error) {\n                handleError(error);\n            }\n            return errorResponseToJson(error, serverMode);\n        }\n        if (error instanceof Error && error.message === \"Expected a response from queryRoute\") {\n            let newError = new Error(\"Expected a Response to be returned from resource route handler\");\n            handleError(newError);\n            return returnLastResortErrorResponse(newError, serverMode);\n        }\n        handleError(error);\n        return returnLastResortErrorResponse(error, serverMode);\n    }\n}\nfunction errorResponseToJson(errorResponse, serverMode) {\n    return Response.json(serializeError(// @ts-expect-error This is \"private\" from users but intended for internal use\n    errorResponse.error || new Error(\"Unexpected Server Error\"), serverMode), {\n        status: errorResponse.status,\n        statusText: errorResponse.statusText,\n        headers: {\n            \"X-Remix-Error\": \"yes\"\n        }\n    });\n}\nfunction returnLastResortErrorResponse(error, serverMode) {\n    let message = \"Unexpected Server Error\";\n    if (serverMode !== \"production\" /* Production */ ) {\n        message += `\n\n${String(error)}`;\n    }\n    return new Response(message, {\n        status: 500,\n        headers: {\n            \"Content-Type\": \"text/plain\"\n        }\n    });\n}\nfunction unwrapResponse(response) {\n    let contentType = response.headers.get(\"Content-Type\");\n    return contentType && /\\bapplication\\/json\\b/.test(contentType) ? response.body == null ? null : response.json() : response.text();\n}\n// lib/server-runtime/sessions.ts\nfunction flash(name) {\n    return `__flash_${name}__`;\n}\nvar createSession = (initialData = {}, id = \"\")=>{\n    let map = new Map(Object.entries(initialData));\n    return {\n        get id () {\n            return id;\n        },\n        get data () {\n            return Object.fromEntries(map);\n        },\n        has (name) {\n            return map.has(name) || map.has(flash(name));\n        },\n        get (name) {\n            if (map.has(name)) return map.get(name);\n            let flashName = flash(name);\n            if (map.has(flashName)) {\n                let value = map.get(flashName);\n                map.delete(flashName);\n                return value;\n            }\n            return void 0;\n        },\n        set (name, value) {\n            map.set(name, value);\n        },\n        flash (name, value) {\n            map.set(flash(name), value);\n        },\n        unset (name) {\n            map.delete(name);\n        }\n    };\n};\nvar isSession = (object)=>{\n    return object != null && typeof object.id === \"string\" && typeof object.data !== \"undefined\" && typeof object.has === \"function\" && typeof object.get === \"function\" && typeof object.set === \"function\" && typeof object.flash === \"function\" && typeof object.unset === \"function\";\n};\nfunction createSessionStorage({ cookie: cookieArg, createData, readData, updateData, deleteData }) {\n    let cookie = isCookie(cookieArg) ? cookieArg : createCookie(cookieArg?.name || \"__session\", cookieArg);\n    warnOnceAboutSigningSessionCookie(cookie);\n    return {\n        async getSession (cookieHeader, options) {\n            let id = cookieHeader && await cookie.parse(cookieHeader, options);\n            let data2 = id && await readData(id);\n            return createSession(data2 || {}, id || \"\");\n        },\n        async commitSession (session, options) {\n            let { id, data: data2 } = session;\n            let expires = options?.maxAge != null ? new Date(Date.now() + options.maxAge * 1e3) : options?.expires != null ? options.expires : cookie.expires;\n            if (id) {\n                await updateData(id, data2, expires);\n            } else {\n                id = await createData(data2, expires);\n            }\n            return cookie.serialize(id, options);\n        },\n        async destroySession (session, options) {\n            await deleteData(session.id);\n            return cookie.serialize(\"\", {\n                ...options,\n                maxAge: void 0,\n                expires: /* @__PURE__ */ new Date(0)\n            });\n        }\n    };\n}\nfunction warnOnceAboutSigningSessionCookie(cookie) {\n    warnOnce(cookie.isSigned, `The \"${cookie.name}\" cookie is not signed, but session cookies should be signed to prevent tampering on the client before they are sent back to the server. See https://reactrouter.com/explanation/sessions-and-cookies#signing-cookies for more information.`);\n}\n// lib/server-runtime/sessions/cookieStorage.ts\nfunction createCookieSessionStorage({ cookie: cookieArg } = {}) {\n    let cookie = isCookie(cookieArg) ? cookieArg : createCookie(cookieArg?.name || \"__session\", cookieArg);\n    warnOnceAboutSigningSessionCookie(cookie);\n    return {\n        async getSession (cookieHeader, options) {\n            return createSession(cookieHeader && await cookie.parse(cookieHeader, options) || {});\n        },\n        async commitSession (session, options) {\n            let serializedCookie = await cookie.serialize(session.data, options);\n            if (serializedCookie.length > 4096) {\n                throw new Error(\"Cookie length will exceed browser maximum. Length: \" + serializedCookie.length);\n            }\n            return serializedCookie;\n        },\n        async destroySession (_session, options) {\n            return cookie.serialize(\"\", {\n                ...options,\n                maxAge: void 0,\n                expires: /* @__PURE__ */ new Date(0)\n            });\n        }\n    };\n}\n// lib/server-runtime/sessions/memoryStorage.ts\nfunction createMemorySessionStorage({ cookie } = {}) {\n    let map = /* @__PURE__ */ new Map();\n    return createSessionStorage({\n        cookie,\n        async createData (data2, expires) {\n            let id = Math.random().toString(36).substring(2, 10);\n            map.set(id, {\n                data: data2,\n                expires\n            });\n            return id;\n        },\n        async readData (id) {\n            if (map.has(id)) {\n                let { data: data2, expires } = map.get(id);\n                if (!expires || expires > /* @__PURE__ */ new Date()) {\n                    return data2;\n                }\n                if (expires) map.delete(id);\n            }\n            return null;\n        },\n        async updateData (id, data2, expires) {\n            map.set(id, {\n                data: data2,\n                expires\n            });\n        },\n        async deleteData (id) {\n            map.delete(id);\n        }\n    });\n}\n// lib/href.ts\nfunction href(path, ...args) {\n    let params = args[0];\n    return path.split(\"/\").map((segment)=>{\n        if (segment === \"*\") {\n            return params ? params[\"*\"] : void 0;\n        }\n        const match = segment.match(/^:([\\w-]+)(\\?)?/);\n        if (!match) return segment;\n        const param = match[1];\n        const value = params ? params[param] : void 0;\n        const isRequired = match[2] === void 0;\n        if (isRequired && value === void 0) {\n            throw Error(`Path '${path}' requires param '${param}' but it was not provided`);\n        }\n        return value;\n    }).filter((segment)=>segment !== void 0).join(\"/\");\n}\n// lib/dom/ssr/errors.ts\nfunction deserializeErrors2(errors) {\n    if (!errors) return null;\n    let entries = Object.entries(errors);\n    let serialized = {};\n    for (let [key, val] of entries){\n        if (val && val.__type === \"RouteErrorResponse\") {\n            serialized[key] = new ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);\n        } else if (val && val.__type === \"Error\") {\n            if (val.__subType) {\n                let ErrorConstructor = window[val.__subType];\n                if (typeof ErrorConstructor === \"function\") {\n                    try {\n                        let error = new ErrorConstructor(val.message);\n                        error.stack = val.stack;\n                        serialized[key] = error;\n                    } catch (e) {}\n                }\n            }\n            if (serialized[key] == null) {\n                let error = new Error(val.message);\n                error.stack = val.stack;\n                serialized[key] = error;\n            }\n        } else {\n            serialized[key] = val;\n        }\n    }\n    return serialized;\n}\n// lib/dom/ssr/hydration.tsx\nfunction getHydrationData(state, routes, getRouteInfo, location, basename, isSpaMode) {\n    let hydrationData = {\n        ...state,\n        loaderData: {\n            ...state.loaderData\n        }\n    };\n    let initialMatches = matchRoutes(routes, location, basename);\n    if (initialMatches) {\n        for (let match of initialMatches){\n            let routeId = match.route.id;\n            let routeInfo = getRouteInfo(routeId);\n            if (shouldHydrateRouteLoader(routeId, routeInfo.clientLoader, routeInfo.hasLoader, isSpaMode) && (routeInfo.hasHydrateFallback || !routeInfo.hasLoader)) {\n                delete hydrationData.loaderData[routeId];\n            } else if (!routeInfo.hasLoader) {\n                hydrationData.loaderData[routeId] = null;\n            }\n        }\n    }\n    return hydrationData;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2Rpc3QvZGV2ZWxvcG1lbnQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7OztDQVNDLEdBQ1k7QUFDYixJQUFJQSxXQUFXQyxPQUFPQyxNQUFNO0FBQzVCLElBQUlDLFlBQVlGLE9BQU9HLGNBQWM7QUFDckMsSUFBSUMsbUJBQW1CSixPQUFPSyx3QkFBd0I7QUFDdEQsSUFBSUMsb0JBQW9CTixPQUFPTyxtQkFBbUI7QUFDbEQsSUFBSUMsZUFBZVIsT0FBT1MsY0FBYztBQUN4QyxJQUFJQyxlQUFlVixPQUFPVyxTQUFTLENBQUNDLGNBQWM7QUFDbEQsSUFBSUMsY0FBYyxDQUFDQztJQUNqQixNQUFNQyxVQUFVRDtBQUNsQjtBQUNBLElBQUlFLFdBQVcsQ0FBQ0MsUUFBUUM7SUFDdEIsSUFBSyxJQUFJQyxRQUFRRCxJQUNmaEIsVUFBVWUsUUFBUUUsTUFBTTtRQUFFQyxLQUFLRixHQUFHLENBQUNDLEtBQUs7UUFBRUUsWUFBWTtJQUFLO0FBQy9EO0FBQ0EsSUFBSUMsY0FBYyxDQUFDQyxJQUFJQyxNQUFNQyxRQUFRQztJQUNuQyxJQUFJRixRQUFRLE9BQU9BLFNBQVMsWUFBWSxPQUFPQSxTQUFTLFlBQVk7UUFDbEUsS0FBSyxJQUFJRyxPQUFPckIsa0JBQWtCa0IsTUFDaEMsSUFBSSxDQUFDZCxhQUFha0IsSUFBSSxDQUFDTCxJQUFJSSxRQUFRQSxRQUFRRixRQUN6Q3ZCLFVBQVVxQixJQUFJSSxLQUFLO1lBQUVQLEtBQUssSUFBTUksSUFBSSxDQUFDRyxJQUFJO1lBQUVOLFlBQVksQ0FBRUssQ0FBQUEsT0FBT3RCLGlCQUFpQm9CLE1BQU1HLElBQUcsS0FBTUQsS0FBS0wsVUFBVTtRQUFDO0lBQ3RIO0lBQ0EsT0FBT0U7QUFDVDtBQUNBLElBQUlNLFVBQVUsQ0FBQ0MsS0FBS0MsWUFBWWQsU0FBWUEsQ0FBQUEsU0FBU2EsT0FBTyxPQUFPL0IsU0FBU1MsYUFBYXNCLFFBQVEsQ0FBQyxHQUFH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QUFRLEVBQUV3RyxRQUFRLEVBQUV3eEIsU0FBUztJQUNsRixJQUFJOW1CLGdCQUFnQjtRQUNsQixHQUFHN1IsS0FBSztRQUNSaUksWUFBWTtZQUFFLEdBQUdqSSxNQUFNaUksVUFBVTtRQUFDO0lBQ3BDO0lBQ0EsSUFBSTZKLGlCQUFpQnhWLFlBQVlpSyxRQUFRNUYsVUFBVXdHO0lBQ25ELElBQUkySyxnQkFBZ0I7UUFDbEIsS0FBSyxJQUFJOUosU0FBUzhKLGVBQWdCO1lBQ2hDLElBQUl5SCxVQUFVdlIsTUFBTTNCLEtBQUssQ0FBQ1EsRUFBRTtZQUM1QixJQUFJMDlDLFlBQVk3ZixhQUFhbnJCO1lBQzdCLElBQUlwZix5QkFDRm9mLFNBQ0FnckMsVUFBVXRhLFlBQVksRUFDdEJzYSxVQUFVanBCLFNBQVMsRUFDbkIzQyxjQUNJNHJCLENBQUFBLFVBQVVDLGtCQUFrQixJQUFJLENBQUNELFVBQVVqcEIsU0FBUyxHQUFHO2dCQUMzRCxPQUFPenBCLGNBQWM1SixVQUFVLENBQUNzUixRQUFRO1lBQzFDLE9BQU8sSUFBSSxDQUFDZ3JDLFVBQVVqcEIsU0FBUyxFQUFFO2dCQUMvQnpwQixjQUFjNUosVUFBVSxDQUFDc1IsUUFBUSxHQUFHO1lBQ3RDO1FBQ0Y7SUFDRjtJQUNBLE9BQU8xSDtBQUNUO0FBQ0EsNkRBQTZEO0FBQzdELEtBQU0zUyxDQUFBQSxDQXdITiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1zaG9wLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9kaXN0L2RldmVsb3BtZW50L2luZGV4LmpzPzNjNzkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiByZWFjdC1yb3V0ZXIgdjcuNi4yXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3R5cGVFcnJvciA9IChtc2cpID0+IHtcbiAgdGhyb3cgVHlwZUVycm9yKG1zZyk7XG59O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+ICh0YXJnZXQgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcyhcbiAgLy8gSWYgdGhlIGltcG9ydGVyIGlzIGluIG5vZGUgY29tcGF0aWJpbGl0eSBtb2RlIG9yIHRoaXMgaXMgbm90IGFuIEVTTVxuICAvLyBmaWxlIHRoYXQgaGFzIGJlZW4gY29udmVydGVkIHRvIGEgQ29tbW9uSlMgZmlsZSB1c2luZyBhIEJhYmVsLVxuICAvLyBjb21wYXRpYmxlIHRyYW5zZm9ybSAoaS5lLiBcIl9fZXNNb2R1bGVcIiBoYXMgbm90IGJlZW4gc2V0KSwgdGhlbiBzZXRcbiAgLy8gXCJkZWZhdWx0XCIgdG8gdGhlIENvbW1vbkpTIFwibW9kdWxlLmV4cG9ydHNcIiBmb3Igbm9kZSBjb21wYXRpYmlsaXR5LlxuICBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldCxcbiAgbW9kXG4pKTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIF9fYWNjZXNzQ2hlY2sgPSAob2JqLCBtZW1iZXIsIG1zZykgPT4gbWVtYmVyLmhhcyhvYmopIHx8IF9fdHlwZUVycm9yKFwiQ2Fubm90IFwiICsgbXNnKTtcbnZhciBfX3ByaXZhdGVHZXQgPSAob2JqLCBtZW1iZXIsIGdldHRlcikgPT4gKF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIiksIGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiBtZW1iZXIuZ2V0KG9iaikpO1xudmFyIF9fcHJpdmF0ZUFkZCA9IChvYmosIG1lbWJlciwgdmFsdWUpID0+IG1lbWJlci5oYXMob2JqKSA/IF9fdHlwZUVycm9yKFwiQ2Fubm90IGFkZCB0aGUgc2FtZSBwcml2YXRlIG1lbWJlciBtb3JlIHRoYW4gb25jZVwiKSA6IG1lbWJlciBpbnN0YW5jZW9mIFdlYWtTZXQgPyBtZW1iZXIuYWRkKG9iaikgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xuXG4vLyBpbmRleC50c1xudmFyIHJlYWN0X3JvdXRlcl9leHBvcnRzID0ge307XG5fX2V4cG9ydChyZWFjdF9yb3V0ZXJfZXhwb3J0cywge1xuICBBd2FpdDogKCkgPT4gQXdhaXQsXG4gIEJyb3dzZXJSb3V0ZXI6ICgpID0+IEJyb3dzZXJSb3V0ZXIsXG4gIEZvcm06ICgpID0+IEZvcm0sXG4gIEhhc2hSb3V0ZXI6ICgpID0+IEhhc2hSb3V0ZXIsXG4gIElETEVfQkxPQ0tFUjogKCkgPT4gSURMRV9CTE9DS0VSLFxuICBJRExFX0ZFVENIRVI6ICgpID0+IElETEVfRkVUQ0hFUixcbiAgSURMRV9OQVZJR0FUSU9OOiAoKSA9PiBJRExFX05BVklHQVRJT04sXG4gIExpbms6ICgpID0+IExpbmssXG4gIExpbmtzOiAoKSA9PiBMaW5rcyxcbiAgTWVtb3J5Um91dGVyOiAoKSA9PiBNZW1vcnlSb3V0ZXIsXG4gIE1ldGE6ICgpID0+IE1ldGEsXG4gIE5hdkxpbms6ICgpID0+IE5hdkxpbmssXG4gIE5hdmlnYXRlOiAoKSA9PiBOYXZpZ2F0ZSxcbiAgTmF2aWdhdGlvblR5cGU6ICgpID0+IEFjdGlvbixcbiAgT3V0bGV0OiAoKSA9PiBPdXRsZXQsXG4gIFByZWZldGNoUGFnZUxpbmtzOiAoKSA9PiBQcmVmZXRjaFBhZ2VMaW5rcyxcbiAgUm91dGU6ICgpID0+IFJvdXRlLFxuICBSb3V0ZXI6ICgpID0+IFJvdXRlcixcbiAgUm91dGVyUHJvdmlkZXI6ICgpID0+IFJvdXRlclByb3ZpZGVyLFxuICBSb3V0ZXM6ICgpID0+IFJvdXRlcyxcbiAgU2NyaXB0czogKCkgPT4gU2NyaXB0cyxcbiAgU2Nyb2xsUmVzdG9yYXRpb246ICgpID0+IFNjcm9sbFJlc3RvcmF0aW9uLFxuICBTZXJ2ZXJSb3V0ZXI6ICgpID0+IFNlcnZlclJvdXRlcixcbiAgU3RhdGljUm91dGVyOiAoKSA9PiBTdGF0aWNSb3V0ZXIsXG4gIFN0YXRpY1JvdXRlclByb3ZpZGVyOiAoKSA9PiBTdGF0aWNSb3V0ZXJQcm92aWRlcixcbiAgVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0OiAoKSA9PiBEYXRhUm91dGVyQ29udGV4dCxcbiAgVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQ6ICgpID0+IERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQsXG4gIFVOU0FGRV9FcnJvclJlc3BvbnNlSW1wbDogKCkgPT4gRXJyb3JSZXNwb25zZUltcGwsXG4gIFVOU0FGRV9GZXRjaGVyc0NvbnRleHQ6ICgpID0+IEZldGNoZXJzQ29udGV4dCxcbiAgVU5TQUZFX0ZyYW1ld29ya0NvbnRleHQ6ICgpID0+IEZyYW1ld29ya0NvbnRleHQsXG4gIFVOU0FGRV9Mb2NhdGlvbkNvbnRleHQ6ICgpID0+IExvY2F0aW9uQ29udGV4dCxcbiAgVU5TQUZFX05hdmlnYXRpb25Db250ZXh0OiAoKSA9PiBOYXZpZ2F0aW9uQ29udGV4dCxcbiAgVU5TQUZFX1JlbWl4RXJyb3JCb3VuZGFyeTogKCkgPT4gUmVtaXhFcnJvckJvdW5kYXJ5LFxuICBVTlNBRkVfUm91dGVDb250ZXh0OiAoKSA9PiBSb3V0ZUNvbnRleHQsXG4gIFVOU0FGRV9TZXJ2ZXJNb2RlOiAoKSA9PiBTZXJ2ZXJNb2RlLFxuICBVTlNBRkVfU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbDogKCkgPT4gU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbCxcbiAgVU5TQUZFX1ZpZXdUcmFuc2l0aW9uQ29udGV4dDogKCkgPT4gVmlld1RyYW5zaXRpb25Db250ZXh0LFxuICBVTlNBRkVfY3JlYXRlQnJvd3Nlckhpc3Rvcnk6ICgpID0+IGNyZWF0ZUJyb3dzZXJIaXN0b3J5LFxuICBVTlNBRkVfY3JlYXRlQ2xpZW50Um91dGVzOiAoKSA9PiBjcmVhdGVDbGllbnRSb3V0ZXMsXG4gIFVOU0FGRV9jcmVhdGVDbGllbnRSb3V0ZXNXaXRoSE1SUmV2YWxpZGF0aW9uT3B0T3V0OiAoKSA9PiBjcmVhdGVDbGllbnRSb3V0ZXNXaXRoSE1SUmV2YWxpZGF0aW9uT3B0T3V0LFxuICBVTlNBRkVfY3JlYXRlUm91dGVyOiAoKSA9PiBjcmVhdGVSb3V0ZXIsXG4gIFVOU0FGRV9kZWNvZGVWaWFUdXJib1N0cmVhbTogKCkgPT4gZGVjb2RlVmlhVHVyYm9TdHJlYW0sXG4gIFVOU0FGRV9kZXNlcmlhbGl6ZUVycm9yczogKCkgPT4gZGVzZXJpYWxpemVFcnJvcnMyLFxuICBVTlNBRkVfZ2V0SHlkcmF0aW9uRGF0YTogKCkgPT4gZ2V0SHlkcmF0aW9uRGF0YSxcbiAgVU5TQUZFX2dldFBhdGNoUm91dGVzT25OYXZpZ2F0aW9uRnVuY3Rpb246ICgpID0+IGdldFBhdGNoUm91dGVzT25OYXZpZ2F0aW9uRnVuY3Rpb24sXG4gIFVOU0FGRV9nZXRUdXJib1N0cmVhbVNpbmdsZUZldGNoRGF0YVN0cmF0ZWd5OiAoKSA9PiBnZXRUdXJib1N0cmVhbVNpbmdsZUZldGNoRGF0YVN0cmF0ZWd5LFxuICBVTlNBRkVfaHlkcmF0aW9uUm91dGVQcm9wZXJ0aWVzOiAoKSA9PiBoeWRyYXRpb25Sb3V0ZVByb3BlcnRpZXMsXG4gIFVOU0FGRV9pbnZhcmlhbnQ6ICgpID0+IGludmFyaWFudCxcbiAgVU5TQUZFX21hcFJvdXRlUHJvcGVydGllczogKCkgPT4gbWFwUm91dGVQcm9wZXJ0aWVzLFxuICBVTlNBRkVfc2hvdWxkSHlkcmF0ZVJvdXRlTG9hZGVyOiAoKSA9PiBzaG91bGRIeWRyYXRlUm91dGVMb2FkZXIsXG4gIFVOU0FGRV91c2VGb2dPRldhckRpc2NvdmVyeTogKCkgPT4gdXNlRm9nT0ZXYXJEaXNjb3ZlcnksXG4gIFVOU0FGRV91c2VTY3JvbGxSZXN0b3JhdGlvbjogKCkgPT4gdXNlU2Nyb2xsUmVzdG9yYXRpb24sXG4gIFVOU0FGRV93aXRoQ29tcG9uZW50UHJvcHM6ICgpID0+IHdpdGhDb21wb25lbnRQcm9wcyxcbiAgVU5TQUZFX3dpdGhFcnJvckJvdW5kYXJ5UHJvcHM6ICgpID0+IHdpdGhFcnJvckJvdW5kYXJ5UHJvcHMsXG4gIFVOU0FGRV93aXRoSHlkcmF0ZUZhbGxiYWNrUHJvcHM6ICgpID0+IHdpdGhIeWRyYXRlRmFsbGJhY2tQcm9wcyxcbiAgY3JlYXRlQnJvd3NlclJvdXRlcjogKCkgPT4gY3JlYXRlQnJvd3NlclJvdXRlcixcbiAgY3JlYXRlQ29va2llOiAoKSA9PiBjcmVhdGVDb29raWUsXG4gIGNyZWF0ZUNvb2tpZVNlc3Npb25TdG9yYWdlOiAoKSA9PiBjcmVhdGVDb29raWVTZXNzaW9uU3RvcmFnZSxcbiAgY3JlYXRlSGFzaFJvdXRlcjogKCkgPT4gY3JlYXRlSGFzaFJvdXRlcixcbiAgY3JlYXRlTWVtb3J5Um91dGVyOiAoKSA9PiBjcmVhdGVNZW1vcnlSb3V0ZXIsXG4gIGNyZWF0ZU1lbW9yeVNlc3Npb25TdG9yYWdlOiAoKSA9PiBjcmVhdGVNZW1vcnlTZXNzaW9uU3RvcmFnZSxcbiAgY3JlYXRlUGF0aDogKCkgPT4gY3JlYXRlUGF0aCxcbiAgY3JlYXRlUmVxdWVzdEhhbmRsZXI6ICgpID0+IGNyZWF0ZVJlcXVlc3RIYW5kbGVyLFxuICBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW46ICgpID0+IGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbixcbiAgY3JlYXRlUm91dGVzRnJvbUVsZW1lbnRzOiAoKSA9PiBjcmVhdGVSb3V0ZXNGcm9tRWxlbWVudHMsXG4gIGNyZWF0ZVJvdXRlc1N0dWI6ICgpID0+IGNyZWF0ZVJvdXRlc1N0dWIsXG4gIGNyZWF0ZVNlYXJjaFBhcmFtczogKCkgPT4gY3JlYXRlU2VhcmNoUGFyYW1zLFxuICBjcmVhdGVTZXNzaW9uOiAoKSA9PiBjcmVhdGVTZXNzaW9uLFxuICBjcmVhdGVTZXNzaW9uU3RvcmFnZTogKCkgPT4gY3JlYXRlU2Vzc2lvblN0b3JhZ2UsXG4gIGNyZWF0ZVN0YXRpY0hhbmRsZXI6ICgpID0+IGNyZWF0ZVN0YXRpY0hhbmRsZXIyLFxuICBjcmVhdGVTdGF0aWNSb3V0ZXI6ICgpID0+IGNyZWF0ZVN0YXRpY1JvdXRlcixcbiAgZGF0YTogKCkgPT4gZGF0YSxcbiAgZ2VuZXJhdGVQYXRoOiAoKSA9PiBnZW5lcmF0ZVBhdGgsXG4gIGhyZWY6ICgpID0+IGhyZWYsXG4gIGlzQ29va2llOiAoKSA9PiBpc0Nvb2tpZSxcbiAgaXNSb3V0ZUVycm9yUmVzcG9uc2U6ICgpID0+IGlzUm91dGVFcnJvclJlc3BvbnNlLFxuICBpc1Nlc3Npb246ICgpID0+IGlzU2Vzc2lvbixcbiAgbWF0Y2hQYXRoOiAoKSA9PiBtYXRjaFBhdGgsXG4gIG1hdGNoUm91dGVzOiAoKSA9PiBtYXRjaFJvdXRlcyxcbiAgcGFyc2VQYXRoOiAoKSA9PiBwYXJzZVBhdGgsXG4gIHJlZGlyZWN0OiAoKSA9PiByZWRpcmVjdCxcbiAgcmVkaXJlY3REb2N1bWVudDogKCkgPT4gcmVkaXJlY3REb2N1bWVudCxcbiAgcmVuZGVyTWF0Y2hlczogKCkgPT4gcmVuZGVyTWF0Y2hlcyxcbiAgcmVwbGFjZTogKCkgPT4gcmVwbGFjZSxcbiAgcmVzb2x2ZVBhdGg6ICgpID0+IHJlc29sdmVQYXRoLFxuICB1bnN0YWJsZV9IaXN0b3J5Um91dGVyOiAoKSA9PiBIaXN0b3J5Um91dGVyLFxuICB1bnN0YWJsZV9Sb3V0ZXJDb250ZXh0UHJvdmlkZXI6ICgpID0+IHVuc3RhYmxlX1JvdXRlckNvbnRleHRQcm92aWRlcixcbiAgdW5zdGFibGVfY3JlYXRlQ29udGV4dDogKCkgPT4gdW5zdGFibGVfY3JlYXRlQ29udGV4dCxcbiAgdW5zdGFibGVfc2V0RGV2U2VydmVySG9va3M6ICgpID0+IHNldERldlNlcnZlckhvb2tzLFxuICB1bnN0YWJsZV91c2VQcm9tcHQ6ICgpID0+IHVzZVByb21wdCxcbiAgdXNlQWN0aW9uRGF0YTogKCkgPT4gdXNlQWN0aW9uRGF0YSxcbiAgdXNlQXN5bmNFcnJvcjogKCkgPT4gdXNlQXN5bmNFcnJvcixcbiAgdXNlQXN5bmNWYWx1ZTogKCkgPT4gdXNlQXN5bmNWYWx1ZSxcbiAgdXNlQmVmb3JlVW5sb2FkOiAoKSA9PiB1c2VCZWZvcmVVbmxvYWQsXG4gIHVzZUJsb2NrZXI6ICgpID0+IHVzZUJsb2NrZXIsXG4gIHVzZUZldGNoZXI6ICgpID0+IHVzZUZldGNoZXIsXG4gIHVzZUZldGNoZXJzOiAoKSA9PiB1c2VGZXRjaGVycyxcbiAgdXNlRm9ybUFjdGlvbjogKCkgPT4gdXNlRm9ybUFjdGlvbixcbiAgdXNlSHJlZjogKCkgPT4gdXNlSHJlZixcbiAgdXNlSW5Sb3V0ZXJDb250ZXh0OiAoKSA9PiB1c2VJblJvdXRlckNvbnRleHQsXG4gIHVzZUxpbmtDbGlja0hhbmRsZXI6ICgpID0+IHVzZUxpbmtDbGlja0hhbmRsZXIsXG4gIHVzZUxvYWRlckRhdGE6ICgpID0+IHVzZUxvYWRlckRhdGEsXG4gIHVzZUxvY2F0aW9uOiAoKSA9PiB1c2VMb2NhdGlvbixcbiAgdXNlTWF0Y2g6ICgpID0+IHVzZU1hdGNoLFxuICB1c2VNYXRjaGVzOiAoKSA9PiB1c2VNYXRjaGVzLFxuICB1c2VOYXZpZ2F0ZTogKCkgPT4gdXNlTmF2aWdhdGUsXG4gIHVzZU5hdmlnYXRpb246ICgpID0+IHVzZU5hdmlnYXRpb24sXG4gIHVzZU5hdmlnYXRpb25UeXBlOiAoKSA9PiB1c2VOYXZpZ2F0aW9uVHlwZSxcbiAgdXNlT3V0bGV0OiAoKSA9PiB1c2VPdXRsZXQsXG4gIHVzZU91dGxldENvbnRleHQ6ICgpID0+IHVzZU91dGxldENvbnRleHQsXG4gIHVzZVBhcmFtczogKCkgPT4gdXNlUGFyYW1zLFxuICB1c2VSZXNvbHZlZFBhdGg6ICgpID0+IHVzZVJlc29sdmVkUGF0aCxcbiAgdXNlUmV2YWxpZGF0b3I6ICgpID0+IHVzZVJldmFsaWRhdG9yLFxuICB1c2VSb3V0ZUVycm9yOiAoKSA9PiB1c2VSb3V0ZUVycm9yLFxuICB1c2VSb3V0ZUxvYWRlckRhdGE6ICgpID0+IHVzZVJvdXRlTG9hZGVyRGF0YSxcbiAgdXNlUm91dGVzOiAoKSA9PiB1c2VSb3V0ZXMsXG4gIHVzZVNlYXJjaFBhcmFtczogKCkgPT4gdXNlU2VhcmNoUGFyYW1zLFxuICB1c2VTdWJtaXQ6ICgpID0+IHVzZVN1Ym1pdCxcbiAgdXNlVmlld1RyYW5zaXRpb25TdGF0ZTogKCkgPT4gdXNlVmlld1RyYW5zaXRpb25TdGF0ZVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhyZWFjdF9yb3V0ZXJfZXhwb3J0cyk7XG5cbi8vIGxpYi9yb3V0ZXIvaGlzdG9yeS50c1xudmFyIEFjdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyAoKEFjdGlvbjIpID0+IHtcbiAgQWN0aW9uMltcIlBvcFwiXSA9IFwiUE9QXCI7XG4gIEFjdGlvbjJbXCJQdXNoXCJdID0gXCJQVVNIXCI7XG4gIEFjdGlvbjJbXCJSZXBsYWNlXCJdID0gXCJSRVBMQUNFXCI7XG4gIHJldHVybiBBY3Rpb24yO1xufSkoQWN0aW9uIHx8IHt9KTtcbnZhciBQb3BTdGF0ZUV2ZW50VHlwZSA9IFwicG9wc3RhdGVcIjtcbmZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUhpc3Rvcnkob3B0aW9ucyA9IHt9KSB7XG4gIGxldCB7IGluaXRpYWxFbnRyaWVzID0gW1wiL1wiXSwgaW5pdGlhbEluZGV4LCB2NUNvbXBhdCA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICBsZXQgZW50cmllcztcbiAgZW50cmllcyA9IGluaXRpYWxFbnRyaWVzLm1hcChcbiAgICAoZW50cnksIGluZGV4MikgPT4gY3JlYXRlTWVtb3J5TG9jYXRpb24oXG4gICAgICBlbnRyeSxcbiAgICAgIHR5cGVvZiBlbnRyeSA9PT0gXCJzdHJpbmdcIiA/IG51bGwgOiBlbnRyeS5zdGF0ZSxcbiAgICAgIGluZGV4MiA9PT0gMCA/IFwiZGVmYXVsdFwiIDogdm9pZCAwXG4gICAgKVxuICApO1xuICBsZXQgaW5kZXggPSBjbGFtcEluZGV4KFxuICAgIGluaXRpYWxJbmRleCA9PSBudWxsID8gZW50cmllcy5sZW5ndGggLSAxIDogaW5pdGlhbEluZGV4XG4gICk7XG4gIGxldCBhY3Rpb24gPSBcIlBPUFwiIC8qIFBvcCAqLztcbiAgbGV0IGxpc3RlbmVyID0gbnVsbDtcbiAgZnVuY3Rpb24gY2xhbXBJbmRleChuKSB7XG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG4sIDApLCBlbnRyaWVzLmxlbmd0aCAtIDEpO1xuICB9XG4gIGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbigpIHtcbiAgICByZXR1cm4gZW50cmllc1tpbmRleF07XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlTWVtb3J5TG9jYXRpb24odG8sIHN0YXRlID0gbnVsbCwga2V5KSB7XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oXG4gICAgICBlbnRyaWVzID8gZ2V0Q3VycmVudExvY2F0aW9uKCkucGF0aG5hbWUgOiBcIi9cIixcbiAgICAgIHRvLFxuICAgICAgc3RhdGUsXG4gICAgICBrZXlcbiAgICApO1xuICAgIHdhcm5pbmcoXG4gICAgICBsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgPT09IFwiL1wiLFxuICAgICAgYHJlbGF0aXZlIHBhdGhuYW1lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBtZW1vcnkgaGlzdG9yeTogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgdG9cbiAgICAgICl9YFxuICAgICk7XG4gICAgcmV0dXJuIGxvY2F0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUhyZWYyKHRvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gIH1cbiAgbGV0IGhpc3RvcnkgPSB7XG4gICAgZ2V0IGluZGV4KCkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG4gICAgZ2V0IGFjdGlvbigpIHtcbiAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfSxcbiAgICBnZXQgbG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gZ2V0Q3VycmVudExvY2F0aW9uKCk7XG4gICAgfSxcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmMixcbiAgICBjcmVhdGVVUkwodG8pIHtcbiAgICAgIHJldHVybiBuZXcgVVJMKGNyZWF0ZUhyZWYyKHRvKSwgXCJodHRwOi8vbG9jYWxob3N0XCIpO1xuICAgIH0sXG4gICAgZW5jb2RlTG9jYXRpb24odG8pIHtcbiAgICAgIGxldCBwYXRoID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvKSA6IHRvO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aG5hbWU6IHBhdGgucGF0aG5hbWUgfHwgXCJcIixcbiAgICAgICAgc2VhcmNoOiBwYXRoLnNlYXJjaCB8fCBcIlwiLFxuICAgICAgICBoYXNoOiBwYXRoLmhhc2ggfHwgXCJcIlxuICAgICAgfTtcbiAgICB9LFxuICAgIHB1c2godG8sIHN0YXRlKSB7XG4gICAgICBhY3Rpb24gPSBcIlBVU0hcIiAvKiBQdXNoICovO1xuICAgICAgbGV0IG5leHRMb2NhdGlvbiA9IGNyZWF0ZU1lbW9yeUxvY2F0aW9uKHRvLCBzdGF0ZSk7XG4gICAgICBpbmRleCArPSAxO1xuICAgICAgZW50cmllcy5zcGxpY2UoaW5kZXgsIGVudHJpZXMubGVuZ3RoLCBuZXh0TG9jYXRpb24pO1xuICAgICAgaWYgKHY1Q29tcGF0ICYmIGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogbmV4dExvY2F0aW9uLCBkZWx0YTogMSB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlcGxhY2UodG8sIHN0YXRlKSB7XG4gICAgICBhY3Rpb24gPSBcIlJFUExBQ0VcIiAvKiBSZXBsYWNlICovO1xuICAgICAgbGV0IG5leHRMb2NhdGlvbiA9IGNyZWF0ZU1lbW9yeUxvY2F0aW9uKHRvLCBzdGF0ZSk7XG4gICAgICBlbnRyaWVzW2luZGV4XSA9IG5leHRMb2NhdGlvbjtcbiAgICAgIGlmICh2NUNvbXBhdCAmJiBsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IG5leHRMb2NhdGlvbiwgZGVsdGE6IDAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnbyhkZWx0YSkge1xuICAgICAgYWN0aW9uID0gXCJQT1BcIiAvKiBQb3AgKi87XG4gICAgICBsZXQgbmV4dEluZGV4ID0gY2xhbXBJbmRleChpbmRleCArIGRlbHRhKTtcbiAgICAgIGxldCBuZXh0TG9jYXRpb24gPSBlbnRyaWVzW25leHRJbmRleF07XG4gICAgICBpbmRleCA9IG5leHRJbmRleDtcbiAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IG5leHRMb2NhdGlvbiwgZGVsdGEgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBsaXN0ZW4oZm4pIHtcbiAgICAgIGxpc3RlbmVyID0gZm47XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBsaXN0ZW5lciA9IG51bGw7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG5mdW5jdGlvbiBjcmVhdGVCcm93c2VySGlzdG9yeShvcHRpb25zID0ge30pIHtcbiAgZnVuY3Rpb24gY3JlYXRlQnJvd3NlckxvY2F0aW9uKHdpbmRvdzIsIGdsb2JhbEhpc3RvcnkpIHtcbiAgICBsZXQgeyBwYXRobmFtZSwgc2VhcmNoLCBoYXNoIH0gPSB3aW5kb3cyLmxvY2F0aW9uO1xuICAgIHJldHVybiBjcmVhdGVMb2NhdGlvbihcbiAgICAgIFwiXCIsXG4gICAgICB7IHBhdGhuYW1lLCBzZWFyY2gsIGhhc2ggfSxcbiAgICAgIC8vIHN0YXRlIGRlZmF1bHRzIHRvIGBudWxsYCBiZWNhdXNlIGB3aW5kb3cuaGlzdG9yeS5zdGF0ZWAgZG9lc1xuICAgICAgZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLnVzciB8fCBudWxsLFxuICAgICAgZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLmtleSB8fCBcImRlZmF1bHRcIlxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlQnJvd3NlckhyZWYod2luZG93MiwgdG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcbiAgfVxuICByZXR1cm4gZ2V0VXJsQmFzZWRIaXN0b3J5KFxuICAgIGNyZWF0ZUJyb3dzZXJMb2NhdGlvbixcbiAgICBjcmVhdGVCcm93c2VySHJlZixcbiAgICBudWxsLFxuICAgIG9wdGlvbnNcbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUhhc2hIaXN0b3J5KG9wdGlvbnMgPSB7fSkge1xuICBmdW5jdGlvbiBjcmVhdGVIYXNoTG9jYXRpb24od2luZG93MiwgZ2xvYmFsSGlzdG9yeSkge1xuICAgIGxldCB7XG4gICAgICBwYXRobmFtZSA9IFwiL1wiLFxuICAgICAgc2VhcmNoID0gXCJcIixcbiAgICAgIGhhc2ggPSBcIlwiXG4gICAgfSA9IHBhcnNlUGF0aCh3aW5kb3cyLmxvY2F0aW9uLmhhc2guc3Vic3RyaW5nKDEpKTtcbiAgICBpZiAoIXBhdGhuYW1lLnN0YXJ0c1dpdGgoXCIvXCIpICYmICFwYXRobmFtZS5zdGFydHNXaXRoKFwiLlwiKSkge1xuICAgICAgcGF0aG5hbWUgPSBcIi9cIiArIHBhdGhuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlTG9jYXRpb24oXG4gICAgICBcIlwiLFxuICAgICAgeyBwYXRobmFtZSwgc2VhcmNoLCBoYXNoIH0sXG4gICAgICAvLyBzdGF0ZSBkZWZhdWx0cyB0byBgbnVsbGAgYmVjYXVzZSBgd2luZG93Lmhpc3Rvcnkuc3RhdGVgIGRvZXNcbiAgICAgIGdsb2JhbEhpc3Rvcnkuc3RhdGUgJiYgZ2xvYmFsSGlzdG9yeS5zdGF0ZS51c3IgfHwgbnVsbCxcbiAgICAgIGdsb2JhbEhpc3Rvcnkuc3RhdGUgJiYgZ2xvYmFsSGlzdG9yeS5zdGF0ZS5rZXkgfHwgXCJkZWZhdWx0XCJcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUhhc2hIcmVmKHdpbmRvdzIsIHRvKSB7XG4gICAgbGV0IGJhc2UgPSB3aW5kb3cyLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJiYXNlXCIpO1xuICAgIGxldCBocmVmMiA9IFwiXCI7XG4gICAgaWYgKGJhc2UgJiYgYmFzZS5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpKSB7XG4gICAgICBsZXQgdXJsID0gd2luZG93Mi5sb2NhdGlvbi5ocmVmO1xuICAgICAgbGV0IGhhc2hJbmRleCA9IHVybC5pbmRleE9mKFwiI1wiKTtcbiAgICAgIGhyZWYyID0gaGFzaEluZGV4ID09PSAtMSA/IHVybCA6IHVybC5zbGljZSgwLCBoYXNoSW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gaHJlZjIgKyBcIiNcIiArICh0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IGNyZWF0ZVBhdGgodG8pKTtcbiAgfVxuICBmdW5jdGlvbiB2YWxpZGF0ZUhhc2hMb2NhdGlvbihsb2NhdGlvbiwgdG8pIHtcbiAgICB3YXJuaW5nKFxuICAgICAgbG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApID09PSBcIi9cIixcbiAgICAgIGByZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gaGFzaCBoaXN0b3J5LnB1c2goJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgdG9cbiAgICAgICl9KWBcbiAgICApO1xuICB9XG4gIHJldHVybiBnZXRVcmxCYXNlZEhpc3RvcnkoXG4gICAgY3JlYXRlSGFzaExvY2F0aW9uLFxuICAgIGNyZWF0ZUhhc2hIcmVmLFxuICAgIHZhbGlkYXRlSGFzaExvY2F0aW9uLFxuICAgIG9wdGlvbnNcbiAgKTtcbn1cbmZ1bmN0aW9uIGludmFyaWFudCh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuZnVuY3Rpb24gd2FybmluZyhjb25kLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZCkge1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIHRyeSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDEwKTtcbn1cbmZ1bmN0aW9uIGdldEhpc3RvcnlTdGF0ZShsb2NhdGlvbiwgaW5kZXgpIHtcbiAgcmV0dXJuIHtcbiAgICB1c3I6IGxvY2F0aW9uLnN0YXRlLFxuICAgIGtleTogbG9jYXRpb24ua2V5LFxuICAgIGlkeDogaW5kZXhcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKGN1cnJlbnQsIHRvLCBzdGF0ZSA9IG51bGwsIGtleSkge1xuICBsZXQgbG9jYXRpb24gPSB7XG4gICAgcGF0aG5hbWU6IHR5cGVvZiBjdXJyZW50ID09PSBcInN0cmluZ1wiID8gY3VycmVudCA6IGN1cnJlbnQucGF0aG5hbWUsXG4gICAgc2VhcmNoOiBcIlwiLFxuICAgIGhhc2g6IFwiXCIsXG4gICAgLi4udHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvKSA6IHRvLFxuICAgIHN0YXRlLFxuICAgIC8vIFRPRE86IFRoaXMgY291bGQgYmUgY2xlYW5lZCB1cC4gIHB1c2gvcmVwbGFjZSBzaG91bGQgcHJvYmFibHkganVzdCB0YWtlXG4gICAgLy8gZnVsbCBMb2NhdGlvbnMgbm93IGFuZCBhdm9pZCB0aGUgbmVlZCB0byBydW4gdGhyb3VnaCB0aGlzIGZsb3cgYXQgYWxsXG4gICAgLy8gQnV0IHRoYXQncyBhIHByZXR0eSBiaWcgcmVmYWN0b3IgdG8gdGhlIGN1cnJlbnQgdGVzdCBzdWl0ZSBzbyBnb2luZyB0b1xuICAgIC8vIGtlZXAgYXMgaXMgZm9yIHRoZSB0aW1lIGJlaW5nIGFuZCBqdXN0IGxldCBhbnkgaW5jb21pbmcga2V5cyB0YWtlIHByZWNlZGVuY2VcbiAgICBrZXk6IHRvICYmIHRvLmtleSB8fCBrZXkgfHwgY3JlYXRlS2V5KClcbiAgfTtcbiAgcmV0dXJuIGxvY2F0aW9uO1xufVxuZnVuY3Rpb24gY3JlYXRlUGF0aCh7XG4gIHBhdGhuYW1lID0gXCIvXCIsXG4gIHNlYXJjaCA9IFwiXCIsXG4gIGhhc2ggPSBcIlwiXG59KSB7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoICE9PSBcIj9cIilcbiAgICBwYXRobmFtZSArPSBzZWFyY2guY2hhckF0KDApID09PSBcIj9cIiA/IHNlYXJjaCA6IFwiP1wiICsgc2VhcmNoO1xuICBpZiAoaGFzaCAmJiBoYXNoICE9PSBcIiNcIilcbiAgICBwYXRobmFtZSArPSBoYXNoLmNoYXJBdCgwKSA9PT0gXCIjXCIgPyBoYXNoIDogXCIjXCIgKyBoYXNoO1xuICByZXR1cm4gcGF0aG5hbWU7XG59XG5mdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICBsZXQgcGFyc2VkUGF0aCA9IHt9O1xuICBpZiAocGF0aCkge1xuICAgIGxldCBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoXCIjXCIpO1xuICAgIGlmIChoYXNoSW5kZXggPj0gMCkge1xuICAgICAgcGFyc2VkUGF0aC5oYXNoID0gcGF0aC5zdWJzdHJpbmcoaGFzaEluZGV4KTtcbiAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygwLCBoYXNoSW5kZXgpO1xuICAgIH1cbiAgICBsZXQgc2VhcmNoSW5kZXggPSBwYXRoLmluZGV4T2YoXCI/XCIpO1xuICAgIGlmIChzZWFyY2hJbmRleCA+PSAwKSB7XG4gICAgICBwYXJzZWRQYXRoLnNlYXJjaCA9IHBhdGguc3Vic3RyaW5nKHNlYXJjaEluZGV4KTtcbiAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygwLCBzZWFyY2hJbmRleCk7XG4gICAgfVxuICAgIGlmIChwYXRoKSB7XG4gICAgICBwYXJzZWRQYXRoLnBhdGhuYW1lID0gcGF0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnNlZFBhdGg7XG59XG5mdW5jdGlvbiBnZXRVcmxCYXNlZEhpc3RvcnkoZ2V0TG9jYXRpb24sIGNyZWF0ZUhyZWYyLCB2YWxpZGF0ZUxvY2F0aW9uLCBvcHRpb25zID0ge30pIHtcbiAgbGV0IHsgd2luZG93OiB3aW5kb3cyID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcsIHY1Q29tcGF0ID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gIGxldCBnbG9iYWxIaXN0b3J5ID0gd2luZG93Mi5oaXN0b3J5O1xuICBsZXQgYWN0aW9uID0gXCJQT1BcIiAvKiBQb3AgKi87XG4gIGxldCBsaXN0ZW5lciA9IG51bGw7XG4gIGxldCBpbmRleCA9IGdldEluZGV4KCk7XG4gIGlmIChpbmRleCA9PSBudWxsKSB7XG4gICAgaW5kZXggPSAwO1xuICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKHsgLi4uZ2xvYmFsSGlzdG9yeS5zdGF0ZSwgaWR4OiBpbmRleCB9LCBcIlwiKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRJbmRleCgpIHtcbiAgICBsZXQgc3RhdGUgPSBnbG9iYWxIaXN0b3J5LnN0YXRlIHx8IHsgaWR4OiBudWxsIH07XG4gICAgcmV0dXJuIHN0YXRlLmlkeDtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVQb3AoKSB7XG4gICAgYWN0aW9uID0gXCJQT1BcIiAvKiBQb3AgKi87XG4gICAgbGV0IG5leHRJbmRleCA9IGdldEluZGV4KCk7XG4gICAgbGV0IGRlbHRhID0gbmV4dEluZGV4ID09IG51bGwgPyBudWxsIDogbmV4dEluZGV4IC0gaW5kZXg7XG4gICAgaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sIGRlbHRhIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwdXNoKHRvLCBzdGF0ZSkge1xuICAgIGFjdGlvbiA9IFwiUFVTSFwiIC8qIFB1c2ggKi87XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oaGlzdG9yeS5sb2NhdGlvbiwgdG8sIHN0YXRlKTtcbiAgICBpZiAodmFsaWRhdGVMb2NhdGlvbikgdmFsaWRhdGVMb2NhdGlvbihsb2NhdGlvbiwgdG8pO1xuICAgIGluZGV4ID0gZ2V0SW5kZXgoKSArIDE7XG4gICAgbGV0IGhpc3RvcnlTdGF0ZSA9IGdldEhpc3RvcnlTdGF0ZShsb2NhdGlvbiwgaW5kZXgpO1xuICAgIGxldCB1cmwgPSBoaXN0b3J5LmNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgIHRyeSB7XG4gICAgICBnbG9iYWxIaXN0b3J5LnB1c2hTdGF0ZShoaXN0b3J5U3RhdGUsIFwiXCIsIHVybCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbiAmJiBlcnJvci5uYW1lID09PSBcIkRhdGFDbG9uZUVycm9yXCIpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB3aW5kb3cyLmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgIH1cbiAgICBpZiAodjVDb21wYXQgJiYgbGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbiwgZGVsdGE6IDEgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlcGxhY2UyKHRvLCBzdGF0ZSkge1xuICAgIGFjdGlvbiA9IFwiUkVQTEFDRVwiIC8qIFJlcGxhY2UgKi87XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oaGlzdG9yeS5sb2NhdGlvbiwgdG8sIHN0YXRlKTtcbiAgICBpZiAodmFsaWRhdGVMb2NhdGlvbikgdmFsaWRhdGVMb2NhdGlvbihsb2NhdGlvbiwgdG8pO1xuICAgIGluZGV4ID0gZ2V0SW5kZXgoKTtcbiAgICBsZXQgaGlzdG9yeVN0YXRlID0gZ2V0SGlzdG9yeVN0YXRlKGxvY2F0aW9uLCBpbmRleCk7XG4gICAgbGV0IHVybCA9IGhpc3RvcnkuY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gICAgZ2xvYmFsSGlzdG9yeS5yZXBsYWNlU3RhdGUoaGlzdG9yeVN0YXRlLCBcIlwiLCB1cmwpO1xuICAgIGlmICh2NUNvbXBhdCAmJiBsaXN0ZW5lcikge1xuICAgICAgbGlzdGVuZXIoeyBhY3Rpb24sIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uLCBkZWx0YTogMCB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlVVJMKHRvKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJyb3dzZXJVUkxJbXBsKHRvKTtcbiAgfVxuICBsZXQgaGlzdG9yeSA9IHtcbiAgICBnZXQgYWN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9LFxuICAgIGdldCBsb2NhdGlvbigpIHtcbiAgICAgIHJldHVybiBnZXRMb2NhdGlvbih3aW5kb3cyLCBnbG9iYWxIaXN0b3J5KTtcbiAgICB9LFxuICAgIGxpc3Rlbihmbikge1xuICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgaGlzdG9yeSBvbmx5IGFjY2VwdHMgb25lIGFjdGl2ZSBsaXN0ZW5lclwiKTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdzIuYWRkRXZlbnRMaXN0ZW5lcihQb3BTdGF0ZUV2ZW50VHlwZSwgaGFuZGxlUG9wKTtcbiAgICAgIGxpc3RlbmVyID0gZm47XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB3aW5kb3cyLnJlbW92ZUV2ZW50TGlzdGVuZXIoUG9wU3RhdGVFdmVudFR5cGUsIGhhbmRsZVBvcCk7XG4gICAgICAgIGxpc3RlbmVyID0gbnVsbDtcbiAgICAgIH07XG4gICAgfSxcbiAgICBjcmVhdGVIcmVmKHRvKSB7XG4gICAgICByZXR1cm4gY3JlYXRlSHJlZjIod2luZG93MiwgdG8pO1xuICAgIH0sXG4gICAgY3JlYXRlVVJMLFxuICAgIGVuY29kZUxvY2F0aW9uKHRvKSB7XG4gICAgICBsZXQgdXJsID0gY3JlYXRlVVJMKHRvKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGhuYW1lOiB1cmwucGF0aG5hbWUsXG4gICAgICAgIHNlYXJjaDogdXJsLnNlYXJjaCxcbiAgICAgICAgaGFzaDogdXJsLmhhc2hcbiAgICAgIH07XG4gICAgfSxcbiAgICBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UyLFxuICAgIGdvKG4pIHtcbiAgICAgIHJldHVybiBnbG9iYWxIaXN0b3J5LmdvKG4pO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG5mdW5jdGlvbiBjcmVhdGVCcm93c2VyVVJMSW1wbCh0bywgaXNBYnNvbHV0ZSA9IGZhbHNlKSB7XG4gIGxldCBiYXNlID0gXCJodHRwOi8vbG9jYWxob3N0XCI7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgYmFzZSA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gIT09IFwibnVsbFwiID8gd2luZG93LmxvY2F0aW9uLm9yaWdpbiA6IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB9XG4gIGludmFyaWFudChiYXNlLCBcIk5vIHdpbmRvdy5sb2NhdGlvbi4ob3JpZ2lufGhyZWYpIGF2YWlsYWJsZSB0byBjcmVhdGUgVVJMXCIpO1xuICBsZXQgaHJlZjIgPSB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IGNyZWF0ZVBhdGgodG8pO1xuICBocmVmMiA9IGhyZWYyLnJlcGxhY2UoLyAkLywgXCIlMjBcIik7XG4gIGlmICghaXNBYnNvbHV0ZSAmJiBocmVmMi5zdGFydHNXaXRoKFwiLy9cIikpIHtcbiAgICBocmVmMiA9IGJhc2UgKyBocmVmMjtcbiAgfVxuICByZXR1cm4gbmV3IFVSTChocmVmMiwgYmFzZSk7XG59XG5cbi8vIGxpYi9yb3V0ZXIvdXRpbHMudHNcbmZ1bmN0aW9uIHVuc3RhYmxlX2NyZWF0ZUNvbnRleHQoZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiB7IGRlZmF1bHRWYWx1ZSB9O1xufVxudmFyIF9tYXA7XG52YXIgdW5zdGFibGVfUm91dGVyQ29udGV4dFByb3ZpZGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihpbml0KSB7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9tYXAsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIGlmIChpbml0KSB7XG4gICAgICBmb3IgKGxldCBbY29udGV4dCwgdmFsdWVdIG9mIGluaXQpIHtcbiAgICAgICAgdGhpcy5zZXQoY29udGV4dCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQoY29udGV4dCkge1xuICAgIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX21hcCkuaGFzKGNvbnRleHQpKSB7XG4gICAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9tYXApLmdldChjb250ZXh0KTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQuZGVmYXVsdFZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBjb250ZXh0LmRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdmFsdWUgZm91bmQgZm9yIGNvbnRleHRcIik7XG4gIH1cbiAgc2V0KGNvbnRleHQsIHZhbHVlKSB7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9tYXApLnNldChjb250ZXh0LCB2YWx1ZSk7XG4gIH1cbn07XG5fbWFwID0gbmV3IFdlYWtNYXAoKTtcbnZhciB1bnN1cHBvcnRlZExhenlSb3V0ZU9iamVjdEtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwibGF6eVwiLFxuICBcImNhc2VTZW5zaXRpdmVcIixcbiAgXCJwYXRoXCIsXG4gIFwiaWRcIixcbiAgXCJpbmRleFwiLFxuICBcImNoaWxkcmVuXCJcbl0pO1xuZnVuY3Rpb24gaXNVbnN1cHBvcnRlZExhenlSb3V0ZU9iamVjdEtleShrZXkpIHtcbiAgcmV0dXJuIHVuc3VwcG9ydGVkTGF6eVJvdXRlT2JqZWN0S2V5cy5oYXMoXG4gICAga2V5XG4gICk7XG59XG52YXIgdW5zdXBwb3J0ZWRMYXp5Um91dGVGdW5jdGlvbktleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwibGF6eVwiLFxuICBcImNhc2VTZW5zaXRpdmVcIixcbiAgXCJwYXRoXCIsXG4gIFwiaWRcIixcbiAgXCJpbmRleFwiLFxuICBcInVuc3RhYmxlX21pZGRsZXdhcmVcIixcbiAgXCJjaGlsZHJlblwiXG5dKTtcbmZ1bmN0aW9uIGlzVW5zdXBwb3J0ZWRMYXp5Um91dGVGdW5jdGlvbktleShrZXkpIHtcbiAgcmV0dXJuIHVuc3VwcG9ydGVkTGF6eVJvdXRlRnVuY3Rpb25LZXlzLmhhcyhcbiAgICBrZXlcbiAgKTtcbn1cbmZ1bmN0aW9uIGlzSW5kZXhSb3V0ZShyb3V0ZSkge1xuICByZXR1cm4gcm91dGUuaW5kZXggPT09IHRydWU7XG59XG5mdW5jdGlvbiBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKHJvdXRlcywgbWFwUm91dGVQcm9wZXJ0aWVzMiwgcGFyZW50UGF0aCA9IFtdLCBtYW5pZmVzdCA9IHt9KSB7XG4gIHJldHVybiByb3V0ZXMubWFwKChyb3V0ZSwgaW5kZXgpID0+IHtcbiAgICBsZXQgdHJlZVBhdGggPSBbLi4ucGFyZW50UGF0aCwgU3RyaW5nKGluZGV4KV07XG4gICAgbGV0IGlkID0gdHlwZW9mIHJvdXRlLmlkID09PSBcInN0cmluZ1wiID8gcm91dGUuaWQgOiB0cmVlUGF0aC5qb2luKFwiLVwiKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICByb3V0ZS5pbmRleCAhPT0gdHJ1ZSB8fCAhcm91dGUuY2hpbGRyZW4sXG4gICAgICBgQ2Fubm90IHNwZWNpZnkgY2hpbGRyZW4gb24gYW4gaW5kZXggcm91dGVgXG4gICAgKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICAhbWFuaWZlc3RbaWRdLFxuICAgICAgYEZvdW5kIGEgcm91dGUgaWQgY29sbGlzaW9uIG9uIGlkIFwiJHtpZH1cIi4gIFJvdXRlIGlkJ3MgbXVzdCBiZSBnbG9iYWxseSB1bmlxdWUgd2l0aGluIERhdGEgUm91dGVyIHVzYWdlc2BcbiAgICApO1xuICAgIGlmIChpc0luZGV4Um91dGUocm91dGUpKSB7XG4gICAgICBsZXQgaW5kZXhSb3V0ZSA9IHtcbiAgICAgICAgLi4ucm91dGUsXG4gICAgICAgIC4uLm1hcFJvdXRlUHJvcGVydGllczIocm91dGUpLFxuICAgICAgICBpZFxuICAgICAgfTtcbiAgICAgIG1hbmlmZXN0W2lkXSA9IGluZGV4Um91dGU7XG4gICAgICByZXR1cm4gaW5kZXhSb3V0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHBhdGhPckxheW91dFJvdXRlID0ge1xuICAgICAgICAuLi5yb3V0ZSxcbiAgICAgICAgLi4ubWFwUm91dGVQcm9wZXJ0aWVzMihyb3V0ZSksXG4gICAgICAgIGlkLFxuICAgICAgICBjaGlsZHJlbjogdm9pZCAwXG4gICAgICB9O1xuICAgICAgbWFuaWZlc3RbaWRdID0gcGF0aE9yTGF5b3V0Um91dGU7XG4gICAgICBpZiAocm91dGUuY2hpbGRyZW4pIHtcbiAgICAgICAgcGF0aE9yTGF5b3V0Um91dGUuY2hpbGRyZW4gPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKFxuICAgICAgICAgIHJvdXRlLmNoaWxkcmVuLFxuICAgICAgICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgICAgICAgdHJlZVBhdGgsXG4gICAgICAgICAgbWFuaWZlc3RcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXRoT3JMYXlvdXRSb3V0ZTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gbWF0Y2hSb3V0ZXMocm91dGVzLCBsb2NhdGlvbkFyZywgYmFzZW5hbWUgPSBcIi9cIikge1xuICByZXR1cm4gbWF0Y2hSb3V0ZXNJbXBsKHJvdXRlcywgbG9jYXRpb25BcmcsIGJhc2VuYW1lLCBmYWxzZSk7XG59XG5mdW5jdGlvbiBtYXRjaFJvdXRlc0ltcGwocm91dGVzLCBsb2NhdGlvbkFyZywgYmFzZW5hbWUsIGFsbG93UGFydGlhbCkge1xuICBsZXQgbG9jYXRpb24gPSB0eXBlb2YgbG9jYXRpb25BcmcgPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgobG9jYXRpb25BcmcpIDogbG9jYXRpb25Bcmc7XG4gIGxldCBwYXRobmFtZSA9IHN0cmlwQmFzZW5hbWUobG9jYXRpb24ucGF0aG5hbWUgfHwgXCIvXCIsIGJhc2VuYW1lKTtcbiAgaWYgKHBhdGhuYW1lID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsZXQgYnJhbmNoZXMgPSBmbGF0dGVuUm91dGVzKHJvdXRlcyk7XG4gIHJhbmtSb3V0ZUJyYW5jaGVzKGJyYW5jaGVzKTtcbiAgbGV0IG1hdGNoZXMgPSBudWxsO1xuICBmb3IgKGxldCBpID0gMDsgbWF0Y2hlcyA9PSBudWxsICYmIGkgPCBicmFuY2hlcy5sZW5ndGg7ICsraSkge1xuICAgIGxldCBkZWNvZGVkID0gZGVjb2RlUGF0aChwYXRobmFtZSk7XG4gICAgbWF0Y2hlcyA9IG1hdGNoUm91dGVCcmFuY2goXG4gICAgICBicmFuY2hlc1tpXSxcbiAgICAgIGRlY29kZWQsXG4gICAgICBhbGxvd1BhcnRpYWxcbiAgICApO1xuICB9XG4gIHJldHVybiBtYXRjaGVzO1xufVxuZnVuY3Rpb24gY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2gobWF0Y2gsIGxvYWRlckRhdGEpIHtcbiAgbGV0IHsgcm91dGUsIHBhdGhuYW1lLCBwYXJhbXMgfSA9IG1hdGNoO1xuICByZXR1cm4ge1xuICAgIGlkOiByb3V0ZS5pZCxcbiAgICBwYXRobmFtZSxcbiAgICBwYXJhbXMsXG4gICAgZGF0YTogbG9hZGVyRGF0YVtyb3V0ZS5pZF0sXG4gICAgaGFuZGxlOiByb3V0ZS5oYW5kbGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW5Sb3V0ZXMocm91dGVzLCBicmFuY2hlcyA9IFtdLCBwYXJlbnRzTWV0YSA9IFtdLCBwYXJlbnRQYXRoID0gXCJcIikge1xuICBsZXQgZmxhdHRlblJvdXRlID0gKHJvdXRlLCBpbmRleCwgcmVsYXRpdmVQYXRoKSA9PiB7XG4gICAgbGV0IG1ldGEgPSB7XG4gICAgICByZWxhdGl2ZVBhdGg6IHJlbGF0aXZlUGF0aCA9PT0gdm9pZCAwID8gcm91dGUucGF0aCB8fCBcIlwiIDogcmVsYXRpdmVQYXRoLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogcm91dGUuY2FzZVNlbnNpdGl2ZSA9PT0gdHJ1ZSxcbiAgICAgIGNoaWxkcmVuSW5kZXg6IGluZGV4LFxuICAgICAgcm91dGVcbiAgICB9O1xuICAgIGlmIChtZXRhLnJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICBtZXRhLnJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKHBhcmVudFBhdGgpLFxuICAgICAgICBgQWJzb2x1dGUgcm91dGUgcGF0aCBcIiR7bWV0YS5yZWxhdGl2ZVBhdGh9XCIgbmVzdGVkIHVuZGVyIHBhdGggXCIke3BhcmVudFBhdGh9XCIgaXMgbm90IHZhbGlkLiBBbiBhYnNvbHV0ZSBjaGlsZCByb3V0ZSBwYXRoIG11c3Qgc3RhcnQgd2l0aCB0aGUgY29tYmluZWQgcGF0aCBvZiBhbGwgaXRzIHBhcmVudCByb3V0ZXMuYFxuICAgICAgKTtcbiAgICAgIG1ldGEucmVsYXRpdmVQYXRoID0gbWV0YS5yZWxhdGl2ZVBhdGguc2xpY2UocGFyZW50UGF0aC5sZW5ndGgpO1xuICAgIH1cbiAgICBsZXQgcGF0aCA9IGpvaW5QYXRocyhbcGFyZW50UGF0aCwgbWV0YS5yZWxhdGl2ZVBhdGhdKTtcbiAgICBsZXQgcm91dGVzTWV0YSA9IHBhcmVudHNNZXRhLmNvbmNhdChtZXRhKTtcbiAgICBpZiAocm91dGUuY2hpbGRyZW4gJiYgcm91dGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICAvLyBPdXIgdHlwZXMga25vdyBiZXR0ZXIsIGJ1dCBydW50aW1lIEpTIG1heSBub3QhXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgcm91dGUuaW5kZXggIT09IHRydWUsXG4gICAgICAgIGBJbmRleCByb3V0ZXMgbXVzdCBub3QgaGF2ZSBjaGlsZCByb3V0ZXMuIFBsZWFzZSByZW1vdmUgYWxsIGNoaWxkIHJvdXRlcyBmcm9tIHJvdXRlIHBhdGggXCIke3BhdGh9XCIuYFxuICAgICAgKTtcbiAgICAgIGZsYXR0ZW5Sb3V0ZXMocm91dGUuY2hpbGRyZW4sIGJyYW5jaGVzLCByb3V0ZXNNZXRhLCBwYXRoKTtcbiAgICB9XG4gICAgaWYgKHJvdXRlLnBhdGggPT0gbnVsbCAmJiAhcm91dGUuaW5kZXgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYnJhbmNoZXMucHVzaCh7XG4gICAgICBwYXRoLFxuICAgICAgc2NvcmU6IGNvbXB1dGVTY29yZShwYXRoLCByb3V0ZS5pbmRleCksXG4gICAgICByb3V0ZXNNZXRhXG4gICAgfSk7XG4gIH07XG4gIHJvdXRlcy5mb3JFYWNoKChyb3V0ZSwgaW5kZXgpID0+IHtcbiAgICBpZiAocm91dGUucGF0aCA9PT0gXCJcIiB8fCAhcm91dGUucGF0aD8uaW5jbHVkZXMoXCI/XCIpKSB7XG4gICAgICBmbGF0dGVuUm91dGUocm91dGUsIGluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgZXhwbG9kZWQgb2YgZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMocm91dGUucGF0aCkpIHtcbiAgICAgICAgZmxhdHRlblJvdXRlKHJvdXRlLCBpbmRleCwgZXhwbG9kZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBicmFuY2hlcztcbn1cbmZ1bmN0aW9uIGV4cGxvZGVPcHRpb25hbFNlZ21lbnRzKHBhdGgpIHtcbiAgbGV0IHNlZ21lbnRzID0gcGF0aC5zcGxpdChcIi9cIik7XG4gIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDApIHJldHVybiBbXTtcbiAgbGV0IFtmaXJzdCwgLi4ucmVzdF0gPSBzZWdtZW50cztcbiAgbGV0IGlzT3B0aW9uYWwgPSBmaXJzdC5lbmRzV2l0aChcIj9cIik7XG4gIGxldCByZXF1aXJlZCA9IGZpcnN0LnJlcGxhY2UoL1xcPyQvLCBcIlwiKTtcbiAgaWYgKHJlc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGlzT3B0aW9uYWwgPyBbcmVxdWlyZWQsIFwiXCJdIDogW3JlcXVpcmVkXTtcbiAgfVxuICBsZXQgcmVzdEV4cGxvZGVkID0gZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMocmVzdC5qb2luKFwiL1wiKSk7XG4gIGxldCByZXN1bHQgPSBbXTtcbiAgcmVzdWx0LnB1c2goXG4gICAgLi4ucmVzdEV4cGxvZGVkLm1hcChcbiAgICAgIChzdWJwYXRoKSA9PiBzdWJwYXRoID09PSBcIlwiID8gcmVxdWlyZWQgOiBbcmVxdWlyZWQsIHN1YnBhdGhdLmpvaW4oXCIvXCIpXG4gICAgKVxuICApO1xuICBpZiAoaXNPcHRpb25hbCkge1xuICAgIHJlc3VsdC5wdXNoKC4uLnJlc3RFeHBsb2RlZCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5tYXAoXG4gICAgKGV4cGxvZGVkKSA9PiBwYXRoLnN0YXJ0c1dpdGgoXCIvXCIpICYmIGV4cGxvZGVkID09PSBcIlwiID8gXCIvXCIgOiBleHBsb2RlZFxuICApO1xufVxuZnVuY3Rpb24gcmFua1JvdXRlQnJhbmNoZXMoYnJhbmNoZXMpIHtcbiAgYnJhbmNoZXMuc29ydChcbiAgICAoYSwgYikgPT4gYS5zY29yZSAhPT0gYi5zY29yZSA/IGIuc2NvcmUgLSBhLnNjb3JlIDogY29tcGFyZUluZGV4ZXMoXG4gICAgICBhLnJvdXRlc01ldGEubWFwKChtZXRhKSA9PiBtZXRhLmNoaWxkcmVuSW5kZXgpLFxuICAgICAgYi5yb3V0ZXNNZXRhLm1hcCgobWV0YSkgPT4gbWV0YS5jaGlsZHJlbkluZGV4KVxuICAgIClcbiAgKTtcbn1cbnZhciBwYXJhbVJlID0gL146W1xcdy1dKyQvO1xudmFyIGR5bmFtaWNTZWdtZW50VmFsdWUgPSAzO1xudmFyIGluZGV4Um91dGVWYWx1ZSA9IDI7XG52YXIgZW1wdHlTZWdtZW50VmFsdWUgPSAxO1xudmFyIHN0YXRpY1NlZ21lbnRWYWx1ZSA9IDEwO1xudmFyIHNwbGF0UGVuYWx0eSA9IC0yO1xudmFyIGlzU3BsYXQgPSAocykgPT4gcyA9PT0gXCIqXCI7XG5mdW5jdGlvbiBjb21wdXRlU2NvcmUocGF0aCwgaW5kZXgpIHtcbiAgbGV0IHNlZ21lbnRzID0gcGF0aC5zcGxpdChcIi9cIik7XG4gIGxldCBpbml0aWFsU2NvcmUgPSBzZWdtZW50cy5sZW5ndGg7XG4gIGlmIChzZWdtZW50cy5zb21lKGlzU3BsYXQpKSB7XG4gICAgaW5pdGlhbFNjb3JlICs9IHNwbGF0UGVuYWx0eTtcbiAgfVxuICBpZiAoaW5kZXgpIHtcbiAgICBpbml0aWFsU2NvcmUgKz0gaW5kZXhSb3V0ZVZhbHVlO1xuICB9XG4gIHJldHVybiBzZWdtZW50cy5maWx0ZXIoKHMpID0+ICFpc1NwbGF0KHMpKS5yZWR1Y2UoXG4gICAgKHNjb3JlLCBzZWdtZW50KSA9PiBzY29yZSArIChwYXJhbVJlLnRlc3Qoc2VnbWVudCkgPyBkeW5hbWljU2VnbWVudFZhbHVlIDogc2VnbWVudCA9PT0gXCJcIiA/IGVtcHR5U2VnbWVudFZhbHVlIDogc3RhdGljU2VnbWVudFZhbHVlKSxcbiAgICBpbml0aWFsU2NvcmVcbiAgKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVJbmRleGVzKGEsIGIpIHtcbiAgbGV0IHNpYmxpbmdzID0gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuc2xpY2UoMCwgLTEpLmV2ZXJ5KChuLCBpKSA9PiBuID09PSBiW2ldKTtcbiAgcmV0dXJuIHNpYmxpbmdzID8gKFxuICAgIC8vIElmIHR3byByb3V0ZXMgYXJlIHNpYmxpbmdzLCB3ZSBzaG91bGQgdHJ5IHRvIG1hdGNoIHRoZSBlYXJsaWVyIHNpYmxpbmdcbiAgICAvLyBmaXJzdC4gVGhpcyBhbGxvd3MgcGVvcGxlIHRvIGhhdmUgZmluZS1ncmFpbmVkIGNvbnRyb2wgb3ZlciB0aGUgbWF0Y2hpbmdcbiAgICAvLyBiZWhhdmlvciBieSBzaW1wbHkgcHV0dGluZyByb3V0ZXMgd2l0aCBpZGVudGljYWwgcGF0aHMgaW4gdGhlIG9yZGVyIHRoZXlcbiAgICAvLyB3YW50IHRoZW0gdHJpZWQuXG4gICAgYVthLmxlbmd0aCAtIDFdIC0gYltiLmxlbmd0aCAtIDFdXG4gICkgOiAoXG4gICAgLy8gT3RoZXJ3aXNlLCBpdCBkb2Vzbid0IHJlYWxseSBtYWtlIHNlbnNlIHRvIHJhbmsgbm9uLXNpYmxpbmdzIGJ5IGluZGV4LFxuICAgIC8vIHNvIHRoZXkgc29ydCBlcXVhbGx5LlxuICAgIDBcbiAgKTtcbn1cbmZ1bmN0aW9uIG1hdGNoUm91dGVCcmFuY2goYnJhbmNoLCBwYXRobmFtZSwgYWxsb3dQYXJ0aWFsID0gZmFsc2UpIHtcbiAgbGV0IHsgcm91dGVzTWV0YSB9ID0gYnJhbmNoO1xuICBsZXQgbWF0Y2hlZFBhcmFtcyA9IHt9O1xuICBsZXQgbWF0Y2hlZFBhdGhuYW1lID0gXCIvXCI7XG4gIGxldCBtYXRjaGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGVzTWV0YS5sZW5ndGg7ICsraSkge1xuICAgIGxldCBtZXRhID0gcm91dGVzTWV0YVtpXTtcbiAgICBsZXQgZW5kID0gaSA9PT0gcm91dGVzTWV0YS5sZW5ndGggLSAxO1xuICAgIGxldCByZW1haW5pbmdQYXRobmFtZSA9IG1hdGNoZWRQYXRobmFtZSA9PT0gXCIvXCIgPyBwYXRobmFtZSA6IHBhdGhuYW1lLnNsaWNlKG1hdGNoZWRQYXRobmFtZS5sZW5ndGgpIHx8IFwiL1wiO1xuICAgIGxldCBtYXRjaCA9IG1hdGNoUGF0aChcbiAgICAgIHsgcGF0aDogbWV0YS5yZWxhdGl2ZVBhdGgsIGNhc2VTZW5zaXRpdmU6IG1ldGEuY2FzZVNlbnNpdGl2ZSwgZW5kIH0sXG4gICAgICByZW1haW5pbmdQYXRobmFtZVxuICAgICk7XG4gICAgbGV0IHJvdXRlID0gbWV0YS5yb3V0ZTtcbiAgICBpZiAoIW1hdGNoICYmIGVuZCAmJiBhbGxvd1BhcnRpYWwgJiYgIXJvdXRlc01ldGFbcm91dGVzTWV0YS5sZW5ndGggLSAxXS5yb3V0ZS5pbmRleCkge1xuICAgICAgbWF0Y2ggPSBtYXRjaFBhdGgoXG4gICAgICAgIHtcbiAgICAgICAgICBwYXRoOiBtZXRhLnJlbGF0aXZlUGF0aCxcbiAgICAgICAgICBjYXNlU2Vuc2l0aXZlOiBtZXRhLmNhc2VTZW5zaXRpdmUsXG4gICAgICAgICAgZW5kOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICByZW1haW5pbmdQYXRobmFtZVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24obWF0Y2hlZFBhcmFtcywgbWF0Y2gucGFyYW1zKTtcbiAgICBtYXRjaGVzLnB1c2goe1xuICAgICAgLy8gVE9ETzogQ2FuIHRoaXMgYXMgYmUgYXZvaWRlZD9cbiAgICAgIHBhcmFtczogbWF0Y2hlZFBhcmFtcyxcbiAgICAgIHBhdGhuYW1lOiBqb2luUGF0aHMoW21hdGNoZWRQYXRobmFtZSwgbWF0Y2gucGF0aG5hbWVdKSxcbiAgICAgIHBhdGhuYW1lQmFzZTogbm9ybWFsaXplUGF0aG5hbWUoXG4gICAgICAgIGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZUJhc2VdKVxuICAgICAgKSxcbiAgICAgIHJvdXRlXG4gICAgfSk7XG4gICAgaWYgKG1hdGNoLnBhdGhuYW1lQmFzZSAhPT0gXCIvXCIpIHtcbiAgICAgIG1hdGNoZWRQYXRobmFtZSA9IGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZUJhc2VdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVBhdGgob3JpZ2luYWxQYXRoLCBwYXJhbXMgPSB7fSkge1xuICBsZXQgcGF0aCA9IG9yaWdpbmFsUGF0aDtcbiAgaWYgKHBhdGguZW5kc1dpdGgoXCIqXCIpICYmIHBhdGggIT09IFwiKlwiICYmICFwYXRoLmVuZHNXaXRoKFwiLypcIikpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgZmFsc2UsXG4gICAgICBgUm91dGUgcGF0aCBcIiR7cGF0aH1cIiB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgaXQgd2VyZSBcIiR7cGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKX1cIiBiZWNhdXNlIHRoZSBcXGAqXFxgIGNoYXJhY3RlciBtdXN0IGFsd2F5cyBmb2xsb3cgYSBcXGAvXFxgIGluIHRoZSBwYXR0ZXJuLiBUbyBnZXQgcmlkIG9mIHRoaXMgd2FybmluZywgcGxlYXNlIGNoYW5nZSB0aGUgcm91dGUgcGF0aCB0byBcIiR7cGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKX1cIi5gXG4gICAgKTtcbiAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKTtcbiAgfVxuICBjb25zdCBwcmVmaXggPSBwYXRoLnN0YXJ0c1dpdGgoXCIvXCIpID8gXCIvXCIgOiBcIlwiO1xuICBjb25zdCBzdHJpbmdpZnkyID0gKHApID0+IHAgPT0gbnVsbCA/IFwiXCIgOiB0eXBlb2YgcCA9PT0gXCJzdHJpbmdcIiA/IHAgOiBTdHJpbmcocCk7XG4gIGNvbnN0IHNlZ21lbnRzID0gcGF0aC5zcGxpdCgvXFwvKy8pLm1hcCgoc2VnbWVudCwgaW5kZXgsIGFycmF5KSA9PiB7XG4gICAgY29uc3QgaXNMYXN0U2VnbWVudCA9IGluZGV4ID09PSBhcnJheS5sZW5ndGggLSAxO1xuICAgIGlmIChpc0xhc3RTZWdtZW50ICYmIHNlZ21lbnQgPT09IFwiKlwiKSB7XG4gICAgICBjb25zdCBzdGFyID0gXCIqXCI7XG4gICAgICByZXR1cm4gc3RyaW5naWZ5MihwYXJhbXNbc3Rhcl0pO1xuICAgIH1cbiAgICBjb25zdCBrZXlNYXRjaCA9IHNlZ21lbnQubWF0Y2goL146KFtcXHctXSspKFxcPz8pJC8pO1xuICAgIGlmIChrZXlNYXRjaCkge1xuICAgICAgY29uc3QgWywga2V5LCBvcHRpb25hbF0gPSBrZXlNYXRjaDtcbiAgICAgIGxldCBwYXJhbSA9IHBhcmFtc1trZXldO1xuICAgICAgaW52YXJpYW50KG9wdGlvbmFsID09PSBcIj9cIiB8fCBwYXJhbSAhPSBudWxsLCBgTWlzc2luZyBcIjoke2tleX1cIiBwYXJhbWApO1xuICAgICAgcmV0dXJuIHN0cmluZ2lmeTIocGFyYW0pO1xuICAgIH1cbiAgICByZXR1cm4gc2VnbWVudC5yZXBsYWNlKC9cXD8kL2csIFwiXCIpO1xuICB9KS5maWx0ZXIoKHNlZ21lbnQpID0+ICEhc2VnbWVudCk7XG4gIHJldHVybiBwcmVmaXggKyBzZWdtZW50cy5qb2luKFwiL1wiKTtcbn1cbmZ1bmN0aW9uIG1hdGNoUGF0aChwYXR0ZXJuLCBwYXRobmFtZSkge1xuICBpZiAodHlwZW9mIHBhdHRlcm4gPT09IFwic3RyaW5nXCIpIHtcbiAgICBwYXR0ZXJuID0geyBwYXRoOiBwYXR0ZXJuLCBjYXNlU2Vuc2l0aXZlOiBmYWxzZSwgZW5kOiB0cnVlIH07XG4gIH1cbiAgbGV0IFttYXRjaGVyLCBjb21waWxlZFBhcmFtc10gPSBjb21waWxlUGF0aChcbiAgICBwYXR0ZXJuLnBhdGgsXG4gICAgcGF0dGVybi5jYXNlU2Vuc2l0aXZlLFxuICAgIHBhdHRlcm4uZW5kXG4gICk7XG4gIGxldCBtYXRjaCA9IHBhdGhuYW1lLm1hdGNoKG1hdGNoZXIpO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcbiAgbGV0IG1hdGNoZWRQYXRobmFtZSA9IG1hdGNoWzBdO1xuICBsZXQgcGF0aG5hbWVCYXNlID0gbWF0Y2hlZFBhdGhuYW1lLnJlcGxhY2UoLyguKVxcLyskLywgXCIkMVwiKTtcbiAgbGV0IGNhcHR1cmVHcm91cHMgPSBtYXRjaC5zbGljZSgxKTtcbiAgbGV0IHBhcmFtcyA9IGNvbXBpbGVkUGFyYW1zLnJlZHVjZShcbiAgICAobWVtbzIsIHsgcGFyYW1OYW1lLCBpc09wdGlvbmFsIH0sIGluZGV4KSA9PiB7XG4gICAgICBpZiAocGFyYW1OYW1lID09PSBcIipcIikge1xuICAgICAgICBsZXQgc3BsYXRWYWx1ZSA9IGNhcHR1cmVHcm91cHNbaW5kZXhdIHx8IFwiXCI7XG4gICAgICAgIHBhdGhuYW1lQmFzZSA9IG1hdGNoZWRQYXRobmFtZS5zbGljZSgwLCBtYXRjaGVkUGF0aG5hbWUubGVuZ3RoIC0gc3BsYXRWYWx1ZS5sZW5ndGgpLnJlcGxhY2UoLyguKVxcLyskLywgXCIkMVwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gY2FwdHVyZUdyb3Vwc1tpbmRleF07XG4gICAgICBpZiAoaXNPcHRpb25hbCAmJiAhdmFsdWUpIHtcbiAgICAgICAgbWVtbzJbcGFyYW1OYW1lXSA9IHZvaWQgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lbW8yW3BhcmFtTmFtZV0gPSAodmFsdWUgfHwgXCJcIikucmVwbGFjZSgvJTJGL2csIFwiL1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZW1vMjtcbiAgICB9LFxuICAgIHt9XG4gICk7XG4gIHJldHVybiB7XG4gICAgcGFyYW1zLFxuICAgIHBhdGhuYW1lOiBtYXRjaGVkUGF0aG5hbWUsXG4gICAgcGF0aG5hbWVCYXNlLFxuICAgIHBhdHRlcm5cbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbXBpbGVQYXRoKHBhdGgsIGNhc2VTZW5zaXRpdmUgPSBmYWxzZSwgZW5kID0gdHJ1ZSkge1xuICB3YXJuaW5nKFxuICAgIHBhdGggPT09IFwiKlwiIHx8ICFwYXRoLmVuZHNXaXRoKFwiKlwiKSB8fCBwYXRoLmVuZHNXaXRoKFwiLypcIiksXG4gICAgYFJvdXRlIHBhdGggXCIke3BhdGh9XCIgd2lsbCBiZSB0cmVhdGVkIGFzIGlmIGl0IHdlcmUgXCIke3BhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIil9XCIgYmVjYXVzZSB0aGUgXFxgKlxcYCBjaGFyYWN0ZXIgbXVzdCBhbHdheXMgZm9sbG93IGEgXFxgL1xcYCBpbiB0aGUgcGF0dGVybi4gVG8gZ2V0IHJpZCBvZiB0aGlzIHdhcm5pbmcsIHBsZWFzZSBjaGFuZ2UgdGhlIHJvdXRlIHBhdGggdG8gXCIke3BhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIil9XCIuYFxuICApO1xuICBsZXQgcGFyYW1zID0gW107XG4gIGxldCByZWdleHBTb3VyY2UgPSBcIl5cIiArIHBhdGgucmVwbGFjZSgvXFwvKlxcKj8kLywgXCJcIikucmVwbGFjZSgvXlxcLyovLCBcIi9cIikucmVwbGFjZSgvW1xcXFwuKiteJHt9fCgpW1xcXV0vZywgXCJcXFxcJCZcIikucmVwbGFjZShcbiAgICAvXFwvOihbXFx3LV0rKShcXD8pPy9nLFxuICAgIChfLCBwYXJhbU5hbWUsIGlzT3B0aW9uYWwpID0+IHtcbiAgICAgIHBhcmFtcy5wdXNoKHsgcGFyYW1OYW1lLCBpc09wdGlvbmFsOiBpc09wdGlvbmFsICE9IG51bGwgfSk7XG4gICAgICByZXR1cm4gaXNPcHRpb25hbCA/IFwiLz8oW15cXFxcL10rKT9cIiA6IFwiLyhbXlxcXFwvXSspXCI7XG4gICAgfVxuICApO1xuICBpZiAocGF0aC5lbmRzV2l0aChcIipcIikpIHtcbiAgICBwYXJhbXMucHVzaCh7IHBhcmFtTmFtZTogXCIqXCIgfSk7XG4gICAgcmVnZXhwU291cmNlICs9IHBhdGggPT09IFwiKlwiIHx8IHBhdGggPT09IFwiLypcIiA/IFwiKC4qKSRcIiA6IFwiKD86XFxcXC8oLispfFxcXFwvKikkXCI7XG4gIH0gZWxzZSBpZiAoZW5kKSB7XG4gICAgcmVnZXhwU291cmNlICs9IFwiXFxcXC8qJFwiO1xuICB9IGVsc2UgaWYgKHBhdGggIT09IFwiXCIgJiYgcGF0aCAhPT0gXCIvXCIpIHtcbiAgICByZWdleHBTb3VyY2UgKz0gXCIoPzooPz1cXFxcL3wkKSlcIjtcbiAgfSBlbHNlIHtcbiAgfVxuICBsZXQgbWF0Y2hlciA9IG5ldyBSZWdFeHAocmVnZXhwU291cmNlLCBjYXNlU2Vuc2l0aXZlID8gdm9pZCAwIDogXCJpXCIpO1xuICByZXR1cm4gW21hdGNoZXIsIHBhcmFtc107XG59XG5mdW5jdGlvbiBkZWNvZGVQYXRoKHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHZhbHVlLnNwbGl0KFwiL1wiKS5tYXAoKHYpID0+IGRlY29kZVVSSUNvbXBvbmVudCh2KS5yZXBsYWNlKC9cXC8vZywgXCIlMkZcIikpLmpvaW4oXCIvXCIpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHdhcm5pbmcoXG4gICAgICBmYWxzZSxcbiAgICAgIGBUaGUgVVJMIHBhdGggXCIke3ZhbHVlfVwiIGNvdWxkIG5vdCBiZSBkZWNvZGVkIGJlY2F1c2UgaXQgaXMgYSBtYWxmb3JtZWQgVVJMIHNlZ21lbnQuIFRoaXMgaXMgcHJvYmFibHkgZHVlIHRvIGEgYmFkIHBlcmNlbnQgZW5jb2RpbmcgKCR7ZXJyb3J9KS5gXG4gICAgKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIHN0cmlwQmFzZW5hbWUocGF0aG5hbWUsIGJhc2VuYW1lKSB7XG4gIGlmIChiYXNlbmFtZSA9PT0gXCIvXCIpIHJldHVybiBwYXRobmFtZTtcbiAgaWYgKCFwYXRobmFtZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoYmFzZW5hbWUudG9Mb3dlckNhc2UoKSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsZXQgc3RhcnRJbmRleCA9IGJhc2VuYW1lLmVuZHNXaXRoKFwiL1wiKSA/IGJhc2VuYW1lLmxlbmd0aCAtIDEgOiBiYXNlbmFtZS5sZW5ndGg7XG4gIGxldCBuZXh0Q2hhciA9IHBhdGhuYW1lLmNoYXJBdChzdGFydEluZGV4KTtcbiAgaWYgKG5leHRDaGFyICYmIG5leHRDaGFyICE9PSBcIi9cIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBwYXRobmFtZS5zbGljZShzdGFydEluZGV4KSB8fCBcIi9cIjtcbn1cbmZ1bmN0aW9uIHJlc29sdmVQYXRoKHRvLCBmcm9tUGF0aG5hbWUgPSBcIi9cIikge1xuICBsZXQge1xuICAgIHBhdGhuYW1lOiB0b1BhdGhuYW1lLFxuICAgIHNlYXJjaCA9IFwiXCIsXG4gICAgaGFzaCA9IFwiXCJcbiAgfSA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0bykgOiB0bztcbiAgbGV0IHBhdGhuYW1lID0gdG9QYXRobmFtZSA/IHRvUGF0aG5hbWUuc3RhcnRzV2l0aChcIi9cIikgPyB0b1BhdGhuYW1lIDogcmVzb2x2ZVBhdGhuYW1lKHRvUGF0aG5hbWUsIGZyb21QYXRobmFtZSkgOiBmcm9tUGF0aG5hbWU7XG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBub3JtYWxpemVTZWFyY2goc2VhcmNoKSxcbiAgICBoYXNoOiBub3JtYWxpemVIYXNoKGhhc2gpXG4gIH07XG59XG5mdW5jdGlvbiByZXNvbHZlUGF0aG5hbWUocmVsYXRpdmVQYXRoLCBmcm9tUGF0aG5hbWUpIHtcbiAgbGV0IHNlZ21lbnRzID0gZnJvbVBhdGhuYW1lLnJlcGxhY2UoL1xcLyskLywgXCJcIikuc3BsaXQoXCIvXCIpO1xuICBsZXQgcmVsYXRpdmVTZWdtZW50cyA9IHJlbGF0aXZlUGF0aC5zcGxpdChcIi9cIik7XG4gIHJlbGF0aXZlU2VnbWVudHMuZm9yRWFjaCgoc2VnbWVudCkgPT4ge1xuICAgIGlmIChzZWdtZW50ID09PSBcIi4uXCIpIHtcbiAgICAgIGlmIChzZWdtZW50cy5sZW5ndGggPiAxKSBzZWdtZW50cy5wb3AoKTtcbiAgICB9IGVsc2UgaWYgKHNlZ21lbnQgIT09IFwiLlwiKSB7XG4gICAgICBzZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzZWdtZW50cy5sZW5ndGggPiAxID8gc2VnbWVudHMuam9pbihcIi9cIikgOiBcIi9cIjtcbn1cbmZ1bmN0aW9uIGdldEludmFsaWRQYXRoRXJyb3IoY2hhciwgZmllbGQsIGRlc3QsIHBhdGgpIHtcbiAgcmV0dXJuIGBDYW5ub3QgaW5jbHVkZSBhICcke2NoYXJ9JyBjaGFyYWN0ZXIgaW4gYSBtYW51YWxseSBzcGVjaWZpZWQgXFxgdG8uJHtmaWVsZH1cXGAgZmllbGQgWyR7SlNPTi5zdHJpbmdpZnkoXG4gICAgcGF0aFxuICApfV0uICBQbGVhc2Ugc2VwYXJhdGUgaXQgb3V0IHRvIHRoZSBcXGB0by4ke2Rlc3R9XFxgIGZpZWxkLiBBbHRlcm5hdGl2ZWx5IHlvdSBtYXkgcHJvdmlkZSB0aGUgZnVsbCBwYXRoIGFzIGEgc3RyaW5nIGluIDxMaW5rIHRvPVwiLi4uXCI+IGFuZCB0aGUgcm91dGVyIHdpbGwgcGFyc2UgaXQgZm9yIHlvdS5gO1xufVxuZnVuY3Rpb24gZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMobWF0Y2hlcykge1xuICByZXR1cm4gbWF0Y2hlcy5maWx0ZXIoXG4gICAgKG1hdGNoLCBpbmRleCkgPT4gaW5kZXggPT09IDAgfHwgbWF0Y2gucm91dGUucGF0aCAmJiBtYXRjaC5yb3V0ZS5wYXRoLmxlbmd0aCA+IDBcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldFJlc29sdmVUb01hdGNoZXMobWF0Y2hlcykge1xuICBsZXQgcGF0aE1hdGNoZXMgPSBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyhtYXRjaGVzKTtcbiAgcmV0dXJuIHBhdGhNYXRjaGVzLm1hcChcbiAgICAobWF0Y2gsIGlkeCkgPT4gaWR4ID09PSBwYXRoTWF0Y2hlcy5sZW5ndGggLSAxID8gbWF0Y2gucGF0aG5hbWUgOiBtYXRjaC5wYXRobmFtZUJhc2VcbiAgKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUbyh0b0FyZywgcm91dGVQYXRobmFtZXMsIGxvY2F0aW9uUGF0aG5hbWUsIGlzUGF0aFJlbGF0aXZlID0gZmFsc2UpIHtcbiAgbGV0IHRvO1xuICBpZiAodHlwZW9mIHRvQXJnID09PSBcInN0cmluZ1wiKSB7XG4gICAgdG8gPSBwYXJzZVBhdGgodG9BcmcpO1xuICB9IGVsc2Uge1xuICAgIHRvID0geyAuLi50b0FyZyB9O1xuICAgIGludmFyaWFudChcbiAgICAgICF0by5wYXRobmFtZSB8fCAhdG8ucGF0aG5hbWUuaW5jbHVkZXMoXCI/XCIpLFxuICAgICAgZ2V0SW52YWxpZFBhdGhFcnJvcihcIj9cIiwgXCJwYXRobmFtZVwiLCBcInNlYXJjaFwiLCB0bylcbiAgICApO1xuICAgIGludmFyaWFudChcbiAgICAgICF0by5wYXRobmFtZSB8fCAhdG8ucGF0aG5hbWUuaW5jbHVkZXMoXCIjXCIpLFxuICAgICAgZ2V0SW52YWxpZFBhdGhFcnJvcihcIiNcIiwgXCJwYXRobmFtZVwiLCBcImhhc2hcIiwgdG8pXG4gICAgKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICAhdG8uc2VhcmNoIHx8ICF0by5zZWFyY2guaW5jbHVkZXMoXCIjXCIpLFxuICAgICAgZ2V0SW52YWxpZFBhdGhFcnJvcihcIiNcIiwgXCJzZWFyY2hcIiwgXCJoYXNoXCIsIHRvKVxuICAgICk7XG4gIH1cbiAgbGV0IGlzRW1wdHlQYXRoID0gdG9BcmcgPT09IFwiXCIgfHwgdG8ucGF0aG5hbWUgPT09IFwiXCI7XG4gIGxldCB0b1BhdGhuYW1lID0gaXNFbXB0eVBhdGggPyBcIi9cIiA6IHRvLnBhdGhuYW1lO1xuICBsZXQgZnJvbTtcbiAgaWYgKHRvUGF0aG5hbWUgPT0gbnVsbCkge1xuICAgIGZyb20gPSBsb2NhdGlvblBhdGhuYW1lO1xuICB9IGVsc2Uge1xuICAgIGxldCByb3V0ZVBhdGhuYW1lSW5kZXggPSByb3V0ZVBhdGhuYW1lcy5sZW5ndGggLSAxO1xuICAgIGlmICghaXNQYXRoUmVsYXRpdmUgJiYgdG9QYXRobmFtZS5zdGFydHNXaXRoKFwiLi5cIikpIHtcbiAgICAgIGxldCB0b1NlZ21lbnRzID0gdG9QYXRobmFtZS5zcGxpdChcIi9cIik7XG4gICAgICB3aGlsZSAodG9TZWdtZW50c1swXSA9PT0gXCIuLlwiKSB7XG4gICAgICAgIHRvU2VnbWVudHMuc2hpZnQoKTtcbiAgICAgICAgcm91dGVQYXRobmFtZUluZGV4IC09IDE7XG4gICAgICB9XG4gICAgICB0by5wYXRobmFtZSA9IHRvU2VnbWVudHMuam9pbihcIi9cIik7XG4gICAgfVxuICAgIGZyb20gPSByb3V0ZVBhdGhuYW1lSW5kZXggPj0gMCA/IHJvdXRlUGF0aG5hbWVzW3JvdXRlUGF0aG5hbWVJbmRleF0gOiBcIi9cIjtcbiAgfVxuICBsZXQgcGF0aCA9IHJlc29sdmVQYXRoKHRvLCBmcm9tKTtcbiAgbGV0IGhhc0V4cGxpY2l0VHJhaWxpbmdTbGFzaCA9IHRvUGF0aG5hbWUgJiYgdG9QYXRobmFtZSAhPT0gXCIvXCIgJiYgdG9QYXRobmFtZS5lbmRzV2l0aChcIi9cIik7XG4gIGxldCBoYXNDdXJyZW50VHJhaWxpbmdTbGFzaCA9IChpc0VtcHR5UGF0aCB8fCB0b1BhdGhuYW1lID09PSBcIi5cIikgJiYgbG9jYXRpb25QYXRobmFtZS5lbmRzV2l0aChcIi9cIik7XG4gIGlmICghcGF0aC5wYXRobmFtZS5lbmRzV2l0aChcIi9cIikgJiYgKGhhc0V4cGxpY2l0VHJhaWxpbmdTbGFzaCB8fCBoYXNDdXJyZW50VHJhaWxpbmdTbGFzaCkpIHtcbiAgICBwYXRoLnBhdGhuYW1lICs9IFwiL1wiO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxudmFyIGpvaW5QYXRocyA9IChwYXRocykgPT4gcGF0aHMuam9pbihcIi9cIikucmVwbGFjZSgvXFwvXFwvKy9nLCBcIi9cIik7XG52YXIgbm9ybWFsaXplUGF0aG5hbWUgPSAocGF0aG5hbWUpID0+IHBhdGhuYW1lLnJlcGxhY2UoL1xcLyskLywgXCJcIikucmVwbGFjZSgvXlxcLyovLCBcIi9cIik7XG52YXIgbm9ybWFsaXplU2VhcmNoID0gKHNlYXJjaCkgPT4gIXNlYXJjaCB8fCBzZWFyY2ggPT09IFwiP1wiID8gXCJcIiA6IHNlYXJjaC5zdGFydHNXaXRoKFwiP1wiKSA/IHNlYXJjaCA6IFwiP1wiICsgc2VhcmNoO1xudmFyIG5vcm1hbGl6ZUhhc2ggPSAoaGFzaCkgPT4gIWhhc2ggfHwgaGFzaCA9PT0gXCIjXCIgPyBcIlwiIDogaGFzaC5zdGFydHNXaXRoKFwiI1wiKSA/IGhhc2ggOiBcIiNcIiArIGhhc2g7XG52YXIgRGF0YVdpdGhSZXNwb25zZUluaXQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGRhdGEyLCBpbml0KSB7XG4gICAgdGhpcy50eXBlID0gXCJEYXRhV2l0aFJlc3BvbnNlSW5pdFwiO1xuICAgIHRoaXMuZGF0YSA9IGRhdGEyO1xuICAgIHRoaXMuaW5pdCA9IGluaXQgfHwgbnVsbDtcbiAgfVxufTtcbmZ1bmN0aW9uIGRhdGEoZGF0YTIsIGluaXQpIHtcbiAgcmV0dXJuIG5ldyBEYXRhV2l0aFJlc3BvbnNlSW5pdChcbiAgICBkYXRhMixcbiAgICB0eXBlb2YgaW5pdCA9PT0gXCJudW1iZXJcIiA/IHsgc3RhdHVzOiBpbml0IH0gOiBpbml0XG4gICk7XG59XG52YXIgcmVkaXJlY3QgPSAodXJsLCBpbml0ID0gMzAyKSA9PiB7XG4gIGxldCByZXNwb25zZUluaXQgPSBpbml0O1xuICBpZiAodHlwZW9mIHJlc3BvbnNlSW5pdCA9PT0gXCJudW1iZXJcIikge1xuICAgIHJlc3BvbnNlSW5pdCA9IHsgc3RhdHVzOiByZXNwb25zZUluaXQgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcmVzcG9uc2VJbml0LnN0YXR1cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJlc3BvbnNlSW5pdC5zdGF0dXMgPSAzMDI7XG4gIH1cbiAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhyZXNwb25zZUluaXQuaGVhZGVycyk7XG4gIGhlYWRlcnMuc2V0KFwiTG9jYXRpb25cIiwgdXJsKTtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7IC4uLnJlc3BvbnNlSW5pdCwgaGVhZGVycyB9KTtcbn07XG52YXIgcmVkaXJlY3REb2N1bWVudCA9ICh1cmwsIGluaXQpID0+IHtcbiAgbGV0IHJlc3BvbnNlID0gcmVkaXJlY3QodXJsLCBpbml0KTtcbiAgcmVzcG9uc2UuaGVhZGVycy5zZXQoXCJYLVJlbWl4LVJlbG9hZC1Eb2N1bWVudFwiLCBcInRydWVcIik7XG4gIHJldHVybiByZXNwb25zZTtcbn07XG52YXIgcmVwbGFjZSA9ICh1cmwsIGluaXQpID0+IHtcbiAgbGV0IHJlc3BvbnNlID0gcmVkaXJlY3QodXJsLCBpbml0KTtcbiAgcmVzcG9uc2UuaGVhZGVycy5zZXQoXCJYLVJlbWl4LVJlcGxhY2VcIiwgXCJ0cnVlXCIpO1xuICByZXR1cm4gcmVzcG9uc2U7XG59O1xudmFyIEVycm9yUmVzcG9uc2VJbXBsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzdGF0dXMsIHN0YXR1c1RleHQsIGRhdGEyLCBpbnRlcm5hbCA9IGZhbHNlKSB7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gc3RhdHVzVGV4dCB8fCBcIlwiO1xuICAgIHRoaXMuaW50ZXJuYWwgPSBpbnRlcm5hbDtcbiAgICBpZiAoZGF0YTIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhpcy5kYXRhID0gZGF0YTIudG9TdHJpbmcoKTtcbiAgICAgIHRoaXMuZXJyb3IgPSBkYXRhMjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kYXRhID0gZGF0YTI7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gaXNSb3V0ZUVycm9yUmVzcG9uc2UoZXJyb3IpIHtcbiAgcmV0dXJuIGVycm9yICE9IG51bGwgJiYgdHlwZW9mIGVycm9yLnN0YXR1cyA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgZXJyb3Iuc3RhdHVzVGV4dCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgZXJyb3IuaW50ZXJuYWwgPT09IFwiYm9vbGVhblwiICYmIFwiZGF0YVwiIGluIGVycm9yO1xufVxuXG4vLyBsaWIvcm91dGVyL3JvdXRlci50c1xudmFyIHZhbGlkTXV0YXRpb25NZXRob2RzQXJyID0gW1xuICBcIlBPU1RcIixcbiAgXCJQVVRcIixcbiAgXCJQQVRDSFwiLFxuICBcIkRFTEVURVwiXG5dO1xudmFyIHZhbGlkTXV0YXRpb25NZXRob2RzID0gbmV3IFNldChcbiAgdmFsaWRNdXRhdGlvbk1ldGhvZHNBcnJcbik7XG52YXIgdmFsaWRSZXF1ZXN0TWV0aG9kc0FyciA9IFtcbiAgXCJHRVRcIixcbiAgLi4udmFsaWRNdXRhdGlvbk1ldGhvZHNBcnJcbl07XG52YXIgdmFsaWRSZXF1ZXN0TWV0aG9kcyA9IG5ldyBTZXQodmFsaWRSZXF1ZXN0TWV0aG9kc0Fycik7XG52YXIgcmVkaXJlY3RTdGF0dXNDb2RlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF0pO1xudmFyIHJlZGlyZWN0UHJlc2VydmVNZXRob2RTdGF0dXNDb2RlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFszMDcsIDMwOF0pO1xudmFyIElETEVfTkFWSUdBVElPTiA9IHtcbiAgc3RhdGU6IFwiaWRsZVwiLFxuICBsb2NhdGlvbjogdm9pZCAwLFxuICBmb3JtTWV0aG9kOiB2b2lkIDAsXG4gIGZvcm1BY3Rpb246IHZvaWQgMCxcbiAgZm9ybUVuY1R5cGU6IHZvaWQgMCxcbiAgZm9ybURhdGE6IHZvaWQgMCxcbiAganNvbjogdm9pZCAwLFxuICB0ZXh0OiB2b2lkIDBcbn07XG52YXIgSURMRV9GRVRDSEVSID0ge1xuICBzdGF0ZTogXCJpZGxlXCIsXG4gIGRhdGE6IHZvaWQgMCxcbiAgZm9ybU1ldGhvZDogdm9pZCAwLFxuICBmb3JtQWN0aW9uOiB2b2lkIDAsXG4gIGZvcm1FbmNUeXBlOiB2b2lkIDAsXG4gIGZvcm1EYXRhOiB2b2lkIDAsXG4gIGpzb246IHZvaWQgMCxcbiAgdGV4dDogdm9pZCAwXG59O1xudmFyIElETEVfQkxPQ0tFUiA9IHtcbiAgc3RhdGU6IFwidW5ibG9ja2VkXCIsXG4gIHByb2NlZWQ6IHZvaWQgMCxcbiAgcmVzZXQ6IHZvaWQgMCxcbiAgbG9jYXRpb246IHZvaWQgMFxufTtcbnZhciBBQlNPTFVURV9VUkxfUkVHRVggPSAvXig/OlthLXpdW2EtejAtOSsuLV0qOnxcXC9cXC8pL2k7XG52YXIgZGVmYXVsdE1hcFJvdXRlUHJvcGVydGllcyA9IChyb3V0ZSkgPT4gKHtcbiAgaGFzRXJyb3JCb3VuZGFyeTogQm9vbGVhbihyb3V0ZS5oYXNFcnJvckJvdW5kYXJ5KVxufSk7XG52YXIgVFJBTlNJVElPTlNfU1RPUkFHRV9LRVkgPSBcInJlbWl4LXJvdXRlci10cmFuc2l0aW9uc1wiO1xudmFyIFJlc2V0TG9hZGVyRGF0YVN5bWJvbCA9IFN5bWJvbChcIlJlc2V0TG9hZGVyRGF0YVwiKTtcbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlcihpbml0KSB7XG4gIGNvbnN0IHJvdXRlcldpbmRvdyA9IGluaXQud2luZG93ID8gaW5pdC53aW5kb3cgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdm9pZCAwO1xuICBjb25zdCBpc0Jyb3dzZXIyID0gdHlwZW9mIHJvdXRlcldpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygcm91dGVyV2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiByb3V0ZXJXaW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgaW52YXJpYW50KFxuICAgIGluaXQucm91dGVzLmxlbmd0aCA+IDAsXG4gICAgXCJZb3UgbXVzdCBwcm92aWRlIGEgbm9uLWVtcHR5IHJvdXRlcyBhcnJheSB0byBjcmVhdGVSb3V0ZXJcIlxuICApO1xuICBsZXQgaHlkcmF0aW9uUm91dGVQcm9wZXJ0aWVzMiA9IGluaXQuaHlkcmF0aW9uUm91dGVQcm9wZXJ0aWVzIHx8IFtdO1xuICBsZXQgbWFwUm91dGVQcm9wZXJ0aWVzMiA9IGluaXQubWFwUm91dGVQcm9wZXJ0aWVzIHx8IGRlZmF1bHRNYXBSb3V0ZVByb3BlcnRpZXM7XG4gIGxldCBtYW5pZmVzdCA9IHt9O1xuICBsZXQgZGF0YVJvdXRlcyA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMoXG4gICAgaW5pdC5yb3V0ZXMsXG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICB2b2lkIDAsXG4gICAgbWFuaWZlc3RcbiAgKTtcbiAgbGV0IGluRmxpZ2h0RGF0YVJvdXRlcztcbiAgbGV0IGJhc2VuYW1lID0gaW5pdC5iYXNlbmFtZSB8fCBcIi9cIjtcbiAgbGV0IGRhdGFTdHJhdGVneUltcGwgPSBpbml0LmRhdGFTdHJhdGVneSB8fCBkZWZhdWx0RGF0YVN0cmF0ZWd5V2l0aE1pZGRsZXdhcmU7XG4gIGxldCBmdXR1cmUgPSB7XG4gICAgdW5zdGFibGVfbWlkZGxld2FyZTogZmFsc2UsXG4gICAgLi4uaW5pdC5mdXR1cmVcbiAgfTtcbiAgbGV0IHVubGlzdGVuSGlzdG9yeSA9IG51bGw7XG4gIGxldCBzdWJzY3JpYmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBzYXZlZFNjcm9sbFBvc2l0aW9uczIgPSBudWxsO1xuICBsZXQgZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkyID0gbnVsbDtcbiAgbGV0IGdldFNjcm9sbFBvc2l0aW9uID0gbnVsbDtcbiAgbGV0IGluaXRpYWxTY3JvbGxSZXN0b3JlZCA9IGluaXQuaHlkcmF0aW9uRGF0YSAhPSBudWxsO1xuICBsZXQgaW5pdGlhbE1hdGNoZXMgPSBtYXRjaFJvdXRlcyhkYXRhUm91dGVzLCBpbml0Lmhpc3RvcnkubG9jYXRpb24sIGJhc2VuYW1lKTtcbiAgbGV0IGluaXRpYWxNYXRjaGVzSXNGT1cgPSBmYWxzZTtcbiAgbGV0IGluaXRpYWxFcnJvcnMgPSBudWxsO1xuICBsZXQgaW5pdGlhbGl6ZWQ7XG4gIGlmIChpbml0aWFsTWF0Y2hlcyA9PSBudWxsICYmICFpbml0LnBhdGNoUm91dGVzT25OYXZpZ2F0aW9uKSB7XG4gICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHtcbiAgICAgIHBhdGhuYW1lOiBpbml0Lmhpc3RvcnkubG9jYXRpb24ucGF0aG5hbWVcbiAgICB9KTtcbiAgICBsZXQgeyBtYXRjaGVzLCByb3V0ZSB9ID0gZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhkYXRhUm91dGVzKTtcbiAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgaW5pdGlhbE1hdGNoZXMgPSBtYXRjaGVzO1xuICAgIGluaXRpYWxFcnJvcnMgPSB7IFtyb3V0ZS5pZF06IGVycm9yIH07XG4gIH0gZWxzZSB7XG4gICAgaWYgKGluaXRpYWxNYXRjaGVzICYmICFpbml0Lmh5ZHJhdGlvbkRhdGEpIHtcbiAgICAgIGxldCBmb2dPZldhciA9IGNoZWNrRm9nT2ZXYXIoXG4gICAgICAgIGluaXRpYWxNYXRjaGVzLFxuICAgICAgICBkYXRhUm91dGVzLFxuICAgICAgICBpbml0Lmhpc3RvcnkubG9jYXRpb24ucGF0aG5hbWVcbiAgICAgICk7XG4gICAgICBpZiAoZm9nT2ZXYXIuYWN0aXZlKSB7XG4gICAgICAgIGluaXRpYWxNYXRjaGVzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpbml0aWFsTWF0Y2hlcykge1xuICAgICAgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgIGluaXRpYWxNYXRjaGVzID0gW107XG4gICAgICBsZXQgZm9nT2ZXYXIgPSBjaGVja0ZvZ09mV2FyKFxuICAgICAgICBudWxsLFxuICAgICAgICBkYXRhUm91dGVzLFxuICAgICAgICBpbml0Lmhpc3RvcnkubG9jYXRpb24ucGF0aG5hbWVcbiAgICAgICk7XG4gICAgICBpZiAoZm9nT2ZXYXIuYWN0aXZlICYmIGZvZ09mV2FyLm1hdGNoZXMpIHtcbiAgICAgICAgaW5pdGlhbE1hdGNoZXNJc0ZPVyA9IHRydWU7XG4gICAgICAgIGluaXRpYWxNYXRjaGVzID0gZm9nT2ZXYXIubWF0Y2hlcztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGluaXRpYWxNYXRjaGVzLnNvbWUoKG0pID0+IG0ucm91dGUubGF6eSkpIHtcbiAgICAgIGluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICghaW5pdGlhbE1hdGNoZXMuc29tZSgobSkgPT4gbS5yb3V0ZS5sb2FkZXIpKSB7XG4gICAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBsb2FkZXJEYXRhID0gaW5pdC5oeWRyYXRpb25EYXRhID8gaW5pdC5oeWRyYXRpb25EYXRhLmxvYWRlckRhdGEgOiBudWxsO1xuICAgICAgbGV0IGVycm9ycyA9IGluaXQuaHlkcmF0aW9uRGF0YSA/IGluaXQuaHlkcmF0aW9uRGF0YS5lcnJvcnMgOiBudWxsO1xuICAgICAgaWYgKGVycm9ycykge1xuICAgICAgICBsZXQgaWR4ID0gaW5pdGlhbE1hdGNoZXMuZmluZEluZGV4KFxuICAgICAgICAgIChtKSA9PiBlcnJvcnNbbS5yb3V0ZS5pZF0gIT09IHZvaWQgMFxuICAgICAgICApO1xuICAgICAgICBpbml0aWFsaXplZCA9IGluaXRpYWxNYXRjaGVzLnNsaWNlKDAsIGlkeCArIDEpLmV2ZXJ5KFxuICAgICAgICAgIChtKSA9PiAhc2hvdWxkTG9hZFJvdXRlT25IeWRyYXRpb24obS5yb3V0ZSwgbG9hZGVyRGF0YSwgZXJyb3JzKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdGlhbGl6ZWQgPSBpbml0aWFsTWF0Y2hlcy5ldmVyeShcbiAgICAgICAgICAobSkgPT4gIXNob3VsZExvYWRSb3V0ZU9uSHlkcmF0aW9uKG0ucm91dGUsIGxvYWRlckRhdGEsIGVycm9ycylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IHJvdXRlcjtcbiAgbGV0IHN0YXRlID0ge1xuICAgIGhpc3RvcnlBY3Rpb246IGluaXQuaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGluaXQuaGlzdG9yeS5sb2NhdGlvbixcbiAgICBtYXRjaGVzOiBpbml0aWFsTWF0Y2hlcyxcbiAgICBpbml0aWFsaXplZCxcbiAgICBuYXZpZ2F0aW9uOiBJRExFX05BVklHQVRJT04sXG4gICAgLy8gRG9uJ3QgcmVzdG9yZSBvbiBpbml0aWFsIHVwZGF0ZVN0YXRlKCkgaWYgd2Ugd2VyZSBTU1InZFxuICAgIHJlc3RvcmVTY3JvbGxQb3NpdGlvbjogaW5pdC5oeWRyYXRpb25EYXRhICE9IG51bGwgPyBmYWxzZSA6IG51bGwsXG4gICAgcHJldmVudFNjcm9sbFJlc2V0OiBmYWxzZSxcbiAgICByZXZhbGlkYXRpb246IFwiaWRsZVwiLFxuICAgIGxvYWRlckRhdGE6IGluaXQuaHlkcmF0aW9uRGF0YSAmJiBpbml0Lmh5ZHJhdGlvbkRhdGEubG9hZGVyRGF0YSB8fCB7fSxcbiAgICBhY3Rpb25EYXRhOiBpbml0Lmh5ZHJhdGlvbkRhdGEgJiYgaW5pdC5oeWRyYXRpb25EYXRhLmFjdGlvbkRhdGEgfHwgbnVsbCxcbiAgICBlcnJvcnM6IGluaXQuaHlkcmF0aW9uRGF0YSAmJiBpbml0Lmh5ZHJhdGlvbkRhdGEuZXJyb3JzIHx8IGluaXRpYWxFcnJvcnMsXG4gICAgZmV0Y2hlcnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgYmxvY2tlcnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKClcbiAgfTtcbiAgbGV0IHBlbmRpbmdBY3Rpb24gPSBcIlBPUFwiIC8qIFBvcCAqLztcbiAgbGV0IHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPSBmYWxzZTtcbiAgbGV0IHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlcjtcbiAgbGV0IHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQgPSBmYWxzZTtcbiAgbGV0IGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBsZXQgcmVtb3ZlUGFnZUhpZGVFdmVudExpc3RlbmVyID0gbnVsbDtcbiAgbGV0IGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiA9IGZhbHNlO1xuICBsZXQgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IGZhbHNlO1xuICBsZXQgY2FuY2VsbGVkRmV0Y2hlckxvYWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgbGV0IGZldGNoQ29udHJvbGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBsZXQgaW5jcmVtZW50aW5nTG9hZElkID0gMDtcbiAgbGV0IHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkID0gLTE7XG4gIGxldCBmZXRjaFJlbG9hZElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGxldCBmZXRjaFJlZGlyZWN0SWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgbGV0IGZldGNoTG9hZE1hdGNoZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBsZXQgYWN0aXZlRmV0Y2hlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBsZXQgZmV0Y2hlcnNRdWV1ZWRGb3JEZWxldGlvbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBibG9ja2VyRnVuY3Rpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IHVuYmxvY2tCbG9ja2VySGlzdG9yeVVwZGF0ZSA9IHZvaWQgMDtcbiAgbGV0IHBlbmRpbmdSZXZhbGlkYXRpb25EZmQgPSBudWxsO1xuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIHVubGlzdGVuSGlzdG9yeSA9IGluaXQuaGlzdG9yeS5saXN0ZW4oXG4gICAgICAoeyBhY3Rpb246IGhpc3RvcnlBY3Rpb24sIGxvY2F0aW9uLCBkZWx0YSB9KSA9PiB7XG4gICAgICAgIGlmICh1bmJsb2NrQmxvY2tlckhpc3RvcnlVcGRhdGUpIHtcbiAgICAgICAgICB1bmJsb2NrQmxvY2tlckhpc3RvcnlVcGRhdGUoKTtcbiAgICAgICAgICB1bmJsb2NrQmxvY2tlckhpc3RvcnlVcGRhdGUgPSB2b2lkIDA7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgYmxvY2tlckZ1bmN0aW9ucy5zaXplID09PSAwIHx8IGRlbHRhICE9IG51bGwsXG4gICAgICAgICAgXCJZb3UgYXJlIHRyeWluZyB0byB1c2UgYSBibG9ja2VyIG9uIGEgUE9QIG5hdmlnYXRpb24gdG8gYSBsb2NhdGlvbiB0aGF0IHdhcyBub3QgY3JlYXRlZCBieSBAcmVtaXgtcnVuL3JvdXRlci4gVGhpcyB3aWxsIGZhaWwgc2lsZW50bHkgaW4gcHJvZHVjdGlvbi4gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBhcmUgbmF2aWdhdGluZyBvdXRzaWRlIHRoZSByb3V0ZXIgdmlhIGB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGVgL2B3aW5kb3cubG9jYXRpb24uaGFzaGAgaW5zdGVhZCBvZiB1c2luZyByb3V0ZXIgbmF2aWdhdGlvbiBBUElzLiAgVGhpcyBjYW4gYWxzbyBoYXBwZW4gaWYgeW91IGFyZSB1c2luZyBjcmVhdGVIYXNoUm91dGVyIGFuZCB0aGUgdXNlciBtYW51YWxseSBjaGFuZ2VzIHRoZSBVUkwuXCJcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IGJsb2NrZXJLZXkgPSBzaG91bGRCbG9ja05hdmlnYXRpb24oe1xuICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICAgICAgbmV4dExvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICBoaXN0b3J5QWN0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYmxvY2tlcktleSAmJiBkZWx0YSAhPSBudWxsKSB7XG4gICAgICAgICAgbGV0IG5leHRIaXN0b3J5VXBkYXRlUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICB1bmJsb2NrQmxvY2tlckhpc3RvcnlVcGRhdGUgPSByZXNvbHZlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGluaXQuaGlzdG9yeS5nbyhkZWx0YSAqIC0xKTtcbiAgICAgICAgICB1cGRhdGVCbG9ja2VyKGJsb2NrZXJLZXksIHtcbiAgICAgICAgICAgIHN0YXRlOiBcImJsb2NrZWRcIixcbiAgICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgICAgcHJvY2VlZCgpIHtcbiAgICAgICAgICAgICAgdXBkYXRlQmxvY2tlcihibG9ja2VyS2V5LCB7XG4gICAgICAgICAgICAgICAgc3RhdGU6IFwicHJvY2VlZGluZ1wiLFxuICAgICAgICAgICAgICAgIHByb2NlZWQ6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICByZXNldDogdm9pZCAwLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBuZXh0SGlzdG9yeVVwZGF0ZVByb21pc2UudGhlbigoKSA9PiBpbml0Lmhpc3RvcnkuZ28oZGVsdGEpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICAgICAgbGV0IGJsb2NrZXJzID0gbmV3IE1hcChzdGF0ZS5ibG9ja2Vycyk7XG4gICAgICAgICAgICAgIGJsb2NrZXJzLnNldChibG9ja2VyS2V5LCBJRExFX0JMT0NLRVIpO1xuICAgICAgICAgICAgICB1cGRhdGVTdGF0ZSh7IGJsb2NrZXJzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhcnROYXZpZ2F0aW9uKGhpc3RvcnlBY3Rpb24sIGxvY2F0aW9uKTtcbiAgICAgIH1cbiAgICApO1xuICAgIGlmIChpc0Jyb3dzZXIyKSB7XG4gICAgICByZXN0b3JlQXBwbGllZFRyYW5zaXRpb25zKHJvdXRlcldpbmRvdywgYXBwbGllZFZpZXdUcmFuc2l0aW9ucyk7XG4gICAgICBsZXQgX3NhdmVBcHBsaWVkVHJhbnNpdGlvbnMgPSAoKSA9PiBwZXJzaXN0QXBwbGllZFRyYW5zaXRpb25zKHJvdXRlcldpbmRvdywgYXBwbGllZFZpZXdUcmFuc2l0aW9ucyk7XG4gICAgICByb3V0ZXJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIF9zYXZlQXBwbGllZFRyYW5zaXRpb25zKTtcbiAgICAgIHJlbW92ZVBhZ2VIaWRlRXZlbnRMaXN0ZW5lciA9ICgpID0+IHJvdXRlcldpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgX3NhdmVBcHBsaWVkVHJhbnNpdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoIXN0YXRlLmluaXRpYWxpemVkKSB7XG4gICAgICBzdGFydE5hdmlnYXRpb24oXCJQT1BcIiAvKiBQb3AgKi8sIHN0YXRlLmxvY2F0aW9uLCB7XG4gICAgICAgIGluaXRpYWxIeWRyYXRpb246IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcm91dGVyO1xuICB9XG4gIGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHVubGlzdGVuSGlzdG9yeSkge1xuICAgICAgdW5saXN0ZW5IaXN0b3J5KCk7XG4gICAgfVxuICAgIGlmIChyZW1vdmVQYWdlSGlkZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHJlbW92ZVBhZ2VIaWRlRXZlbnRMaXN0ZW5lcigpO1xuICAgIH1cbiAgICBzdWJzY3JpYmVycy5jbGVhcigpO1xuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciAmJiBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICBzdGF0ZS5mZXRjaGVycy5mb3JFYWNoKChfLCBrZXkpID0+IGRlbGV0ZUZldGNoZXIoa2V5KSk7XG4gICAgc3RhdGUuYmxvY2tlcnMuZm9yRWFjaCgoXywga2V5KSA9PiBkZWxldGVCbG9ja2VyKGtleSkpO1xuICB9XG4gIGZ1bmN0aW9uIHN1YnNjcmliZShmbikge1xuICAgIHN1YnNjcmliZXJzLmFkZChmbik7XG4gICAgcmV0dXJuICgpID0+IHN1YnNjcmliZXJzLmRlbGV0ZShmbik7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlU3RhdGUobmV3U3RhdGUsIG9wdHMgPSB7fSkge1xuICAgIHN0YXRlID0ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICAuLi5uZXdTdGF0ZVxuICAgIH07XG4gICAgbGV0IHVubW91bnRlZEZldGNoZXJzID0gW107XG4gICAgbGV0IG1vdW50ZWRGZXRjaGVycyA9IFtdO1xuICAgIHN0YXRlLmZldGNoZXJzLmZvckVhY2goKGZldGNoZXIsIGtleSkgPT4ge1xuICAgICAgaWYgKGZldGNoZXIuc3RhdGUgPT09IFwiaWRsZVwiKSB7XG4gICAgICAgIGlmIChmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uLmhhcyhrZXkpKSB7XG4gICAgICAgICAgdW5tb3VudGVkRmV0Y2hlcnMucHVzaChrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vdW50ZWRGZXRjaGVycy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKCFzdGF0ZS5mZXRjaGVycy5oYXMoa2V5KSAmJiAhZmV0Y2hDb250cm9sbGVycy5oYXMoa2V5KSkge1xuICAgICAgICB1bm1vdW50ZWRGZXRjaGVycy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgWy4uLnN1YnNjcmliZXJzXS5mb3JFYWNoKFxuICAgICAgKHN1YnNjcmliZXIpID0+IHN1YnNjcmliZXIoc3RhdGUsIHtcbiAgICAgICAgZGVsZXRlZEZldGNoZXJzOiB1bm1vdW50ZWRGZXRjaGVycyxcbiAgICAgICAgdmlld1RyYW5zaXRpb25PcHRzOiBvcHRzLnZpZXdUcmFuc2l0aW9uT3B0cyxcbiAgICAgICAgZmx1c2hTeW5jOiBvcHRzLmZsdXNoU3luYyA9PT0gdHJ1ZVxuICAgICAgfSlcbiAgICApO1xuICAgIHVubW91bnRlZEZldGNoZXJzLmZvckVhY2goKGtleSkgPT4gZGVsZXRlRmV0Y2hlcihrZXkpKTtcbiAgICBtb3VudGVkRmV0Y2hlcnMuZm9yRWFjaCgoa2V5KSA9PiBzdGF0ZS5mZXRjaGVycy5kZWxldGUoa2V5KSk7XG4gIH1cbiAgZnVuY3Rpb24gY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCBuZXdTdGF0ZSwgeyBmbHVzaFN5bmMgfSA9IHt9KSB7XG4gICAgbGV0IGlzQWN0aW9uUmVsb2FkID0gc3RhdGUuYWN0aW9uRGF0YSAhPSBudWxsICYmIHN0YXRlLm5hdmlnYXRpb24uZm9ybU1ldGhvZCAhPSBudWxsICYmIGlzTXV0YXRpb25NZXRob2Qoc3RhdGUubmF2aWdhdGlvbi5mb3JtTWV0aG9kKSAmJiBzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlID09PSBcImxvYWRpbmdcIiAmJiBsb2NhdGlvbi5zdGF0ZT8uX2lzUmVkaXJlY3QgIT09IHRydWU7XG4gICAgbGV0IGFjdGlvbkRhdGE7XG4gICAgaWYgKG5ld1N0YXRlLmFjdGlvbkRhdGEpIHtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhuZXdTdGF0ZS5hY3Rpb25EYXRhKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGFjdGlvbkRhdGEgPSBuZXdTdGF0ZS5hY3Rpb25EYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aW9uRGF0YSA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0FjdGlvblJlbG9hZCkge1xuICAgICAgYWN0aW9uRGF0YSA9IHN0YXRlLmFjdGlvbkRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjdGlvbkRhdGEgPSBudWxsO1xuICAgIH1cbiAgICBsZXQgbG9hZGVyRGF0YSA9IG5ld1N0YXRlLmxvYWRlckRhdGEgPyBtZXJnZUxvYWRlckRhdGEoXG4gICAgICBzdGF0ZS5sb2FkZXJEYXRhLFxuICAgICAgbmV3U3RhdGUubG9hZGVyRGF0YSxcbiAgICAgIG5ld1N0YXRlLm1hdGNoZXMgfHwgW10sXG4gICAgICBuZXdTdGF0ZS5lcnJvcnNcbiAgICApIDogc3RhdGUubG9hZGVyRGF0YTtcbiAgICBsZXQgYmxvY2tlcnMgPSBzdGF0ZS5ibG9ja2VycztcbiAgICBpZiAoYmxvY2tlcnMuc2l6ZSA+IDApIHtcbiAgICAgIGJsb2NrZXJzID0gbmV3IE1hcChibG9ja2Vycyk7XG4gICAgICBibG9ja2Vycy5mb3JFYWNoKChfLCBrKSA9PiBibG9ja2Vycy5zZXQoaywgSURMRV9CTE9DS0VSKSk7XG4gICAgfVxuICAgIGxldCBwcmV2ZW50U2Nyb2xsUmVzZXQgPSBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID09PSB0cnVlIHx8IHN0YXRlLm5hdmlnYXRpb24uZm9ybU1ldGhvZCAhPSBudWxsICYmIGlzTXV0YXRpb25NZXRob2Qoc3RhdGUubmF2aWdhdGlvbi5mb3JtTWV0aG9kKSAmJiBsb2NhdGlvbi5zdGF0ZT8uX2lzUmVkaXJlY3QgIT09IHRydWU7XG4gICAgaWYgKGluRmxpZ2h0RGF0YVJvdXRlcykge1xuICAgICAgZGF0YVJvdXRlcyA9IGluRmxpZ2h0RGF0YVJvdXRlcztcbiAgICAgIGluRmxpZ2h0RGF0YVJvdXRlcyA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbikge1xuICAgIH0gZWxzZSBpZiAocGVuZGluZ0FjdGlvbiA9PT0gXCJQT1BcIiAvKiBQb3AgKi8pIHtcbiAgICB9IGVsc2UgaWYgKHBlbmRpbmdBY3Rpb24gPT09IFwiUFVTSFwiIC8qIFB1c2ggKi8pIHtcbiAgICAgIGluaXQuaGlzdG9yeS5wdXNoKGxvY2F0aW9uLCBsb2NhdGlvbi5zdGF0ZSk7XG4gICAgfSBlbHNlIGlmIChwZW5kaW5nQWN0aW9uID09PSBcIlJFUExBQ0VcIiAvKiBSZXBsYWNlICovKSB7XG4gICAgICBpbml0Lmhpc3RvcnkucmVwbGFjZShsb2NhdGlvbiwgbG9jYXRpb24uc3RhdGUpO1xuICAgIH1cbiAgICBsZXQgdmlld1RyYW5zaXRpb25PcHRzO1xuICAgIGlmIChwZW5kaW5nQWN0aW9uID09PSBcIlBPUFwiIC8qIFBvcCAqLykge1xuICAgICAgbGV0IHByaW9yUGF0aHMgPSBhcHBsaWVkVmlld1RyYW5zaXRpb25zLmdldChzdGF0ZS5sb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgICBpZiAocHJpb3JQYXRocyAmJiBwcmlvclBhdGhzLmhhcyhsb2NhdGlvbi5wYXRobmFtZSkpIHtcbiAgICAgICAgdmlld1RyYW5zaXRpb25PcHRzID0ge1xuICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICAgICAgbmV4dExvY2F0aW9uOiBsb2NhdGlvblxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChhcHBsaWVkVmlld1RyYW5zaXRpb25zLmhhcyhsb2NhdGlvbi5wYXRobmFtZSkpIHtcbiAgICAgICAgdmlld1RyYW5zaXRpb25PcHRzID0ge1xuICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgICAgbmV4dExvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvblxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGVuZGluZ1ZpZXdUcmFuc2l0aW9uRW5hYmxlZCkge1xuICAgICAgbGV0IHRvUGF0aHMgPSBhcHBsaWVkVmlld1RyYW5zaXRpb25zLmdldChzdGF0ZS5sb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgICBpZiAodG9QYXRocykge1xuICAgICAgICB0b1BhdGhzLmFkZChsb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b1BhdGhzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW2xvY2F0aW9uLnBhdGhuYW1lXSk7XG4gICAgICAgIGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMuc2V0KHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lLCB0b1BhdGhzKTtcbiAgICAgIH1cbiAgICAgIHZpZXdUcmFuc2l0aW9uT3B0cyA9IHtcbiAgICAgICAgY3VycmVudExvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgICAgbmV4dExvY2F0aW9uOiBsb2NhdGlvblxuICAgICAgfTtcbiAgICB9XG4gICAgdXBkYXRlU3RhdGUoXG4gICAgICB7XG4gICAgICAgIC4uLm5ld1N0YXRlLFxuICAgICAgICAvLyBtYXRjaGVzLCBlcnJvcnMsIGZldGNoZXJzIGdvIHRocm91Z2ggYXMtaXNcbiAgICAgICAgYWN0aW9uRGF0YSxcbiAgICAgICAgbG9hZGVyRGF0YSxcbiAgICAgICAgaGlzdG9yeUFjdGlvbjogcGVuZGluZ0FjdGlvbixcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIGluaXRpYWxpemVkOiB0cnVlLFxuICAgICAgICBuYXZpZ2F0aW9uOiBJRExFX05BVklHQVRJT04sXG4gICAgICAgIHJldmFsaWRhdGlvbjogXCJpZGxlXCIsXG4gICAgICAgIHJlc3RvcmVTY3JvbGxQb3NpdGlvbjogZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbihcbiAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICBuZXdTdGF0ZS5tYXRjaGVzIHx8IHN0YXRlLm1hdGNoZXNcbiAgICAgICAgKSxcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICBibG9ja2Vyc1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdmlld1RyYW5zaXRpb25PcHRzLFxuICAgICAgICBmbHVzaFN5bmM6IGZsdXNoU3luYyA9PT0gdHJ1ZVxuICAgICAgfVxuICAgICk7XG4gICAgcGVuZGluZ0FjdGlvbiA9IFwiUE9QXCIgLyogUG9wICovO1xuICAgIHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPSBmYWxzZTtcbiAgICBwZW5kaW5nVmlld1RyYW5zaXRpb25FbmFibGVkID0gZmFsc2U7XG4gICAgaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uID0gZmFsc2U7XG4gICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IGZhbHNlO1xuICAgIHBlbmRpbmdSZXZhbGlkYXRpb25EZmQ/LnJlc29sdmUoKTtcbiAgICBwZW5kaW5nUmV2YWxpZGF0aW9uRGZkID0gbnVsbDtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBuYXZpZ2F0ZSh0bywgb3B0cykge1xuICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGluaXQuaGlzdG9yeS5nbyh0byk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVRvKFxuICAgICAgc3RhdGUubG9jYXRpb24sXG4gICAgICBzdGF0ZS5tYXRjaGVzLFxuICAgICAgYmFzZW5hbWUsXG4gICAgICB0byxcbiAgICAgIG9wdHM/LmZyb21Sb3V0ZUlkLFxuICAgICAgb3B0cz8ucmVsYXRpdmVcbiAgICApO1xuICAgIGxldCB7IHBhdGgsIHN1Ym1pc3Npb24sIGVycm9yIH0gPSBub3JtYWxpemVOYXZpZ2F0ZU9wdGlvbnMoXG4gICAgICBmYWxzZSxcbiAgICAgIG5vcm1hbGl6ZWRQYXRoLFxuICAgICAgb3B0c1xuICAgICk7XG4gICAgbGV0IGN1cnJlbnRMb2NhdGlvbiA9IHN0YXRlLmxvY2F0aW9uO1xuICAgIGxldCBuZXh0TG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihzdGF0ZS5sb2NhdGlvbiwgcGF0aCwgb3B0cyAmJiBvcHRzLnN0YXRlKTtcbiAgICBuZXh0TG9jYXRpb24gPSB7XG4gICAgICAuLi5uZXh0TG9jYXRpb24sXG4gICAgICAuLi5pbml0Lmhpc3RvcnkuZW5jb2RlTG9jYXRpb24obmV4dExvY2F0aW9uKVxuICAgIH07XG4gICAgbGV0IHVzZXJSZXBsYWNlID0gb3B0cyAmJiBvcHRzLnJlcGxhY2UgIT0gbnVsbCA/IG9wdHMucmVwbGFjZSA6IHZvaWQgMDtcbiAgICBsZXQgaGlzdG9yeUFjdGlvbiA9IFwiUFVTSFwiIC8qIFB1c2ggKi87XG4gICAgaWYgKHVzZXJSZXBsYWNlID09PSB0cnVlKSB7XG4gICAgICBoaXN0b3J5QWN0aW9uID0gXCJSRVBMQUNFXCIgLyogUmVwbGFjZSAqLztcbiAgICB9IGVsc2UgaWYgKHVzZXJSZXBsYWNlID09PSBmYWxzZSkge1xuICAgIH0gZWxzZSBpZiAoc3VibWlzc2lvbiAhPSBudWxsICYmIGlzTXV0YXRpb25NZXRob2Qoc3VibWlzc2lvbi5mb3JtTWV0aG9kKSAmJiBzdWJtaXNzaW9uLmZvcm1BY3Rpb24gPT09IHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lICsgc3RhdGUubG9jYXRpb24uc2VhcmNoKSB7XG4gICAgICBoaXN0b3J5QWN0aW9uID0gXCJSRVBMQUNFXCIgLyogUmVwbGFjZSAqLztcbiAgICB9XG4gICAgbGV0IHByZXZlbnRTY3JvbGxSZXNldCA9IG9wdHMgJiYgXCJwcmV2ZW50U2Nyb2xsUmVzZXRcIiBpbiBvcHRzID8gb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXQgPT09IHRydWUgOiB2b2lkIDA7XG4gICAgbGV0IGZsdXNoU3luYyA9IChvcHRzICYmIG9wdHMuZmx1c2hTeW5jKSA9PT0gdHJ1ZTtcbiAgICBsZXQgYmxvY2tlcktleSA9IHNob3VsZEJsb2NrTmF2aWdhdGlvbih7XG4gICAgICBjdXJyZW50TG9jYXRpb24sXG4gICAgICBuZXh0TG9jYXRpb24sXG4gICAgICBoaXN0b3J5QWN0aW9uXG4gICAgfSk7XG4gICAgaWYgKGJsb2NrZXJLZXkpIHtcbiAgICAgIHVwZGF0ZUJsb2NrZXIoYmxvY2tlcktleSwge1xuICAgICAgICBzdGF0ZTogXCJibG9ja2VkXCIsXG4gICAgICAgIGxvY2F0aW9uOiBuZXh0TG9jYXRpb24sXG4gICAgICAgIHByb2NlZWQoKSB7XG4gICAgICAgICAgdXBkYXRlQmxvY2tlcihibG9ja2VyS2V5LCB7XG4gICAgICAgICAgICBzdGF0ZTogXCJwcm9jZWVkaW5nXCIsXG4gICAgICAgICAgICBwcm9jZWVkOiB2b2lkIDAsXG4gICAgICAgICAgICByZXNldDogdm9pZCAwLFxuICAgICAgICAgICAgbG9jYXRpb246IG5leHRMb2NhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG5hdmlnYXRlKHRvLCBvcHRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgbGV0IGJsb2NrZXJzID0gbmV3IE1hcChzdGF0ZS5ibG9ja2Vycyk7XG4gICAgICAgICAgYmxvY2tlcnMuc2V0KGJsb2NrZXJLZXksIElETEVfQkxPQ0tFUik7XG4gICAgICAgICAgdXBkYXRlU3RhdGUoeyBibG9ja2VycyB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IHN0YXJ0TmF2aWdhdGlvbihoaXN0b3J5QWN0aW9uLCBuZXh0TG9jYXRpb24sIHtcbiAgICAgIHN1Ym1pc3Npb24sXG4gICAgICAvLyBTZW5kIHRocm91Z2ggdGhlIGZvcm1EYXRhIHNlcmlhbGl6YXRpb24gZXJyb3IgaWYgd2UgaGF2ZSBvbmUgc28gd2UgY2FuXG4gICAgICAvLyByZW5kZXIgYXQgdGhlIHJpZ2h0IGVycm9yIGJvdW5kYXJ5IGFmdGVyIHdlIG1hdGNoIHJvdXRlc1xuICAgICAgcGVuZGluZ0Vycm9yOiBlcnJvcixcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIHJlcGxhY2U6IG9wdHMgJiYgb3B0cy5yZXBsYWNlLFxuICAgICAgZW5hYmxlVmlld1RyYW5zaXRpb246IG9wdHMgJiYgb3B0cy52aWV3VHJhbnNpdGlvbixcbiAgICAgIGZsdXNoU3luY1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHJldmFsaWRhdGUoKSB7XG4gICAgaWYgKCFwZW5kaW5nUmV2YWxpZGF0aW9uRGZkKSB7XG4gICAgICBwZW5kaW5nUmV2YWxpZGF0aW9uRGZkID0gY3JlYXRlRGVmZXJyZWQoKTtcbiAgICB9XG4gICAgaW50ZXJydXB0QWN0aXZlTG9hZHMoKTtcbiAgICB1cGRhdGVTdGF0ZSh7IHJldmFsaWRhdGlvbjogXCJsb2FkaW5nXCIgfSk7XG4gICAgbGV0IHByb21pc2UgPSBwZW5kaW5nUmV2YWxpZGF0aW9uRGZkLnByb21pc2U7XG4gICAgaWYgKHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwic3VibWl0dGluZ1wiKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwiaWRsZVwiKSB7XG4gICAgICBzdGFydE5hdmlnYXRpb24oc3RhdGUuaGlzdG9yeUFjdGlvbiwgc3RhdGUubG9jYXRpb24sIHtcbiAgICAgICAgc3RhcnRVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBzdGFydE5hdmlnYXRpb24oXG4gICAgICBwZW5kaW5nQWN0aW9uIHx8IHN0YXRlLmhpc3RvcnlBY3Rpb24sXG4gICAgICBzdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uLFxuICAgICAge1xuICAgICAgICBvdmVycmlkZU5hdmlnYXRpb246IHN0YXRlLm5hdmlnYXRpb24sXG4gICAgICAgIC8vIFByb3h5IHRocm91Z2ggYW55IHJlbmRpbmcgdmlldyB0cmFuc2l0aW9uXG4gICAgICAgIGVuYWJsZVZpZXdUcmFuc2l0aW9uOiBwZW5kaW5nVmlld1RyYW5zaXRpb25FbmFibGVkID09PSB0cnVlXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBzdGFydE5hdmlnYXRpb24oaGlzdG9yeUFjdGlvbiwgbG9jYXRpb24sIG9wdHMpIHtcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgJiYgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLmFib3J0KCk7XG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyID0gbnVsbDtcbiAgICBwZW5kaW5nQWN0aW9uID0gaGlzdG9yeUFjdGlvbjtcbiAgICBpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24gPSAob3B0cyAmJiBvcHRzLnN0YXJ0VW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbikgPT09IHRydWU7XG4gICAgc2F2ZVNjcm9sbFBvc2l0aW9uKHN0YXRlLmxvY2F0aW9uLCBzdGF0ZS5tYXRjaGVzKTtcbiAgICBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID0gKG9wdHMgJiYgb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXQpID09PSB0cnVlO1xuICAgIHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQgPSAob3B0cyAmJiBvcHRzLmVuYWJsZVZpZXdUcmFuc2l0aW9uKSA9PT0gdHJ1ZTtcbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgbG9hZGluZ05hdmlnYXRpb24gPSBvcHRzICYmIG9wdHMub3ZlcnJpZGVOYXZpZ2F0aW9uO1xuICAgIGxldCBtYXRjaGVzID0gb3B0cz8uaW5pdGlhbEh5ZHJhdGlvbiAmJiBzdGF0ZS5tYXRjaGVzICYmIHN0YXRlLm1hdGNoZXMubGVuZ3RoID4gMCAmJiAhaW5pdGlhbE1hdGNoZXNJc0ZPVyA/IChcbiAgICAgIC8vIGBtYXRjaFJvdXRlcygpYCBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCBpZiB3ZSdyZSBpbiBoZXJlIHZpYSBgcm91dGVyLmluaXRpYWxpemUoKWBcbiAgICAgIHN0YXRlLm1hdGNoZXNcbiAgICApIDogbWF0Y2hSb3V0ZXMocm91dGVzVG9Vc2UsIGxvY2F0aW9uLCBiYXNlbmFtZSk7XG4gICAgbGV0IGZsdXNoU3luYyA9IChvcHRzICYmIG9wdHMuZmx1c2hTeW5jKSA9PT0gdHJ1ZTtcbiAgICBpZiAobWF0Y2hlcyAmJiBzdGF0ZS5pbml0aWFsaXplZCAmJiAhaXNSZXZhbGlkYXRpb25SZXF1aXJlZCAmJiBpc0hhc2hDaGFuZ2VPbmx5KHN0YXRlLmxvY2F0aW9uLCBsb2NhdGlvbikgJiYgIShvcHRzICYmIG9wdHMuc3VibWlzc2lvbiAmJiBpc011dGF0aW9uTWV0aG9kKG9wdHMuc3VibWlzc2lvbi5mb3JtTWV0aG9kKSkpIHtcbiAgICAgIGNvbXBsZXRlTmF2aWdhdGlvbihsb2NhdGlvbiwgeyBtYXRjaGVzIH0sIHsgZmx1c2hTeW5jIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZm9nT2ZXYXIgPSBjaGVja0ZvZ09mV2FyKG1hdGNoZXMsIHJvdXRlc1RvVXNlLCBsb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgaWYgKGZvZ09mV2FyLmFjdGl2ZSAmJiBmb2dPZldhci5tYXRjaGVzKSB7XG4gICAgICBtYXRjaGVzID0gZm9nT2ZXYXIubWF0Y2hlcztcbiAgICB9XG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICBsZXQgeyBlcnJvciwgbm90Rm91bmRNYXRjaGVzLCByb3V0ZSB9ID0gaGFuZGxlTmF2aWdhdGlvbmFsNDA0KFxuICAgICAgICBsb2NhdGlvbi5wYXRobmFtZVxuICAgICAgKTtcbiAgICAgIGNvbXBsZXRlTmF2aWdhdGlvbihcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIHtcbiAgICAgICAgICBtYXRjaGVzOiBub3RGb3VuZE1hdGNoZXMsXG4gICAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgICBbcm91dGUuaWRdOiBlcnJvclxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgeyBmbHVzaFN5bmMgfVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxldCByZXF1ZXN0ID0gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoXG4gICAgICBpbml0Lmhpc3RvcnksXG4gICAgICBsb2NhdGlvbixcbiAgICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5zaWduYWwsXG4gICAgICBvcHRzICYmIG9wdHMuc3VibWlzc2lvblxuICAgICk7XG4gICAgbGV0IHNjb3BlZENvbnRleHQgPSBuZXcgdW5zdGFibGVfUm91dGVyQ29udGV4dFByb3ZpZGVyKFxuICAgICAgaW5pdC51bnN0YWJsZV9nZXRDb250ZXh0ID8gYXdhaXQgaW5pdC51bnN0YWJsZV9nZXRDb250ZXh0KCkgOiB2b2lkIDBcbiAgICApO1xuICAgIGxldCBwZW5kaW5nQWN0aW9uUmVzdWx0O1xuICAgIGlmIChvcHRzICYmIG9wdHMucGVuZGluZ0Vycm9yKSB7XG4gICAgICBwZW5kaW5nQWN0aW9uUmVzdWx0ID0gW1xuICAgICAgICBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMpLnJvdXRlLmlkLFxuICAgICAgICB7IHR5cGU6IFwiZXJyb3JcIiAvKiBlcnJvciAqLywgZXJyb3I6IG9wdHMucGVuZGluZ0Vycm9yIH1cbiAgICAgIF07XG4gICAgfSBlbHNlIGlmIChvcHRzICYmIG9wdHMuc3VibWlzc2lvbiAmJiBpc011dGF0aW9uTWV0aG9kKG9wdHMuc3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xuICAgICAgbGV0IGFjdGlvblJlc3VsdCA9IGF3YWl0IGhhbmRsZUFjdGlvbihcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG9wdHMuc3VibWlzc2lvbixcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgc2NvcGVkQ29udGV4dCxcbiAgICAgICAgZm9nT2ZXYXIuYWN0aXZlLFxuICAgICAgICBvcHRzICYmIG9wdHMuaW5pdGlhbEh5ZHJhdGlvbiA9PT0gdHJ1ZSxcbiAgICAgICAgeyByZXBsYWNlOiBvcHRzLnJlcGxhY2UsIGZsdXNoU3luYyB9XG4gICAgICApO1xuICAgICAgaWYgKGFjdGlvblJlc3VsdC5zaG9ydENpcmN1aXRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoYWN0aW9uUmVzdWx0LnBlbmRpbmdBY3Rpb25SZXN1bHQpIHtcbiAgICAgICAgbGV0IFtyb3V0ZUlkLCByZXN1bHRdID0gYWN0aW9uUmVzdWx0LnBlbmRpbmdBY3Rpb25SZXN1bHQ7XG4gICAgICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkgJiYgaXNSb3V0ZUVycm9yUmVzcG9uc2UocmVzdWx0LmVycm9yKSAmJiByZXN1bHQuZXJyb3Iuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBudWxsO1xuICAgICAgICAgIGNvbXBsZXRlTmF2aWdhdGlvbihsb2NhdGlvbiwge1xuICAgICAgICAgICAgbWF0Y2hlczogYWN0aW9uUmVzdWx0Lm1hdGNoZXMsXG4gICAgICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgICAgIGVycm9yczoge1xuICAgICAgICAgICAgICBbcm91dGVJZF06IHJlc3VsdC5lcnJvclxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWF0Y2hlcyA9IGFjdGlvblJlc3VsdC5tYXRjaGVzIHx8IG1hdGNoZXM7XG4gICAgICBwZW5kaW5nQWN0aW9uUmVzdWx0ID0gYWN0aW9uUmVzdWx0LnBlbmRpbmdBY3Rpb25SZXN1bHQ7XG4gICAgICBsb2FkaW5nTmF2aWdhdGlvbiA9IGdldExvYWRpbmdOYXZpZ2F0aW9uKGxvY2F0aW9uLCBvcHRzLnN1Ym1pc3Npb24pO1xuICAgICAgZmx1c2hTeW5jID0gZmFsc2U7XG4gICAgICBmb2dPZldhci5hY3RpdmUgPSBmYWxzZTtcbiAgICAgIHJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChcbiAgICAgICAgaW5pdC5oaXN0b3J5LFxuICAgICAgICByZXF1ZXN0LnVybCxcbiAgICAgICAgcmVxdWVzdC5zaWduYWxcbiAgICAgICk7XG4gICAgfVxuICAgIGxldCB7XG4gICAgICBzaG9ydENpcmN1aXRlZCxcbiAgICAgIG1hdGNoZXM6IHVwZGF0ZWRNYXRjaGVzLFxuICAgICAgbG9hZGVyRGF0YSxcbiAgICAgIGVycm9yc1xuICAgIH0gPSBhd2FpdCBoYW5kbGVMb2FkZXJzKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIHNjb3BlZENvbnRleHQsXG4gICAgICBmb2dPZldhci5hY3RpdmUsXG4gICAgICBsb2FkaW5nTmF2aWdhdGlvbixcbiAgICAgIG9wdHMgJiYgb3B0cy5zdWJtaXNzaW9uLFxuICAgICAgb3B0cyAmJiBvcHRzLmZldGNoZXJTdWJtaXNzaW9uLFxuICAgICAgb3B0cyAmJiBvcHRzLnJlcGxhY2UsXG4gICAgICBvcHRzICYmIG9wdHMuaW5pdGlhbEh5ZHJhdGlvbiA9PT0gdHJ1ZSxcbiAgICAgIGZsdXNoU3luYyxcbiAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHRcbiAgICApO1xuICAgIGlmIChzaG9ydENpcmN1aXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBudWxsO1xuICAgIGNvbXBsZXRlTmF2aWdhdGlvbihsb2NhdGlvbiwge1xuICAgICAgbWF0Y2hlczogdXBkYXRlZE1hdGNoZXMgfHwgbWF0Y2hlcyxcbiAgICAgIC4uLmdldEFjdGlvbkRhdGFGb3JDb21taXQocGVuZGluZ0FjdGlvblJlc3VsdCksXG4gICAgICBsb2FkZXJEYXRhLFxuICAgICAgZXJyb3JzXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlQWN0aW9uKHJlcXVlc3QsIGxvY2F0aW9uLCBzdWJtaXNzaW9uLCBtYXRjaGVzLCBzY29wZWRDb250ZXh0LCBpc0ZvZ09mV2FyLCBpbml0aWFsSHlkcmF0aW9uLCBvcHRzID0ge30pIHtcbiAgICBpbnRlcnJ1cHRBY3RpdmVMb2FkcygpO1xuICAgIGxldCBuYXZpZ2F0aW9uID0gZ2V0U3VibWl0dGluZ05hdmlnYXRpb24obG9jYXRpb24sIHN1Ym1pc3Npb24pO1xuICAgIHVwZGF0ZVN0YXRlKHsgbmF2aWdhdGlvbiB9LCB7IGZsdXNoU3luYzogb3B0cy5mbHVzaFN5bmMgPT09IHRydWUgfSk7XG4gICAgaWYgKGlzRm9nT2ZXYXIpIHtcbiAgICAgIGxldCBkaXNjb3ZlclJlc3VsdCA9IGF3YWl0IGRpc2NvdmVyUm91dGVzKFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgcmVxdWVzdC5zaWduYWxcbiAgICAgICk7XG4gICAgICBpZiAoZGlzY292ZXJSZXN1bHQudHlwZSA9PT0gXCJhYm9ydGVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHsgc2hvcnRDaXJjdWl0ZWQ6IHRydWUgfTtcbiAgICAgIH0gZWxzZSBpZiAoZGlzY292ZXJSZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgIGxldCBib3VuZGFyeUlkID0gZmluZE5lYXJlc3RCb3VuZGFyeShkaXNjb3ZlclJlc3VsdC5wYXJ0aWFsTWF0Y2hlcykucm91dGUuaWQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWF0Y2hlczogZGlzY292ZXJSZXN1bHQucGFydGlhbE1hdGNoZXMsXG4gICAgICAgICAgcGVuZGluZ0FjdGlvblJlc3VsdDogW1xuICAgICAgICAgICAgYm91bmRhcnlJZCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiIC8qIGVycm9yICovLFxuICAgICAgICAgICAgICBlcnJvcjogZGlzY292ZXJSZXN1bHQuZXJyb3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKCFkaXNjb3ZlclJlc3VsdC5tYXRjaGVzKSB7XG4gICAgICAgIGxldCB7IG5vdEZvdW5kTWF0Y2hlcywgZXJyb3IsIHJvdXRlIH0gPSBoYW5kbGVOYXZpZ2F0aW9uYWw0MDQoXG4gICAgICAgICAgbG9jYXRpb24ucGF0aG5hbWVcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtYXRjaGVzOiBub3RGb3VuZE1hdGNoZXMsXG4gICAgICAgICAgcGVuZGluZ0FjdGlvblJlc3VsdDogW1xuICAgICAgICAgICAgcm91dGUuaWQsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIiAvKiBlcnJvciAqLyxcbiAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXRjaGVzID0gZGlzY292ZXJSZXN1bHQubWF0Y2hlcztcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHJlc3VsdDtcbiAgICBsZXQgYWN0aW9uTWF0Y2ggPSBnZXRUYXJnZXRNYXRjaChtYXRjaGVzLCBsb2NhdGlvbik7XG4gICAgaWYgKCFhY3Rpb25NYXRjaC5yb3V0ZS5hY3Rpb24gJiYgIWFjdGlvbk1hdGNoLnJvdXRlLmxhenkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgdHlwZTogXCJlcnJvclwiIC8qIGVycm9yICovLFxuICAgICAgICBlcnJvcjogZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcbiAgICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgICByb3V0ZUlkOiBhY3Rpb25NYXRjaC5yb3V0ZS5pZFxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRzTWF0Y2hlcyA9IGdldFRhcmdldGVkRGF0YVN0cmF0ZWd5TWF0Y2hlcyhcbiAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGFjdGlvbk1hdGNoLFxuICAgICAgICBpbml0aWFsSHlkcmF0aW9uID8gW10gOiBoeWRyYXRpb25Sb3V0ZVByb3BlcnRpZXMyLFxuICAgICAgICBzY29wZWRDb250ZXh0XG4gICAgICApO1xuICAgICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBjYWxsRGF0YVN0cmF0ZWd5KFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBkc01hdGNoZXMsXG4gICAgICAgIHNjb3BlZENvbnRleHQsXG4gICAgICAgIG51bGxcbiAgICAgICk7XG4gICAgICByZXN1bHQgPSByZXN1bHRzW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTtcbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIGZvciAobGV0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICAgICAgICBpZiAocmVzdWx0c1ttYXRjaC5yb3V0ZS5pZF0pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHNbbWF0Y2gucm91dGUuaWRdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgcmVwbGFjZTI7XG4gICAgICBpZiAob3B0cyAmJiBvcHRzLnJlcGxhY2UgIT0gbnVsbCkge1xuICAgICAgICByZXBsYWNlMiA9IG9wdHMucmVwbGFjZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBsb2NhdGlvbjIgPSBub3JtYWxpemVSZWRpcmVjdExvY2F0aW9uKFxuICAgICAgICAgIHJlc3VsdC5yZXNwb25zZS5oZWFkZXJzLmdldChcIkxvY2F0aW9uXCIpLFxuICAgICAgICAgIG5ldyBVUkwocmVxdWVzdC51cmwpLFxuICAgICAgICAgIGJhc2VuYW1lXG4gICAgICAgICk7XG4gICAgICAgIHJlcGxhY2UyID0gbG9jYXRpb24yID09PSBzdGF0ZS5sb2NhdGlvbi5wYXRobmFtZSArIHN0YXRlLmxvY2F0aW9uLnNlYXJjaDtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHJlcXVlc3QsIHJlc3VsdCwgdHJ1ZSwge1xuICAgICAgICBzdWJtaXNzaW9uLFxuICAgICAgICByZXBsYWNlOiByZXBsYWNlMlxuICAgICAgfSk7XG4gICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgIH1cbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hlcywgYWN0aW9uTWF0Y2gucm91dGUuaWQpO1xuICAgICAgaWYgKChvcHRzICYmIG9wdHMucmVwbGFjZSkgIT09IHRydWUpIHtcbiAgICAgICAgcGVuZGluZ0FjdGlvbiA9IFwiUFVTSFwiIC8qIFB1c2ggKi87XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBwZW5kaW5nQWN0aW9uUmVzdWx0OiBbXG4gICAgICAgICAgYm91bmRhcnlNYXRjaC5yb3V0ZS5pZCxcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgYWN0aW9uTWF0Y2gucm91dGUuaWRcbiAgICAgICAgXVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hdGNoZXMsXG4gICAgICBwZW5kaW5nQWN0aW9uUmVzdWx0OiBbYWN0aW9uTWF0Y2gucm91dGUuaWQsIHJlc3VsdF1cbiAgICB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUxvYWRlcnMocmVxdWVzdCwgbG9jYXRpb24sIG1hdGNoZXMsIHNjb3BlZENvbnRleHQsIGlzRm9nT2ZXYXIsIG92ZXJyaWRlTmF2aWdhdGlvbiwgc3VibWlzc2lvbiwgZmV0Y2hlclN1Ym1pc3Npb24sIHJlcGxhY2UyLCBpbml0aWFsSHlkcmF0aW9uLCBmbHVzaFN5bmMsIHBlbmRpbmdBY3Rpb25SZXN1bHQpIHtcbiAgICBsZXQgbG9hZGluZ05hdmlnYXRpb24gPSBvdmVycmlkZU5hdmlnYXRpb24gfHwgZ2V0TG9hZGluZ05hdmlnYXRpb24obG9jYXRpb24sIHN1Ym1pc3Npb24pO1xuICAgIGxldCBhY3RpdmVTdWJtaXNzaW9uID0gc3VibWlzc2lvbiB8fCBmZXRjaGVyU3VibWlzc2lvbiB8fCBnZXRTdWJtaXNzaW9uRnJvbU5hdmlnYXRpb24obG9hZGluZ05hdmlnYXRpb24pO1xuICAgIGxldCBzaG91bGRVcGRhdGVOYXZpZ2F0aW9uU3RhdGUgPSAhaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uICYmICFpbml0aWFsSHlkcmF0aW9uO1xuICAgIGlmIChpc0ZvZ09mV2FyKSB7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlTmF2aWdhdGlvblN0YXRlKSB7XG4gICAgICAgIGxldCBhY3Rpb25EYXRhID0gZ2V0VXBkYXRlZEFjdGlvbkRhdGEocGVuZGluZ0FjdGlvblJlc3VsdCk7XG4gICAgICAgIHVwZGF0ZVN0YXRlKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hdmlnYXRpb246IGxvYWRpbmdOYXZpZ2F0aW9uLFxuICAgICAgICAgICAgLi4uYWN0aW9uRGF0YSAhPT0gdm9pZCAwID8geyBhY3Rpb25EYXRhIH0gOiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgZmx1c2hTeW5jXG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgbGV0IGRpc2NvdmVyUmVzdWx0ID0gYXdhaXQgZGlzY292ZXJSb3V0ZXMoXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICByZXF1ZXN0LnNpZ25hbFxuICAgICAgKTtcbiAgICAgIGlmIChkaXNjb3ZlclJlc3VsdC50eXBlID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgICAgfSBlbHNlIGlmIChkaXNjb3ZlclJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgbGV0IGJvdW5kYXJ5SWQgPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KGRpc2NvdmVyUmVzdWx0LnBhcnRpYWxNYXRjaGVzKS5yb3V0ZS5pZDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtYXRjaGVzOiBkaXNjb3ZlclJlc3VsdC5wYXJ0aWFsTWF0Y2hlcyxcbiAgICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICAgIFtib3VuZGFyeUlkXTogZGlzY292ZXJSZXN1bHQuZXJyb3JcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKCFkaXNjb3ZlclJlc3VsdC5tYXRjaGVzKSB7XG4gICAgICAgIGxldCB7IGVycm9yLCBub3RGb3VuZE1hdGNoZXMsIHJvdXRlIH0gPSBoYW5kbGVOYXZpZ2F0aW9uYWw0MDQoXG4gICAgICAgICAgbG9jYXRpb24ucGF0aG5hbWVcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtYXRjaGVzOiBub3RGb3VuZE1hdGNoZXMsXG4gICAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgICBbcm91dGUuaWRdOiBlcnJvclxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoZXMgPSBkaXNjb3ZlclJlc3VsdC5tYXRjaGVzO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgeyBkc01hdGNoZXMsIHJldmFsaWRhdGluZ0ZldGNoZXJzIH0gPSBnZXRNYXRjaGVzVG9Mb2FkKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHNjb3BlZENvbnRleHQsXG4gICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgICAgbWFuaWZlc3QsXG4gICAgICBpbml0Lmhpc3RvcnksXG4gICAgICBzdGF0ZSxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBhY3RpdmVTdWJtaXNzaW9uLFxuICAgICAgbG9jYXRpb24sXG4gICAgICBpbml0aWFsSHlkcmF0aW9uID8gW10gOiBoeWRyYXRpb25Sb3V0ZVByb3BlcnRpZXMyLFxuICAgICAgaW5pdGlhbEh5ZHJhdGlvbiA9PT0gdHJ1ZSxcbiAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQsXG4gICAgICBjYW5jZWxsZWRGZXRjaGVyTG9hZHMsXG4gICAgICBmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uLFxuICAgICAgZmV0Y2hMb2FkTWF0Y2hlcyxcbiAgICAgIGZldGNoUmVkaXJlY3RJZHMsXG4gICAgICByb3V0ZXNUb1VzZSxcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgaW5pdC5wYXRjaFJvdXRlc09uTmF2aWdhdGlvbiAhPSBudWxsLFxuICAgICAgcGVuZGluZ0FjdGlvblJlc3VsdFxuICAgICk7XG4gICAgcGVuZGluZ05hdmlnYXRpb25Mb2FkSWQgPSArK2luY3JlbWVudGluZ0xvYWRJZDtcbiAgICBpZiAoIWluaXQuZGF0YVN0cmF0ZWd5ICYmICFkc01hdGNoZXMuc29tZSgobSkgPT4gbS5zaG91bGRMb2FkKSAmJiByZXZhbGlkYXRpbmdGZXRjaGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIGxldCB1cGRhdGVkRmV0Y2hlcnMyID0gbWFya0ZldGNoUmVkaXJlY3RzRG9uZSgpO1xuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAge1xuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgICAgLy8gQ29tbWl0IHBlbmRpbmcgZXJyb3IgaWYgd2UncmUgc2hvcnQgY2lyY3VpdGluZ1xuICAgICAgICAgIGVycm9yczogcGVuZGluZ0FjdGlvblJlc3VsdCAmJiBpc0Vycm9yUmVzdWx0KHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0pID8geyBbcGVuZGluZ0FjdGlvblJlc3VsdFswXV06IHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0uZXJyb3IgfSA6IG51bGwsXG4gICAgICAgICAgLi4uZ2V0QWN0aW9uRGF0YUZvckNvbW1pdChwZW5kaW5nQWN0aW9uUmVzdWx0KSxcbiAgICAgICAgICAuLi51cGRhdGVkRmV0Y2hlcnMyID8geyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSA6IHt9XG4gICAgICAgIH0sXG4gICAgICAgIHsgZmx1c2hTeW5jIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgIH1cbiAgICBpZiAoc2hvdWxkVXBkYXRlTmF2aWdhdGlvblN0YXRlKSB7XG4gICAgICBsZXQgdXBkYXRlcyA9IHt9O1xuICAgICAgaWYgKCFpc0ZvZ09mV2FyKSB7XG4gICAgICAgIHVwZGF0ZXMubmF2aWdhdGlvbiA9IGxvYWRpbmdOYXZpZ2F0aW9uO1xuICAgICAgICBsZXQgYWN0aW9uRGF0YSA9IGdldFVwZGF0ZWRBY3Rpb25EYXRhKHBlbmRpbmdBY3Rpb25SZXN1bHQpO1xuICAgICAgICBpZiAoYWN0aW9uRGF0YSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdXBkYXRlcy5hY3Rpb25EYXRhID0gYWN0aW9uRGF0YTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJldmFsaWRhdGluZ0ZldGNoZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdXBkYXRlcy5mZXRjaGVycyA9IGdldFVwZGF0ZWRSZXZhbGlkYXRpbmdGZXRjaGVycyhyZXZhbGlkYXRpbmdGZXRjaGVycyk7XG4gICAgICB9XG4gICAgICB1cGRhdGVTdGF0ZSh1cGRhdGVzLCB7IGZsdXNoU3luYyB9KTtcbiAgICB9XG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaCgocmYpID0+IHtcbiAgICAgIGFib3J0RmV0Y2hlcihyZi5rZXkpO1xuICAgICAgaWYgKHJmLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgZmV0Y2hDb250cm9sbGVycy5zZXQocmYua2V5LCByZi5jb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zID0gKCkgPT4gcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaCgoZikgPT4gYWJvcnRGZXRjaGVyKGYua2V5KSk7XG4gICAgaWYgKHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlcikge1xuICAgICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcImFib3J0XCIsXG4gICAgICAgIGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9uc1xuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IHsgbG9hZGVyUmVzdWx0cywgZmV0Y2hlclJlc3VsdHMgfSA9IGF3YWl0IGNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YShcbiAgICAgIGRzTWF0Y2hlcyxcbiAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHNjb3BlZENvbnRleHRcbiAgICApO1xuICAgIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgIH1cbiAgICBpZiAocGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyKSB7XG4gICAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwiYWJvcnRcIixcbiAgICAgICAgYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zXG4gICAgICApO1xuICAgIH1cbiAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKChyZikgPT4gZmV0Y2hDb250cm9sbGVycy5kZWxldGUocmYua2V5KSk7XG4gICAgbGV0IHJlZGlyZWN0MiA9IGZpbmRSZWRpcmVjdChsb2FkZXJSZXN1bHRzKTtcbiAgICBpZiAocmVkaXJlY3QyKSB7XG4gICAgICBhd2FpdCBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihyZXF1ZXN0LCByZWRpcmVjdDIucmVzdWx0LCB0cnVlLCB7XG4gICAgICAgIHJlcGxhY2U6IHJlcGxhY2UyXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgfVxuICAgIHJlZGlyZWN0MiA9IGZpbmRSZWRpcmVjdChmZXRjaGVyUmVzdWx0cyk7XG4gICAgaWYgKHJlZGlyZWN0Mikge1xuICAgICAgZmV0Y2hSZWRpcmVjdElkcy5hZGQocmVkaXJlY3QyLmtleSk7XG4gICAgICBhd2FpdCBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihyZXF1ZXN0LCByZWRpcmVjdDIucmVzdWx0LCB0cnVlLCB7XG4gICAgICAgIHJlcGxhY2U6IHJlcGxhY2UyXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgfVxuICAgIGxldCB7IGxvYWRlckRhdGEsIGVycm9ycyB9ID0gcHJvY2Vzc0xvYWRlckRhdGEoXG4gICAgICBzdGF0ZSxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBsb2FkZXJSZXN1bHRzLFxuICAgICAgcGVuZGluZ0FjdGlvblJlc3VsdCxcbiAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLFxuICAgICAgZmV0Y2hlclJlc3VsdHNcbiAgICApO1xuICAgIGlmIChpbml0aWFsSHlkcmF0aW9uICYmIHN0YXRlLmVycm9ycykge1xuICAgICAgZXJyb3JzID0geyAuLi5zdGF0ZS5lcnJvcnMsIC4uLmVycm9ycyB9O1xuICAgIH1cbiAgICBsZXQgdXBkYXRlZEZldGNoZXJzID0gbWFya0ZldGNoUmVkaXJlY3RzRG9uZSgpO1xuICAgIGxldCBkaWRBYm9ydEZldGNoTG9hZHMgPSBhYm9ydFN0YWxlRmV0Y2hMb2FkcyhwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCk7XG4gICAgbGV0IHNob3VsZFVwZGF0ZUZldGNoZXJzID0gdXBkYXRlZEZldGNoZXJzIHx8IGRpZEFib3J0RmV0Y2hMb2FkcyB8fCByZXZhbGlkYXRpbmdGZXRjaGVycy5sZW5ndGggPiAwO1xuICAgIHJldHVybiB7XG4gICAgICBtYXRjaGVzLFxuICAgICAgbG9hZGVyRGF0YSxcbiAgICAgIGVycm9ycyxcbiAgICAgIC4uLnNob3VsZFVwZGF0ZUZldGNoZXJzID8geyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSA6IHt9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBnZXRVcGRhdGVkQWN0aW9uRGF0YShwZW5kaW5nQWN0aW9uUmVzdWx0KSB7XG4gICAgaWYgKHBlbmRpbmdBY3Rpb25SZXN1bHQgJiYgIWlzRXJyb3JSZXN1bHQocGVuZGluZ0FjdGlvblJlc3VsdFsxXSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFtwZW5kaW5nQWN0aW9uUmVzdWx0WzBdXTogcGVuZGluZ0FjdGlvblJlc3VsdFsxXS5kYXRhXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuYWN0aW9uRGF0YSkge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHN0YXRlLmFjdGlvbkRhdGEpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5hY3Rpb25EYXRhO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRVcGRhdGVkUmV2YWxpZGF0aW5nRmV0Y2hlcnMocmV2YWxpZGF0aW5nRmV0Y2hlcnMpIHtcbiAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKChyZikgPT4ge1xuICAgICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQocmYua2V5KTtcbiAgICAgIGxldCByZXZhbGlkYXRpbmdGZXRjaGVyID0gZ2V0TG9hZGluZ0ZldGNoZXIoXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgZmV0Y2hlciA/IGZldGNoZXIuZGF0YSA6IHZvaWQgMFxuICAgICAgKTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLnNldChyZi5rZXksIHJldmFsaWRhdGluZ0ZldGNoZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBmZXRjaDIoa2V5LCByb3V0ZUlkLCBocmVmMiwgb3B0cykge1xuICAgIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgIGxldCBmbHVzaFN5bmMgPSAob3B0cyAmJiBvcHRzLmZsdXNoU3luYykgPT09IHRydWU7XG4gICAgbGV0IHJvdXRlc1RvVXNlID0gaW5GbGlnaHREYXRhUm91dGVzIHx8IGRhdGFSb3V0ZXM7XG4gICAgbGV0IG5vcm1hbGl6ZWRQYXRoID0gbm9ybWFsaXplVG8oXG4gICAgICBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIHN0YXRlLm1hdGNoZXMsXG4gICAgICBiYXNlbmFtZSxcbiAgICAgIGhyZWYyLFxuICAgICAgcm91dGVJZCxcbiAgICAgIG9wdHM/LnJlbGF0aXZlXG4gICAgKTtcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlc1RvVXNlLCBub3JtYWxpemVkUGF0aCwgYmFzZW5hbWUpO1xuICAgIGxldCBmb2dPZldhciA9IGNoZWNrRm9nT2ZXYXIobWF0Y2hlcywgcm91dGVzVG9Vc2UsIG5vcm1hbGl6ZWRQYXRoKTtcbiAgICBpZiAoZm9nT2ZXYXIuYWN0aXZlICYmIGZvZ09mV2FyLm1hdGNoZXMpIHtcbiAgICAgIG1hdGNoZXMgPSBmb2dPZldhci5tYXRjaGVzO1xuICAgIH1cbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHNldEZldGNoZXJFcnJvcihcbiAgICAgICAga2V5LFxuICAgICAgICByb3V0ZUlkLFxuICAgICAgICBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZTogbm9ybWFsaXplZFBhdGggfSksXG4gICAgICAgIHsgZmx1c2hTeW5jIH1cbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB7IHBhdGgsIHN1Ym1pc3Npb24sIGVycm9yIH0gPSBub3JtYWxpemVOYXZpZ2F0ZU9wdGlvbnMoXG4gICAgICB0cnVlLFxuICAgICAgbm9ybWFsaXplZFBhdGgsXG4gICAgICBvcHRzXG4gICAgKTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGVycm9yLCB7IGZsdXNoU3luYyB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IG1hdGNoID0gZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgcGF0aCk7XG4gICAgbGV0IHNjb3BlZENvbnRleHQgPSBuZXcgdW5zdGFibGVfUm91dGVyQ29udGV4dFByb3ZpZGVyKFxuICAgICAgaW5pdC51bnN0YWJsZV9nZXRDb250ZXh0ID8gYXdhaXQgaW5pdC51bnN0YWJsZV9nZXRDb250ZXh0KCkgOiB2b2lkIDBcbiAgICApO1xuICAgIGxldCBwcmV2ZW50U2Nyb2xsUmVzZXQgPSAob3B0cyAmJiBvcHRzLnByZXZlbnRTY3JvbGxSZXNldCkgPT09IHRydWU7XG4gICAgaWYgKHN1Ym1pc3Npb24gJiYgaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgICBhd2FpdCBoYW5kbGVGZXRjaGVyQWN0aW9uKFxuICAgICAgICBrZXksXG4gICAgICAgIHJvdXRlSWQsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBzY29wZWRDb250ZXh0LFxuICAgICAgICBmb2dPZldhci5hY3RpdmUsXG4gICAgICAgIGZsdXNoU3luYyxcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICBzdWJtaXNzaW9uXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmZXRjaExvYWRNYXRjaGVzLnNldChrZXksIHsgcm91dGVJZCwgcGF0aCB9KTtcbiAgICBhd2FpdCBoYW5kbGVGZXRjaGVyTG9hZGVyKFxuICAgICAga2V5LFxuICAgICAgcm91dGVJZCxcbiAgICAgIHBhdGgsXG4gICAgICBtYXRjaCxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBzY29wZWRDb250ZXh0LFxuICAgICAgZm9nT2ZXYXIuYWN0aXZlLFxuICAgICAgZmx1c2hTeW5jLFxuICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgc3VibWlzc2lvblxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlRmV0Y2hlckFjdGlvbihrZXksIHJvdXRlSWQsIHBhdGgsIG1hdGNoLCByZXF1ZXN0TWF0Y2hlcywgc2NvcGVkQ29udGV4dCwgaXNGb2dPZldhciwgZmx1c2hTeW5jLCBwcmV2ZW50U2Nyb2xsUmVzZXQsIHN1Ym1pc3Npb24pIHtcbiAgICBpbnRlcnJ1cHRBY3RpdmVMb2FkcygpO1xuICAgIGZldGNoTG9hZE1hdGNoZXMuZGVsZXRlKGtleSk7XG4gICAgZnVuY3Rpb24gZGV0ZWN0QW5kSGFuZGxlNDA1RXJyb3IobSkge1xuICAgICAgaWYgKCFtLnJvdXRlLmFjdGlvbiAmJiAhbS5yb3V0ZS5sYXp5KSB7XG4gICAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7XG4gICAgICAgICAgbWV0aG9kOiBzdWJtaXNzaW9uLmZvcm1NZXRob2QsXG4gICAgICAgICAgcGF0aG5hbWU6IHBhdGgsXG4gICAgICAgICAgcm91dGVJZFxuICAgICAgICB9KTtcbiAgICAgICAgc2V0RmV0Y2hlckVycm9yKGtleSwgcm91dGVJZCwgZXJyb3IsIHsgZmx1c2hTeW5jIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFpc0ZvZ09mV2FyICYmIGRldGVjdEFuZEhhbmRsZTQwNUVycm9yKG1hdGNoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZXhpc3RpbmdGZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0U3VibWl0dGluZ0ZldGNoZXIoc3VibWlzc2lvbiwgZXhpc3RpbmdGZXRjaGVyKSwge1xuICAgICAgZmx1c2hTeW5jXG4gICAgfSk7XG4gICAgbGV0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBsZXQgZmV0Y2hSZXF1ZXN0ID0gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoXG4gICAgICBpbml0Lmhpc3RvcnksXG4gICAgICBwYXRoLFxuICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgIHN1Ym1pc3Npb25cbiAgICApO1xuICAgIGlmIChpc0ZvZ09mV2FyKSB7XG4gICAgICBsZXQgZGlzY292ZXJSZXN1bHQgPSBhd2FpdCBkaXNjb3ZlclJvdXRlcyhcbiAgICAgICAgcmVxdWVzdE1hdGNoZXMsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIGZldGNoUmVxdWVzdC5zaWduYWwsXG4gICAgICAgIGtleVxuICAgICAgKTtcbiAgICAgIGlmIChkaXNjb3ZlclJlc3VsdC50eXBlID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKGRpc2NvdmVyUmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBkaXNjb3ZlclJlc3VsdC5lcnJvciwgeyBmbHVzaFN5bmMgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoIWRpc2NvdmVyUmVzdWx0Lm1hdGNoZXMpIHtcbiAgICAgICAgc2V0RmV0Y2hlckVycm9yKFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICByb3V0ZUlkLFxuICAgICAgICAgIGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7IHBhdGhuYW1lOiBwYXRoIH0pLFxuICAgICAgICAgIHsgZmx1c2hTeW5jIH1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdE1hdGNoZXMgPSBkaXNjb3ZlclJlc3VsdC5tYXRjaGVzO1xuICAgICAgICBtYXRjaCA9IGdldFRhcmdldE1hdGNoKHJlcXVlc3RNYXRjaGVzLCBwYXRoKTtcbiAgICAgICAgaWYgKGRldGVjdEFuZEhhbmRsZTQwNUVycm9yKG1hdGNoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmZXRjaENvbnRyb2xsZXJzLnNldChrZXksIGFib3J0Q29udHJvbGxlcik7XG4gICAgbGV0IG9yaWdpbmF0aW5nTG9hZElkID0gaW5jcmVtZW50aW5nTG9hZElkO1xuICAgIGxldCBmZXRjaE1hdGNoZXMgPSBnZXRUYXJnZXRlZERhdGFTdHJhdGVneU1hdGNoZXMoXG4gICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgICAgbWFuaWZlc3QsXG4gICAgICBmZXRjaFJlcXVlc3QsXG4gICAgICByZXF1ZXN0TWF0Y2hlcyxcbiAgICAgIG1hdGNoLFxuICAgICAgaHlkcmF0aW9uUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgIHNjb3BlZENvbnRleHRcbiAgICApO1xuICAgIGxldCBhY3Rpb25SZXN1bHRzID0gYXdhaXQgY2FsbERhdGFTdHJhdGVneShcbiAgICAgIGZldGNoUmVxdWVzdCxcbiAgICAgIGZldGNoTWF0Y2hlcyxcbiAgICAgIHNjb3BlZENvbnRleHQsXG4gICAgICBrZXlcbiAgICApO1xuICAgIGxldCBhY3Rpb25SZXN1bHQgPSBhY3Rpb25SZXN1bHRzW21hdGNoLnJvdXRlLmlkXTtcbiAgICBpZiAoZmV0Y2hSZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5nZXQoa2V5KSA9PT0gYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uLmhhcyhrZXkpKSB7XG4gICAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChhY3Rpb25SZXN1bHQpIHx8IGlzRXJyb3JSZXN1bHQoYWN0aW9uUmVzdWx0KSkge1xuICAgICAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXREb25lRmV0Y2hlcih2b2lkIDApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChhY3Rpb25SZXN1bHQpKSB7XG4gICAgICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gICAgICAgIGlmIChwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCA+IG9yaWdpbmF0aW5nTG9hZElkKSB7XG4gICAgICAgICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0RG9uZUZldGNoZXIodm9pZCAwKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZldGNoUmVkaXJlY3RJZHMuYWRkKGtleSk7XG4gICAgICAgICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0TG9hZGluZ0ZldGNoZXIoc3VibWlzc2lvbikpO1xuICAgICAgICAgIHJldHVybiBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihmZXRjaFJlcXVlc3QsIGFjdGlvblJlc3VsdCwgZmFsc2UsIHtcbiAgICAgICAgICAgIGZldGNoZXJTdWJtaXNzaW9uOiBzdWJtaXNzaW9uLFxuICAgICAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0Vycm9yUmVzdWx0KGFjdGlvblJlc3VsdCkpIHtcbiAgICAgICAgc2V0RmV0Y2hlckVycm9yKGtleSwgcm91dGVJZCwgYWN0aW9uUmVzdWx0LmVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbmV4dExvY2F0aW9uID0gc3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbiB8fCBzdGF0ZS5sb2NhdGlvbjtcbiAgICBsZXQgcmV2YWxpZGF0aW9uUmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KFxuICAgICAgaW5pdC5oaXN0b3J5LFxuICAgICAgbmV4dExvY2F0aW9uLFxuICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbFxuICAgICk7XG4gICAgbGV0IHJvdXRlc1RvVXNlID0gaW5GbGlnaHREYXRhUm91dGVzIHx8IGRhdGFSb3V0ZXM7XG4gICAgbGV0IG1hdGNoZXMgPSBzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlICE9PSBcImlkbGVcIiA/IG1hdGNoUm91dGVzKHJvdXRlc1RvVXNlLCBzdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uLCBiYXNlbmFtZSkgOiBzdGF0ZS5tYXRjaGVzO1xuICAgIGludmFyaWFudChtYXRjaGVzLCBcIkRpZG4ndCBmaW5kIGFueSBtYXRjaGVzIGFmdGVyIGZldGNoZXIgYWN0aW9uXCIpO1xuICAgIGxldCBsb2FkSWQgPSArK2luY3JlbWVudGluZ0xvYWRJZDtcbiAgICBmZXRjaFJlbG9hZElkcy5zZXQoa2V5LCBsb2FkSWQpO1xuICAgIGxldCBsb2FkRmV0Y2hlciA9IGdldExvYWRpbmdGZXRjaGVyKHN1Ym1pc3Npb24sIGFjdGlvblJlc3VsdC5kYXRhKTtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBsb2FkRmV0Y2hlcik7XG4gICAgbGV0IHsgZHNNYXRjaGVzLCByZXZhbGlkYXRpbmdGZXRjaGVycyB9ID0gZ2V0TWF0Y2hlc1RvTG9hZChcbiAgICAgIHJldmFsaWRhdGlvblJlcXVlc3QsXG4gICAgICBzY29wZWRDb250ZXh0LFxuICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgIG1hbmlmZXN0LFxuICAgICAgaW5pdC5oaXN0b3J5LFxuICAgICAgc3RhdGUsXG4gICAgICBtYXRjaGVzLFxuICAgICAgc3VibWlzc2lvbixcbiAgICAgIG5leHRMb2NhdGlvbixcbiAgICAgIGh5ZHJhdGlvblJvdXRlUHJvcGVydGllczIsXG4gICAgICBmYWxzZSxcbiAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQsXG4gICAgICBjYW5jZWxsZWRGZXRjaGVyTG9hZHMsXG4gICAgICBmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uLFxuICAgICAgZmV0Y2hMb2FkTWF0Y2hlcyxcbiAgICAgIGZldGNoUmVkaXJlY3RJZHMsXG4gICAgICByb3V0ZXNUb1VzZSxcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgaW5pdC5wYXRjaFJvdXRlc09uTmF2aWdhdGlvbiAhPSBudWxsLFxuICAgICAgW21hdGNoLnJvdXRlLmlkLCBhY3Rpb25SZXN1bHRdXG4gICAgKTtcbiAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5maWx0ZXIoKHJmKSA9PiByZi5rZXkgIT09IGtleSkuZm9yRWFjaCgocmYpID0+IHtcbiAgICAgIGxldCBzdGFsZUtleSA9IHJmLmtleTtcbiAgICAgIGxldCBleGlzdGluZ0ZldGNoZXIyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KHN0YWxlS2V5KTtcbiAgICAgIGxldCByZXZhbGlkYXRpbmdGZXRjaGVyID0gZ2V0TG9hZGluZ0ZldGNoZXIoXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgZXhpc3RpbmdGZXRjaGVyMiA/IGV4aXN0aW5nRmV0Y2hlcjIuZGF0YSA6IHZvaWQgMFxuICAgICAgKTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLnNldChzdGFsZUtleSwgcmV2YWxpZGF0aW5nRmV0Y2hlcik7XG4gICAgICBhYm9ydEZldGNoZXIoc3RhbGVLZXkpO1xuICAgICAgaWYgKHJmLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgZmV0Y2hDb250cm9sbGVycy5zZXQoc3RhbGVLZXksIHJmLmNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHVwZGF0ZVN0YXRlKHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH0pO1xuICAgIGxldCBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnMgPSAoKSA9PiByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKChyZikgPT4gYWJvcnRGZXRjaGVyKHJmLmtleSkpO1xuICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwiYWJvcnRcIixcbiAgICAgIGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9uc1xuICAgICk7XG4gICAgbGV0IHsgbG9hZGVyUmVzdWx0cywgZmV0Y2hlclJlc3VsdHMgfSA9IGF3YWl0IGNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YShcbiAgICAgIGRzTWF0Y2hlcyxcbiAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLFxuICAgICAgcmV2YWxpZGF0aW9uUmVxdWVzdCxcbiAgICAgIHNjb3BlZENvbnRleHRcbiAgICApO1xuICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgXCJhYm9ydFwiLFxuICAgICAgYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zXG4gICAgKTtcbiAgICBmZXRjaFJlbG9hZElkcy5kZWxldGUoa2V5KTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goKHIpID0+IGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKHIua2V5KSk7XG4gICAgaWYgKHN0YXRlLmZldGNoZXJzLmhhcyhrZXkpKSB7XG4gICAgICBsZXQgZG9uZUZldGNoZXIgPSBnZXREb25lRmV0Y2hlcihhY3Rpb25SZXN1bHQuZGF0YSk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgfVxuICAgIGxldCByZWRpcmVjdDIgPSBmaW5kUmVkaXJlY3QobG9hZGVyUmVzdWx0cyk7XG4gICAgaWYgKHJlZGlyZWN0Mikge1xuICAgICAgcmV0dXJuIHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKFxuICAgICAgICByZXZhbGlkYXRpb25SZXF1ZXN0LFxuICAgICAgICByZWRpcmVjdDIucmVzdWx0LFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgeyBwcmV2ZW50U2Nyb2xsUmVzZXQgfVxuICAgICAgKTtcbiAgICB9XG4gICAgcmVkaXJlY3QyID0gZmluZFJlZGlyZWN0KGZldGNoZXJSZXN1bHRzKTtcbiAgICBpZiAocmVkaXJlY3QyKSB7XG4gICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChyZWRpcmVjdDIua2V5KTtcbiAgICAgIHJldHVybiBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihcbiAgICAgICAgcmV2YWxpZGF0aW9uUmVxdWVzdCxcbiAgICAgICAgcmVkaXJlY3QyLnJlc3VsdCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHsgcHJldmVudFNjcm9sbFJlc2V0IH1cbiAgICAgICk7XG4gICAgfVxuICAgIGxldCB7IGxvYWRlckRhdGEsIGVycm9ycyB9ID0gcHJvY2Vzc0xvYWRlckRhdGEoXG4gICAgICBzdGF0ZSxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBsb2FkZXJSZXN1bHRzLFxuICAgICAgdm9pZCAwLFxuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMsXG4gICAgICBmZXRjaGVyUmVzdWx0c1xuICAgICk7XG4gICAgYWJvcnRTdGFsZUZldGNoTG9hZHMobG9hZElkKTtcbiAgICBpZiAoc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIgJiYgbG9hZElkID4gcGVuZGluZ05hdmlnYXRpb25Mb2FkSWQpIHtcbiAgICAgIGludmFyaWFudChwZW5kaW5nQWN0aW9uLCBcIkV4cGVjdGVkIHBlbmRpbmcgYWN0aW9uXCIpO1xuICAgICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyICYmIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKHN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24sIHtcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgbG9hZGVyRGF0YSxcbiAgICAgICAgZXJyb3JzLFxuICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICAgIGVycm9ycyxcbiAgICAgICAgbG9hZGVyRGF0YTogbWVyZ2VMb2FkZXJEYXRhKFxuICAgICAgICAgIHN0YXRlLmxvYWRlckRhdGEsXG4gICAgICAgICAgbG9hZGVyRGF0YSxcbiAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgIGVycm9yc1xuICAgICAgICApLFxuICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICAgIH0pO1xuICAgICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVGZXRjaGVyTG9hZGVyKGtleSwgcm91dGVJZCwgcGF0aCwgbWF0Y2gsIG1hdGNoZXMsIHNjb3BlZENvbnRleHQsIGlzRm9nT2ZXYXIsIGZsdXNoU3luYywgcHJldmVudFNjcm9sbFJlc2V0LCBzdWJtaXNzaW9uKSB7XG4gICAgbGV0IGV4aXN0aW5nRmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShcbiAgICAgIGtleSxcbiAgICAgIGdldExvYWRpbmdGZXRjaGVyKFxuICAgICAgICBzdWJtaXNzaW9uLFxuICAgICAgICBleGlzdGluZ0ZldGNoZXIgPyBleGlzdGluZ0ZldGNoZXIuZGF0YSA6IHZvaWQgMFxuICAgICAgKSxcbiAgICAgIHsgZmx1c2hTeW5jIH1cbiAgICApO1xuICAgIGxldCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IGZldGNoUmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KFxuICAgICAgaW5pdC5oaXN0b3J5LFxuICAgICAgcGF0aCxcbiAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICApO1xuICAgIGlmIChpc0ZvZ09mV2FyKSB7XG4gICAgICBsZXQgZGlzY292ZXJSZXN1bHQgPSBhd2FpdCBkaXNjb3ZlclJvdXRlcyhcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgZmV0Y2hSZXF1ZXN0LnNpZ25hbCxcbiAgICAgICAga2V5XG4gICAgICApO1xuICAgICAgaWYgKGRpc2NvdmVyUmVzdWx0LnR5cGUgPT09IFwiYWJvcnRlZFwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoZGlzY292ZXJSZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGRpc2NvdmVyUmVzdWx0LmVycm9yLCB7IGZsdXNoU3luYyB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmICghZGlzY292ZXJSZXN1bHQubWF0Y2hlcykge1xuICAgICAgICBzZXRGZXRjaGVyRXJyb3IoXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIHJvdXRlSWQsXG4gICAgICAgICAgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHsgcGF0aG5hbWU6IHBhdGggfSksXG4gICAgICAgICAgeyBmbHVzaFN5bmMgfVxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXRjaGVzID0gZGlzY292ZXJSZXN1bHQubWF0Y2hlcztcbiAgICAgICAgbWF0Y2ggPSBnZXRUYXJnZXRNYXRjaChtYXRjaGVzLCBwYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZmV0Y2hDb250cm9sbGVycy5zZXQoa2V5LCBhYm9ydENvbnRyb2xsZXIpO1xuICAgIGxldCBvcmlnaW5hdGluZ0xvYWRJZCA9IGluY3JlbWVudGluZ0xvYWRJZDtcbiAgICBsZXQgZHNNYXRjaGVzID0gZ2V0VGFyZ2V0ZWREYXRhU3RyYXRlZ3lNYXRjaGVzKFxuICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgIG1hbmlmZXN0LFxuICAgICAgZmV0Y2hSZXF1ZXN0LFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIG1hdGNoLFxuICAgICAgaHlkcmF0aW9uUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgIHNjb3BlZENvbnRleHRcbiAgICApO1xuICAgIGxldCByZXN1bHRzID0gYXdhaXQgY2FsbERhdGFTdHJhdGVneShcbiAgICAgIGZldGNoUmVxdWVzdCxcbiAgICAgIGRzTWF0Y2hlcyxcbiAgICAgIHNjb3BlZENvbnRleHQsXG4gICAgICBrZXlcbiAgICApO1xuICAgIGxldCByZXN1bHQgPSByZXN1bHRzW21hdGNoLnJvdXRlLmlkXTtcbiAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5nZXQoa2V5KSA9PT0gYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICBpZiAoZmV0Y2hSZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uLmhhcyhrZXkpKSB7XG4gICAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXREb25lRmV0Y2hlcih2b2lkIDApKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgaWYgKHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkID4gb3JpZ2luYXRpbmdMb2FkSWQpIHtcbiAgICAgICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0RG9uZUZldGNoZXIodm9pZCAwKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZldGNoUmVkaXJlY3RJZHMuYWRkKGtleSk7XG4gICAgICAgIGF3YWl0IHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKGZldGNoUmVxdWVzdCwgcmVzdWx0LCBmYWxzZSwge1xuICAgICAgICAgIHByZXZlbnRTY3JvbGxSZXNldFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCByZXN1bHQuZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXREb25lRmV0Y2hlcihyZXN1bHQuZGF0YSkpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHJlcXVlc3QsIHJlZGlyZWN0MiwgaXNOYXZpZ2F0aW9uLCB7XG4gICAgc3VibWlzc2lvbixcbiAgICBmZXRjaGVyU3VibWlzc2lvbixcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgcmVwbGFjZTogcmVwbGFjZTJcbiAgfSA9IHt9KSB7XG4gICAgaWYgKHJlZGlyZWN0Mi5yZXNwb25zZS5oZWFkZXJzLmhhcyhcIlgtUmVtaXgtUmV2YWxpZGF0ZVwiKSkge1xuICAgICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IHRydWU7XG4gICAgfVxuICAgIGxldCBsb2NhdGlvbiA9IHJlZGlyZWN0Mi5yZXNwb25zZS5oZWFkZXJzLmdldChcIkxvY2F0aW9uXCIpO1xuICAgIGludmFyaWFudChsb2NhdGlvbiwgXCJFeHBlY3RlZCBhIExvY2F0aW9uIGhlYWRlciBvbiB0aGUgcmVkaXJlY3QgUmVzcG9uc2VcIik7XG4gICAgbG9jYXRpb24gPSBub3JtYWxpemVSZWRpcmVjdExvY2F0aW9uKFxuICAgICAgbG9jYXRpb24sXG4gICAgICBuZXcgVVJMKHJlcXVlc3QudXJsKSxcbiAgICAgIGJhc2VuYW1lXG4gICAgKTtcbiAgICBsZXQgcmVkaXJlY3RMb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHN0YXRlLmxvY2F0aW9uLCBsb2NhdGlvbiwge1xuICAgICAgX2lzUmVkaXJlY3Q6IHRydWVcbiAgICB9KTtcbiAgICBpZiAoaXNCcm93c2VyMikge1xuICAgICAgbGV0IGlzRG9jdW1lbnRSZWxvYWQgPSBmYWxzZTtcbiAgICAgIGlmIChyZWRpcmVjdDIucmVzcG9uc2UuaGVhZGVycy5oYXMoXCJYLVJlbWl4LVJlbG9hZC1Eb2N1bWVudFwiKSkge1xuICAgICAgICBpc0RvY3VtZW50UmVsb2FkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoQUJTT0xVVEVfVVJMX1JFR0VYLnRlc3QobG9jYXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGNyZWF0ZUJyb3dzZXJVUkxJbXBsKGxvY2F0aW9uLCB0cnVlKTtcbiAgICAgICAgaXNEb2N1bWVudFJlbG9hZCA9IC8vIEhhcmQgcmVsb2FkIGlmIGl0J3MgYW4gYWJzb2x1dGUgVVJMIHRvIGEgbmV3IG9yaWdpblxuICAgICAgICB1cmwub3JpZ2luICE9PSByb3V0ZXJXaW5kb3cubG9jYXRpb24ub3JpZ2luIHx8IC8vIEhhcmQgcmVsb2FkIGlmIGl0J3MgYW4gYWJzb2x1dGUgVVJMIHRoYXQgZG9lcyBub3QgbWF0Y2ggb3VyIGJhc2VuYW1lXG4gICAgICAgIHN0cmlwQmFzZW5hbWUodXJsLnBhdGhuYW1lLCBiYXNlbmFtZSkgPT0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RvY3VtZW50UmVsb2FkKSB7XG4gICAgICAgIGlmIChyZXBsYWNlMikge1xuICAgICAgICAgIHJvdXRlcldpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGxvY2F0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb3V0ZXJXaW5kb3cubG9jYXRpb24uYXNzaWduKGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG51bGw7XG4gICAgbGV0IHJlZGlyZWN0TmF2aWdhdGlvblR5cGUgPSByZXBsYWNlMiA9PT0gdHJ1ZSB8fCByZWRpcmVjdDIucmVzcG9uc2UuaGVhZGVycy5oYXMoXCJYLVJlbWl4LVJlcGxhY2VcIikgPyBcIlJFUExBQ0VcIiAvKiBSZXBsYWNlICovIDogXCJQVVNIXCIgLyogUHVzaCAqLztcbiAgICBsZXQgeyBmb3JtTWV0aG9kLCBmb3JtQWN0aW9uLCBmb3JtRW5jVHlwZSB9ID0gc3RhdGUubmF2aWdhdGlvbjtcbiAgICBpZiAoIXN1Ym1pc3Npb24gJiYgIWZldGNoZXJTdWJtaXNzaW9uICYmIGZvcm1NZXRob2QgJiYgZm9ybUFjdGlvbiAmJiBmb3JtRW5jVHlwZSkge1xuICAgICAgc3VibWlzc2lvbiA9IGdldFN1Ym1pc3Npb25Gcm9tTmF2aWdhdGlvbihzdGF0ZS5uYXZpZ2F0aW9uKTtcbiAgICB9XG4gICAgbGV0IGFjdGl2ZVN1Ym1pc3Npb24gPSBzdWJtaXNzaW9uIHx8IGZldGNoZXJTdWJtaXNzaW9uO1xuICAgIGlmIChyZWRpcmVjdFByZXNlcnZlTWV0aG9kU3RhdHVzQ29kZXMuaGFzKHJlZGlyZWN0Mi5yZXNwb25zZS5zdGF0dXMpICYmIGFjdGl2ZVN1Ym1pc3Npb24gJiYgaXNNdXRhdGlvbk1ldGhvZChhY3RpdmVTdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgICBhd2FpdCBzdGFydE5hdmlnYXRpb24ocmVkaXJlY3ROYXZpZ2F0aW9uVHlwZSwgcmVkaXJlY3RMb2NhdGlvbiwge1xuICAgICAgICBzdWJtaXNzaW9uOiB7XG4gICAgICAgICAgLi4uYWN0aXZlU3VibWlzc2lvbixcbiAgICAgICAgICBmb3JtQWN0aW9uOiBsb2NhdGlvblxuICAgICAgICB9LFxuICAgICAgICAvLyBQcmVzZXJ2ZSB0aGVzZSBmbGFncyBhY3Jvc3MgcmVkaXJlY3RzXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogcHJldmVudFNjcm9sbFJlc2V0IHx8IHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgIGVuYWJsZVZpZXdUcmFuc2l0aW9uOiBpc05hdmlnYXRpb24gPyBwZW5kaW5nVmlld1RyYW5zaXRpb25FbmFibGVkIDogdm9pZCAwXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG92ZXJyaWRlTmF2aWdhdGlvbiA9IGdldExvYWRpbmdOYXZpZ2F0aW9uKFxuICAgICAgICByZWRpcmVjdExvY2F0aW9uLFxuICAgICAgICBzdWJtaXNzaW9uXG4gICAgICApO1xuICAgICAgYXdhaXQgc3RhcnROYXZpZ2F0aW9uKHJlZGlyZWN0TmF2aWdhdGlvblR5cGUsIHJlZGlyZWN0TG9jYXRpb24sIHtcbiAgICAgICAgb3ZlcnJpZGVOYXZpZ2F0aW9uLFxuICAgICAgICAvLyBTZW5kIGZldGNoZXIgc3VibWlzc2lvbnMgdGhyb3VnaCBmb3Igc2hvdWxkUmV2YWxpZGF0ZVxuICAgICAgICBmZXRjaGVyU3VibWlzc2lvbixcbiAgICAgICAgLy8gUHJlc2VydmUgdGhlc2UgZmxhZ3MgYWNyb3NzIHJlZGlyZWN0c1xuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IHByZXZlbnRTY3JvbGxSZXNldCB8fCBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICBlbmFibGVWaWV3VHJhbnNpdGlvbjogaXNOYXZpZ2F0aW9uID8gcGVuZGluZ1ZpZXdUcmFuc2l0aW9uRW5hYmxlZCA6IHZvaWQgMFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNhbGxEYXRhU3RyYXRlZ3kocmVxdWVzdCwgbWF0Y2hlcywgc2NvcGVkQ29udGV4dCwgZmV0Y2hlcktleSkge1xuICAgIGxldCByZXN1bHRzO1xuICAgIGxldCBkYXRhUmVzdWx0cyA9IHt9O1xuICAgIHRyeSB7XG4gICAgICByZXN1bHRzID0gYXdhaXQgY2FsbERhdGFTdHJhdGVneUltcGwoXG4gICAgICAgIGRhdGFTdHJhdGVneUltcGwsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGZldGNoZXJLZXksXG4gICAgICAgIHNjb3BlZENvbnRleHQsXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG1hdGNoZXMuZmlsdGVyKChtKSA9PiBtLnNob3VsZExvYWQpLmZvckVhY2goKG0pID0+IHtcbiAgICAgICAgZGF0YVJlc3VsdHNbbS5yb3V0ZS5pZF0gPSB7XG4gICAgICAgICAgdHlwZTogXCJlcnJvclwiIC8qIGVycm9yICovLFxuICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkYXRhUmVzdWx0cztcbiAgICB9XG4gICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybiBkYXRhUmVzdWx0cztcbiAgICB9XG4gICAgZm9yIChsZXQgW3JvdXRlSWQsIHJlc3VsdF0gb2YgT2JqZWN0LmVudHJpZXMocmVzdWx0cykpIHtcbiAgICAgIGlmIChpc1JlZGlyZWN0RGF0YVN0cmF0ZWd5UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gcmVzdWx0LnJlc3VsdDtcbiAgICAgICAgZGF0YVJlc3VsdHNbcm91dGVJZF0gPSB7XG4gICAgICAgICAgdHlwZTogXCJyZWRpcmVjdFwiIC8qIHJlZGlyZWN0ICovLFxuICAgICAgICAgIHJlc3BvbnNlOiBub3JtYWxpemVSZWxhdGl2ZVJvdXRpbmdSZWRpcmVjdFJlc3BvbnNlKFxuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgcm91dGVJZCxcbiAgICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgICBiYXNlbmFtZVxuICAgICAgICAgIClcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGFSZXN1bHRzW3JvdXRlSWRdID0gYXdhaXQgY29udmVydERhdGFTdHJhdGVneVJlc3VsdFRvRGF0YVJlc3VsdChcbiAgICAgICAgICByZXN1bHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGFSZXN1bHRzO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YShtYXRjaGVzLCBmZXRjaGVyc1RvTG9hZCwgcmVxdWVzdCwgc2NvcGVkQ29udGV4dCkge1xuICAgIGxldCBsb2FkZXJSZXN1bHRzUHJvbWlzZSA9IGNhbGxEYXRhU3RyYXRlZ3koXG4gICAgICByZXF1ZXN0LFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIHNjb3BlZENvbnRleHQsXG4gICAgICBudWxsXG4gICAgKTtcbiAgICBsZXQgZmV0Y2hlclJlc3VsdHNQcm9taXNlID0gUHJvbWlzZS5hbGwoXG4gICAgICBmZXRjaGVyc1RvTG9hZC5tYXAoYXN5bmMgKGYpID0+IHtcbiAgICAgICAgaWYgKGYubWF0Y2hlcyAmJiBmLm1hdGNoICYmIGYucmVxdWVzdCAmJiBmLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGNhbGxEYXRhU3RyYXRlZ3koXG4gICAgICAgICAgICBmLnJlcXVlc3QsXG4gICAgICAgICAgICBmLm1hdGNoZXMsXG4gICAgICAgICAgICBzY29wZWRDb250ZXh0LFxuICAgICAgICAgICAgZi5rZXlcbiAgICAgICAgICApO1xuICAgICAgICAgIGxldCByZXN1bHQgPSByZXN1bHRzW2YubWF0Y2gucm91dGUuaWRdO1xuICAgICAgICAgIHJldHVybiB7IFtmLmtleV06IHJlc3VsdCB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgW2Yua2V5XToge1xuICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sXG4gICAgICAgICAgICAgIGVycm9yOiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwge1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBmLnBhdGhcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICAgIGxldCBsb2FkZXJSZXN1bHRzID0gYXdhaXQgbG9hZGVyUmVzdWx0c1Byb21pc2U7XG4gICAgbGV0IGZldGNoZXJSZXN1bHRzID0gKGF3YWl0IGZldGNoZXJSZXN1bHRzUHJvbWlzZSkucmVkdWNlKFxuICAgICAgKGFjYywgcikgPT4gT2JqZWN0LmFzc2lnbihhY2MsIHIpLFxuICAgICAge31cbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBsb2FkZXJSZXN1bHRzLFxuICAgICAgZmV0Y2hlclJlc3VsdHNcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGludGVycnVwdEFjdGl2ZUxvYWRzKCkge1xuICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSB0cnVlO1xuICAgIGZldGNoTG9hZE1hdGNoZXMuZm9yRWFjaCgoXywga2V5KSA9PiB7XG4gICAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5oYXMoa2V5KSkge1xuICAgICAgICBjYW5jZWxsZWRGZXRjaGVyTG9hZHMuYWRkKGtleSk7XG4gICAgICB9XG4gICAgICBhYm9ydEZldGNoZXIoa2V5KTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBmZXRjaGVyLCBvcHRzID0ge30pIHtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBmZXRjaGVyKTtcbiAgICB1cGRhdGVTdGF0ZShcbiAgICAgIHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH0sXG4gICAgICB7IGZsdXNoU3luYzogKG9wdHMgJiYgb3B0cy5mbHVzaFN5bmMpID09PSB0cnVlIH1cbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGVycm9yLCBvcHRzID0ge30pIHtcbiAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkoc3RhdGUubWF0Y2hlcywgcm91dGVJZCk7XG4gICAgZGVsZXRlRmV0Y2hlcihrZXkpO1xuICAgIHVwZGF0ZVN0YXRlKFxuICAgICAge1xuICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF06IGVycm9yXG4gICAgICAgIH0sXG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgICAgfSxcbiAgICAgIHsgZmx1c2hTeW5jOiAob3B0cyAmJiBvcHRzLmZsdXNoU3luYykgPT09IHRydWUgfVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RmV0Y2hlcihrZXkpIHtcbiAgICBhY3RpdmVGZXRjaGVycy5zZXQoa2V5LCAoYWN0aXZlRmV0Y2hlcnMuZ2V0KGtleSkgfHwgMCkgKyAxKTtcbiAgICBpZiAoZmV0Y2hlcnNRdWV1ZWRGb3JEZWxldGlvbi5oYXMoa2V5KSkge1xuICAgICAgZmV0Y2hlcnNRdWV1ZWRGb3JEZWxldGlvbi5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLmZldGNoZXJzLmdldChrZXkpIHx8IElETEVfRkVUQ0hFUjtcbiAgfVxuICBmdW5jdGlvbiBkZWxldGVGZXRjaGVyKGtleSkge1xuICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKGtleSkgJiYgIShmZXRjaGVyICYmIGZldGNoZXIuc3RhdGUgPT09IFwibG9hZGluZ1wiICYmIGZldGNoUmVsb2FkSWRzLmhhcyhrZXkpKSkge1xuICAgICAgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgfVxuICAgIGZldGNoTG9hZE1hdGNoZXMuZGVsZXRlKGtleSk7XG4gICAgZmV0Y2hSZWxvYWRJZHMuZGVsZXRlKGtleSk7XG4gICAgZmV0Y2hSZWRpcmVjdElkcy5kZWxldGUoa2V5KTtcbiAgICBmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uLmRlbGV0ZShrZXkpO1xuICAgIGNhbmNlbGxlZEZldGNoZXJMb2Fkcy5kZWxldGUoa2V5KTtcbiAgICBzdGF0ZS5mZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgfVxuICBmdW5jdGlvbiBxdWV1ZUZldGNoZXJGb3JEZWxldGlvbihrZXkpIHtcbiAgICBsZXQgY291bnQgPSAoYWN0aXZlRmV0Y2hlcnMuZ2V0KGtleSkgfHwgMCkgLSAxO1xuICAgIGlmIChjb3VudCA8PSAwKSB7XG4gICAgICBhY3RpdmVGZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgICAgIGZldGNoZXJzUXVldWVkRm9yRGVsZXRpb24uYWRkKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjdGl2ZUZldGNoZXJzLnNldChrZXksIGNvdW50KTtcbiAgICB9XG4gICAgdXBkYXRlU3RhdGUoeyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSk7XG4gIH1cbiAgZnVuY3Rpb24gYWJvcnRGZXRjaGVyKGtleSkge1xuICAgIGxldCBjb250cm9sbGVyID0gZmV0Y2hDb250cm9sbGVycy5nZXQoa2V5KTtcbiAgICBpZiAoY29udHJvbGxlcikge1xuICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWFya0ZldGNoZXJzRG9uZShrZXlzKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIGtleXMpIHtcbiAgICAgIGxldCBmZXRjaGVyID0gZ2V0RmV0Y2hlcihrZXkpO1xuICAgICAgbGV0IGRvbmVGZXRjaGVyID0gZ2V0RG9uZUZldGNoZXIoZmV0Y2hlci5kYXRhKTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGRvbmVGZXRjaGVyKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWFya0ZldGNoUmVkaXJlY3RzRG9uZSgpIHtcbiAgICBsZXQgZG9uZUtleXMgPSBbXTtcbiAgICBsZXQgdXBkYXRlZEZldGNoZXJzID0gZmFsc2U7XG4gICAgZm9yIChsZXQga2V5IG9mIGZldGNoUmVkaXJlY3RJZHMpIHtcbiAgICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgICBpbnZhcmlhbnQoZmV0Y2hlciwgYEV4cGVjdGVkIGZldGNoZXI6ICR7a2V5fWApO1xuICAgICAgaWYgKGZldGNoZXIuc3RhdGUgPT09IFwibG9hZGluZ1wiKSB7XG4gICAgICAgIGZldGNoUmVkaXJlY3RJZHMuZGVsZXRlKGtleSk7XG4gICAgICAgIGRvbmVLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgdXBkYXRlZEZldGNoZXJzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWFya0ZldGNoZXJzRG9uZShkb25lS2V5cyk7XG4gICAgcmV0dXJuIHVwZGF0ZWRGZXRjaGVycztcbiAgfVxuICBmdW5jdGlvbiBhYm9ydFN0YWxlRmV0Y2hMb2FkcyhsYW5kZWRJZCkge1xuICAgIGxldCB5ZWV0ZWRLZXlzID0gW107XG4gICAgZm9yIChsZXQgW2tleSwgaWRdIG9mIGZldGNoUmVsb2FkSWRzKSB7XG4gICAgICBpZiAoaWQgPCBsYW5kZWRJZCkge1xuICAgICAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgICAgICBpbnZhcmlhbnQoZmV0Y2hlciwgYEV4cGVjdGVkIGZldGNoZXI6ICR7a2V5fWApO1xuICAgICAgICBpZiAoZmV0Y2hlci5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgICAgICBhYm9ydEZldGNoZXIoa2V5KTtcbiAgICAgICAgICBmZXRjaFJlbG9hZElkcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICB5ZWV0ZWRLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBtYXJrRmV0Y2hlcnNEb25lKHllZXRlZEtleXMpO1xuICAgIHJldHVybiB5ZWV0ZWRLZXlzLmxlbmd0aCA+IDA7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0QmxvY2tlcihrZXksIGZuKSB7XG4gICAgbGV0IGJsb2NrZXIgPSBzdGF0ZS5ibG9ja2Vycy5nZXQoa2V5KSB8fCBJRExFX0JMT0NLRVI7XG4gICAgaWYgKGJsb2NrZXJGdW5jdGlvbnMuZ2V0KGtleSkgIT09IGZuKSB7XG4gICAgICBibG9ja2VyRnVuY3Rpb25zLnNldChrZXksIGZuKTtcbiAgICB9XG4gICAgcmV0dXJuIGJsb2NrZXI7XG4gIH1cbiAgZnVuY3Rpb24gZGVsZXRlQmxvY2tlcihrZXkpIHtcbiAgICBzdGF0ZS5ibG9ja2Vycy5kZWxldGUoa2V5KTtcbiAgICBibG9ja2VyRnVuY3Rpb25zLmRlbGV0ZShrZXkpO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZUJsb2NrZXIoa2V5LCBuZXdCbG9ja2VyKSB7XG4gICAgbGV0IGJsb2NrZXIgPSBzdGF0ZS5ibG9ja2Vycy5nZXQoa2V5KSB8fCBJRExFX0JMT0NLRVI7XG4gICAgaW52YXJpYW50KFxuICAgICAgYmxvY2tlci5zdGF0ZSA9PT0gXCJ1bmJsb2NrZWRcIiAmJiBuZXdCbG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIiB8fCBibG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIiAmJiBuZXdCbG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIiB8fCBibG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIiAmJiBuZXdCbG9ja2VyLnN0YXRlID09PSBcInByb2NlZWRpbmdcIiB8fCBibG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIiAmJiBuZXdCbG9ja2VyLnN0YXRlID09PSBcInVuYmxvY2tlZFwiIHx8IGJsb2NrZXIuc3RhdGUgPT09IFwicHJvY2VlZGluZ1wiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwidW5ibG9ja2VkXCIsXG4gICAgICBgSW52YWxpZCBibG9ja2VyIHN0YXRlIHRyYW5zaXRpb246ICR7YmxvY2tlci5zdGF0ZX0gLT4gJHtuZXdCbG9ja2VyLnN0YXRlfWBcbiAgICApO1xuICAgIGxldCBibG9ja2VycyA9IG5ldyBNYXAoc3RhdGUuYmxvY2tlcnMpO1xuICAgIGJsb2NrZXJzLnNldChrZXksIG5ld0Jsb2NrZXIpO1xuICAgIHVwZGF0ZVN0YXRlKHsgYmxvY2tlcnMgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc2hvdWxkQmxvY2tOYXZpZ2F0aW9uKHtcbiAgICBjdXJyZW50TG9jYXRpb24sXG4gICAgbmV4dExvY2F0aW9uLFxuICAgIGhpc3RvcnlBY3Rpb25cbiAgfSkge1xuICAgIGlmIChibG9ja2VyRnVuY3Rpb25zLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGJsb2NrZXJGdW5jdGlvbnMuc2l6ZSA+IDEpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsIFwiQSByb3V0ZXIgb25seSBzdXBwb3J0cyBvbmUgYmxvY2tlciBhdCBhIHRpbWVcIik7XG4gICAgfVxuICAgIGxldCBlbnRyaWVzID0gQXJyYXkuZnJvbShibG9ja2VyRnVuY3Rpb25zLmVudHJpZXMoKSk7XG4gICAgbGV0IFtibG9ja2VyS2V5LCBibG9ja2VyRnVuY3Rpb25dID0gZW50cmllc1tlbnRyaWVzLmxlbmd0aCAtIDFdO1xuICAgIGxldCBibG9ja2VyID0gc3RhdGUuYmxvY2tlcnMuZ2V0KGJsb2NrZXJLZXkpO1xuICAgIGlmIChibG9ja2VyICYmIGJsb2NrZXIuc3RhdGUgPT09IFwicHJvY2VlZGluZ1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChibG9ja2VyRnVuY3Rpb24oeyBjdXJyZW50TG9jYXRpb24sIG5leHRMb2NhdGlvbiwgaGlzdG9yeUFjdGlvbiB9KSkge1xuICAgICAgcmV0dXJuIGJsb2NrZXJLZXk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZU5hdmlnYXRpb25hbDQwNChwYXRobmFtZSkge1xuICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7IHBhdGhuYW1lIH0pO1xuICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xuICAgIGxldCB7IG1hdGNoZXMsIHJvdXRlIH0gPSBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKHJvdXRlc1RvVXNlKTtcbiAgICByZXR1cm4geyBub3RGb3VuZE1hdGNoZXM6IG1hdGNoZXMsIHJvdXRlLCBlcnJvciB9O1xuICB9XG4gIGZ1bmN0aW9uIGVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uKHBvc2l0aW9ucywgZ2V0UG9zaXRpb24sIGdldEtleSkge1xuICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zMiA9IHBvc2l0aW9ucztcbiAgICBnZXRTY3JvbGxQb3NpdGlvbiA9IGdldFBvc2l0aW9uO1xuICAgIGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5MiA9IGdldEtleSB8fCBudWxsO1xuICAgIGlmICghaW5pdGlhbFNjcm9sbFJlc3RvcmVkICYmIHN0YXRlLm5hdmlnYXRpb24gPT09IElETEVfTkFWSUdBVElPTikge1xuICAgICAgaW5pdGlhbFNjcm9sbFJlc3RvcmVkID0gdHJ1ZTtcbiAgICAgIGxldCB5ID0gZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbihzdGF0ZS5sb2NhdGlvbiwgc3RhdGUubWF0Y2hlcyk7XG4gICAgICBpZiAoeSAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZVN0YXRlKHsgcmVzdG9yZVNjcm9sbFBvc2l0aW9uOiB5IH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnMyID0gbnVsbDtcbiAgICAgIGdldFNjcm9sbFBvc2l0aW9uID0gbnVsbDtcbiAgICAgIGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5MiA9IG51bGw7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBnZXRTY3JvbGxLZXkobG9jYXRpb24sIG1hdGNoZXMpIHtcbiAgICBpZiAoZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkyKSB7XG4gICAgICBsZXQga2V5ID0gZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkyKFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgbWF0Y2hlcy5tYXAoKG0pID0+IGNvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoKG0sIHN0YXRlLmxvYWRlckRhdGEpKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBrZXkgfHwgbG9jYXRpb24ua2V5O1xuICAgIH1cbiAgICByZXR1cm4gbG9jYXRpb24ua2V5O1xuICB9XG4gIGZ1bmN0aW9uIHNhdmVTY3JvbGxQb3NpdGlvbihsb2NhdGlvbiwgbWF0Y2hlcykge1xuICAgIGlmIChzYXZlZFNjcm9sbFBvc2l0aW9uczIgJiYgZ2V0U2Nyb2xsUG9zaXRpb24pIHtcbiAgICAgIGxldCBrZXkgPSBnZXRTY3JvbGxLZXkobG9jYXRpb24sIG1hdGNoZXMpO1xuICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnMyW2tleV0gPSBnZXRTY3JvbGxQb3NpdGlvbigpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRTYXZlZFNjcm9sbFBvc2l0aW9uKGxvY2F0aW9uLCBtYXRjaGVzKSB7XG4gICAgaWYgKHNhdmVkU2Nyb2xsUG9zaXRpb25zMikge1xuICAgICAgbGV0IGtleSA9IGdldFNjcm9sbEtleShsb2NhdGlvbiwgbWF0Y2hlcyk7XG4gICAgICBsZXQgeSA9IHNhdmVkU2Nyb2xsUG9zaXRpb25zMltrZXldO1xuICAgICAgaWYgKHR5cGVvZiB5ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiB5O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBjaGVja0ZvZ09mV2FyKG1hdGNoZXMsIHJvdXRlc1RvVXNlLCBwYXRobmFtZSkge1xuICAgIGlmIChpbml0LnBhdGNoUm91dGVzT25OYXZpZ2F0aW9uKSB7XG4gICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgbGV0IGZvZ01hdGNoZXMgPSBtYXRjaFJvdXRlc0ltcGwoXG4gICAgICAgICAgcm91dGVzVG9Vc2UsXG4gICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgYmFzZW5hbWUsXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4geyBhY3RpdmU6IHRydWUsIG1hdGNoZXM6IGZvZ01hdGNoZXMgfHwgW10gfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhtYXRjaGVzWzBdLnBhcmFtcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGxldCBwYXJ0aWFsTWF0Y2hlcyA9IG1hdGNoUm91dGVzSW1wbChcbiAgICAgICAgICAgIHJvdXRlc1RvVXNlLFxuICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiB7IGFjdGl2ZTogdHJ1ZSwgbWF0Y2hlczogcGFydGlhbE1hdGNoZXMgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBhY3RpdmU6IGZhbHNlLCBtYXRjaGVzOiBudWxsIH07XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZGlzY292ZXJSb3V0ZXMobWF0Y2hlcywgcGF0aG5hbWUsIHNpZ25hbCwgZmV0Y2hlcktleSkge1xuICAgIGlmICghaW5pdC5wYXRjaFJvdXRlc09uTmF2aWdhdGlvbikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJzdWNjZXNzXCIsIG1hdGNoZXMgfTtcbiAgICB9XG4gICAgbGV0IHBhcnRpYWxNYXRjaGVzID0gbWF0Y2hlcztcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgbGV0IGlzTm9uSE1SID0gaW5GbGlnaHREYXRhUm91dGVzID09IG51bGw7XG4gICAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICAgIGxldCBsb2NhbE1hbmlmZXN0ID0gbWFuaWZlc3Q7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBpbml0LnBhdGNoUm91dGVzT25OYXZpZ2F0aW9uKHtcbiAgICAgICAgICBzaWduYWwsXG4gICAgICAgICAgcGF0aDogcGF0aG5hbWUsXG4gICAgICAgICAgbWF0Y2hlczogcGFydGlhbE1hdGNoZXMsXG4gICAgICAgICAgZmV0Y2hlcktleSxcbiAgICAgICAgICBwYXRjaDogKHJvdXRlSWQsIGNoaWxkcmVuKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHJldHVybjtcbiAgICAgICAgICAgIHBhdGNoUm91dGVzSW1wbChcbiAgICAgICAgICAgICAgcm91dGVJZCxcbiAgICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICAgIHJvdXRlc1RvVXNlLFxuICAgICAgICAgICAgICBsb2NhbE1hbmlmZXN0LFxuICAgICAgICAgICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgZXJyb3I6IGUsIHBhcnRpYWxNYXRjaGVzIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoaXNOb25ITVIgJiYgIXNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgZGF0YVJvdXRlcyA9IFsuLi5kYXRhUm91dGVzXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiYWJvcnRlZFwiIH07XG4gICAgICB9XG4gICAgICBsZXQgbmV3TWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlc1RvVXNlLCBwYXRobmFtZSwgYmFzZW5hbWUpO1xuICAgICAgaWYgKG5ld01hdGNoZXMpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJzdWNjZXNzXCIsIG1hdGNoZXM6IG5ld01hdGNoZXMgfTtcbiAgICAgIH1cbiAgICAgIGxldCBuZXdQYXJ0aWFsTWF0Y2hlcyA9IG1hdGNoUm91dGVzSW1wbChcbiAgICAgICAgcm91dGVzVG9Vc2UsXG4gICAgICAgIHBhdGhuYW1lLFxuICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICAgIGlmICghbmV3UGFydGlhbE1hdGNoZXMgfHwgcGFydGlhbE1hdGNoZXMubGVuZ3RoID09PSBuZXdQYXJ0aWFsTWF0Y2hlcy5sZW5ndGggJiYgcGFydGlhbE1hdGNoZXMuZXZlcnkoXG4gICAgICAgIChtLCBpKSA9PiBtLnJvdXRlLmlkID09PSBuZXdQYXJ0aWFsTWF0Y2hlc1tpXS5yb3V0ZS5pZFxuICAgICAgKSkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcInN1Y2Nlc3NcIiwgbWF0Y2hlczogbnVsbCB9O1xuICAgICAgfVxuICAgICAgcGFydGlhbE1hdGNoZXMgPSBuZXdQYXJ0aWFsTWF0Y2hlcztcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gX2ludGVybmFsU2V0Um91dGVzKG5ld1JvdXRlcykge1xuICAgIG1hbmlmZXN0ID0ge307XG4gICAgaW5GbGlnaHREYXRhUm91dGVzID0gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhcbiAgICAgIG5ld1JvdXRlcyxcbiAgICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgICB2b2lkIDAsXG4gICAgICBtYW5pZmVzdFxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gcGF0Y2hSb3V0ZXMocm91dGVJZCwgY2hpbGRyZW4pIHtcbiAgICBsZXQgaXNOb25ITVIgPSBpbkZsaWdodERhdGFSb3V0ZXMgPT0gbnVsbDtcbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBwYXRjaFJvdXRlc0ltcGwoXG4gICAgICByb3V0ZUlkLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICByb3V0ZXNUb1VzZSxcbiAgICAgIG1hbmlmZXN0LFxuICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMlxuICAgICk7XG4gICAgaWYgKGlzTm9uSE1SKSB7XG4gICAgICBkYXRhUm91dGVzID0gWy4uLmRhdGFSb3V0ZXNdO1xuICAgICAgdXBkYXRlU3RhdGUoe30pO1xuICAgIH1cbiAgfVxuICByb3V0ZXIgPSB7XG4gICAgZ2V0IGJhc2VuYW1lKCkge1xuICAgICAgcmV0dXJuIGJhc2VuYW1lO1xuICAgIH0sXG4gICAgZ2V0IGZ1dHVyZSgpIHtcbiAgICAgIHJldHVybiBmdXR1cmU7XG4gICAgfSxcbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSxcbiAgICBnZXQgcm91dGVzKCkge1xuICAgICAgcmV0dXJuIGRhdGFSb3V0ZXM7XG4gICAgfSxcbiAgICBnZXQgd2luZG93KCkge1xuICAgICAgcmV0dXJuIHJvdXRlcldpbmRvdztcbiAgICB9LFxuICAgIGluaXRpYWxpemUsXG4gICAgc3Vic2NyaWJlLFxuICAgIGVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uLFxuICAgIG5hdmlnYXRlLFxuICAgIGZldGNoOiBmZXRjaDIsXG4gICAgcmV2YWxpZGF0ZSxcbiAgICAvLyBQYXNzdGhyb3VnaCB0byBoaXN0b3J5LWF3YXJlIGNyZWF0ZUhyZWYgdXNlZCBieSB1c2VIcmVmIHNvIHdlIGdldCBwcm9wZXJcbiAgICAvLyBoYXNoLWF3YXJlIFVSTHMgaW4gRE9NIHBhdGhzXG4gICAgY3JlYXRlSHJlZjogKHRvKSA9PiBpbml0Lmhpc3RvcnkuY3JlYXRlSHJlZih0byksXG4gICAgZW5jb2RlTG9jYXRpb246ICh0bykgPT4gaW5pdC5oaXN0b3J5LmVuY29kZUxvY2F0aW9uKHRvKSxcbiAgICBnZXRGZXRjaGVyLFxuICAgIGRlbGV0ZUZldGNoZXI6IHF1ZXVlRmV0Y2hlckZvckRlbGV0aW9uLFxuICAgIGRpc3Bvc2UsXG4gICAgZ2V0QmxvY2tlcixcbiAgICBkZWxldGVCbG9ja2VyLFxuICAgIHBhdGNoUm91dGVzLFxuICAgIF9pbnRlcm5hbEZldGNoQ29udHJvbGxlcnM6IGZldGNoQ29udHJvbGxlcnMsXG4gICAgLy8gVE9ETzogUmVtb3ZlIHNldFJvdXRlcywgaXQncyB0ZW1wb3JhcnkgdG8gYXZvaWQgZGVhbGluZyB3aXRoXG4gICAgLy8gdXBkYXRpbmcgdGhlIHRyZWUgd2hpbGUgdmFsaWRhdGluZyB0aGUgdXBkYXRlIGFsZ29yaXRobS5cbiAgICBfaW50ZXJuYWxTZXRSb3V0ZXNcbiAgfTtcbiAgcmV0dXJuIHJvdXRlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY0hhbmRsZXIocm91dGVzLCBvcHRzKSB7XG4gIGludmFyaWFudChcbiAgICByb3V0ZXMubGVuZ3RoID4gMCxcbiAgICBcIllvdSBtdXN0IHByb3ZpZGUgYSBub24tZW1wdHkgcm91dGVzIGFycmF5IHRvIGNyZWF0ZVN0YXRpY0hhbmRsZXJcIlxuICApO1xuICBsZXQgbWFuaWZlc3QgPSB7fTtcbiAgbGV0IGJhc2VuYW1lID0gKG9wdHMgPyBvcHRzLmJhc2VuYW1lIDogbnVsbCkgfHwgXCIvXCI7XG4gIGxldCBtYXBSb3V0ZVByb3BlcnRpZXMyID0gb3B0cz8ubWFwUm91dGVQcm9wZXJ0aWVzIHx8IGRlZmF1bHRNYXBSb3V0ZVByb3BlcnRpZXM7XG4gIGxldCBkYXRhUm91dGVzID0gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhcbiAgICByb3V0ZXMsXG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICB2b2lkIDAsXG4gICAgbWFuaWZlc3RcbiAgKTtcbiAgYXN5bmMgZnVuY3Rpb24gcXVlcnkocmVxdWVzdCwge1xuICAgIHJlcXVlc3RDb250ZXh0LFxuICAgIGZpbHRlck1hdGNoZXNUb0xvYWQsXG4gICAgc2tpcExvYWRlckVycm9yQnViYmxpbmcsXG4gICAgc2tpcFJldmFsaWRhdGlvbixcbiAgICBkYXRhU3RyYXRlZ3ksXG4gICAgdW5zdGFibGVfcmVzcG9uZDogcmVzcG9uZFxuICB9ID0ge30pIHtcbiAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgbGV0IG1ldGhvZCA9IHJlcXVlc3QubWV0aG9kO1xuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKFwiXCIsIGNyZWF0ZVBhdGgodXJsKSwgbnVsbCwgXCJkZWZhdWx0XCIpO1xuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMoZGF0YVJvdXRlcywgbG9jYXRpb24sIGJhc2VuYW1lKTtcbiAgICByZXF1ZXN0Q29udGV4dCA9IHJlcXVlc3RDb250ZXh0ICE9IG51bGwgPyByZXF1ZXN0Q29udGV4dCA6IG5ldyB1bnN0YWJsZV9Sb3V0ZXJDb250ZXh0UHJvdmlkZXIoKTtcbiAgICBpZiAoIWlzVmFsaWRNZXRob2QobWV0aG9kKSAmJiBtZXRob2QgIT09IFwiSEVBRFwiKSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwgeyBtZXRob2QgfSk7XG4gICAgICBsZXQgeyBtYXRjaGVzOiBtZXRob2ROb3RBbGxvd2VkTWF0Y2hlcywgcm91dGUgfSA9IGdldFNob3J0Q2lyY3VpdE1hdGNoZXMoZGF0YVJvdXRlcyk7XG4gICAgICBsZXQgc3RhdGljQ29udGV4dCA9IHtcbiAgICAgICAgYmFzZW5hbWUsXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBtYXRjaGVzOiBtZXRob2ROb3RBbGxvd2VkTWF0Y2hlcyxcbiAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yczoge1xuICAgICAgICAgIFtyb3V0ZS5pZF06IGVycm9yXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXR1c0NvZGU6IGVycm9yLnN0YXR1cyxcbiAgICAgICAgbG9hZGVySGVhZGVyczoge30sXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHt9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlc3BvbmQgPyByZXNwb25kKHN0YXRpY0NvbnRleHQpIDogc3RhdGljQ29udGV4dDtcbiAgICB9IGVsc2UgaWYgKCFtYXRjaGVzKSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUgfSk7XG4gICAgICBsZXQgeyBtYXRjaGVzOiBub3RGb3VuZE1hdGNoZXMsIHJvdXRlIH0gPSBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKGRhdGFSb3V0ZXMpO1xuICAgICAgbGV0IHN0YXRpY0NvbnRleHQgPSB7XG4gICAgICAgIGJhc2VuYW1lLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgW3JvdXRlLmlkXTogZXJyb3JcbiAgICAgICAgfSxcbiAgICAgICAgc3RhdHVzQ29kZTogZXJyb3Iuc3RhdHVzLFxuICAgICAgICBsb2FkZXJIZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aW9uSGVhZGVyczoge31cbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVzcG9uZCA/IHJlc3BvbmQoc3RhdGljQ29udGV4dCkgOiBzdGF0aWNDb250ZXh0O1xuICAgIH1cbiAgICBpZiAocmVzcG9uZCAmJiBtYXRjaGVzLnNvbWUoXG4gICAgICAobSkgPT4gbS5yb3V0ZS51bnN0YWJsZV9taWRkbGV3YXJlIHx8IHR5cGVvZiBtLnJvdXRlLmxhenkgPT09IFwib2JqZWN0XCIgJiYgbS5yb3V0ZS5sYXp5LnVuc3RhYmxlX21pZGRsZXdhcmVcbiAgICApKSB7XG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgIHJlcXVlc3RDb250ZXh0IGluc3RhbmNlb2YgdW5zdGFibGVfUm91dGVyQ29udGV4dFByb3ZpZGVyLFxuICAgICAgICBcIldoZW4gdXNpbmcgbWlkZGxld2FyZSBpbiBgc3RhdGljSGFuZGxlci5xdWVyeSgpYCwgYW55IHByb3ZpZGVkIGByZXF1ZXN0Q29udGV4dGAgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBgdW5zdGFibGVfUm91dGVyQ29udGV4dFByb3ZpZGVyYFwiXG4gICAgICApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgbG9hZExhenlNaWRkbGV3YXJlRm9yTWF0Y2hlcyhcbiAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgIG1hbmlmZXN0LFxuICAgICAgICAgIG1hcFJvdXRlUHJvcGVydGllczJcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IHJlbmRlcmVkU3RhdGljQ29udGV4dDtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgcnVuTWlkZGxld2FyZVBpcGVsaW5lKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgICAgcGFyYW1zOiBtYXRjaGVzWzBdLnBhcmFtcyxcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIGNhbGxpbmcgbWlkZGxld2FyZSB0aGVuIGl0IG11c3QgYmUgZW5hYmxlZCBzbyB3ZSBjYW4gY2FzdFxuICAgICAgICAgICAgLy8gdGhpcyB0byB0aGUgcHJvcGVyIHR5cGUga25vd2luZyBpdCdzIG5vdCBhbiBgQXBwTG9hZENvbnRleHRgXG4gICAgICAgICAgICBjb250ZXh0OiByZXF1ZXN0Q29udGV4dFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0MiA9IGF3YWl0IHF1ZXJ5SW1wbChcbiAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgICAgICAgICBkYXRhU3RyYXRlZ3kgfHwgbnVsbCxcbiAgICAgICAgICAgICAgc2tpcExvYWRlckVycm9yQnViYmxpbmcgPT09IHRydWUsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIGZpbHRlck1hdGNoZXNUb0xvYWQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgc2tpcFJldmFsaWRhdGlvbiA9PT0gdHJ1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChpc1Jlc3BvbnNlKHJlc3VsdDIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVuZGVyZWRTdGF0aWNDb250ZXh0ID0geyBsb2NhdGlvbiwgYmFzZW5hbWUsIC4uLnJlc3VsdDIgfTtcbiAgICAgICAgICAgIGxldCByZXMgPSBhd2FpdCByZXNwb25kKHJlbmRlcmVkU3RhdGljQ29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYXN5bmMgKGVycm9yLCByb3V0ZUlkKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNSZXNwb25zZShlcnJvcikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlbmRlcmVkU3RhdGljQ29udGV4dCkge1xuICAgICAgICAgICAgICBpZiAocm91dGVJZCBpbiByZW5kZXJlZFN0YXRpY0NvbnRleHQubG9hZGVyRGF0YSkge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVkU3RhdGljQ29udGV4dC5sb2FkZXJEYXRhW3JvdXRlSWRdID0gdm9pZCAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXNwb25kKFxuICAgICAgICAgICAgICAgIGdldFN0YXRpY0NvbnRleHRGcm9tRXJyb3IoXG4gICAgICAgICAgICAgICAgICBkYXRhUm91dGVzLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyZWRTdGF0aWNDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgICBza2lwTG9hZGVyRXJyb3JCdWJibGluZyA/IHJvdXRlSWQgOiBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMsIHJvdXRlSWQpLnJvdXRlLmlkXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbGV0IGJvdW5kYXJ5Um91dGVJZCA9IHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nID8gcm91dGVJZCA6IGZpbmROZWFyZXN0Qm91bmRhcnkoXG4gICAgICAgICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICAgICAgICBtYXRjaGVzLmZpbmQoXG4gICAgICAgICAgICAgICAgICAobSkgPT4gbS5yb3V0ZS5pZCA9PT0gcm91dGVJZCB8fCBtLnJvdXRlLmxvYWRlclxuICAgICAgICAgICAgICAgICk/LnJvdXRlLmlkIHx8IHJvdXRlSWRcbiAgICAgICAgICAgICAgKS5yb3V0ZS5pZDtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbmQoe1xuICAgICAgICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgICAgICAgYmFzZW5hbWUsXG4gICAgICAgICAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgICAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICAgICAgICAgIFtib3VuZGFyeVJvdXRlSWRdOiBlcnJvclxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogaXNSb3V0ZUVycm9yUmVzcG9uc2UoZXJyb3IpID8gZXJyb3Iuc3RhdHVzIDogNTAwLFxuICAgICAgICAgICAgICAgIGFjdGlvbkhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgICAgIGxvYWRlckhlYWRlcnM6IHt9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgaW52YXJpYW50KGlzUmVzcG9uc2UocmVzcG9uc2UpLCBcIkV4cGVjdGVkIGEgcmVzcG9uc2UgaW4gcXVlcnkoKVwiKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoaXNSZXNwb25zZShlKSkge1xuICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBhd2FpdCBxdWVyeUltcGwoXG4gICAgICByZXF1ZXN0LFxuICAgICAgbG9jYXRpb24sXG4gICAgICBtYXRjaGVzLFxuICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICBkYXRhU3RyYXRlZ3kgfHwgbnVsbCxcbiAgICAgIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nID09PSB0cnVlLFxuICAgICAgbnVsbCxcbiAgICAgIGZpbHRlck1hdGNoZXNUb0xvYWQgfHwgbnVsbCxcbiAgICAgIHNraXBSZXZhbGlkYXRpb24gPT09IHRydWVcbiAgICApO1xuICAgIGlmIChpc1Jlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiB7IGxvY2F0aW9uLCBiYXNlbmFtZSwgLi4ucmVzdWx0IH07XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcXVlcnlSb3V0ZShyZXF1ZXN0LCB7XG4gICAgcm91dGVJZCxcbiAgICByZXF1ZXN0Q29udGV4dCxcbiAgICBkYXRhU3RyYXRlZ3ksXG4gICAgdW5zdGFibGVfcmVzcG9uZDogcmVzcG9uZFxuICB9ID0ge30pIHtcbiAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgbGV0IG1ldGhvZCA9IHJlcXVlc3QubWV0aG9kO1xuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKFwiXCIsIGNyZWF0ZVBhdGgodXJsKSwgbnVsbCwgXCJkZWZhdWx0XCIpO1xuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMoZGF0YVJvdXRlcywgbG9jYXRpb24sIGJhc2VuYW1lKTtcbiAgICByZXF1ZXN0Q29udGV4dCA9IHJlcXVlc3RDb250ZXh0ICE9IG51bGwgPyByZXF1ZXN0Q29udGV4dCA6IG5ldyB1bnN0YWJsZV9Sb3V0ZXJDb250ZXh0UHJvdmlkZXIoKTtcbiAgICBpZiAoIWlzVmFsaWRNZXRob2QobWV0aG9kKSAmJiBtZXRob2QgIT09IFwiSEVBRFwiICYmIG1ldGhvZCAhPT0gXCJPUFRJT05TXCIpIHtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7IG1ldGhvZCB9KTtcbiAgICB9IGVsc2UgaWYgKCFtYXRjaGVzKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUgfSk7XG4gICAgfVxuICAgIGxldCBtYXRjaCA9IHJvdXRlSWQgPyBtYXRjaGVzLmZpbmQoKG0pID0+IG0ucm91dGUuaWQgPT09IHJvdXRlSWQpIDogZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgbG9jYXRpb24pO1xuICAgIGlmIChyb3V0ZUlkICYmICFtYXRjaCkge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDMsIHtcbiAgICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICByb3V0ZUlkXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFtYXRjaCkge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHsgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lIH0pO1xuICAgIH1cbiAgICBpZiAocmVzcG9uZCAmJiBtYXRjaGVzLnNvbWUoXG4gICAgICAobSkgPT4gbS5yb3V0ZS51bnN0YWJsZV9taWRkbGV3YXJlIHx8IHR5cGVvZiBtLnJvdXRlLmxhenkgPT09IFwib2JqZWN0XCIgJiYgbS5yb3V0ZS5sYXp5LnVuc3RhYmxlX21pZGRsZXdhcmVcbiAgICApKSB7XG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgIHJlcXVlc3RDb250ZXh0IGluc3RhbmNlb2YgdW5zdGFibGVfUm91dGVyQ29udGV4dFByb3ZpZGVyLFxuICAgICAgICBcIldoZW4gdXNpbmcgbWlkZGxld2FyZSBpbiBgc3RhdGljSGFuZGxlci5xdWVyeVJvdXRlKClgLCBhbnkgcHJvdmlkZWQgYHJlcXVlc3RDb250ZXh0YCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIGB1bnN0YWJsZV9Sb3V0ZXJDb250ZXh0UHJvdmlkZXJgXCJcbiAgICAgICk7XG4gICAgICBhd2FpdCBsb2FkTGF6eU1pZGRsZXdhcmVGb3JNYXRjaGVzKG1hdGNoZXMsIG1hbmlmZXN0LCBtYXBSb3V0ZVByb3BlcnRpZXMyKTtcbiAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHJ1bk1pZGRsZXdhcmVQaXBlbGluZShcbiAgICAgICAge1xuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICBwYXJhbXM6IG1hdGNoZXNbMF0ucGFyYW1zLFxuICAgICAgICAgIC8vIElmIHdlJ3JlIGNhbGxpbmcgbWlkZGxld2FyZSB0aGVuIGl0IG11c3QgYmUgZW5hYmxlZCBzbyB3ZSBjYW4gY2FzdFxuICAgICAgICAgIC8vIHRoaXMgdG8gdGhlIHByb3BlciB0eXBlIGtub3dpbmcgaXQncyBub3QgYW4gYEFwcExvYWRDb250ZXh0YFxuICAgICAgICAgIGNvbnRleHQ6IHJlcXVlc3RDb250ZXh0XG4gICAgICAgIH0sXG4gICAgICAgIHRydWUsXG4gICAgICAgIGFzeW5jICgpID0+IHtcbiAgICAgICAgICBsZXQgcmVzdWx0MiA9IGF3YWl0IHF1ZXJ5SW1wbChcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgICAgICAgIGRhdGFTdHJhdGVneSB8fCBudWxsLFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGlzUmVzcG9uc2UocmVzdWx0MikpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25kKHJlc3VsdDIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgZXJyb3IyID0gcmVzdWx0Mi5lcnJvcnMgPyBPYmplY3QudmFsdWVzKHJlc3VsdDIuZXJyb3JzKVswXSA6IHZvaWQgMDtcbiAgICAgICAgICBpZiAoZXJyb3IyICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHZhbHVlID0gcmVzdWx0Mi5hY3Rpb25EYXRhID8gT2JqZWN0LnZhbHVlcyhyZXN1bHQyLmFjdGlvbkRhdGEpWzBdIDogT2JqZWN0LnZhbHVlcyhyZXN1bHQyLmxvYWRlckRhdGEpWzBdO1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyBuZXcgUmVzcG9uc2UodmFsdWUpIDogUmVzcG9uc2UuanNvbih2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnJvcjIpID0+IHtcbiAgICAgICAgICBpZiAoaXNSZXNwb25zZShlcnJvcjIpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uZChlcnJvcjIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKFN0cmluZyhlcnJvcjIpLCB7XG4gICAgICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgICAgICAgIHN0YXR1c1RleHQ6IFwiVW5leHBlY3RlZCBTZXJ2ZXIgRXJyb3JcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgcXVlcnlJbXBsKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgZGF0YVN0cmF0ZWd5IHx8IG51bGwsXG4gICAgICBmYWxzZSxcbiAgICAgIG1hdGNoLFxuICAgICAgbnVsbCxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICBpZiAoaXNSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBsZXQgZXJyb3IgPSByZXN1bHQuZXJyb3JzID8gT2JqZWN0LnZhbHVlcyhyZXN1bHQuZXJyb3JzKVswXSA6IHZvaWQgMDtcbiAgICBpZiAoZXJyb3IgIT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmIChyZXN1bHQuYWN0aW9uRGF0YSkge1xuICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMocmVzdWx0LmFjdGlvbkRhdGEpWzBdO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LmxvYWRlckRhdGEpIHtcbiAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHJlc3VsdC5sb2FkZXJEYXRhKVswXTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBxdWVyeUltcGwocmVxdWVzdCwgbG9jYXRpb24sIG1hdGNoZXMsIHJlcXVlc3RDb250ZXh0LCBkYXRhU3RyYXRlZ3ksIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nLCByb3V0ZU1hdGNoLCBmaWx0ZXJNYXRjaGVzVG9Mb2FkLCBza2lwUmV2YWxpZGF0aW9uKSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgcmVxdWVzdC5zaWduYWwsXG4gICAgICBcInF1ZXJ5KCkvcXVlcnlSb3V0ZSgpIHJlcXVlc3RzIG11c3QgY29udGFpbiBhbiBBYm9ydENvbnRyb2xsZXIgc2lnbmFsXCJcbiAgICApO1xuICAgIHRyeSB7XG4gICAgICBpZiAoaXNNdXRhdGlvbk1ldGhvZChyZXF1ZXN0Lm1ldGhvZCkpIHtcbiAgICAgICAgbGV0IHJlc3VsdDIgPSBhd2FpdCBzdWJtaXQoXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgIHJvdXRlTWF0Y2ggfHwgZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgbG9jYXRpb24pLFxuICAgICAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgICAgIGRhdGFTdHJhdGVneSxcbiAgICAgICAgICBza2lwTG9hZGVyRXJyb3JCdWJibGluZyxcbiAgICAgICAgICByb3V0ZU1hdGNoICE9IG51bGwsXG4gICAgICAgICAgZmlsdGVyTWF0Y2hlc1RvTG9hZCxcbiAgICAgICAgICBza2lwUmV2YWxpZGF0aW9uXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgfVxuICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGxvYWRSb3V0ZURhdGEoXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgICBkYXRhU3RyYXRlZ3ksXG4gICAgICAgIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nLFxuICAgICAgICByb3V0ZU1hdGNoLFxuICAgICAgICBmaWx0ZXJNYXRjaGVzVG9Mb2FkXG4gICAgICApO1xuICAgICAgcmV0dXJuIGlzUmVzcG9uc2UocmVzdWx0KSA/IHJlc3VsdCA6IHtcbiAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICBhY3Rpb25EYXRhOiBudWxsLFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoaXNEYXRhU3RyYXRlZ3lSZXN1bHQoZSkgJiYgaXNSZXNwb25zZShlLnJlc3VsdCkpIHtcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJlcnJvclwiIC8qIGVycm9yICovKSB7XG4gICAgICAgICAgdGhyb3cgZS5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGUucmVzdWx0O1xuICAgICAgfVxuICAgICAgaWYgKGlzUmVkaXJlY3RSZXNwb25zZShlKSkge1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHN1Ym1pdChyZXF1ZXN0LCBtYXRjaGVzLCBhY3Rpb25NYXRjaCwgcmVxdWVzdENvbnRleHQsIGRhdGFTdHJhdGVneSwgc2tpcExvYWRlckVycm9yQnViYmxpbmcsIGlzUm91dGVSZXF1ZXN0LCBmaWx0ZXJNYXRjaGVzVG9Mb2FkLCBza2lwUmV2YWxpZGF0aW9uKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAoIWFjdGlvbk1hdGNoLnJvdXRlLmFjdGlvbiAmJiAhYWN0aW9uTWF0Y2gucm91dGUubGF6eSkge1xuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcbiAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgcGF0aG5hbWU6IG5ldyBVUkwocmVxdWVzdC51cmwpLnBhdGhuYW1lLFxuICAgICAgICByb3V0ZUlkOiBhY3Rpb25NYXRjaC5yb3V0ZS5pZFxuICAgICAgfSk7XG4gICAgICBpZiAoaXNSb3V0ZVJlcXVlc3QpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIHR5cGU6IFwiZXJyb3JcIiAvKiBlcnJvciAqLyxcbiAgICAgICAgZXJyb3JcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkc01hdGNoZXMgPSBnZXRUYXJnZXRlZERhdGFTdHJhdGVneU1hdGNoZXMoXG4gICAgICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgICAgIG1hbmlmZXN0LFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBhY3Rpb25NYXRjaCxcbiAgICAgICAgW10sXG4gICAgICAgIHJlcXVlc3RDb250ZXh0XG4gICAgICApO1xuICAgICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBjYWxsRGF0YVN0cmF0ZWd5KFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBkc01hdGNoZXMsXG4gICAgICAgIGlzUm91dGVSZXF1ZXN0LFxuICAgICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgICAgZGF0YVN0cmF0ZWd5XG4gICAgICApO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0c1thY3Rpb25NYXRjaC5yb3V0ZS5pZF07XG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICB0aHJvd1N0YXRpY0hhbmRsZXJBYm9ydGVkRXJyb3IocmVxdWVzdCwgaXNSb3V0ZVJlcXVlc3QpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICB0aHJvdyBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICBzdGF0dXM6IHJlc3VsdC5yZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogcmVzdWx0LnJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiTG9jYXRpb25cIilcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpc1JvdXRlUmVxdWVzdCkge1xuICAgICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXRjaGVzOiBbYWN0aW9uTWF0Y2hdLFxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgYWN0aW9uRGF0YTogeyBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZGF0YSB9LFxuICAgICAgICBlcnJvcnM6IG51bGwsXG4gICAgICAgIC8vIE5vdGU6IHN0YXR1c0NvZGUgKyBoZWFkZXJzIGFyZSB1bnVzZWQgaGVyZSBzaW5jZSBxdWVyeVJvdXRlIHdpbGxcbiAgICAgICAgLy8gcmV0dXJuIHRoZSByYXcgUmVzcG9uc2Ugb3IgdmFsdWVcbiAgICAgICAgc3RhdHVzQ29kZTogMjAwLFxuICAgICAgICBsb2FkZXJIZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aW9uSGVhZGVyczoge31cbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChza2lwUmV2YWxpZGF0aW9uKSB7XG4gICAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gc2tpcExvYWRlckVycm9yQnViYmxpbmcgPyBhY3Rpb25NYXRjaCA6IGZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hlcywgYWN0aW9uTWF0Y2gucm91dGUuaWQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXR1c0NvZGU6IGlzUm91dGVFcnJvclJlc3BvbnNlKHJlc3VsdC5lcnJvcikgPyByZXN1bHQuZXJyb3Iuc3RhdHVzIDogcmVzdWx0LnN0YXR1c0NvZGUgIT0gbnVsbCA/IHJlc3VsdC5zdGF0dXNDb2RlIDogNTAwLFxuICAgICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgICAgYWN0aW9uSGVhZGVyczoge1xuICAgICAgICAgICAgLi4ucmVzdWx0LmhlYWRlcnMgPyB7IFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5oZWFkZXJzIH0gOiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICAgIFtib3VuZGFyeU1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmVycm9yXG4gICAgICAgICAgfSxcbiAgICAgICAgICBsb2FkZXJIZWFkZXJzOiB7fVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhY3Rpb25EYXRhOiB7XG4gICAgICAgICAgICBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZGF0YVxuICAgICAgICAgIH0sXG4gICAgICAgICAgYWN0aW9uSGVhZGVyczogcmVzdWx0LmhlYWRlcnMgPyB7IFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5oZWFkZXJzIH0gOiB7fSxcbiAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICAgIGVycm9yczogbnVsbCxcbiAgICAgICAgICBzdGF0dXNDb2RlOiByZXN1bHQuc3RhdHVzQ29kZSB8fCAyMDAsXG4gICAgICAgICAgbG9hZGVySGVhZGVyczoge31cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGxvYWRlclJlcXVlc3QgPSBuZXcgUmVxdWVzdChyZXF1ZXN0LnVybCwge1xuICAgICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzLFxuICAgICAgcmVkaXJlY3Q6IHJlcXVlc3QucmVkaXJlY3QsXG4gICAgICBzaWduYWw6IHJlcXVlc3Quc2lnbmFsXG4gICAgfSk7XG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBza2lwTG9hZGVyRXJyb3JCdWJibGluZyA/IGFjdGlvbk1hdGNoIDogZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCBhY3Rpb25NYXRjaC5yb3V0ZS5pZCk7XG4gICAgICBsZXQgaGFuZGxlckNvbnRleHQyID0gYXdhaXQgbG9hZFJvdXRlRGF0YShcbiAgICAgICAgbG9hZGVyUmVxdWVzdCxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICAgIGRhdGFTdHJhdGVneSxcbiAgICAgICAgc2tpcExvYWRlckVycm9yQnViYmxpbmcsXG4gICAgICAgIG51bGwsXG4gICAgICAgIGZpbHRlck1hdGNoZXNUb0xvYWQsXG4gICAgICAgIFtib3VuZGFyeU1hdGNoLnJvdXRlLmlkLCByZXN1bHRdXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uaGFuZGxlckNvbnRleHQyLFxuICAgICAgICBzdGF0dXNDb2RlOiBpc1JvdXRlRXJyb3JSZXNwb25zZShyZXN1bHQuZXJyb3IpID8gcmVzdWx0LmVycm9yLnN0YXR1cyA6IHJlc3VsdC5zdGF0dXNDb2RlICE9IG51bGwgPyByZXN1bHQuc3RhdHVzQ29kZSA6IDUwMCxcbiAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgYWN0aW9uSGVhZGVyczoge1xuICAgICAgICAgIC4uLnJlc3VsdC5oZWFkZXJzID8geyBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQuaGVhZGVycyB9IDoge31cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IGhhbmRsZXJDb250ZXh0ID0gYXdhaXQgbG9hZFJvdXRlRGF0YShcbiAgICAgIGxvYWRlclJlcXVlc3QsXG4gICAgICBtYXRjaGVzLFxuICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICBkYXRhU3RyYXRlZ3ksXG4gICAgICBza2lwTG9hZGVyRXJyb3JCdWJibGluZyxcbiAgICAgIG51bGwsXG4gICAgICBmaWx0ZXJNYXRjaGVzVG9Mb2FkXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uaGFuZGxlckNvbnRleHQsXG4gICAgICBhY3Rpb25EYXRhOiB7XG4gICAgICAgIFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5kYXRhXG4gICAgICB9LFxuICAgICAgLy8gYWN0aW9uIHN0YXR1cyBjb2RlcyB0YWtlIHByZWNlZGVuY2Ugb3ZlciBsb2FkZXIgc3RhdHVzIGNvZGVzXG4gICAgICAuLi5yZXN1bHQuc3RhdHVzQ29kZSA/IHsgc3RhdHVzQ29kZTogcmVzdWx0LnN0YXR1c0NvZGUgfSA6IHt9LFxuICAgICAgYWN0aW9uSGVhZGVyczogcmVzdWx0LmhlYWRlcnMgPyB7IFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5oZWFkZXJzIH0gOiB7fVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbG9hZFJvdXRlRGF0YShyZXF1ZXN0LCBtYXRjaGVzLCByZXF1ZXN0Q29udGV4dCwgZGF0YVN0cmF0ZWd5LCBza2lwTG9hZGVyRXJyb3JCdWJibGluZywgcm91dGVNYXRjaCwgZmlsdGVyTWF0Y2hlc1RvTG9hZCwgcGVuZGluZ0FjdGlvblJlc3VsdCkge1xuICAgIGxldCBpc1JvdXRlUmVxdWVzdCA9IHJvdXRlTWF0Y2ggIT0gbnVsbDtcbiAgICBpZiAoaXNSb3V0ZVJlcXVlc3QgJiYgIXJvdXRlTWF0Y2g/LnJvdXRlLmxvYWRlciAmJiAhcm91dGVNYXRjaD8ucm91dGUubGF6eSkge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDAsIHtcbiAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgcGF0aG5hbWU6IG5ldyBVUkwocmVxdWVzdC51cmwpLnBhdGhuYW1lLFxuICAgICAgICByb3V0ZUlkOiByb3V0ZU1hdGNoPy5yb3V0ZS5pZFxuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBkc01hdGNoZXM7XG4gICAgaWYgKHJvdXRlTWF0Y2gpIHtcbiAgICAgIGRzTWF0Y2hlcyA9IGdldFRhcmdldGVkRGF0YVN0cmF0ZWd5TWF0Y2hlcyhcbiAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIHJvdXRlTWF0Y2gsXG4gICAgICAgIFtdLFxuICAgICAgICByZXF1ZXN0Q29udGV4dFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG1heElkeCA9IHBlbmRpbmdBY3Rpb25SZXN1bHQgJiYgaXNFcnJvclJlc3VsdChwZW5kaW5nQWN0aW9uUmVzdWx0WzFdKSA/IChcbiAgICAgICAgLy8gVXAgdG8gYnV0IG5vdCBpbmNsdWRpbmcgdGhlIGJvdW5kYXJ5XG4gICAgICAgIG1hdGNoZXMuZmluZEluZGV4KChtKSA9PiBtLnJvdXRlLmlkID09PSBwZW5kaW5nQWN0aW9uUmVzdWx0WzBdKSAtIDFcbiAgICAgICkgOiB2b2lkIDA7XG4gICAgICBkc01hdGNoZXMgPSBtYXRjaGVzLm1hcCgobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChtYXhJZHggIT0gbnVsbCAmJiBpbmRleCA+IG1heElkeCkge1xuICAgICAgICAgIHJldHVybiBnZXREYXRhU3RyYXRlZ3lNYXRjaChcbiAgICAgICAgICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICAgIFtdLFxuICAgICAgICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldERhdGFTdHJhdGVneU1hdGNoKFxuICAgICAgICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBbXSxcbiAgICAgICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgICAgICAobWF0Y2gucm91dGUubG9hZGVyIHx8IG1hdGNoLnJvdXRlLmxhenkpICE9IG51bGwgJiYgKCFmaWx0ZXJNYXRjaGVzVG9Mb2FkIHx8IGZpbHRlck1hdGNoZXNUb0xvYWQobWF0Y2gpKVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghZGF0YVN0cmF0ZWd5ICYmICFkc01hdGNoZXMuc29tZSgobSkgPT4gbS5zaG91bGRMb2FkKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgIGVycm9yczogcGVuZGluZ0FjdGlvblJlc3VsdCAmJiBpc0Vycm9yUmVzdWx0KHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0pID8ge1xuICAgICAgICAgIFtwZW5kaW5nQWN0aW9uUmVzdWx0WzBdXTogcGVuZGluZ0FjdGlvblJlc3VsdFsxXS5lcnJvclxuICAgICAgICB9IDogbnVsbCxcbiAgICAgICAgc3RhdHVzQ29kZTogMjAwLFxuICAgICAgICBsb2FkZXJIZWFkZXJzOiB7fVxuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBjYWxsRGF0YVN0cmF0ZWd5KFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGRzTWF0Y2hlcyxcbiAgICAgIGlzUm91dGVSZXF1ZXN0LFxuICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICBkYXRhU3RyYXRlZ3lcbiAgICApO1xuICAgIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICB0aHJvd1N0YXRpY0hhbmRsZXJBYm9ydGVkRXJyb3IocmVxdWVzdCwgaXNSb3V0ZVJlcXVlc3QpO1xuICAgIH1cbiAgICBsZXQgaGFuZGxlckNvbnRleHQgPSBwcm9jZXNzUm91dGVMb2FkZXJEYXRhKFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIHJlc3VsdHMsXG4gICAgICBwZW5kaW5nQWN0aW9uUmVzdWx0LFxuICAgICAgdHJ1ZSxcbiAgICAgIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uaGFuZGxlckNvbnRleHQsXG4gICAgICBtYXRjaGVzXG4gICAgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjYWxsRGF0YVN0cmF0ZWd5KHJlcXVlc3QsIG1hdGNoZXMsIGlzUm91dGVSZXF1ZXN0LCByZXF1ZXN0Q29udGV4dCwgZGF0YVN0cmF0ZWd5KSB7XG4gICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBjYWxsRGF0YVN0cmF0ZWd5SW1wbChcbiAgICAgIGRhdGFTdHJhdGVneSB8fCBkZWZhdWx0RGF0YVN0cmF0ZWd5LFxuICAgICAgcmVxdWVzdCxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBudWxsLFxuICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICBsZXQgZGF0YVJlc3VsdHMgPSB7fTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIG1hdGNoZXMubWFwKGFzeW5jIChtYXRjaCkgPT4ge1xuICAgICAgICBpZiAoIShtYXRjaC5yb3V0ZS5pZCBpbiByZXN1bHRzKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gcmVzdWx0c1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgICAgIGlmIChpc1JlZGlyZWN0RGF0YVN0cmF0ZWd5UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgICAgICBsZXQgcmVzcG9uc2UgPSByZXN1bHQucmVzdWx0O1xuICAgICAgICAgIHRocm93IG5vcm1hbGl6ZVJlbGF0aXZlUm91dGluZ1JlZGlyZWN0UmVzcG9uc2UoXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICBtYXRjaC5yb3V0ZS5pZCxcbiAgICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgICBiYXNlbmFtZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUmVzcG9uc2UocmVzdWx0LnJlc3VsdCkgJiYgaXNSb3V0ZVJlcXVlc3QpIHtcbiAgICAgICAgICB0aHJvdyByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVJlc3VsdHNbbWF0Y2gucm91dGUuaWRdID0gYXdhaXQgY29udmVydERhdGFTdHJhdGVneVJlc3VsdFRvRGF0YVJlc3VsdChyZXN1bHQpO1xuICAgICAgfSlcbiAgICApO1xuICAgIHJldHVybiBkYXRhUmVzdWx0cztcbiAgfVxuICByZXR1cm4ge1xuICAgIGRhdGFSb3V0ZXMsXG4gICAgcXVlcnksXG4gICAgcXVlcnlSb3V0ZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0U3RhdGljQ29udGV4dEZyb21FcnJvcihyb3V0ZXMsIGhhbmRsZXJDb250ZXh0LCBlcnJvciwgYm91bmRhcnlJZCkge1xuICBsZXQgZXJyb3JCb3VuZGFyeUlkID0gYm91bmRhcnlJZCB8fCBoYW5kbGVyQ29udGV4dC5fZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCB8fCByb3V0ZXNbMF0uaWQ7XG4gIHJldHVybiB7XG4gICAgLi4uaGFuZGxlckNvbnRleHQsXG4gICAgc3RhdHVzQ29kZTogaXNSb3V0ZUVycm9yUmVzcG9uc2UoZXJyb3IpID8gZXJyb3Iuc3RhdHVzIDogNTAwLFxuICAgIGVycm9yczoge1xuICAgICAgW2Vycm9yQm91bmRhcnlJZF06IGVycm9yXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gdGhyb3dTdGF0aWNIYW5kbGVyQWJvcnRlZEVycm9yKHJlcXVlc3QsIGlzUm91dGVSZXF1ZXN0KSB7XG4gIGlmIChyZXF1ZXN0LnNpZ25hbC5yZWFzb24gIT09IHZvaWQgMCkge1xuICAgIHRocm93IHJlcXVlc3Quc2lnbmFsLnJlYXNvbjtcbiAgfVxuICBsZXQgbWV0aG9kID0gaXNSb3V0ZVJlcXVlc3QgPyBcInF1ZXJ5Um91dGVcIiA6IFwicXVlcnlcIjtcbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIGAke21ldGhvZH0oKSBjYWxsIGFib3J0ZWQgd2l0aG91dCBhbiBcXGBBYm9ydFNpZ25hbC5yZWFzb25cXGA6ICR7cmVxdWVzdC5tZXRob2R9ICR7cmVxdWVzdC51cmx9YFxuICApO1xufVxuZnVuY3Rpb24gaXNTdWJtaXNzaW9uTmF2aWdhdGlvbihvcHRzKSB7XG4gIHJldHVybiBvcHRzICE9IG51bGwgJiYgKFwiZm9ybURhdGFcIiBpbiBvcHRzICYmIG9wdHMuZm9ybURhdGEgIT0gbnVsbCB8fCBcImJvZHlcIiBpbiBvcHRzICYmIG9wdHMuYm9keSAhPT0gdm9pZCAwKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRvKGxvY2F0aW9uLCBtYXRjaGVzLCBiYXNlbmFtZSwgdG8sIGZyb21Sb3V0ZUlkLCByZWxhdGl2ZSkge1xuICBsZXQgY29udGV4dHVhbE1hdGNoZXM7XG4gIGxldCBhY3RpdmVSb3V0ZU1hdGNoO1xuICBpZiAoZnJvbVJvdXRlSWQpIHtcbiAgICBjb250ZXh0dWFsTWF0Y2hlcyA9IFtdO1xuICAgIGZvciAobGV0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICAgIGNvbnRleHR1YWxNYXRjaGVzLnB1c2gobWF0Y2gpO1xuICAgICAgaWYgKG1hdGNoLnJvdXRlLmlkID09PSBmcm9tUm91dGVJZCkge1xuICAgICAgICBhY3RpdmVSb3V0ZU1hdGNoID0gbWF0Y2g7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0dWFsTWF0Y2hlcyA9IG1hdGNoZXM7XG4gICAgYWN0aXZlUm91dGVNYXRjaCA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgfVxuICBsZXQgcGF0aCA9IHJlc29sdmVUbyhcbiAgICB0byA/IHRvIDogXCIuXCIsXG4gICAgZ2V0UmVzb2x2ZVRvTWF0Y2hlcyhjb250ZXh0dWFsTWF0Y2hlcyksXG4gICAgc3RyaXBCYXNlbmFtZShsb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgIHJlbGF0aXZlID09PSBcInBhdGhcIlxuICApO1xuICBpZiAodG8gPT0gbnVsbCkge1xuICAgIHBhdGguc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoO1xuICAgIHBhdGguaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG4gIH1cbiAgaWYgKCh0byA9PSBudWxsIHx8IHRvID09PSBcIlwiIHx8IHRvID09PSBcIi5cIikgJiYgYWN0aXZlUm91dGVNYXRjaCkge1xuICAgIGxldCBuYWtlZEluZGV4ID0gaGFzTmFrZWRJbmRleFF1ZXJ5KHBhdGguc2VhcmNoKTtcbiAgICBpZiAoYWN0aXZlUm91dGVNYXRjaC5yb3V0ZS5pbmRleCAmJiAhbmFrZWRJbmRleCkge1xuICAgICAgcGF0aC5zZWFyY2ggPSBwYXRoLnNlYXJjaCA/IHBhdGguc2VhcmNoLnJlcGxhY2UoL15cXD8vLCBcIj9pbmRleCZcIikgOiBcIj9pbmRleFwiO1xuICAgIH0gZWxzZSBpZiAoIWFjdGl2ZVJvdXRlTWF0Y2gucm91dGUuaW5kZXggJiYgbmFrZWRJbmRleCkge1xuICAgICAgbGV0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGF0aC5zZWFyY2gpO1xuICAgICAgbGV0IGluZGV4VmFsdWVzID0gcGFyYW1zLmdldEFsbChcImluZGV4XCIpO1xuICAgICAgcGFyYW1zLmRlbGV0ZShcImluZGV4XCIpO1xuICAgICAgaW5kZXhWYWx1ZXMuZmlsdGVyKCh2KSA9PiB2KS5mb3JFYWNoKCh2KSA9PiBwYXJhbXMuYXBwZW5kKFwiaW5kZXhcIiwgdikpO1xuICAgICAgbGV0IHFzID0gcGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgICBwYXRoLnNlYXJjaCA9IHFzID8gYD8ke3FzfWAgOiBcIlwiO1xuICAgIH1cbiAgfVxuICBpZiAoYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgcGF0aC5wYXRobmFtZSA9IHBhdGgucGF0aG5hbWUgPT09IFwiL1wiID8gYmFzZW5hbWUgOiBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRoLnBhdGhuYW1lXSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVBhdGgocGF0aCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVOYXZpZ2F0ZU9wdGlvbnMoaXNGZXRjaGVyLCBwYXRoLCBvcHRzKSB7XG4gIGlmICghb3B0cyB8fCAhaXNTdWJtaXNzaW9uTmF2aWdhdGlvbihvcHRzKSkge1xuICAgIHJldHVybiB7IHBhdGggfTtcbiAgfVxuICBpZiAob3B0cy5mb3JtTWV0aG9kICYmICFpc1ZhbGlkTWV0aG9kKG9wdHMuZm9ybU1ldGhvZCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aCxcbiAgICAgIGVycm9yOiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwgeyBtZXRob2Q6IG9wdHMuZm9ybU1ldGhvZCB9KVxuICAgIH07XG4gIH1cbiAgbGV0IGdldEludmFsaWRCb2R5RXJyb3IgPSAoKSA9PiAoe1xuICAgIHBhdGgsXG4gICAgZXJyb3I6IGdldEludGVybmFsUm91dGVyRXJyb3IoNDAwLCB7IHR5cGU6IFwiaW52YWxpZC1ib2R5XCIgfSlcbiAgfSk7XG4gIGxldCByYXdGb3JtTWV0aG9kID0gb3B0cy5mb3JtTWV0aG9kIHx8IFwiZ2V0XCI7XG4gIGxldCBmb3JtTWV0aG9kID0gcmF3Rm9ybU1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICBsZXQgZm9ybUFjdGlvbiA9IHN0cmlwSGFzaEZyb21QYXRoKHBhdGgpO1xuICBpZiAob3B0cy5ib2R5ICE9PSB2b2lkIDApIHtcbiAgICBpZiAob3B0cy5mb3JtRW5jVHlwZSA9PT0gXCJ0ZXh0L3BsYWluXCIpIHtcbiAgICAgIGlmICghaXNNdXRhdGlvbk1ldGhvZChmb3JtTWV0aG9kKSkge1xuICAgICAgICByZXR1cm4gZ2V0SW52YWxpZEJvZHlFcnJvcigpO1xuICAgICAgfVxuICAgICAgbGV0IHRleHQgPSB0eXBlb2Ygb3B0cy5ib2R5ID09PSBcInN0cmluZ1wiID8gb3B0cy5ib2R5IDogb3B0cy5ib2R5IGluc3RhbmNlb2YgRm9ybURhdGEgfHwgb3B0cy5ib2R5IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zID8gKFxuICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3JtLWNvbnRyb2wtaW5mcmFzdHJ1Y3R1cmUuaHRtbCNwbGFpbi10ZXh0LWZvcm0tZGF0YVxuICAgICAgICBBcnJheS5mcm9tKG9wdHMuYm9keS5lbnRyaWVzKCkpLnJlZHVjZShcbiAgICAgICAgICAoYWNjLCBbbmFtZSwgdmFsdWVdKSA9PiBgJHthY2N9JHtuYW1lfT0ke3ZhbHVlfVxuYCxcbiAgICAgICAgICBcIlwiXG4gICAgICAgIClcbiAgICAgICkgOiBTdHJpbmcob3B0cy5ib2R5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIHN1Ym1pc3Npb246IHtcbiAgICAgICAgICBmb3JtTWV0aG9kLFxuICAgICAgICAgIGZvcm1BY3Rpb24sXG4gICAgICAgICAgZm9ybUVuY1R5cGU6IG9wdHMuZm9ybUVuY1R5cGUsXG4gICAgICAgICAgZm9ybURhdGE6IHZvaWQgMCxcbiAgICAgICAgICBqc29uOiB2b2lkIDAsXG4gICAgICAgICAgdGV4dFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAob3B0cy5mb3JtRW5jVHlwZSA9PT0gXCJhcHBsaWNhdGlvbi9qc29uXCIpIHtcbiAgICAgIGlmICghaXNNdXRhdGlvbk1ldGhvZChmb3JtTWV0aG9kKSkge1xuICAgICAgICByZXR1cm4gZ2V0SW52YWxpZEJvZHlFcnJvcigpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IGpzb24gPSB0eXBlb2Ygb3B0cy5ib2R5ID09PSBcInN0cmluZ1wiID8gSlNPTi5wYXJzZShvcHRzLmJvZHkpIDogb3B0cy5ib2R5O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgc3VibWlzc2lvbjoge1xuICAgICAgICAgICAgZm9ybU1ldGhvZCxcbiAgICAgICAgICAgIGZvcm1BY3Rpb24sXG4gICAgICAgICAgICBmb3JtRW5jVHlwZTogb3B0cy5mb3JtRW5jVHlwZSxcbiAgICAgICAgICAgIGZvcm1EYXRhOiB2b2lkIDAsXG4gICAgICAgICAgICBqc29uLFxuICAgICAgICAgICAgdGV4dDogdm9pZCAwXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZ2V0SW52YWxpZEJvZHlFcnJvcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpbnZhcmlhbnQoXG4gICAgdHlwZW9mIEZvcm1EYXRhID09PSBcImZ1bmN0aW9uXCIsXG4gICAgXCJGb3JtRGF0YSBpcyBub3QgYXZhaWxhYmxlIGluIHRoaXMgZW52aXJvbm1lbnRcIlxuICApO1xuICBsZXQgc2VhcmNoUGFyYW1zO1xuICBsZXQgZm9ybURhdGE7XG4gIGlmIChvcHRzLmZvcm1EYXRhKSB7XG4gICAgc2VhcmNoUGFyYW1zID0gY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMob3B0cy5mb3JtRGF0YSk7XG4gICAgZm9ybURhdGEgPSBvcHRzLmZvcm1EYXRhO1xuICB9IGVsc2UgaWYgKG9wdHMuYm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgc2VhcmNoUGFyYW1zID0gY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMob3B0cy5ib2R5KTtcbiAgICBmb3JtRGF0YSA9IG9wdHMuYm9keTtcbiAgfSBlbHNlIGlmIChvcHRzLmJvZHkgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMpIHtcbiAgICBzZWFyY2hQYXJhbXMgPSBvcHRzLmJvZHk7XG4gICAgZm9ybURhdGEgPSBjb252ZXJ0U2VhcmNoUGFyYW1zVG9Gb3JtRGF0YShzZWFyY2hQYXJhbXMpO1xuICB9IGVsc2UgaWYgKG9wdHMuYm9keSA9PSBudWxsKSB7XG4gICAgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0cy5ib2R5KTtcbiAgICAgIGZvcm1EYXRhID0gY29udmVydFNlYXJjaFBhcmFtc1RvRm9ybURhdGEoc2VhcmNoUGFyYW1zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZ2V0SW52YWxpZEJvZHlFcnJvcigpO1xuICAgIH1cbiAgfVxuICBsZXQgc3VibWlzc2lvbiA9IHtcbiAgICBmb3JtTWV0aG9kLFxuICAgIGZvcm1BY3Rpb24sXG4gICAgZm9ybUVuY1R5cGU6IG9wdHMgJiYgb3B0cy5mb3JtRW5jVHlwZSB8fCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLFxuICAgIGZvcm1EYXRhLFxuICAgIGpzb246IHZvaWQgMCxcbiAgICB0ZXh0OiB2b2lkIDBcbiAgfTtcbiAgaWYgKGlzTXV0YXRpb25NZXRob2Qoc3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xuICAgIHJldHVybiB7IHBhdGgsIHN1Ym1pc3Npb24gfTtcbiAgfVxuICBsZXQgcGFyc2VkUGF0aCA9IHBhcnNlUGF0aChwYXRoKTtcbiAgaWYgKGlzRmV0Y2hlciAmJiBwYXJzZWRQYXRoLnNlYXJjaCAmJiBoYXNOYWtlZEluZGV4UXVlcnkocGFyc2VkUGF0aC5zZWFyY2gpKSB7XG4gICAgc2VhcmNoUGFyYW1zLmFwcGVuZChcImluZGV4XCIsIFwiXCIpO1xuICB9XG4gIHBhcnNlZFBhdGguc2VhcmNoID0gYD8ke3NlYXJjaFBhcmFtc31gO1xuICByZXR1cm4geyBwYXRoOiBjcmVhdGVQYXRoKHBhcnNlZFBhdGgpLCBzdWJtaXNzaW9uIH07XG59XG5mdW5jdGlvbiBnZXRNYXRjaGVzVG9Mb2FkKHJlcXVlc3QsIHNjb3BlZENvbnRleHQsIG1hcFJvdXRlUHJvcGVydGllczIsIG1hbmlmZXN0LCBoaXN0b3J5LCBzdGF0ZSwgbWF0Y2hlcywgc3VibWlzc2lvbiwgbG9jYXRpb24sIGxhenlSb3V0ZVByb3BlcnRpZXNUb1NraXAsIGluaXRpYWxIeWRyYXRpb24sIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQsIGNhbmNlbGxlZEZldGNoZXJMb2FkcywgZmV0Y2hlcnNRdWV1ZWRGb3JEZWxldGlvbiwgZmV0Y2hMb2FkTWF0Y2hlcywgZmV0Y2hSZWRpcmVjdElkcywgcm91dGVzVG9Vc2UsIGJhc2VuYW1lLCBoYXNQYXRjaFJvdXRlc09uTmF2aWdhdGlvbiwgcGVuZGluZ0FjdGlvblJlc3VsdCkge1xuICBsZXQgYWN0aW9uUmVzdWx0ID0gcGVuZGluZ0FjdGlvblJlc3VsdCA/IGlzRXJyb3JSZXN1bHQocGVuZGluZ0FjdGlvblJlc3VsdFsxXSkgPyBwZW5kaW5nQWN0aW9uUmVzdWx0WzFdLmVycm9yIDogcGVuZGluZ0FjdGlvblJlc3VsdFsxXS5kYXRhIDogdm9pZCAwO1xuICBsZXQgY3VycmVudFVybCA9IGhpc3RvcnkuY3JlYXRlVVJMKHN0YXRlLmxvY2F0aW9uKTtcbiAgbGV0IG5leHRVcmwgPSBoaXN0b3J5LmNyZWF0ZVVSTChsb2NhdGlvbik7XG4gIGxldCBtYXhJZHg7XG4gIGlmIChpbml0aWFsSHlkcmF0aW9uICYmIHN0YXRlLmVycm9ycykge1xuICAgIGxldCBib3VuZGFyeUlkID0gT2JqZWN0LmtleXMoc3RhdGUuZXJyb3JzKVswXTtcbiAgICBtYXhJZHggPSBtYXRjaGVzLmZpbmRJbmRleCgobSkgPT4gbS5yb3V0ZS5pZCA9PT0gYm91bmRhcnlJZCk7XG4gIH0gZWxzZSBpZiAocGVuZGluZ0FjdGlvblJlc3VsdCAmJiBpc0Vycm9yUmVzdWx0KHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0pKSB7XG4gICAgbGV0IGJvdW5kYXJ5SWQgPSBwZW5kaW5nQWN0aW9uUmVzdWx0WzBdO1xuICAgIG1heElkeCA9IG1hdGNoZXMuZmluZEluZGV4KChtKSA9PiBtLnJvdXRlLmlkID09PSBib3VuZGFyeUlkKSAtIDE7XG4gIH1cbiAgbGV0IGFjdGlvblN0YXR1cyA9IHBlbmRpbmdBY3Rpb25SZXN1bHQgPyBwZW5kaW5nQWN0aW9uUmVzdWx0WzFdLnN0YXR1c0NvZGUgOiB2b2lkIDA7XG4gIGxldCBzaG91bGRTa2lwUmV2YWxpZGF0aW9uID0gYWN0aW9uU3RhdHVzICYmIGFjdGlvblN0YXR1cyA+PSA0MDA7XG4gIGxldCBiYXNlU2hvdWxkUmV2YWxpZGF0ZUFyZ3MgPSB7XG4gICAgY3VycmVudFVybCxcbiAgICBjdXJyZW50UGFyYW1zOiBzdGF0ZS5tYXRjaGVzWzBdPy5wYXJhbXMgfHwge30sXG4gICAgbmV4dFVybCxcbiAgICBuZXh0UGFyYW1zOiBtYXRjaGVzWzBdLnBhcmFtcyxcbiAgICAuLi5zdWJtaXNzaW9uLFxuICAgIGFjdGlvblJlc3VsdCxcbiAgICBhY3Rpb25TdGF0dXNcbiAgfTtcbiAgbGV0IGRzTWF0Y2hlcyA9IG1hdGNoZXMubWFwKChtYXRjaCwgaW5kZXgpID0+IHtcbiAgICBsZXQgeyByb3V0ZSB9ID0gbWF0Y2g7XG4gICAgbGV0IGZvcmNlU2hvdWxkTG9hZCA9IG51bGw7XG4gICAgaWYgKG1heElkeCAhPSBudWxsICYmIGluZGV4ID4gbWF4SWR4KSB7XG4gICAgICBmb3JjZVNob3VsZExvYWQgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHJvdXRlLmxhenkpIHtcbiAgICAgIGZvcmNlU2hvdWxkTG9hZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChyb3V0ZS5sb2FkZXIgPT0gbnVsbCkge1xuICAgICAgZm9yY2VTaG91bGRMb2FkID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpbml0aWFsSHlkcmF0aW9uKSB7XG4gICAgICBmb3JjZVNob3VsZExvYWQgPSBzaG91bGRMb2FkUm91dGVPbkh5ZHJhdGlvbihcbiAgICAgICAgcm91dGUsXG4gICAgICAgIHN0YXRlLmxvYWRlckRhdGEsXG4gICAgICAgIHN0YXRlLmVycm9yc1xuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzTmV3TG9hZGVyKHN0YXRlLmxvYWRlckRhdGEsIHN0YXRlLm1hdGNoZXNbaW5kZXhdLCBtYXRjaCkpIHtcbiAgICAgIGZvcmNlU2hvdWxkTG9hZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChmb3JjZVNob3VsZExvYWQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBnZXREYXRhU3RyYXRlZ3lNYXRjaChcbiAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBsYXp5Um91dGVQcm9wZXJ0aWVzVG9Ta2lwLFxuICAgICAgICBzY29wZWRDb250ZXh0LFxuICAgICAgICBmb3JjZVNob3VsZExvYWRcbiAgICAgICk7XG4gICAgfVxuICAgIGxldCBkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZSA9IHNob3VsZFNraXBSZXZhbGlkYXRpb24gPyBmYWxzZSA6IChcbiAgICAgIC8vIEZvcmNlZCByZXZhbGlkYXRpb24gZHVlIHRvIHN1Ym1pc3Npb24sIHVzZVJldmFsaWRhdG9yLCBvciBYLVJlbWl4LVJldmFsaWRhdGVcbiAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgfHwgY3VycmVudFVybC5wYXRobmFtZSArIGN1cnJlbnRVcmwuc2VhcmNoID09PSBuZXh0VXJsLnBhdGhuYW1lICsgbmV4dFVybC5zZWFyY2ggfHwgLy8gU2VhcmNoIHBhcmFtcyBhZmZlY3QgYWxsIGxvYWRlcnNcbiAgICAgIGN1cnJlbnRVcmwuc2VhcmNoICE9PSBuZXh0VXJsLnNlYXJjaCB8fCBpc05ld1JvdXRlSW5zdGFuY2Uoc3RhdGUubWF0Y2hlc1tpbmRleF0sIG1hdGNoKVxuICAgICk7XG4gICAgbGV0IHNob3VsZFJldmFsaWRhdGVBcmdzID0ge1xuICAgICAgLi4uYmFzZVNob3VsZFJldmFsaWRhdGVBcmdzLFxuICAgICAgZGVmYXVsdFNob3VsZFJldmFsaWRhdGVcbiAgICB9O1xuICAgIGxldCBzaG91bGRMb2FkID0gc2hvdWxkUmV2YWxpZGF0ZUxvYWRlcihtYXRjaCwgc2hvdWxkUmV2YWxpZGF0ZUFyZ3MpO1xuICAgIHJldHVybiBnZXREYXRhU3RyYXRlZ3lNYXRjaChcbiAgICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgICBtYW5pZmVzdCxcbiAgICAgIHJlcXVlc3QsXG4gICAgICBtYXRjaCxcbiAgICAgIGxhenlSb3V0ZVByb3BlcnRpZXNUb1NraXAsXG4gICAgICBzY29wZWRDb250ZXh0LFxuICAgICAgc2hvdWxkTG9hZCxcbiAgICAgIHNob3VsZFJldmFsaWRhdGVBcmdzXG4gICAgKTtcbiAgfSk7XG4gIGxldCByZXZhbGlkYXRpbmdGZXRjaGVycyA9IFtdO1xuICBmZXRjaExvYWRNYXRjaGVzLmZvckVhY2goKGYsIGtleSkgPT4ge1xuICAgIGlmIChpbml0aWFsSHlkcmF0aW9uIHx8ICFtYXRjaGVzLnNvbWUoKG0pID0+IG0ucm91dGUuaWQgPT09IGYucm91dGVJZCkgfHwgZmV0Y2hlcnNRdWV1ZWRGb3JEZWxldGlvbi5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIGxldCBpc01pZEluaXRpYWxMb2FkID0gZmV0Y2hlciAmJiBmZXRjaGVyLnN0YXRlICE9PSBcImlkbGVcIiAmJiBmZXRjaGVyLmRhdGEgPT09IHZvaWQgMDtcbiAgICBsZXQgZmV0Y2hlck1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXNUb1VzZSwgZi5wYXRoLCBiYXNlbmFtZSk7XG4gICAgaWYgKCFmZXRjaGVyTWF0Y2hlcykge1xuICAgICAgaWYgKGhhc1BhdGNoUm91dGVzT25OYXZpZ2F0aW9uICYmIGlzTWlkSW5pdGlhbExvYWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMucHVzaCh7XG4gICAgICAgIGtleSxcbiAgICAgICAgcm91dGVJZDogZi5yb3V0ZUlkLFxuICAgICAgICBwYXRoOiBmLnBhdGgsXG4gICAgICAgIG1hdGNoZXM6IG51bGwsXG4gICAgICAgIG1hdGNoOiBudWxsLFxuICAgICAgICByZXF1ZXN0OiBudWxsLFxuICAgICAgICBjb250cm9sbGVyOiBudWxsXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGZldGNoUmVkaXJlY3RJZHMuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGZldGNoZXJNYXRjaCA9IGdldFRhcmdldE1hdGNoKGZldGNoZXJNYXRjaGVzLCBmLnBhdGgpO1xuICAgIGxldCBmZXRjaENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IGZldGNoUmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KFxuICAgICAgaGlzdG9yeSxcbiAgICAgIGYucGF0aCxcbiAgICAgIGZldGNoQ29udHJvbGxlci5zaWduYWxcbiAgICApO1xuICAgIGxldCBmZXRjaGVyRHNNYXRjaGVzID0gbnVsbDtcbiAgICBpZiAoY2FuY2VsbGVkRmV0Y2hlckxvYWRzLmhhcyhrZXkpKSB7XG4gICAgICBjYW5jZWxsZWRGZXRjaGVyTG9hZHMuZGVsZXRlKGtleSk7XG4gICAgICBmZXRjaGVyRHNNYXRjaGVzID0gZ2V0VGFyZ2V0ZWREYXRhU3RyYXRlZ3lNYXRjaGVzKFxuICAgICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgZmV0Y2hSZXF1ZXN0LFxuICAgICAgICBmZXRjaGVyTWF0Y2hlcyxcbiAgICAgICAgZmV0Y2hlck1hdGNoLFxuICAgICAgICBsYXp5Um91dGVQcm9wZXJ0aWVzVG9Ta2lwLFxuICAgICAgICBzY29wZWRDb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNNaWRJbml0aWFsTG9hZCkge1xuICAgICAgaWYgKGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQpIHtcbiAgICAgICAgZmV0Y2hlckRzTWF0Y2hlcyA9IGdldFRhcmdldGVkRGF0YVN0cmF0ZWd5TWF0Y2hlcyhcbiAgICAgICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgICAgICAgIG1hbmlmZXN0LFxuICAgICAgICAgIGZldGNoUmVxdWVzdCxcbiAgICAgICAgICBmZXRjaGVyTWF0Y2hlcyxcbiAgICAgICAgICBmZXRjaGVyTWF0Y2gsXG4gICAgICAgICAgbGF6eVJvdXRlUHJvcGVydGllc1RvU2tpcCxcbiAgICAgICAgICBzY29wZWRDb250ZXh0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBzaG91bGRSZXZhbGlkYXRlQXJncyA9IHtcbiAgICAgICAgLi4uYmFzZVNob3VsZFJldmFsaWRhdGVBcmdzLFxuICAgICAgICBkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZTogc2hvdWxkU2tpcFJldmFsaWRhdGlvbiA/IGZhbHNlIDogaXNSZXZhbGlkYXRpb25SZXF1aXJlZFxuICAgICAgfTtcbiAgICAgIGlmIChzaG91bGRSZXZhbGlkYXRlTG9hZGVyKGZldGNoZXJNYXRjaCwgc2hvdWxkUmV2YWxpZGF0ZUFyZ3MpKSB7XG4gICAgICAgIGZldGNoZXJEc01hdGNoZXMgPSBnZXRUYXJnZXRlZERhdGFTdHJhdGVneU1hdGNoZXMoXG4gICAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgICBmZXRjaFJlcXVlc3QsXG4gICAgICAgICAgZmV0Y2hlck1hdGNoZXMsXG4gICAgICAgICAgZmV0Y2hlck1hdGNoLFxuICAgICAgICAgIGxhenlSb3V0ZVByb3BlcnRpZXNUb1NraXAsXG4gICAgICAgICAgc2NvcGVkQ29udGV4dCxcbiAgICAgICAgICBzaG91bGRSZXZhbGlkYXRlQXJnc1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmV0Y2hlckRzTWF0Y2hlcykge1xuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMucHVzaCh7XG4gICAgICAgIGtleSxcbiAgICAgICAgcm91dGVJZDogZi5yb3V0ZUlkLFxuICAgICAgICBwYXRoOiBmLnBhdGgsXG4gICAgICAgIG1hdGNoZXM6IGZldGNoZXJEc01hdGNoZXMsXG4gICAgICAgIG1hdGNoOiBmZXRjaGVyTWF0Y2gsXG4gICAgICAgIHJlcXVlc3Q6IGZldGNoUmVxdWVzdCxcbiAgICAgICAgY29udHJvbGxlcjogZmV0Y2hDb250cm9sbGVyXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4geyBkc01hdGNoZXMsIHJldmFsaWRhdGluZ0ZldGNoZXJzIH07XG59XG5mdW5jdGlvbiBzaG91bGRMb2FkUm91dGVPbkh5ZHJhdGlvbihyb3V0ZSwgbG9hZGVyRGF0YSwgZXJyb3JzKSB7XG4gIGlmIChyb3V0ZS5sYXp5KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCFyb3V0ZS5sb2FkZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGV0IGhhc0RhdGEgPSBsb2FkZXJEYXRhICE9IG51bGwgJiYgcm91dGUuaWQgaW4gbG9hZGVyRGF0YTtcbiAgbGV0IGhhc0Vycm9yID0gZXJyb3JzICE9IG51bGwgJiYgZXJyb3JzW3JvdXRlLmlkXSAhPT0gdm9pZCAwO1xuICBpZiAoIWhhc0RhdGEgJiYgaGFzRXJyb3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiByb3V0ZS5sb2FkZXIgPT09IFwiZnVuY3Rpb25cIiAmJiByb3V0ZS5sb2FkZXIuaHlkcmF0ZSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiAhaGFzRGF0YSAmJiAhaGFzRXJyb3I7XG59XG5mdW5jdGlvbiBpc05ld0xvYWRlcihjdXJyZW50TG9hZGVyRGF0YSwgY3VycmVudE1hdGNoLCBtYXRjaCkge1xuICBsZXQgaXNOZXcgPSAoXG4gICAgLy8gW2FdIC0+IFthLCBiXVxuICAgICFjdXJyZW50TWF0Y2ggfHwgLy8gW2EsIGJdIC0+IFthLCBjXVxuICAgIG1hdGNoLnJvdXRlLmlkICE9PSBjdXJyZW50TWF0Y2gucm91dGUuaWRcbiAgKTtcbiAgbGV0IGlzTWlzc2luZ0RhdGEgPSAhY3VycmVudExvYWRlckRhdGEuaGFzT3duUHJvcGVydHkobWF0Y2gucm91dGUuaWQpO1xuICByZXR1cm4gaXNOZXcgfHwgaXNNaXNzaW5nRGF0YTtcbn1cbmZ1bmN0aW9uIGlzTmV3Um91dGVJbnN0YW5jZShjdXJyZW50TWF0Y2gsIG1hdGNoKSB7XG4gIGxldCBjdXJyZW50UGF0aCA9IGN1cnJlbnRNYXRjaC5yb3V0ZS5wYXRoO1xuICByZXR1cm4gKFxuICAgIC8vIHBhcmFtIGNoYW5nZSBmb3IgdGhpcyBtYXRjaCwgL3VzZXJzLzEyMyAtPiAvdXNlcnMvNDU2XG4gICAgY3VycmVudE1hdGNoLnBhdGhuYW1lICE9PSBtYXRjaC5wYXRobmFtZSB8fCAvLyBzcGxhdCBwYXJhbSBjaGFuZ2VkLCB3aGljaCBpcyBub3QgcHJlc2VudCBpbiBtYXRjaC5wYXRoXG4gICAgLy8gZS5nLiAvZmlsZXMvaW1hZ2VzL2F2YXRhci5qcGcgLT4gZmlsZXMvZmluYW5jZXMueGxzXG4gICAgY3VycmVudFBhdGggIT0gbnVsbCAmJiBjdXJyZW50UGF0aC5lbmRzV2l0aChcIipcIikgJiYgY3VycmVudE1hdGNoLnBhcmFtc1tcIipcIl0gIT09IG1hdGNoLnBhcmFtc1tcIipcIl1cbiAgKTtcbn1cbmZ1bmN0aW9uIHNob3VsZFJldmFsaWRhdGVMb2FkZXIobG9hZGVyTWF0Y2gsIGFyZykge1xuICBpZiAobG9hZGVyTWF0Y2gucm91dGUuc2hvdWxkUmV2YWxpZGF0ZSkge1xuICAgIGxldCByb3V0ZUNob2ljZSA9IGxvYWRlck1hdGNoLnJvdXRlLnNob3VsZFJldmFsaWRhdGUoYXJnKTtcbiAgICBpZiAodHlwZW9mIHJvdXRlQ2hvaWNlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgcmV0dXJuIHJvdXRlQ2hvaWNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJnLmRlZmF1bHRTaG91bGRSZXZhbGlkYXRlO1xufVxuZnVuY3Rpb24gcGF0Y2hSb3V0ZXNJbXBsKHJvdXRlSWQsIGNoaWxkcmVuLCByb3V0ZXNUb1VzZSwgbWFuaWZlc3QsIG1hcFJvdXRlUHJvcGVydGllczIpIHtcbiAgbGV0IGNoaWxkcmVuVG9QYXRjaDtcbiAgaWYgKHJvdXRlSWQpIHtcbiAgICBsZXQgcm91dGUgPSBtYW5pZmVzdFtyb3V0ZUlkXTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICByb3V0ZSxcbiAgICAgIGBObyByb3V0ZSBmb3VuZCB0byBwYXRjaCBjaGlsZHJlbiBpbnRvOiByb3V0ZUlkID0gJHtyb3V0ZUlkfWBcbiAgICApO1xuICAgIGlmICghcm91dGUuY2hpbGRyZW4pIHtcbiAgICAgIHJvdXRlLmNoaWxkcmVuID0gW107XG4gICAgfVxuICAgIGNoaWxkcmVuVG9QYXRjaCA9IHJvdXRlLmNoaWxkcmVuO1xuICB9IGVsc2Uge1xuICAgIGNoaWxkcmVuVG9QYXRjaCA9IHJvdXRlc1RvVXNlO1xuICB9XG4gIGxldCB1bmlxdWVDaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihcbiAgICAobmV3Um91dGUpID0+ICFjaGlsZHJlblRvUGF0Y2guc29tZShcbiAgICAgIChleGlzdGluZ1JvdXRlKSA9PiBpc1NhbWVSb3V0ZShuZXdSb3V0ZSwgZXhpc3RpbmdSb3V0ZSlcbiAgICApXG4gICk7XG4gIGxldCBuZXdSb3V0ZXMgPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKFxuICAgIHVuaXF1ZUNoaWxkcmVuLFxuICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgW3JvdXRlSWQgfHwgXCJfXCIsIFwicGF0Y2hcIiwgU3RyaW5nKGNoaWxkcmVuVG9QYXRjaD8ubGVuZ3RoIHx8IFwiMFwiKV0sXG4gICAgbWFuaWZlc3RcbiAgKTtcbiAgY2hpbGRyZW5Ub1BhdGNoLnB1c2goLi4ubmV3Um91dGVzKTtcbn1cbmZ1bmN0aW9uIGlzU2FtZVJvdXRlKG5ld1JvdXRlLCBleGlzdGluZ1JvdXRlKSB7XG4gIGlmIChcImlkXCIgaW4gbmV3Um91dGUgJiYgXCJpZFwiIGluIGV4aXN0aW5nUm91dGUgJiYgbmV3Um91dGUuaWQgPT09IGV4aXN0aW5nUm91dGUuaWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoIShuZXdSb3V0ZS5pbmRleCA9PT0gZXhpc3RpbmdSb3V0ZS5pbmRleCAmJiBuZXdSb3V0ZS5wYXRoID09PSBleGlzdGluZ1JvdXRlLnBhdGggJiYgbmV3Um91dGUuY2FzZVNlbnNpdGl2ZSA9PT0gZXhpc3RpbmdSb3V0ZS5jYXNlU2Vuc2l0aXZlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoKCFuZXdSb3V0ZS5jaGlsZHJlbiB8fCBuZXdSb3V0ZS5jaGlsZHJlbi5sZW5ndGggPT09IDApICYmICghZXhpc3RpbmdSb3V0ZS5jaGlsZHJlbiB8fCBleGlzdGluZ1JvdXRlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gbmV3Um91dGUuY2hpbGRyZW4uZXZlcnkoXG4gICAgKGFDaGlsZCwgaSkgPT4gZXhpc3RpbmdSb3V0ZS5jaGlsZHJlbj8uc29tZSgoYkNoaWxkKSA9PiBpc1NhbWVSb3V0ZShhQ2hpbGQsIGJDaGlsZCkpXG4gICk7XG59XG52YXIgbGF6eVJvdXRlUHJvcGVydHlDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xudmFyIGxvYWRMYXp5Um91dGVQcm9wZXJ0eSA9ICh7XG4gIGtleSxcbiAgcm91dGUsXG4gIG1hbmlmZXN0LFxuICBtYXBSb3V0ZVByb3BlcnRpZXM6IG1hcFJvdXRlUHJvcGVydGllczJcbn0pID0+IHtcbiAgbGV0IHJvdXRlVG9VcGRhdGUgPSBtYW5pZmVzdFtyb3V0ZS5pZF07XG4gIGludmFyaWFudChyb3V0ZVRvVXBkYXRlLCBcIk5vIHJvdXRlIGZvdW5kIGluIG1hbmlmZXN0XCIpO1xuICBpZiAoIXJvdXRlVG9VcGRhdGUubGF6eSB8fCB0eXBlb2Ygcm91dGVUb1VwZGF0ZS5sYXp5ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBsYXp5Rm4gPSByb3V0ZVRvVXBkYXRlLmxhenlba2V5XTtcbiAgaWYgKCFsYXp5Rm4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGNhY2hlID0gbGF6eVJvdXRlUHJvcGVydHlDYWNoZS5nZXQocm91dGVUb1VwZGF0ZSk7XG4gIGlmICghY2FjaGUpIHtcbiAgICBjYWNoZSA9IHt9O1xuICAgIGxhenlSb3V0ZVByb3BlcnR5Q2FjaGUuc2V0KHJvdXRlVG9VcGRhdGUsIGNhY2hlKTtcbiAgfVxuICBsZXQgY2FjaGVkUHJvbWlzZSA9IGNhY2hlW2tleV07XG4gIGlmIChjYWNoZWRQcm9taXNlKSB7XG4gICAgcmV0dXJuIGNhY2hlZFByb21pc2U7XG4gIH1cbiAgbGV0IHByb3BlcnR5UHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgbGV0IGlzVW5zdXBwb3J0ZWQgPSBpc1Vuc3VwcG9ydGVkTGF6eVJvdXRlT2JqZWN0S2V5KGtleSk7XG4gICAgbGV0IHN0YXRpY1JvdXRlVmFsdWUgPSByb3V0ZVRvVXBkYXRlW2tleV07XG4gICAgbGV0IGlzU3RhdGljYWxseURlZmluZWQgPSBzdGF0aWNSb3V0ZVZhbHVlICE9PSB2b2lkIDAgJiYga2V5ICE9PSBcImhhc0Vycm9yQm91bmRhcnlcIjtcbiAgICBpZiAoaXNVbnN1cHBvcnRlZCkge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgIWlzVW5zdXBwb3J0ZWQsXG4gICAgICAgIFwiUm91dGUgcHJvcGVydHkgXCIgKyBrZXkgKyBcIiBpcyBub3QgYSBzdXBwb3J0ZWQgbGF6eSByb3V0ZSBwcm9wZXJ0eS4gVGhpcyBwcm9wZXJ0eSB3aWxsIGJlIGlnbm9yZWQuXCJcbiAgICAgICk7XG4gICAgICBjYWNoZVtrZXldID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfSBlbHNlIGlmIChpc1N0YXRpY2FsbHlEZWZpbmVkKSB7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgYFJvdXRlIFwiJHtyb3V0ZVRvVXBkYXRlLmlkfVwiIGhhcyBhIHN0YXRpYyBwcm9wZXJ0eSBcIiR7a2V5fVwiIGRlZmluZWQuIFRoZSBsYXp5IHByb3BlcnR5IHdpbGwgYmUgaWdub3JlZC5gXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgdmFsdWUgPSBhd2FpdCBsYXp5Rm4oKTtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocm91dGVUb1VwZGF0ZSwgeyBba2V5XTogdmFsdWUgfSk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocm91dGVUb1VwZGF0ZSwgbWFwUm91dGVQcm9wZXJ0aWVzMihyb3V0ZVRvVXBkYXRlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygcm91dGVUb1VwZGF0ZS5sYXp5ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICByb3V0ZVRvVXBkYXRlLmxhenlba2V5XSA9IHZvaWQgMDtcbiAgICAgIGlmIChPYmplY3QudmFsdWVzKHJvdXRlVG9VcGRhdGUubGF6eSkuZXZlcnkoKHZhbHVlKSA9PiB2YWx1ZSA9PT0gdm9pZCAwKSkge1xuICAgICAgICByb3V0ZVRvVXBkYXRlLmxhenkgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9KSgpO1xuICBjYWNoZVtrZXldID0gcHJvcGVydHlQcm9taXNlO1xuICByZXR1cm4gcHJvcGVydHlQcm9taXNlO1xufTtcbnZhciBsYXp5Um91dGVGdW5jdGlvbkNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBsb2FkTGF6eVJvdXRlKHJvdXRlLCB0eXBlLCBtYW5pZmVzdCwgbWFwUm91dGVQcm9wZXJ0aWVzMiwgbGF6eVJvdXRlUHJvcGVydGllc1RvU2tpcCkge1xuICBsZXQgcm91dGVUb1VwZGF0ZSA9IG1hbmlmZXN0W3JvdXRlLmlkXTtcbiAgaW52YXJpYW50KHJvdXRlVG9VcGRhdGUsIFwiTm8gcm91dGUgZm91bmQgaW4gbWFuaWZlc3RcIik7XG4gIGlmICghcm91dGUubGF6eSkge1xuICAgIHJldHVybiB7XG4gICAgICBsYXp5Um91dGVQcm9taXNlOiB2b2lkIDAsXG4gICAgICBsYXp5SGFuZGxlclByb21pc2U6IHZvaWQgMFxuICAgIH07XG4gIH1cbiAgaWYgKHR5cGVvZiByb3V0ZS5sYXp5ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBsZXQgY2FjaGVkUHJvbWlzZSA9IGxhenlSb3V0ZUZ1bmN0aW9uQ2FjaGUuZ2V0KHJvdXRlVG9VcGRhdGUpO1xuICAgIGlmIChjYWNoZWRQcm9taXNlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsYXp5Um91dGVQcm9taXNlOiBjYWNoZWRQcm9taXNlLFxuICAgICAgICBsYXp5SGFuZGxlclByb21pc2U6IGNhY2hlZFByb21pc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGxldCBsYXp5Um91dGVQcm9taXNlMiA9IChhc3luYyAoKSA9PiB7XG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgIHR5cGVvZiByb3V0ZS5sYXp5ID09PSBcImZ1bmN0aW9uXCIsXG4gICAgICAgIFwiTm8gbGF6eSByb3V0ZSBmdW5jdGlvbiBmb3VuZFwiXG4gICAgICApO1xuICAgICAgbGV0IGxhenlSb3V0ZSA9IGF3YWl0IHJvdXRlLmxhenkoKTtcbiAgICAgIGxldCByb3V0ZVVwZGF0ZXMgPSB7fTtcbiAgICAgIGZvciAobGV0IGxhenlSb3V0ZVByb3BlcnR5IGluIGxhenlSb3V0ZSkge1xuICAgICAgICBsZXQgbGF6eVZhbHVlID0gbGF6eVJvdXRlW2xhenlSb3V0ZVByb3BlcnR5XTtcbiAgICAgICAgaWYgKGxhenlWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlzVW5zdXBwb3J0ZWQgPSBpc1Vuc3VwcG9ydGVkTGF6eVJvdXRlRnVuY3Rpb25LZXkobGF6eVJvdXRlUHJvcGVydHkpO1xuICAgICAgICBsZXQgc3RhdGljUm91dGVWYWx1ZSA9IHJvdXRlVG9VcGRhdGVbbGF6eVJvdXRlUHJvcGVydHldO1xuICAgICAgICBsZXQgaXNTdGF0aWNhbGx5RGVmaW5lZCA9IHN0YXRpY1JvdXRlVmFsdWUgIT09IHZvaWQgMCAmJiAvLyBUaGlzIHByb3BlcnR5IGlzbid0IHN0YXRpYyBzaW5jZSBpdCBzaG91bGQgYWx3YXlzIGJlIHVwZGF0ZWQgYmFzZWRcbiAgICAgICAgLy8gb24gdGhlIHJvdXRlIHVwZGF0ZXNcbiAgICAgICAgbGF6eVJvdXRlUHJvcGVydHkgIT09IFwiaGFzRXJyb3JCb3VuZGFyeVwiO1xuICAgICAgICBpZiAoaXNVbnN1cHBvcnRlZCkge1xuICAgICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgICAhaXNVbnN1cHBvcnRlZCxcbiAgICAgICAgICAgIFwiUm91dGUgcHJvcGVydHkgXCIgKyBsYXp5Um91dGVQcm9wZXJ0eSArIFwiIGlzIG5vdCBhIHN1cHBvcnRlZCBwcm9wZXJ0eSB0byBiZSByZXR1cm5lZCBmcm9tIGEgbGF6eSByb3V0ZSBmdW5jdGlvbi4gVGhpcyBwcm9wZXJ0eSB3aWxsIGJlIGlnbm9yZWQuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKGlzU3RhdGljYWxseURlZmluZWQpIHtcbiAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgIWlzU3RhdGljYWxseURlZmluZWQsXG4gICAgICAgICAgICBgUm91dGUgXCIke3JvdXRlVG9VcGRhdGUuaWR9XCIgaGFzIGEgc3RhdGljIHByb3BlcnR5IFwiJHtsYXp5Um91dGVQcm9wZXJ0eX1cIiBkZWZpbmVkIGJ1dCBpdHMgbGF6eSBmdW5jdGlvbiBpcyBhbHNvIHJldHVybmluZyBhIHZhbHVlIGZvciB0aGlzIHByb3BlcnR5LiBUaGUgbGF6eSByb3V0ZSBwcm9wZXJ0eSBcIiR7bGF6eVJvdXRlUHJvcGVydHl9XCIgd2lsbCBiZSBpZ25vcmVkLmBcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJvdXRlVXBkYXRlc1tsYXp5Um91dGVQcm9wZXJ0eV0gPSBsYXp5VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIE9iamVjdC5hc3NpZ24ocm91dGVUb1VwZGF0ZSwgcm91dGVVcGRhdGVzKTtcbiAgICAgIE9iamVjdC5hc3NpZ24ocm91dGVUb1VwZGF0ZSwge1xuICAgICAgICAvLyBUbyBrZWVwIHRoaW5ncyBmcmFtZXdvcmsgYWdub3N0aWMsIHdlIHVzZSB0aGUgcHJvdmlkZWQgYG1hcFJvdXRlUHJvcGVydGllc2BcbiAgICAgICAgLy8gZnVuY3Rpb24gdG8gc2V0IHRoZSBmcmFtZXdvcmstYXdhcmUgcHJvcGVydGllcyAoYGVsZW1lbnRgL2BoYXNFcnJvckJvdW5kYXJ5YClcbiAgICAgICAgLy8gc2luY2UgdGhlIGxvZ2ljIHdpbGwgZGlmZmVyIGJldHdlZW4gZnJhbWV3b3Jrcy5cbiAgICAgICAgLi4ubWFwUm91dGVQcm9wZXJ0aWVzMihyb3V0ZVRvVXBkYXRlKSxcbiAgICAgICAgbGF6eTogdm9pZCAwXG4gICAgICB9KTtcbiAgICB9KSgpO1xuICAgIGxhenlSb3V0ZUZ1bmN0aW9uQ2FjaGUuc2V0KHJvdXRlVG9VcGRhdGUsIGxhenlSb3V0ZVByb21pc2UyKTtcbiAgICBsYXp5Um91dGVQcm9taXNlMi5jYXRjaCgoKSA9PiB7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhenlSb3V0ZVByb21pc2U6IGxhenlSb3V0ZVByb21pc2UyLFxuICAgICAgbGF6eUhhbmRsZXJQcm9taXNlOiBsYXp5Um91dGVQcm9taXNlMlxuICAgIH07XG4gIH1cbiAgbGV0IGxhenlLZXlzID0gT2JqZWN0LmtleXMocm91dGUubGF6eSk7XG4gIGxldCBsYXp5UHJvcGVydHlQcm9taXNlcyA9IFtdO1xuICBsZXQgbGF6eUhhbmRsZXJQcm9taXNlID0gdm9pZCAwO1xuICBmb3IgKGxldCBrZXkgb2YgbGF6eUtleXMpIHtcbiAgICBpZiAobGF6eVJvdXRlUHJvcGVydGllc1RvU2tpcCAmJiBsYXp5Um91dGVQcm9wZXJ0aWVzVG9Ta2lwLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBsZXQgcHJvbWlzZSA9IGxvYWRMYXp5Um91dGVQcm9wZXJ0eSh7XG4gICAgICBrZXksXG4gICAgICByb3V0ZSxcbiAgICAgIG1hbmlmZXN0LFxuICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzOiBtYXBSb3V0ZVByb3BlcnRpZXMyXG4gICAgfSk7XG4gICAgaWYgKHByb21pc2UpIHtcbiAgICAgIGxhenlQcm9wZXJ0eVByb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICBpZiAoa2V5ID09PSB0eXBlKSB7XG4gICAgICAgIGxhenlIYW5kbGVyUHJvbWlzZSA9IHByb21pc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxldCBsYXp5Um91dGVQcm9taXNlID0gbGF6eVByb3BlcnR5UHJvbWlzZXMubGVuZ3RoID4gMCA/IFByb21pc2UuYWxsKGxhenlQcm9wZXJ0eVByb21pc2VzKS50aGVuKCgpID0+IHtcbiAgfSkgOiB2b2lkIDA7XG4gIGxhenlSb3V0ZVByb21pc2U/LmNhdGNoKCgpID0+IHtcbiAgfSk7XG4gIGxhenlIYW5kbGVyUHJvbWlzZT8uY2F0Y2goKCkgPT4ge1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBsYXp5Um91dGVQcm9taXNlLFxuICAgIGxhenlIYW5kbGVyUHJvbWlzZVxuICB9O1xufVxuZnVuY3Rpb24gaXNOb25OdWxsYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGxvYWRMYXp5TWlkZGxld2FyZUZvck1hdGNoZXMobWF0Y2hlcywgbWFuaWZlc3QsIG1hcFJvdXRlUHJvcGVydGllczIpIHtcbiAgbGV0IHByb21pc2VzID0gbWF0Y2hlcy5tYXAoKHsgcm91dGUgfSkgPT4ge1xuICAgIGlmICh0eXBlb2Ygcm91dGUubGF6eSAhPT0gXCJvYmplY3RcIiB8fCAhcm91dGUubGF6eS51bnN0YWJsZV9taWRkbGV3YXJlKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gbG9hZExhenlSb3V0ZVByb3BlcnR5KHtcbiAgICAgIGtleTogXCJ1bnN0YWJsZV9taWRkbGV3YXJlXCIsXG4gICAgICByb3V0ZSxcbiAgICAgIG1hbmlmZXN0LFxuICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzOiBtYXBSb3V0ZVByb3BlcnRpZXMyXG4gICAgfSk7XG4gIH0pLmZpbHRlcihpc05vbk51bGxhYmxlKTtcbiAgcmV0dXJuIHByb21pc2VzLmxlbmd0aCA+IDAgPyBQcm9taXNlLmFsbChwcm9taXNlcykgOiB2b2lkIDA7XG59XG5hc3luYyBmdW5jdGlvbiBkZWZhdWx0RGF0YVN0cmF0ZWd5KGFyZ3MpIHtcbiAgbGV0IG1hdGNoZXNUb0xvYWQgPSBhcmdzLm1hdGNoZXMuZmlsdGVyKChtKSA9PiBtLnNob3VsZExvYWQpO1xuICBsZXQga2V5ZWRSZXN1bHRzID0ge307XG4gIGxldCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwobWF0Y2hlc1RvTG9hZC5tYXAoKG0pID0+IG0ucmVzb2x2ZSgpKSk7XG4gIHJlc3VsdHMuZm9yRWFjaCgocmVzdWx0LCBpKSA9PiB7XG4gICAga2V5ZWRSZXN1bHRzW21hdGNoZXNUb0xvYWRbaV0ucm91dGUuaWRdID0gcmVzdWx0O1xuICB9KTtcbiAgcmV0dXJuIGtleWVkUmVzdWx0cztcbn1cbmFzeW5jIGZ1bmN0aW9uIGRlZmF1bHREYXRhU3RyYXRlZ3lXaXRoTWlkZGxld2FyZShhcmdzKSB7XG4gIGlmICghYXJncy5tYXRjaGVzLnNvbWUoKG0pID0+IG0ucm91dGUudW5zdGFibGVfbWlkZGxld2FyZSkpIHtcbiAgICByZXR1cm4gZGVmYXVsdERhdGFTdHJhdGVneShhcmdzKTtcbiAgfVxuICByZXR1cm4gcnVuTWlkZGxld2FyZVBpcGVsaW5lKFxuICAgIGFyZ3MsXG4gICAgZmFsc2UsXG4gICAgKCkgPT4gZGVmYXVsdERhdGFTdHJhdGVneShhcmdzKSxcbiAgICAoZXJyb3IsIHJvdXRlSWQpID0+ICh7IFtyb3V0ZUlkXTogeyB0eXBlOiBcImVycm9yXCIsIHJlc3VsdDogZXJyb3IgfSB9KVxuICApO1xufVxuYXN5bmMgZnVuY3Rpb24gcnVuTWlkZGxld2FyZVBpcGVsaW5lKGFyZ3MsIHByb3BhZ2F0ZVJlc3VsdCwgaGFuZGxlciwgZXJyb3JIYW5kbGVyKSB7XG4gIGxldCB7IG1hdGNoZXMsIHJlcXVlc3QsIHBhcmFtcywgY29udGV4dCB9ID0gYXJncztcbiAgbGV0IG1pZGRsZXdhcmVTdGF0ZSA9IHtcbiAgICBoYW5kbGVyUmVzdWx0OiB2b2lkIDBcbiAgfTtcbiAgdHJ5IHtcbiAgICBsZXQgdHVwbGVzID0gbWF0Y2hlcy5mbGF0TWFwKFxuICAgICAgKG0pID0+IG0ucm91dGUudW5zdGFibGVfbWlkZGxld2FyZSA/IG0ucm91dGUudW5zdGFibGVfbWlkZGxld2FyZS5tYXAoKGZuKSA9PiBbbS5yb3V0ZS5pZCwgZm5dKSA6IFtdXG4gICAgKTtcbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgY2FsbFJvdXRlTWlkZGxld2FyZShcbiAgICAgIHsgcmVxdWVzdCwgcGFyYW1zLCBjb250ZXh0IH0sXG4gICAgICB0dXBsZXMsXG4gICAgICBwcm9wYWdhdGVSZXN1bHQsXG4gICAgICBtaWRkbGV3YXJlU3RhdGUsXG4gICAgICBoYW5kbGVyXG4gICAgKTtcbiAgICByZXR1cm4gcHJvcGFnYXRlUmVzdWx0ID8gcmVzdWx0IDogbWlkZGxld2FyZVN0YXRlLmhhbmRsZXJSZXN1bHQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoIW1pZGRsZXdhcmVTdGF0ZS5taWRkbGV3YXJlRXJyb3IpIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBhd2FpdCBlcnJvckhhbmRsZXIoXG4gICAgICBtaWRkbGV3YXJlU3RhdGUubWlkZGxld2FyZUVycm9yLmVycm9yLFxuICAgICAgbWlkZGxld2FyZVN0YXRlLm1pZGRsZXdhcmVFcnJvci5yb3V0ZUlkXG4gICAgKTtcbiAgICBpZiAocHJvcGFnYXRlUmVzdWx0IHx8ICFtaWRkbGV3YXJlU3RhdGUuaGFuZGxlclJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obWlkZGxld2FyZVN0YXRlLmhhbmRsZXJSZXN1bHQsIHJlc3VsdCk7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGNhbGxSb3V0ZU1pZGRsZXdhcmUoYXJncywgbWlkZGxld2FyZXMsIHByb3BhZ2F0ZVJlc3VsdCwgbWlkZGxld2FyZVN0YXRlLCBoYW5kbGVyLCBpZHggPSAwKSB7XG4gIGxldCB7IHJlcXVlc3QgfSA9IGFyZ3M7XG4gIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgaWYgKHJlcXVlc3Quc2lnbmFsLnJlYXNvbikge1xuICAgICAgdGhyb3cgcmVxdWVzdC5zaWduYWwucmVhc29uO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgUmVxdWVzdCBhYm9ydGVkIHdpdGhvdXQgYW4gXFxgQWJvcnRTaWduYWwucmVhc29uXFxgOiAke3JlcXVlc3QubWV0aG9kfSAke3JlcXVlc3QudXJsfWBcbiAgICApO1xuICB9XG4gIGxldCB0dXBsZSA9IG1pZGRsZXdhcmVzW2lkeF07XG4gIGlmICghdHVwbGUpIHtcbiAgICBtaWRkbGV3YXJlU3RhdGUuaGFuZGxlclJlc3VsdCA9IGF3YWl0IGhhbmRsZXIoKTtcbiAgICByZXR1cm4gbWlkZGxld2FyZVN0YXRlLmhhbmRsZXJSZXN1bHQ7XG4gIH1cbiAgbGV0IFtyb3V0ZUlkLCBtaWRkbGV3YXJlXSA9IHR1cGxlO1xuICBsZXQgbmV4dENhbGxlZCA9IGZhbHNlO1xuICBsZXQgbmV4dFJlc3VsdCA9IHZvaWQgMDtcbiAgbGV0IG5leHQgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKG5leHRDYWxsZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtYXkgb25seSBjYWxsIGBuZXh0KClgIG9uY2UgcGVyIG1pZGRsZXdhcmVcIik7XG4gICAgfVxuICAgIG5leHRDYWxsZWQgPSB0cnVlO1xuICAgIGxldCByZXN1bHQgPSBhd2FpdCBjYWxsUm91dGVNaWRkbGV3YXJlKFxuICAgICAgYXJncyxcbiAgICAgIG1pZGRsZXdhcmVzLFxuICAgICAgcHJvcGFnYXRlUmVzdWx0LFxuICAgICAgbWlkZGxld2FyZVN0YXRlLFxuICAgICAgaGFuZGxlcixcbiAgICAgIGlkeCArIDFcbiAgICApO1xuICAgIGlmIChwcm9wYWdhdGVSZXN1bHQpIHtcbiAgICAgIG5leHRSZXN1bHQgPSByZXN1bHQ7XG4gICAgICByZXR1cm4gbmV4dFJlc3VsdDtcbiAgICB9XG4gIH07XG4gIHRyeSB7XG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IG1pZGRsZXdhcmUoXG4gICAgICB7XG4gICAgICAgIHJlcXVlc3Q6IGFyZ3MucmVxdWVzdCxcbiAgICAgICAgcGFyYW1zOiBhcmdzLnBhcmFtcyxcbiAgICAgICAgY29udGV4dDogYXJncy5jb250ZXh0XG4gICAgICB9LFxuICAgICAgbmV4dFxuICAgICk7XG4gICAgaWYgKG5leHRDYWxsZWQpIHtcbiAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gbmV4dFJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmICghbWlkZGxld2FyZVN0YXRlLm1pZGRsZXdhcmVFcnJvcikge1xuICAgICAgbWlkZGxld2FyZVN0YXRlLm1pZGRsZXdhcmVFcnJvciA9IHsgcm91dGVJZCwgZXJyb3IgfTtcbiAgICB9IGVsc2UgaWYgKG1pZGRsZXdhcmVTdGF0ZS5taWRkbGV3YXJlRXJyb3IuZXJyb3IgIT09IGVycm9yKSB7XG4gICAgICBtaWRkbGV3YXJlU3RhdGUubWlkZGxld2FyZUVycm9yID0geyByb3V0ZUlkLCBlcnJvciB9O1xuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0RGF0YVN0cmF0ZWd5TWF0Y2hMYXp5UHJvbWlzZXMobWFwUm91dGVQcm9wZXJ0aWVzMiwgbWFuaWZlc3QsIHJlcXVlc3QsIG1hdGNoLCBsYXp5Um91dGVQcm9wZXJ0aWVzVG9Ta2lwKSB7XG4gIGxldCBsYXp5TWlkZGxld2FyZVByb21pc2UgPSBsb2FkTGF6eVJvdXRlUHJvcGVydHkoe1xuICAgIGtleTogXCJ1bnN0YWJsZV9taWRkbGV3YXJlXCIsXG4gICAgcm91dGU6IG1hdGNoLnJvdXRlLFxuICAgIG1hbmlmZXN0LFxuICAgIG1hcFJvdXRlUHJvcGVydGllczogbWFwUm91dGVQcm9wZXJ0aWVzMlxuICB9KTtcbiAgbGV0IGxhenlSb3V0ZVByb21pc2VzID0gbG9hZExhenlSb3V0ZShcbiAgICBtYXRjaC5yb3V0ZSxcbiAgICBpc011dGF0aW9uTWV0aG9kKHJlcXVlc3QubWV0aG9kKSA/IFwiYWN0aW9uXCIgOiBcImxvYWRlclwiLFxuICAgIG1hbmlmZXN0LFxuICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgbGF6eVJvdXRlUHJvcGVydGllc1RvU2tpcFxuICApO1xuICByZXR1cm4ge1xuICAgIG1pZGRsZXdhcmU6IGxhenlNaWRkbGV3YXJlUHJvbWlzZSxcbiAgICByb3V0ZTogbGF6eVJvdXRlUHJvbWlzZXMubGF6eVJvdXRlUHJvbWlzZSxcbiAgICBoYW5kbGVyOiBsYXp5Um91dGVQcm9taXNlcy5sYXp5SGFuZGxlclByb21pc2VcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldERhdGFTdHJhdGVneU1hdGNoKG1hcFJvdXRlUHJvcGVydGllczIsIG1hbmlmZXN0LCByZXF1ZXN0LCBtYXRjaCwgbGF6eVJvdXRlUHJvcGVydGllc1RvU2tpcCwgc2NvcGVkQ29udGV4dCwgc2hvdWxkTG9hZCwgdW5zdGFibGVfc2hvdWxkUmV2YWxpZGF0ZUFyZ3MgPSBudWxsKSB7XG4gIGxldCBpc1VzaW5nTmV3QXBpID0gZmFsc2U7XG4gIGxldCBfbGF6eVByb21pc2VzID0gZ2V0RGF0YVN0cmF0ZWd5TWF0Y2hMYXp5UHJvbWlzZXMoXG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICBtYW5pZmVzdCxcbiAgICByZXF1ZXN0LFxuICAgIG1hdGNoLFxuICAgIGxhenlSb3V0ZVByb3BlcnRpZXNUb1NraXBcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5tYXRjaCxcbiAgICBfbGF6eVByb21pc2VzLFxuICAgIHNob3VsZExvYWQsXG4gICAgdW5zdGFibGVfc2hvdWxkUmV2YWxpZGF0ZUFyZ3MsXG4gICAgdW5zdGFibGVfc2hvdWxkQ2FsbEhhbmRsZXIoZGVmYXVsdFNob3VsZFJldmFsaWRhdGUpIHtcbiAgICAgIGlzVXNpbmdOZXdBcGkgPSB0cnVlO1xuICAgICAgaWYgKCF1bnN0YWJsZV9zaG91bGRSZXZhbGlkYXRlQXJncykge1xuICAgICAgICByZXR1cm4gc2hvdWxkTG9hZDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZGVmYXVsdFNob3VsZFJldmFsaWRhdGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHJldHVybiBzaG91bGRSZXZhbGlkYXRlTG9hZGVyKG1hdGNoLCB7XG4gICAgICAgICAgLi4udW5zdGFibGVfc2hvdWxkUmV2YWxpZGF0ZUFyZ3MsXG4gICAgICAgICAgZGVmYXVsdFNob3VsZFJldmFsaWRhdGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2hvdWxkUmV2YWxpZGF0ZUxvYWRlcihtYXRjaCwgdW5zdGFibGVfc2hvdWxkUmV2YWxpZGF0ZUFyZ3MpO1xuICAgIH0sXG4gICAgcmVzb2x2ZShoYW5kbGVyT3ZlcnJpZGUpIHtcbiAgICAgIGlmIChpc1VzaW5nTmV3QXBpIHx8IHNob3VsZExvYWQgfHwgaGFuZGxlck92ZXJyaWRlICYmIHJlcXVlc3QubWV0aG9kID09PSBcIkdFVFwiICYmIChtYXRjaC5yb3V0ZS5sYXp5IHx8IG1hdGNoLnJvdXRlLmxvYWRlcikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxMb2FkZXJPckFjdGlvbih7XG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBsYXp5SGFuZGxlclByb21pc2U6IF9sYXp5UHJvbWlzZXM/LmhhbmRsZXIsXG4gICAgICAgICAgbGF6eVJvdXRlUHJvbWlzZTogX2xhenlQcm9taXNlcz8ucm91dGUsXG4gICAgICAgICAgaGFuZGxlck92ZXJyaWRlLFxuICAgICAgICAgIHNjb3BlZENvbnRleHRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgdHlwZTogXCJkYXRhXCIgLyogZGF0YSAqLywgcmVzdWx0OiB2b2lkIDAgfSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0VGFyZ2V0ZWREYXRhU3RyYXRlZ3lNYXRjaGVzKG1hcFJvdXRlUHJvcGVydGllczIsIG1hbmlmZXN0LCByZXF1ZXN0LCBtYXRjaGVzLCB0YXJnZXRNYXRjaCwgbGF6eVJvdXRlUHJvcGVydGllc1RvU2tpcCwgc2NvcGVkQ29udGV4dCwgc2hvdWxkUmV2YWxpZGF0ZUFyZ3MgPSBudWxsKSB7XG4gIHJldHVybiBtYXRjaGVzLm1hcCgobWF0Y2gpID0+IHtcbiAgICBpZiAobWF0Y2gucm91dGUuaWQgIT09IHRhcmdldE1hdGNoLnJvdXRlLmlkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5tYXRjaCxcbiAgICAgICAgc2hvdWxkTG9hZDogZmFsc2UsXG4gICAgICAgIHVuc3RhYmxlX3Nob3VsZFJldmFsaWRhdGVBcmdzOiBzaG91bGRSZXZhbGlkYXRlQXJncyxcbiAgICAgICAgdW5zdGFibGVfc2hvdWxkQ2FsbEhhbmRsZXI6ICgpID0+IGZhbHNlLFxuICAgICAgICBfbGF6eVByb21pc2VzOiBnZXREYXRhU3RyYXRlZ3lNYXRjaExhenlQcm9taXNlcyhcbiAgICAgICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgICAgICAgIG1hbmlmZXN0LFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgbGF6eVJvdXRlUHJvcGVydGllc1RvU2tpcFxuICAgICAgICApLFxuICAgICAgICByZXNvbHZlOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoeyB0eXBlOiBcImRhdGFcIiwgcmVzdWx0OiB2b2lkIDAgfSlcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBnZXREYXRhU3RyYXRlZ3lNYXRjaChcbiAgICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgICBtYW5pZmVzdCxcbiAgICAgIHJlcXVlc3QsXG4gICAgICBtYXRjaCxcbiAgICAgIGxhenlSb3V0ZVByb3BlcnRpZXNUb1NraXAsXG4gICAgICBzY29wZWRDb250ZXh0LFxuICAgICAgdHJ1ZSxcbiAgICAgIHNob3VsZFJldmFsaWRhdGVBcmdzXG4gICAgKTtcbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBjYWxsRGF0YVN0cmF0ZWd5SW1wbChkYXRhU3RyYXRlZ3lJbXBsLCByZXF1ZXN0LCBtYXRjaGVzLCBmZXRjaGVyS2V5LCBzY29wZWRDb250ZXh0LCBpc1N0YXRpY0hhbmRsZXIpIHtcbiAgaWYgKG1hdGNoZXMuc29tZSgobSkgPT4gbS5fbGF6eVByb21pc2VzPy5taWRkbGV3YXJlKSkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsKG1hdGNoZXMubWFwKChtKSA9PiBtLl9sYXp5UHJvbWlzZXM/Lm1pZGRsZXdhcmUpKTtcbiAgfVxuICBsZXQgZGF0YVN0cmF0ZWd5QXJncyA9IHtcbiAgICByZXF1ZXN0LFxuICAgIHBhcmFtczogbWF0Y2hlc1swXS5wYXJhbXMsXG4gICAgY29udGV4dDogc2NvcGVkQ29udGV4dCxcbiAgICBtYXRjaGVzXG4gIH07XG4gIGxldCB1bnN0YWJsZV9ydW5DbGllbnRNaWRkbGV3YXJlID0gaXNTdGF0aWNIYW5kbGVyID8gKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiWW91IGNhbm5vdCBjYWxsIGB1bnN0YWJsZV9ydW5DbGllbnRNaWRkbGV3YXJlKClgIGZyb20gYSBzdGF0aWMgaGFuZGxlciBgZGF0YVN0cmF0ZWd5YC4gTWlkZGxld2FyZSBpcyBydW4gb3V0c2lkZSBvZiBgZGF0YVN0cmF0ZWd5YCBkdXJpbmcgU1NSIGluIG9yZGVyIHRvIGJ1YmJsZSB1cCB0aGUgUmVzcG9uc2UuICBZb3UgY2FuIGVuYWJsZSBtaWRkbGV3YXJlIHZpYSB0aGUgYHJlc3BvbmRgIEFQSSBpbiBgcXVlcnlgL2BxdWVyeVJvdXRlYFwiXG4gICAgKTtcbiAgfSA6IChjYikgPT4ge1xuICAgIGxldCB0eXBlZERhdGFTdHJhdGVneUFyZ3MgPSBkYXRhU3RyYXRlZ3lBcmdzO1xuICAgIHJldHVybiBydW5NaWRkbGV3YXJlUGlwZWxpbmUoXG4gICAgICB0eXBlZERhdGFTdHJhdGVneUFyZ3MsXG4gICAgICBmYWxzZSxcbiAgICAgICgpID0+IGNiKHtcbiAgICAgICAgLi4udHlwZWREYXRhU3RyYXRlZ3lBcmdzLFxuICAgICAgICBmZXRjaGVyS2V5LFxuICAgICAgICB1bnN0YWJsZV9ydW5DbGllbnRNaWRkbGV3YXJlOiAoKSA9PiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJDYW5ub3QgY2FsbCBgdW5zdGFibGVfcnVuQ2xpZW50TWlkZGxld2FyZSgpYCBmcm9tIHdpdGhpbiBhbiBgdW5zdGFibGVfcnVuQ2xpZW50TWlkZGxld2FyZWAgaGFuZGxlclwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICAoZXJyb3IsIHJvdXRlSWQpID0+ICh7XG4gICAgICAgIFtyb3V0ZUlkXTogeyB0eXBlOiBcImVycm9yXCIsIHJlc3VsdDogZXJyb3IgfVxuICAgICAgfSlcbiAgICApO1xuICB9O1xuICBsZXQgcmVzdWx0cyA9IGF3YWl0IGRhdGFTdHJhdGVneUltcGwoe1xuICAgIC4uLmRhdGFTdHJhdGVneUFyZ3MsXG4gICAgZmV0Y2hlcktleSxcbiAgICB1bnN0YWJsZV9ydW5DbGllbnRNaWRkbGV3YXJlXG4gIH0pO1xuICB0cnkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgbWF0Y2hlcy5mbGF0TWFwKChtKSA9PiBbbS5fbGF6eVByb21pc2VzPy5oYW5kbGVyLCBtLl9sYXp5UHJvbWlzZXM/LnJvdXRlXSlcbiAgICApO1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5hc3luYyBmdW5jdGlvbiBjYWxsTG9hZGVyT3JBY3Rpb24oe1xuICByZXF1ZXN0LFxuICBtYXRjaCxcbiAgbGF6eUhhbmRsZXJQcm9taXNlLFxuICBsYXp5Um91dGVQcm9taXNlLFxuICBoYW5kbGVyT3ZlcnJpZGUsXG4gIHNjb3BlZENvbnRleHRcbn0pIHtcbiAgbGV0IHJlc3VsdDtcbiAgbGV0IG9uUmVqZWN0O1xuICBsZXQgaXNBY3Rpb24gPSBpc011dGF0aW9uTWV0aG9kKHJlcXVlc3QubWV0aG9kKTtcbiAgbGV0IHR5cGUgPSBpc0FjdGlvbiA/IFwiYWN0aW9uXCIgOiBcImxvYWRlclwiO1xuICBsZXQgcnVuSGFuZGxlciA9IChoYW5kbGVyKSA9PiB7XG4gICAgbGV0IHJlamVjdDtcbiAgICBsZXQgYWJvcnRQcm9taXNlID0gbmV3IFByb21pc2UoKF8sIHIpID0+IHJlamVjdCA9IHIpO1xuICAgIG9uUmVqZWN0ID0gKCkgPT4gcmVqZWN0KCk7XG4gICAgcmVxdWVzdC5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uUmVqZWN0KTtcbiAgICBsZXQgYWN0dWFsSGFuZGxlciA9IChjdHgpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgWW91IGNhbm5vdCBjYWxsIHRoZSBoYW5kbGVyIGZvciBhIHJvdXRlIHdoaWNoIGRlZmluZXMgYSBib29sZWFuIFwiJHt0eXBlfVwiIFtyb3V0ZUlkOiAke21hdGNoLnJvdXRlLmlkfV1gXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhbmRsZXIoXG4gICAgICAgIHtcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIHBhcmFtczogbWF0Y2gucGFyYW1zLFxuICAgICAgICAgIGNvbnRleHQ6IHNjb3BlZENvbnRleHRcbiAgICAgICAgfSxcbiAgICAgICAgLi4uY3R4ICE9PSB2b2lkIDAgPyBbY3R4XSA6IFtdXG4gICAgICApO1xuICAgIH07XG4gICAgbGV0IGhhbmRsZXJQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCB2YWwgPSBhd2FpdCAoaGFuZGxlck92ZXJyaWRlID8gaGFuZGxlck92ZXJyaWRlKChjdHgpID0+IGFjdHVhbEhhbmRsZXIoY3R4KSkgOiBhY3R1YWxIYW5kbGVyKCkpO1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImRhdGFcIiwgcmVzdWx0OiB2YWwgfTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCByZXN1bHQ6IGUgfTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICAgIHJldHVybiBQcm9taXNlLnJhY2UoW2hhbmRsZXJQcm9taXNlLCBhYm9ydFByb21pc2VdKTtcbiAgfTtcbiAgdHJ5IHtcbiAgICBsZXQgaGFuZGxlciA9IGlzQWN0aW9uID8gbWF0Y2gucm91dGUuYWN0aW9uIDogbWF0Y2gucm91dGUubG9hZGVyO1xuICAgIGlmIChsYXp5SGFuZGxlclByb21pc2UgfHwgbGF6eVJvdXRlUHJvbWlzZSkge1xuICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgbGV0IGhhbmRsZXJFcnJvcjtcbiAgICAgICAgbGV0IFt2YWx1ZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgLy8gSWYgdGhlIGhhbmRsZXIgdGhyb3dzLCBkb24ndCBsZXQgaXQgaW1tZWRpYXRlbHkgYnViYmxlIG91dCxcbiAgICAgICAgICAvLyBzaW5jZSB3ZSBuZWVkIHRvIGxldCB0aGUgbGF6eSgpIGV4ZWN1dGlvbiBmaW5pc2ggc28gd2Uga25vdyBpZiB0aGlzXG4gICAgICAgICAgLy8gcm91dGUgaGFzIGEgYm91bmRhcnkgdGhhdCBjYW4gaGFuZGxlIHRoZSBlcnJvclxuICAgICAgICAgIHJ1bkhhbmRsZXIoaGFuZGxlcikuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIGhhbmRsZXJFcnJvciA9IGU7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgLy8gRW5zdXJlIGFsbCBsYXp5IHJvdXRlIHByb21pc2VzIGFyZSByZXNvbHZlZCBiZWZvcmUgY29udGludWluZ1xuICAgICAgICAgIGxhenlIYW5kbGVyUHJvbWlzZSxcbiAgICAgICAgICBsYXp5Um91dGVQcm9taXNlXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAoaGFuZGxlckVycm9yICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB0aHJvdyBoYW5kbGVyRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCBsYXp5SGFuZGxlclByb21pc2U7XG4gICAgICAgIGxldCBoYW5kbGVyMiA9IGlzQWN0aW9uID8gbWF0Y2gucm91dGUuYWN0aW9uIDogbWF0Y2gucm91dGUubG9hZGVyO1xuICAgICAgICBpZiAoaGFuZGxlcjIpIHtcbiAgICAgICAgICBbcmVzdWx0XSA9IGF3YWl0IFByb21pc2UuYWxsKFtydW5IYW5kbGVyKGhhbmRsZXIyKSwgbGF6eVJvdXRlUHJvbWlzZV0pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiYWN0aW9uXCIpIHtcbiAgICAgICAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgICAgICAgbGV0IHBhdGhuYW1lID0gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaDtcbiAgICAgICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgcm91dGVJZDogbWF0Y2gucm91dGUuaWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImRhdGFcIiAvKiBkYXRhICovLCByZXN1bHQ6IHZvaWQgMCB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaGFuZGxlcikge1xuICAgICAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgICAgbGV0IHBhdGhuYW1lID0gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaDtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XG4gICAgICAgIHBhdGhuYW1lXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgcnVuSGFuZGxlcihoYW5kbGVyKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sIHJlc3VsdDogZSB9O1xuICB9IGZpbmFsbHkge1xuICAgIGlmIChvblJlamVjdCkge1xuICAgICAgcmVxdWVzdC5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uUmVqZWN0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNvbnZlcnREYXRhU3RyYXRlZ3lSZXN1bHRUb0RhdGFSZXN1bHQoZGF0YVN0cmF0ZWd5UmVzdWx0KSB7XG4gIGxldCB7IHJlc3VsdCwgdHlwZSB9ID0gZGF0YVN0cmF0ZWd5UmVzdWx0O1xuICBpZiAoaXNSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgbGV0IGRhdGEyO1xuICAgIHRyeSB7XG4gICAgICBsZXQgY29udGVudFR5cGUgPSByZXN1bHQuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIik7XG4gICAgICBpZiAoY29udGVudFR5cGUgJiYgL1xcYmFwcGxpY2F0aW9uXFwvanNvblxcYi8udGVzdChjb250ZW50VHlwZSkpIHtcbiAgICAgICAgaWYgKHJlc3VsdC5ib2R5ID09IG51bGwpIHtcbiAgICAgICAgICBkYXRhMiA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YTIgPSBhd2FpdCByZXN1bHQuanNvbigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhMiA9IGF3YWl0IHJlc3VsdC50ZXh0KCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiIC8qIGVycm9yICovLCBlcnJvcjogZSB9O1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJlcnJvclwiIC8qIGVycm9yICovKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sXG4gICAgICAgIGVycm9yOiBuZXcgRXJyb3JSZXNwb25zZUltcGwocmVzdWx0LnN0YXR1cywgcmVzdWx0LnN0YXR1c1RleHQsIGRhdGEyKSxcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzdWx0LnN0YXR1cyxcbiAgICAgICAgaGVhZGVyczogcmVzdWx0LmhlYWRlcnNcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImRhdGFcIiAvKiBkYXRhICovLFxuICAgICAgZGF0YTogZGF0YTIsXG4gICAgICBzdGF0dXNDb2RlOiByZXN1bHQuc3RhdHVzLFxuICAgICAgaGVhZGVyczogcmVzdWx0LmhlYWRlcnNcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlID09PSBcImVycm9yXCIgLyogZXJyb3IgKi8pIHtcbiAgICBpZiAoaXNEYXRhV2l0aFJlc3BvbnNlSW5pdChyZXN1bHQpKSB7XG4gICAgICBpZiAocmVzdWx0LmRhdGEgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIiAvKiBlcnJvciAqLyxcbiAgICAgICAgICBlcnJvcjogcmVzdWx0LmRhdGEsXG4gICAgICAgICAgc3RhdHVzQ29kZTogcmVzdWx0LmluaXQ/LnN0YXR1cyxcbiAgICAgICAgICBoZWFkZXJzOiByZXN1bHQuaW5pdD8uaGVhZGVycyA/IG5ldyBIZWFkZXJzKHJlc3VsdC5pbml0LmhlYWRlcnMpIDogdm9pZCAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sXG4gICAgICAgIGVycm9yOiBuZXcgRXJyb3JSZXNwb25zZUltcGwoXG4gICAgICAgICAgcmVzdWx0LmluaXQ/LnN0YXR1cyB8fCA1MDAsXG4gICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgIHJlc3VsdC5kYXRhXG4gICAgICAgICksXG4gICAgICAgIHN0YXR1c0NvZGU6IGlzUm91dGVFcnJvclJlc3BvbnNlKHJlc3VsdCkgPyByZXN1bHQuc3RhdHVzIDogdm9pZCAwLFxuICAgICAgICBoZWFkZXJzOiByZXN1bHQuaW5pdD8uaGVhZGVycyA/IG5ldyBIZWFkZXJzKHJlc3VsdC5pbml0LmhlYWRlcnMpIDogdm9pZCAwXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlcnJvclwiIC8qIGVycm9yICovLFxuICAgICAgZXJyb3I6IHJlc3VsdCxcbiAgICAgIHN0YXR1c0NvZGU6IGlzUm91dGVFcnJvclJlc3BvbnNlKHJlc3VsdCkgPyByZXN1bHQuc3RhdHVzIDogdm9pZCAwXG4gICAgfTtcbiAgfVxuICBpZiAoaXNEYXRhV2l0aFJlc3BvbnNlSW5pdChyZXN1bHQpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZGF0YVwiIC8qIGRhdGEgKi8sXG4gICAgICBkYXRhOiByZXN1bHQuZGF0YSxcbiAgICAgIHN0YXR1c0NvZGU6IHJlc3VsdC5pbml0Py5zdGF0dXMsXG4gICAgICBoZWFkZXJzOiByZXN1bHQuaW5pdD8uaGVhZGVycyA/IG5ldyBIZWFkZXJzKHJlc3VsdC5pbml0LmhlYWRlcnMpIDogdm9pZCAwXG4gICAgfTtcbiAgfVxuICByZXR1cm4geyB0eXBlOiBcImRhdGFcIiAvKiBkYXRhICovLCBkYXRhOiByZXN1bHQgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlbGF0aXZlUm91dGluZ1JlZGlyZWN0UmVzcG9uc2UocmVzcG9uc2UsIHJlcXVlc3QsIHJvdXRlSWQsIG1hdGNoZXMsIGJhc2VuYW1lKSB7XG4gIGxldCBsb2NhdGlvbiA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiTG9jYXRpb25cIik7XG4gIGludmFyaWFudChcbiAgICBsb2NhdGlvbixcbiAgICBcIlJlZGlyZWN0cyByZXR1cm5lZC90aHJvd24gZnJvbSBsb2FkZXJzL2FjdGlvbnMgbXVzdCBoYXZlIGEgTG9jYXRpb24gaGVhZGVyXCJcbiAgKTtcbiAgaWYgKCFBQlNPTFVURV9VUkxfUkVHRVgudGVzdChsb2NhdGlvbikpIHtcbiAgICBsZXQgdHJpbW1lZE1hdGNoZXMgPSBtYXRjaGVzLnNsaWNlKFxuICAgICAgMCxcbiAgICAgIG1hdGNoZXMuZmluZEluZGV4KChtKSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKSArIDFcbiAgICApO1xuICAgIGxvY2F0aW9uID0gbm9ybWFsaXplVG8oXG4gICAgICBuZXcgVVJMKHJlcXVlc3QudXJsKSxcbiAgICAgIHRyaW1tZWRNYXRjaGVzLFxuICAgICAgYmFzZW5hbWUsXG4gICAgICBsb2NhdGlvblxuICAgICk7XG4gICAgcmVzcG9uc2UuaGVhZGVycy5zZXQoXCJMb2NhdGlvblwiLCBsb2NhdGlvbik7XG4gIH1cbiAgcmV0dXJuIHJlc3BvbnNlO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUmVkaXJlY3RMb2NhdGlvbihsb2NhdGlvbiwgY3VycmVudFVybCwgYmFzZW5hbWUpIHtcbiAgaWYgKEFCU09MVVRFX1VSTF9SRUdFWC50ZXN0KGxvY2F0aW9uKSkge1xuICAgIGxldCBub3JtYWxpemVkTG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICBsZXQgdXJsID0gbm9ybWFsaXplZExvY2F0aW9uLnN0YXJ0c1dpdGgoXCIvL1wiKSA/IG5ldyBVUkwoY3VycmVudFVybC5wcm90b2NvbCArIG5vcm1hbGl6ZWRMb2NhdGlvbikgOiBuZXcgVVJMKG5vcm1hbGl6ZWRMb2NhdGlvbik7XG4gICAgbGV0IGlzU2FtZUJhc2VuYW1lID0gc3RyaXBCYXNlbmFtZSh1cmwucGF0aG5hbWUsIGJhc2VuYW1lKSAhPSBudWxsO1xuICAgIGlmICh1cmwub3JpZ2luID09PSBjdXJyZW50VXJsLm9yaWdpbiAmJiBpc1NhbWVCYXNlbmFtZSkge1xuICAgICAgcmV0dXJuIHVybC5wYXRobmFtZSArIHVybC5zZWFyY2ggKyB1cmwuaGFzaDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxvY2F0aW9uO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoaGlzdG9yeSwgbG9jYXRpb24sIHNpZ25hbCwgc3VibWlzc2lvbikge1xuICBsZXQgdXJsID0gaGlzdG9yeS5jcmVhdGVVUkwoc3RyaXBIYXNoRnJvbVBhdGgobG9jYXRpb24pKS50b1N0cmluZygpO1xuICBsZXQgaW5pdCA9IHsgc2lnbmFsIH07XG4gIGlmIChzdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2Qoc3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xuICAgIGxldCB7IGZvcm1NZXRob2QsIGZvcm1FbmNUeXBlIH0gPSBzdWJtaXNzaW9uO1xuICAgIGluaXQubWV0aG9kID0gZm9ybU1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIGlmIChmb3JtRW5jVHlwZSA9PT0gXCJhcHBsaWNhdGlvbi9qc29uXCIpIHtcbiAgICAgIGluaXQuaGVhZGVycyA9IG5ldyBIZWFkZXJzKHsgXCJDb250ZW50LVR5cGVcIjogZm9ybUVuY1R5cGUgfSk7XG4gICAgICBpbml0LmJvZHkgPSBKU09OLnN0cmluZ2lmeShzdWJtaXNzaW9uLmpzb24pO1xuICAgIH0gZWxzZSBpZiAoZm9ybUVuY1R5cGUgPT09IFwidGV4dC9wbGFpblwiKSB7XG4gICAgICBpbml0LmJvZHkgPSBzdWJtaXNzaW9uLnRleHQ7XG4gICAgfSBlbHNlIGlmIChmb3JtRW5jVHlwZSA9PT0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiAmJiBzdWJtaXNzaW9uLmZvcm1EYXRhKSB7XG4gICAgICBpbml0LmJvZHkgPSBjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyhzdWJtaXNzaW9uLmZvcm1EYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdC5ib2R5ID0gc3VibWlzc2lvbi5mb3JtRGF0YTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KHVybCwgaW5pdCk7XG59XG5mdW5jdGlvbiBjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyhmb3JtRGF0YSkge1xuICBsZXQgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgZm9ybURhdGEuZW50cmllcygpKSB7XG4gICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlIDogdmFsdWUubmFtZSk7XG4gIH1cbiAgcmV0dXJuIHNlYXJjaFBhcmFtcztcbn1cbmZ1bmN0aW9uIGNvbnZlcnRTZWFyY2hQYXJhbXNUb0Zvcm1EYXRhKHNlYXJjaFBhcmFtcykge1xuICBsZXQgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIHNlYXJjaFBhcmFtcy5lbnRyaWVzKCkpIHtcbiAgICBmb3JtRGF0YS5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZvcm1EYXRhO1xufVxuZnVuY3Rpb24gcHJvY2Vzc1JvdXRlTG9hZGVyRGF0YShtYXRjaGVzLCByZXN1bHRzLCBwZW5kaW5nQWN0aW9uUmVzdWx0LCBpc1N0YXRpY0hhbmRsZXIgPSBmYWxzZSwgc2tpcExvYWRlckVycm9yQnViYmxpbmcgPSBmYWxzZSkge1xuICBsZXQgbG9hZGVyRGF0YSA9IHt9O1xuICBsZXQgZXJyb3JzID0gbnVsbDtcbiAgbGV0IHN0YXR1c0NvZGU7XG4gIGxldCBmb3VuZEVycm9yID0gZmFsc2U7XG4gIGxldCBsb2FkZXJIZWFkZXJzID0ge307XG4gIGxldCBwZW5kaW5nRXJyb3IgPSBwZW5kaW5nQWN0aW9uUmVzdWx0ICYmIGlzRXJyb3JSZXN1bHQocGVuZGluZ0FjdGlvblJlc3VsdFsxXSkgPyBwZW5kaW5nQWN0aW9uUmVzdWx0WzFdLmVycm9yIDogdm9pZCAwO1xuICBtYXRjaGVzLmZvckVhY2goKG1hdGNoKSA9PiB7XG4gICAgaWYgKCEobWF0Y2gucm91dGUuaWQgaW4gcmVzdWx0cykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGlkID0gbWF0Y2gucm91dGUuaWQ7XG4gICAgbGV0IHJlc3VsdCA9IHJlc3VsdHNbaWRdO1xuICAgIGludmFyaWFudChcbiAgICAgICFpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCksXG4gICAgICBcIkNhbm5vdCBoYW5kbGUgcmVkaXJlY3QgcmVzdWx0cyBpbiBwcm9jZXNzTG9hZGVyRGF0YVwiXG4gICAgKTtcbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgZXJyb3IgPSByZXN1bHQuZXJyb3I7XG4gICAgICBpZiAocGVuZGluZ0Vycm9yICE9PSB2b2lkIDApIHtcbiAgICAgICAgZXJyb3IgPSBwZW5kaW5nRXJyb3I7XG4gICAgICAgIHBlbmRpbmdFcnJvciA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGVycm9ycyA9IGVycm9ycyB8fCB7fTtcbiAgICAgIGlmIChza2lwTG9hZGVyRXJyb3JCdWJibGluZykge1xuICAgICAgICBlcnJvcnNbaWRdID0gZXJyb3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hlcywgaWQpO1xuICAgICAgICBpZiAoZXJyb3JzW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdID09IG51bGwpIHtcbiAgICAgICAgICBlcnJvcnNbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF0gPSBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFpc1N0YXRpY0hhbmRsZXIpIHtcbiAgICAgICAgbG9hZGVyRGF0YVtpZF0gPSBSZXNldExvYWRlckRhdGFTeW1ib2w7XG4gICAgICB9XG4gICAgICBpZiAoIWZvdW5kRXJyb3IpIHtcbiAgICAgICAgZm91bmRFcnJvciA9IHRydWU7XG4gICAgICAgIHN0YXR1c0NvZGUgPSBpc1JvdXRlRXJyb3JSZXNwb25zZShyZXN1bHQuZXJyb3IpID8gcmVzdWx0LmVycm9yLnN0YXR1cyA6IDUwMDtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQuaGVhZGVycykge1xuICAgICAgICBsb2FkZXJIZWFkZXJzW2lkXSA9IHJlc3VsdC5oZWFkZXJzO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkZXJEYXRhW2lkXSA9IHJlc3VsdC5kYXRhO1xuICAgICAgaWYgKHJlc3VsdC5zdGF0dXNDb2RlICYmIHJlc3VsdC5zdGF0dXNDb2RlICE9PSAyMDAgJiYgIWZvdW5kRXJyb3IpIHtcbiAgICAgICAgc3RhdHVzQ29kZSA9IHJlc3VsdC5zdGF0dXNDb2RlO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdC5oZWFkZXJzKSB7XG4gICAgICAgIGxvYWRlckhlYWRlcnNbaWRdID0gcmVzdWx0LmhlYWRlcnM7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgaWYgKHBlbmRpbmdFcnJvciAhPT0gdm9pZCAwICYmIHBlbmRpbmdBY3Rpb25SZXN1bHQpIHtcbiAgICBlcnJvcnMgPSB7IFtwZW5kaW5nQWN0aW9uUmVzdWx0WzBdXTogcGVuZGluZ0Vycm9yIH07XG4gICAgaWYgKHBlbmRpbmdBY3Rpb25SZXN1bHRbMl0pIHtcbiAgICAgIGxvYWRlckRhdGFbcGVuZGluZ0FjdGlvblJlc3VsdFsyXV0gPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbG9hZGVyRGF0YSxcbiAgICBlcnJvcnMsXG4gICAgc3RhdHVzQ29kZTogc3RhdHVzQ29kZSB8fCAyMDAsXG4gICAgbG9hZGVySGVhZGVyc1xuICB9O1xufVxuZnVuY3Rpb24gcHJvY2Vzc0xvYWRlckRhdGEoc3RhdGUsIG1hdGNoZXMsIHJlc3VsdHMsIHBlbmRpbmdBY3Rpb25SZXN1bHQsIHJldmFsaWRhdGluZ0ZldGNoZXJzLCBmZXRjaGVyUmVzdWx0cykge1xuICBsZXQgeyBsb2FkZXJEYXRhLCBlcnJvcnMgfSA9IHByb2Nlc3NSb3V0ZUxvYWRlckRhdGEoXG4gICAgbWF0Y2hlcyxcbiAgICByZXN1bHRzLFxuICAgIHBlbmRpbmdBY3Rpb25SZXN1bHRcbiAgKTtcbiAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZmlsdGVyKChmKSA9PiAhZi5tYXRjaGVzIHx8IGYubWF0Y2hlcy5zb21lKChtKSA9PiBtLnNob3VsZExvYWQpKS5mb3JFYWNoKChyZikgPT4ge1xuICAgIGxldCB7IGtleSwgbWF0Y2gsIGNvbnRyb2xsZXIgfSA9IHJmO1xuICAgIGxldCByZXN1bHQgPSBmZXRjaGVyUmVzdWx0c1trZXldO1xuICAgIGludmFyaWFudChyZXN1bHQsIFwiRGlkIG5vdCBmaW5kIGNvcnJlc3BvbmRpbmcgZmV0Y2hlciByZXN1bHRcIik7XG4gICAgaWYgKGNvbnRyb2xsZXIgJiYgY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkoc3RhdGUubWF0Y2hlcywgbWF0Y2g/LnJvdXRlLmlkKTtcbiAgICAgIGlmICghKGVycm9ycyAmJiBlcnJvcnNbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF0pKSB7XG4gICAgICAgIGVycm9ycyA9IHtcbiAgICAgICAgICAuLi5lcnJvcnMsXG4gICAgICAgICAgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZXJyb3JcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmZldGNoZXJzLmRlbGV0ZShrZXkpO1xuICAgIH0gZWxzZSBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsIFwiVW5oYW5kbGVkIGZldGNoZXIgcmV2YWxpZGF0aW9uIHJlZGlyZWN0XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZG9uZUZldGNoZXIgPSBnZXREb25lRmV0Y2hlcihyZXN1bHQuZGF0YSk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHsgbG9hZGVyRGF0YSwgZXJyb3JzIH07XG59XG5mdW5jdGlvbiBtZXJnZUxvYWRlckRhdGEobG9hZGVyRGF0YSwgbmV3TG9hZGVyRGF0YSwgbWF0Y2hlcywgZXJyb3JzKSB7XG4gIGxldCBtZXJnZWRMb2FkZXJEYXRhID0gT2JqZWN0LmVudHJpZXMobmV3TG9hZGVyRGF0YSkuZmlsdGVyKChbLCB2XSkgPT4gdiAhPT0gUmVzZXRMb2FkZXJEYXRhU3ltYm9sKS5yZWR1Y2UoKG1lcmdlZCwgW2ssIHZdKSA9PiB7XG4gICAgbWVyZ2VkW2tdID0gdjtcbiAgICByZXR1cm4gbWVyZ2VkO1xuICB9LCB7fSk7XG4gIGZvciAobGV0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICBsZXQgaWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgICBpZiAoIW5ld0xvYWRlckRhdGEuaGFzT3duUHJvcGVydHkoaWQpICYmIGxvYWRlckRhdGEuaGFzT3duUHJvcGVydHkoaWQpICYmIG1hdGNoLnJvdXRlLmxvYWRlcikge1xuICAgICAgbWVyZ2VkTG9hZGVyRGF0YVtpZF0gPSBsb2FkZXJEYXRhW2lkXTtcbiAgICB9XG4gICAgaWYgKGVycm9ycyAmJiBlcnJvcnMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1lcmdlZExvYWRlckRhdGE7XG59XG5mdW5jdGlvbiBnZXRBY3Rpb25EYXRhRm9yQ29tbWl0KHBlbmRpbmdBY3Rpb25SZXN1bHQpIHtcbiAgaWYgKCFwZW5kaW5nQWN0aW9uUmVzdWx0KSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiBpc0Vycm9yUmVzdWx0KHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0pID8ge1xuICAgIC8vIENsZWFyIG91dCBwcmlvciBhY3Rpb25EYXRhIG9uIGVycm9yc1xuICAgIGFjdGlvbkRhdGE6IHt9XG4gIH0gOiB7XG4gICAgYWN0aW9uRGF0YToge1xuICAgICAgW3BlbmRpbmdBY3Rpb25SZXN1bHRbMF1dOiBwZW5kaW5nQWN0aW9uUmVzdWx0WzFdLmRhdGFcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMsIHJvdXRlSWQpIHtcbiAgbGV0IGVsaWdpYmxlTWF0Y2hlcyA9IHJvdXRlSWQgPyBtYXRjaGVzLnNsaWNlKDAsIG1hdGNoZXMuZmluZEluZGV4KChtKSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKSArIDEpIDogWy4uLm1hdGNoZXNdO1xuICByZXR1cm4gZWxpZ2libGVNYXRjaGVzLnJldmVyc2UoKS5maW5kKChtKSA9PiBtLnJvdXRlLmhhc0Vycm9yQm91bmRhcnkgPT09IHRydWUpIHx8IG1hdGNoZXNbMF07XG59XG5mdW5jdGlvbiBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKHJvdXRlcykge1xuICBsZXQgcm91dGUgPSByb3V0ZXMubGVuZ3RoID09PSAxID8gcm91dGVzWzBdIDogcm91dGVzLmZpbmQoKHIpID0+IHIuaW5kZXggfHwgIXIucGF0aCB8fCByLnBhdGggPT09IFwiL1wiKSB8fCB7XG4gICAgaWQ6IGBfX3NoaW0tZXJyb3Itcm91dGVfX2BcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBtYXRjaGVzOiBbXG4gICAgICB7XG4gICAgICAgIHBhcmFtczoge30sXG4gICAgICAgIHBhdGhuYW1lOiBcIlwiLFxuICAgICAgICBwYXRobmFtZUJhc2U6IFwiXCIsXG4gICAgICAgIHJvdXRlXG4gICAgICB9XG4gICAgXSxcbiAgICByb3V0ZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcihzdGF0dXMsIHtcbiAgcGF0aG5hbWUsXG4gIHJvdXRlSWQsXG4gIG1ldGhvZCxcbiAgdHlwZSxcbiAgbWVzc2FnZVxufSA9IHt9KSB7XG4gIGxldCBzdGF0dXNUZXh0ID0gXCJVbmtub3duIFNlcnZlciBFcnJvclwiO1xuICBsZXQgZXJyb3JNZXNzYWdlID0gXCJVbmtub3duIEByZW1peC1ydW4vcm91dGVyIGVycm9yXCI7XG4gIGlmIChzdGF0dXMgPT09IDQwMCkge1xuICAgIHN0YXR1c1RleHQgPSBcIkJhZCBSZXF1ZXN0XCI7XG4gICAgaWYgKG1ldGhvZCAmJiBwYXRobmFtZSAmJiByb3V0ZUlkKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBgWW91IG1hZGUgYSAke21ldGhvZH0gcmVxdWVzdCB0byBcIiR7cGF0aG5hbWV9XCIgYnV0IGRpZCBub3QgcHJvdmlkZSBhIFxcYGxvYWRlclxcYCBmb3Igcm91dGUgXCIke3JvdXRlSWR9XCIsIHNvIHRoZXJlIGlzIG5vIHdheSB0byBoYW5kbGUgdGhlIHJlcXVlc3QuYDtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiaW52YWxpZC1ib2R5XCIpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IFwiVW5hYmxlIHRvIGVuY29kZSBzdWJtaXNzaW9uIGJvZHlcIjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDMpIHtcbiAgICBzdGF0dXNUZXh0ID0gXCJGb3JiaWRkZW5cIjtcbiAgICBlcnJvck1lc3NhZ2UgPSBgUm91dGUgXCIke3JvdXRlSWR9XCIgZG9lcyBub3QgbWF0Y2ggVVJMIFwiJHtwYXRobmFtZX1cImA7XG4gIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDQpIHtcbiAgICBzdGF0dXNUZXh0ID0gXCJOb3QgRm91bmRcIjtcbiAgICBlcnJvck1lc3NhZ2UgPSBgTm8gcm91dGUgbWF0Y2hlcyBVUkwgXCIke3BhdGhuYW1lfVwiYDtcbiAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDQwNSkge1xuICAgIHN0YXR1c1RleHQgPSBcIk1ldGhvZCBOb3QgQWxsb3dlZFwiO1xuICAgIGlmIChtZXRob2QgJiYgcGF0aG5hbWUgJiYgcm91dGVJZCkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gYFlvdSBtYWRlIGEgJHttZXRob2QudG9VcHBlckNhc2UoKX0gcmVxdWVzdCB0byBcIiR7cGF0aG5hbWV9XCIgYnV0IGRpZCBub3QgcHJvdmlkZSBhbiBcXGBhY3Rpb25cXGAgZm9yIHJvdXRlIFwiJHtyb3V0ZUlkfVwiLCBzbyB0aGVyZSBpcyBubyB3YXkgdG8gaGFuZGxlIHRoZSByZXF1ZXN0LmA7XG4gICAgfSBlbHNlIGlmIChtZXRob2QpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IGBJbnZhbGlkIHJlcXVlc3QgbWV0aG9kIFwiJHttZXRob2QudG9VcHBlckNhc2UoKX1cImA7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgRXJyb3JSZXNwb25zZUltcGwoXG4gICAgc3RhdHVzIHx8IDUwMCxcbiAgICBzdGF0dXNUZXh0LFxuICAgIG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpLFxuICAgIHRydWVcbiAgKTtcbn1cbmZ1bmN0aW9uIGZpbmRSZWRpcmVjdChyZXN1bHRzKSB7XG4gIGxldCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMocmVzdWx0cyk7XG4gIGZvciAobGV0IGkgPSBlbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGV0IFtrZXksIHJlc3VsdF0gPSBlbnRyaWVzW2ldO1xuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiB7IGtleSwgcmVzdWx0IH07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzdHJpcEhhc2hGcm9tUGF0aChwYXRoKSB7XG4gIGxldCBwYXJzZWRQYXRoID0gdHlwZW9mIHBhdGggPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgocGF0aCkgOiBwYXRoO1xuICByZXR1cm4gY3JlYXRlUGF0aCh7IC4uLnBhcnNlZFBhdGgsIGhhc2g6IFwiXCIgfSk7XG59XG5mdW5jdGlvbiBpc0hhc2hDaGFuZ2VPbmx5KGEsIGIpIHtcbiAgaWYgKGEucGF0aG5hbWUgIT09IGIucGF0aG5hbWUgfHwgYS5zZWFyY2ggIT09IGIuc2VhcmNoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhLmhhc2ggPT09IFwiXCIpIHtcbiAgICByZXR1cm4gYi5oYXNoICE9PSBcIlwiO1xuICB9IGVsc2UgaWYgKGEuaGFzaCA9PT0gYi5oYXNoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoYi5oYXNoICE9PSBcIlwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNEYXRhU3RyYXRlZ3lSZXN1bHQocmVzdWx0KSB7XG4gIHJldHVybiByZXN1bHQgIT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0ID09PSBcIm9iamVjdFwiICYmIFwidHlwZVwiIGluIHJlc3VsdCAmJiBcInJlc3VsdFwiIGluIHJlc3VsdCAmJiAocmVzdWx0LnR5cGUgPT09IFwiZGF0YVwiIC8qIGRhdGEgKi8gfHwgcmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIiAvKiBlcnJvciAqLyk7XG59XG5mdW5jdGlvbiBpc1JlZGlyZWN0RGF0YVN0cmF0ZWd5UmVzdWx0KHJlc3VsdCkge1xuICByZXR1cm4gaXNSZXNwb25zZShyZXN1bHQucmVzdWx0KSAmJiByZWRpcmVjdFN0YXR1c0NvZGVzLmhhcyhyZXN1bHQucmVzdWx0LnN0YXR1cyk7XG59XG5mdW5jdGlvbiBpc0Vycm9yUmVzdWx0KHJlc3VsdCkge1xuICByZXR1cm4gcmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIiAvKiBlcnJvciAqLztcbn1cbmZ1bmN0aW9uIGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSB7XG4gIHJldHVybiAocmVzdWx0ICYmIHJlc3VsdC50eXBlKSA9PT0gXCJyZWRpcmVjdFwiIC8qIHJlZGlyZWN0ICovO1xufVxuZnVuY3Rpb24gaXNEYXRhV2l0aFJlc3BvbnNlSW5pdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9IG51bGwgJiYgXCJ0eXBlXCIgaW4gdmFsdWUgJiYgXCJkYXRhXCIgaW4gdmFsdWUgJiYgXCJpbml0XCIgaW4gdmFsdWUgJiYgdmFsdWUudHlwZSA9PT0gXCJEYXRhV2l0aFJlc3BvbnNlSW5pdFwiO1xufVxuZnVuY3Rpb24gaXNSZXNwb25zZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUuc3RhdHVzID09PSBcIm51bWJlclwiICYmIHR5cGVvZiB2YWx1ZS5zdGF0dXNUZXh0ID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2YWx1ZS5oZWFkZXJzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZS5ib2R5ICE9PSBcInVuZGVmaW5lZFwiO1xufVxuZnVuY3Rpb24gaXNSZWRpcmVjdFN0YXR1c0NvZGUoc3RhdHVzQ29kZSkge1xuICByZXR1cm4gcmVkaXJlY3RTdGF0dXNDb2Rlcy5oYXMoc3RhdHVzQ29kZSk7XG59XG5mdW5jdGlvbiBpc1JlZGlyZWN0UmVzcG9uc2UocmVzdWx0KSB7XG4gIHJldHVybiBpc1Jlc3BvbnNlKHJlc3VsdCkgJiYgaXNSZWRpcmVjdFN0YXR1c0NvZGUocmVzdWx0LnN0YXR1cykgJiYgcmVzdWx0LmhlYWRlcnMuaGFzKFwiTG9jYXRpb25cIik7XG59XG5mdW5jdGlvbiBpc1ZhbGlkTWV0aG9kKG1ldGhvZCkge1xuICByZXR1cm4gdmFsaWRSZXF1ZXN0TWV0aG9kcy5oYXMobWV0aG9kLnRvVXBwZXJDYXNlKCkpO1xufVxuZnVuY3Rpb24gaXNNdXRhdGlvbk1ldGhvZChtZXRob2QpIHtcbiAgcmV0dXJuIHZhbGlkTXV0YXRpb25NZXRob2RzLmhhcyhtZXRob2QudG9VcHBlckNhc2UoKSk7XG59XG5mdW5jdGlvbiBoYXNOYWtlZEluZGV4UXVlcnkoc2VhcmNoKSB7XG4gIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKHNlYXJjaCkuZ2V0QWxsKFwiaW5kZXhcIikuc29tZSgodikgPT4gdiA9PT0gXCJcIik7XG59XG5mdW5jdGlvbiBnZXRUYXJnZXRNYXRjaChtYXRjaGVzLCBsb2NhdGlvbikge1xuICBsZXQgc2VhcmNoID0gdHlwZW9mIGxvY2F0aW9uID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKGxvY2F0aW9uKS5zZWFyY2ggOiBsb2NhdGlvbi5zZWFyY2g7XG4gIGlmIChtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuaW5kZXggJiYgaGFzTmFrZWRJbmRleFF1ZXJ5KHNlYXJjaCB8fCBcIlwiKSkge1xuICAgIHJldHVybiBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV07XG4gIH1cbiAgbGV0IHBhdGhNYXRjaGVzID0gZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMobWF0Y2hlcyk7XG4gIHJldHVybiBwYXRoTWF0Y2hlc1twYXRoTWF0Y2hlcy5sZW5ndGggLSAxXTtcbn1cbmZ1bmN0aW9uIGdldFN1Ym1pc3Npb25Gcm9tTmF2aWdhdGlvbihuYXZpZ2F0aW9uKSB7XG4gIGxldCB7IGZvcm1NZXRob2QsIGZvcm1BY3Rpb24sIGZvcm1FbmNUeXBlLCB0ZXh0LCBmb3JtRGF0YSwganNvbiB9ID0gbmF2aWdhdGlvbjtcbiAgaWYgKCFmb3JtTWV0aG9kIHx8ICFmb3JtQWN0aW9uIHx8ICFmb3JtRW5jVHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodGV4dCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1NZXRob2QsXG4gICAgICBmb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtRGF0YTogdm9pZCAwLFxuICAgICAganNvbjogdm9pZCAwLFxuICAgICAgdGV4dFxuICAgIH07XG4gIH0gZWxzZSBpZiAoZm9ybURhdGEgIT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICBmb3JtTWV0aG9kLFxuICAgICAgZm9ybUFjdGlvbixcbiAgICAgIGZvcm1FbmNUeXBlLFxuICAgICAgZm9ybURhdGEsXG4gICAgICBqc29uOiB2b2lkIDAsXG4gICAgICB0ZXh0OiB2b2lkIDBcbiAgICB9O1xuICB9IGVsc2UgaWYgKGpzb24gIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB7XG4gICAgICBmb3JtTWV0aG9kLFxuICAgICAgZm9ybUFjdGlvbixcbiAgICAgIGZvcm1FbmNUeXBlLFxuICAgICAgZm9ybURhdGE6IHZvaWQgMCxcbiAgICAgIGpzb24sXG4gICAgICB0ZXh0OiB2b2lkIDBcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBnZXRMb2FkaW5nTmF2aWdhdGlvbihsb2NhdGlvbiwgc3VibWlzc2lvbikge1xuICBpZiAoc3VibWlzc2lvbikge1xuICAgIGxldCBuYXZpZ2F0aW9uID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgbG9jYXRpb24sXG4gICAgICBmb3JtTWV0aG9kOiBzdWJtaXNzaW9uLmZvcm1NZXRob2QsXG4gICAgICBmb3JtQWN0aW9uOiBzdWJtaXNzaW9uLmZvcm1BY3Rpb24sXG4gICAgICBmb3JtRW5jVHlwZTogc3VibWlzc2lvbi5mb3JtRW5jVHlwZSxcbiAgICAgIGZvcm1EYXRhOiBzdWJtaXNzaW9uLmZvcm1EYXRhLFxuICAgICAganNvbjogc3VibWlzc2lvbi5qc29uLFxuICAgICAgdGV4dDogc3VibWlzc2lvbi50ZXh0XG4gICAgfTtcbiAgICByZXR1cm4gbmF2aWdhdGlvbjtcbiAgfSBlbHNlIHtcbiAgICBsZXQgbmF2aWdhdGlvbiA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgZm9ybU1ldGhvZDogdm9pZCAwLFxuICAgICAgZm9ybUFjdGlvbjogdm9pZCAwLFxuICAgICAgZm9ybUVuY1R5cGU6IHZvaWQgMCxcbiAgICAgIGZvcm1EYXRhOiB2b2lkIDAsXG4gICAgICBqc29uOiB2b2lkIDAsXG4gICAgICB0ZXh0OiB2b2lkIDBcbiAgICB9O1xuICAgIHJldHVybiBuYXZpZ2F0aW9uO1xuICB9XG59XG5mdW5jdGlvbiBnZXRTdWJtaXR0aW5nTmF2aWdhdGlvbihsb2NhdGlvbiwgc3VibWlzc2lvbikge1xuICBsZXQgbmF2aWdhdGlvbiA9IHtcbiAgICBzdGF0ZTogXCJzdWJtaXR0aW5nXCIsXG4gICAgbG9jYXRpb24sXG4gICAgZm9ybU1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxuICAgIGZvcm1BY3Rpb246IHN1Ym1pc3Npb24uZm9ybUFjdGlvbixcbiAgICBmb3JtRW5jVHlwZTogc3VibWlzc2lvbi5mb3JtRW5jVHlwZSxcbiAgICBmb3JtRGF0YTogc3VibWlzc2lvbi5mb3JtRGF0YSxcbiAgICBqc29uOiBzdWJtaXNzaW9uLmpzb24sXG4gICAgdGV4dDogc3VibWlzc2lvbi50ZXh0XG4gIH07XG4gIHJldHVybiBuYXZpZ2F0aW9uO1xufVxuZnVuY3Rpb24gZ2V0TG9hZGluZ0ZldGNoZXIoc3VibWlzc2lvbiwgZGF0YTIpIHtcbiAgaWYgKHN1Ym1pc3Npb24pIHtcbiAgICBsZXQgZmV0Y2hlciA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIGZvcm1NZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb246IHN1Ym1pc3Npb24uZm9ybUFjdGlvbixcbiAgICAgIGZvcm1FbmNUeXBlOiBzdWJtaXNzaW9uLmZvcm1FbmNUeXBlLFxuICAgICAgZm9ybURhdGE6IHN1Ym1pc3Npb24uZm9ybURhdGEsXG4gICAgICBqc29uOiBzdWJtaXNzaW9uLmpzb24sXG4gICAgICB0ZXh0OiBzdWJtaXNzaW9uLnRleHQsXG4gICAgICBkYXRhOiBkYXRhMlxuICAgIH07XG4gICAgcmV0dXJuIGZldGNoZXI7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGZldGNoZXIgPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICBmb3JtTWV0aG9kOiB2b2lkIDAsXG4gICAgICBmb3JtQWN0aW9uOiB2b2lkIDAsXG4gICAgICBmb3JtRW5jVHlwZTogdm9pZCAwLFxuICAgICAgZm9ybURhdGE6IHZvaWQgMCxcbiAgICAgIGpzb246IHZvaWQgMCxcbiAgICAgIHRleHQ6IHZvaWQgMCxcbiAgICAgIGRhdGE6IGRhdGEyXG4gICAgfTtcbiAgICByZXR1cm4gZmV0Y2hlcjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0U3VibWl0dGluZ0ZldGNoZXIoc3VibWlzc2lvbiwgZXhpc3RpbmdGZXRjaGVyKSB7XG4gIGxldCBmZXRjaGVyID0ge1xuICAgIHN0YXRlOiBcInN1Ym1pdHRpbmdcIixcbiAgICBmb3JtTWV0aG9kOiBzdWJtaXNzaW9uLmZvcm1NZXRob2QsXG4gICAgZm9ybUFjdGlvbjogc3VibWlzc2lvbi5mb3JtQWN0aW9uLFxuICAgIGZvcm1FbmNUeXBlOiBzdWJtaXNzaW9uLmZvcm1FbmNUeXBlLFxuICAgIGZvcm1EYXRhOiBzdWJtaXNzaW9uLmZvcm1EYXRhLFxuICAgIGpzb246IHN1Ym1pc3Npb24uanNvbixcbiAgICB0ZXh0OiBzdWJtaXNzaW9uLnRleHQsXG4gICAgZGF0YTogZXhpc3RpbmdGZXRjaGVyID8gZXhpc3RpbmdGZXRjaGVyLmRhdGEgOiB2b2lkIDBcbiAgfTtcbiAgcmV0dXJuIGZldGNoZXI7XG59XG5mdW5jdGlvbiBnZXREb25lRmV0Y2hlcihkYXRhMikge1xuICBsZXQgZmV0Y2hlciA9IHtcbiAgICBzdGF0ZTogXCJpZGxlXCIsXG4gICAgZm9ybU1ldGhvZDogdm9pZCAwLFxuICAgIGZvcm1BY3Rpb246IHZvaWQgMCxcbiAgICBmb3JtRW5jVHlwZTogdm9pZCAwLFxuICAgIGZvcm1EYXRhOiB2b2lkIDAsXG4gICAganNvbjogdm9pZCAwLFxuICAgIHRleHQ6IHZvaWQgMCxcbiAgICBkYXRhOiBkYXRhMlxuICB9O1xuICByZXR1cm4gZmV0Y2hlcjtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVBcHBsaWVkVHJhbnNpdGlvbnMoX3dpbmRvdywgdHJhbnNpdGlvbnMpIHtcbiAgdHJ5IHtcbiAgICBsZXQgc2Vzc2lvblBvc2l0aW9ucyA9IF93aW5kb3cuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShcbiAgICAgIFRSQU5TSVRJT05TX1NUT1JBR0VfS0VZXG4gICAgKTtcbiAgICBpZiAoc2Vzc2lvblBvc2l0aW9ucykge1xuICAgICAgbGV0IGpzb24gPSBKU09OLnBhcnNlKHNlc3Npb25Qb3NpdGlvbnMpO1xuICAgICAgZm9yIChsZXQgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKGpzb24gfHwge30pKSB7XG4gICAgICAgIGlmICh2ICYmIEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICB0cmFuc2l0aW9ucy5zZXQoaywgbmV3IFNldCh2IHx8IFtdKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxufVxuZnVuY3Rpb24gcGVyc2lzdEFwcGxpZWRUcmFuc2l0aW9ucyhfd2luZG93LCB0cmFuc2l0aW9ucykge1xuICBpZiAodHJhbnNpdGlvbnMuc2l6ZSA+IDApIHtcbiAgICBsZXQganNvbiA9IHt9O1xuICAgIGZvciAobGV0IFtrLCB2XSBvZiB0cmFuc2l0aW9ucykge1xuICAgICAganNvbltrXSA9IFsuLi52XTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIF93aW5kb3cuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcbiAgICAgICAgVFJBTlNJVElPTlNfU1RPUkFHRV9LRVksXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KGpzb24pXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgYEZhaWxlZCB0byBzYXZlIGFwcGxpZWQgdmlldyB0cmFuc2l0aW9ucyBpbiBzZXNzaW9uU3RvcmFnZSAoJHtlcnJvcn0pLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVEZWZlcnJlZCgpIHtcbiAgbGV0IHJlc29sdmU7XG4gIGxldCByZWplY3Q7XG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgcmVzb2x2ZSA9IGFzeW5jICh2YWwpID0+IHtcbiAgICAgIHJlcyh2YWwpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJlamVjdCA9IGFzeW5jIChlcnJvcikgPT4ge1xuICAgICAgcmVqKGVycm9yKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHByb21pc2U7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcHJvbWlzZSxcbiAgICAvL0B0cy1pZ25vcmVcbiAgICByZXNvbHZlLFxuICAgIC8vQHRzLWlnbm9yZVxuICAgIHJlamVjdFxuICB9O1xufVxuXG4vLyBsaWIvY29tcG9uZW50cy50c3hcbnZhciBSZWFjdDMgPSBfX3RvRVNNKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cbi8vIGxpYi9jb250ZXh0LnRzXG52YXIgUmVhY3QgPSBfX3RvRVNNKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgRGF0YVJvdXRlckNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuRGF0YVJvdXRlckNvbnRleHQuZGlzcGxheU5hbWUgPSBcIkRhdGFSb3V0ZXJcIjtcbnZhciBEYXRhUm91dGVyU3RhdGVDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbkRhdGFSb3V0ZXJTdGF0ZUNvbnRleHQuZGlzcGxheU5hbWUgPSBcIkRhdGFSb3V0ZXJTdGF0ZVwiO1xudmFyIFZpZXdUcmFuc2l0aW9uQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICBpc1RyYW5zaXRpb25pbmc6IGZhbHNlXG59KTtcblZpZXdUcmFuc2l0aW9uQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiVmlld1RyYW5zaXRpb25cIjtcbnZhciBGZXRjaGVyc0NvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KFxuICAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpXG4pO1xuRmV0Y2hlcnNDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJGZXRjaGVyc1wiO1xudmFyIEF3YWl0Q29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5Bd2FpdENvbnRleHQuZGlzcGxheU5hbWUgPSBcIkF3YWl0XCI7XG52YXIgTmF2aWdhdGlvbkNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KFxuICBudWxsXG4pO1xuTmF2aWdhdGlvbkNvbnRleHQuZGlzcGxheU5hbWUgPSBcIk5hdmlnYXRpb25cIjtcbnZhciBMb2NhdGlvbkNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KFxuICBudWxsXG4pO1xuTG9jYXRpb25Db250ZXh0LmRpc3BsYXlOYW1lID0gXCJMb2NhdGlvblwiO1xudmFyIFJvdXRlQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICBvdXRsZXQ6IG51bGwsXG4gIG1hdGNoZXM6IFtdLFxuICBpc0RhdGFSb3V0ZTogZmFsc2Vcbn0pO1xuUm91dGVDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJSb3V0ZVwiO1xudmFyIFJvdXRlRXJyb3JDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblJvdXRlRXJyb3JDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJSb3V0ZUVycm9yXCI7XG52YXIgRU5BQkxFX0RFVl9XQVJOSU5HUyA9IHRydWU7XG5cbi8vIGxpYi9ob29rcy50c3hcbnZhciBSZWFjdDIgPSBfX3RvRVNNKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5mdW5jdGlvbiB1c2VIcmVmKHRvLCB7IHJlbGF0aXZlIH0gPSB7fSkge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VIcmVmKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG4gIGxldCB7IGJhc2VuYW1lLCBuYXZpZ2F0b3IgfSA9IFJlYWN0Mi51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IHsgaGFzaCwgcGF0aG5hbWUsIHNlYXJjaCB9ID0gdXNlUmVzb2x2ZWRQYXRoKHRvLCB7IHJlbGF0aXZlIH0pO1xuICBsZXQgam9pbmVkUGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgaWYgKGJhc2VuYW1lICE9PSBcIi9cIikge1xuICAgIGpvaW5lZFBhdGhuYW1lID0gcGF0aG5hbWUgPT09IFwiL1wiID8gYmFzZW5hbWUgOiBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRobmFtZV0pO1xuICB9XG4gIHJldHVybiBuYXZpZ2F0b3IuY3JlYXRlSHJlZih7IHBhdGhuYW1lOiBqb2luZWRQYXRobmFtZSwgc2VhcmNoLCBoYXNoIH0pO1xufVxuZnVuY3Rpb24gdXNlSW5Sb3V0ZXJDb250ZXh0KCkge1xuICByZXR1cm4gUmVhY3QyLnVzZUNvbnRleHQoTG9jYXRpb25Db250ZXh0KSAhPSBudWxsO1xufVxuZnVuY3Rpb24gdXNlTG9jYXRpb24oKSB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYHVzZUxvY2F0aW9uKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG4gIHJldHVybiBSZWFjdDIudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpLmxvY2F0aW9uO1xufVxuZnVuY3Rpb24gdXNlTmF2aWdhdGlvblR5cGUoKSB7XG4gIHJldHVybiBSZWFjdDIudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpLm5hdmlnYXRpb25UeXBlO1xufVxuZnVuY3Rpb24gdXNlTWF0Y2gocGF0dGVybikge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VNYXRjaCgpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuICBsZXQgeyBwYXRobmFtZSB9ID0gdXNlTG9jYXRpb24oKTtcbiAgcmV0dXJuIFJlYWN0Mi51c2VNZW1vKFxuICAgICgpID0+IG1hdGNoUGF0aChwYXR0ZXJuLCBkZWNvZGVQYXRoKHBhdGhuYW1lKSksXG4gICAgW3BhdGhuYW1lLCBwYXR0ZXJuXVxuICApO1xufVxudmFyIG5hdmlnYXRlRWZmZWN0V2FybmluZyA9IGBZb3Ugc2hvdWxkIGNhbGwgbmF2aWdhdGUoKSBpbiBhIFJlYWN0LnVzZUVmZmVjdCgpLCBub3Qgd2hlbiB5b3VyIGNvbXBvbmVudCBpcyBmaXJzdCByZW5kZXJlZC5gO1xuZnVuY3Rpb24gdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChjYikge1xuICBsZXQgaXNTdGF0aWMgPSBSZWFjdDIudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCkuc3RhdGljO1xuICBpZiAoIWlzU3RhdGljKSB7XG4gICAgUmVhY3QyLnVzZUxheW91dEVmZmVjdChjYik7XG4gIH1cbn1cbmZ1bmN0aW9uIHVzZU5hdmlnYXRlKCkge1xuICBsZXQgeyBpc0RhdGFSb3V0ZSB9ID0gUmVhY3QyLnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgcmV0dXJuIGlzRGF0YVJvdXRlID8gdXNlTmF2aWdhdGVTdGFibGUoKSA6IHVzZU5hdmlnYXRlVW5zdGFibGUoKTtcbn1cbmZ1bmN0aW9uIHVzZU5hdmlnYXRlVW5zdGFibGUoKSB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYHVzZU5hdmlnYXRlKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IFJlYWN0Mi51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcbiAgbGV0IHsgYmFzZW5hbWUsIG5hdmlnYXRvciB9ID0gUmVhY3QyLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgeyBtYXRjaGVzIH0gPSBSZWFjdDIudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgeyBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZSB9ID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHJvdXRlUGF0aG5hbWVzSnNvbiA9IEpTT04uc3RyaW5naWZ5KGdldFJlc29sdmVUb01hdGNoZXMobWF0Y2hlcykpO1xuICBsZXQgYWN0aXZlUmVmID0gUmVhY3QyLnVzZVJlZihmYWxzZSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGFjdGl2ZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgfSk7XG4gIGxldCBuYXZpZ2F0ZSA9IFJlYWN0Mi51c2VDYWxsYmFjayhcbiAgICAodG8sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgd2FybmluZyhhY3RpdmVSZWYuY3VycmVudCwgbmF2aWdhdGVFZmZlY3RXYXJuaW5nKTtcbiAgICAgIGlmICghYWN0aXZlUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgbmF2aWdhdG9yLmdvKHRvKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHBhdGggPSByZXNvbHZlVG8oXG4gICAgICAgIHRvLFxuICAgICAgICBKU09OLnBhcnNlKHJvdXRlUGF0aG5hbWVzSnNvbiksXG4gICAgICAgIGxvY2F0aW9uUGF0aG5hbWUsXG4gICAgICAgIG9wdGlvbnMucmVsYXRpdmUgPT09IFwicGF0aFwiXG4gICAgICApO1xuICAgICAgaWYgKGRhdGFSb3V0ZXJDb250ZXh0ID09IG51bGwgJiYgYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgICAgIHBhdGgucGF0aG5hbWUgPSBwYXRoLnBhdGhuYW1lID09PSBcIi9cIiA/IGJhc2VuYW1lIDogam9pblBhdGhzKFtiYXNlbmFtZSwgcGF0aC5wYXRobmFtZV0pO1xuICAgICAgfVxuICAgICAgKCEhb3B0aW9ucy5yZXBsYWNlID8gbmF2aWdhdG9yLnJlcGxhY2UgOiBuYXZpZ2F0b3IucHVzaCkoXG4gICAgICAgIHBhdGgsXG4gICAgICAgIG9wdGlvbnMuc3RhdGUsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgICk7XG4gICAgfSxcbiAgICBbXG4gICAgICBiYXNlbmFtZSxcbiAgICAgIG5hdmlnYXRvcixcbiAgICAgIHJvdXRlUGF0aG5hbWVzSnNvbixcbiAgICAgIGxvY2F0aW9uUGF0aG5hbWUsXG4gICAgICBkYXRhUm91dGVyQ29udGV4dFxuICAgIF1cbiAgKTtcbiAgcmV0dXJuIG5hdmlnYXRlO1xufVxudmFyIE91dGxldENvbnRleHQgPSBSZWFjdDIuY3JlYXRlQ29udGV4dChudWxsKTtcbmZ1bmN0aW9uIHVzZU91dGxldENvbnRleHQoKSB7XG4gIHJldHVybiBSZWFjdDIudXNlQ29udGV4dChPdXRsZXRDb250ZXh0KTtcbn1cbmZ1bmN0aW9uIHVzZU91dGxldChjb250ZXh0KSB7XG4gIGxldCBvdXRsZXQgPSBSZWFjdDIudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpLm91dGxldDtcbiAgaWYgKG91dGxldCkge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoT3V0bGV0Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dCB9LCBvdXRsZXQpO1xuICB9XG4gIHJldHVybiBvdXRsZXQ7XG59XG5mdW5jdGlvbiB1c2VQYXJhbXMoKSB7XG4gIGxldCB7IG1hdGNoZXMgfSA9IFJlYWN0Mi51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCByb3V0ZU1hdGNoID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGFyYW1zIDoge307XG59XG5mdW5jdGlvbiB1c2VSZXNvbHZlZFBhdGgodG8sIHsgcmVsYXRpdmUgfSA9IHt9KSB7XG4gIGxldCB7IG1hdGNoZXMgfSA9IFJlYWN0Mi51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCB7IHBhdGhuYW1lOiBsb2NhdGlvblBhdGhuYW1lIH0gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgcm91dGVQYXRobmFtZXNKc29uID0gSlNPTi5zdHJpbmdpZnkoZ2V0UmVzb2x2ZVRvTWF0Y2hlcyhtYXRjaGVzKSk7XG4gIHJldHVybiBSZWFjdDIudXNlTWVtbyhcbiAgICAoKSA9PiByZXNvbHZlVG8oXG4gICAgICB0byxcbiAgICAgIEpTT04ucGFyc2Uocm91dGVQYXRobmFtZXNKc29uKSxcbiAgICAgIGxvY2F0aW9uUGF0aG5hbWUsXG4gICAgICByZWxhdGl2ZSA9PT0gXCJwYXRoXCJcbiAgICApLFxuICAgIFt0bywgcm91dGVQYXRobmFtZXNKc29uLCBsb2NhdGlvblBhdGhuYW1lLCByZWxhdGl2ZV1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZVJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uQXJnKSB7XG4gIHJldHVybiB1c2VSb3V0ZXNJbXBsKHJvdXRlcywgbG9jYXRpb25BcmcpO1xufVxuZnVuY3Rpb24gdXNlUm91dGVzSW1wbChyb3V0ZXMsIGxvY2F0aW9uQXJnLCBkYXRhUm91dGVyU3RhdGUsIGZ1dHVyZSkge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VSb3V0ZXMoKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcbiAgbGV0IHsgbmF2aWdhdG9yIH0gPSBSZWFjdDIudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCB7IG1hdGNoZXM6IHBhcmVudE1hdGNoZXMgfSA9IFJlYWN0Mi51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCByb3V0ZU1hdGNoID0gcGFyZW50TWF0Y2hlc1twYXJlbnRNYXRjaGVzLmxlbmd0aCAtIDFdO1xuICBsZXQgcGFyZW50UGFyYW1zID0gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGFyYW1zIDoge307XG4gIGxldCBwYXJlbnRQYXRobmFtZSA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhdGhuYW1lIDogXCIvXCI7XG4gIGxldCBwYXJlbnRQYXRobmFtZUJhc2UgPSByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXRobmFtZUJhc2UgOiBcIi9cIjtcbiAgbGV0IHBhcmVudFJvdXRlID0gcm91dGVNYXRjaCAmJiByb3V0ZU1hdGNoLnJvdXRlO1xuICBpZiAoRU5BQkxFX0RFVl9XQVJOSU5HUykge1xuICAgIGxldCBwYXJlbnRQYXRoID0gcGFyZW50Um91dGUgJiYgcGFyZW50Um91dGUucGF0aCB8fCBcIlwiO1xuICAgIHdhcm5pbmdPbmNlKFxuICAgICAgcGFyZW50UGF0aG5hbWUsXG4gICAgICAhcGFyZW50Um91dGUgfHwgcGFyZW50UGF0aC5lbmRzV2l0aChcIipcIikgfHwgcGFyZW50UGF0aC5lbmRzV2l0aChcIio/XCIpLFxuICAgICAgYFlvdSByZW5kZXJlZCBkZXNjZW5kYW50IDxSb3V0ZXM+IChvciBjYWxsZWQgXFxgdXNlUm91dGVzKClcXGApIGF0IFwiJHtwYXJlbnRQYXRobmFtZX1cIiAodW5kZXIgPFJvdXRlIHBhdGg9XCIke3BhcmVudFBhdGh9XCI+KSBidXQgdGhlIHBhcmVudCByb3V0ZSBwYXRoIGhhcyBubyB0cmFpbGluZyBcIipcIi4gVGhpcyBtZWFucyBpZiB5b3UgbmF2aWdhdGUgZGVlcGVyLCB0aGUgcGFyZW50IHdvbid0IG1hdGNoIGFueW1vcmUgYW5kIHRoZXJlZm9yZSB0aGUgY2hpbGQgcm91dGVzIHdpbGwgbmV2ZXIgcmVuZGVyLlxuXG5QbGVhc2UgY2hhbmdlIHRoZSBwYXJlbnQgPFJvdXRlIHBhdGg9XCIke3BhcmVudFBhdGh9XCI+IHRvIDxSb3V0ZSBwYXRoPVwiJHtwYXJlbnRQYXRoID09PSBcIi9cIiA/IFwiKlwiIDogYCR7cGFyZW50UGF0aH0vKmB9XCI+LmBcbiAgICApO1xuICB9XG4gIGxldCBsb2NhdGlvbkZyb21Db250ZXh0ID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IGxvY2F0aW9uO1xuICBpZiAobG9jYXRpb25BcmcpIHtcbiAgICBsZXQgcGFyc2VkTG9jYXRpb25BcmcgPSB0eXBlb2YgbG9jYXRpb25BcmcgPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgobG9jYXRpb25BcmcpIDogbG9jYXRpb25Bcmc7XG4gICAgaW52YXJpYW50KFxuICAgICAgcGFyZW50UGF0aG5hbWVCYXNlID09PSBcIi9cIiB8fCBwYXJzZWRMb2NhdGlvbkFyZy5wYXRobmFtZT8uc3RhcnRzV2l0aChwYXJlbnRQYXRobmFtZUJhc2UpLFxuICAgICAgYFdoZW4gb3ZlcnJpZGluZyB0aGUgbG9jYXRpb24gdXNpbmcgXFxgPFJvdXRlcyBsb2NhdGlvbj5cXGAgb3IgXFxgdXNlUm91dGVzKHJvdXRlcywgbG9jYXRpb24pXFxgLCB0aGUgbG9jYXRpb24gcGF0aG5hbWUgbXVzdCBiZWdpbiB3aXRoIHRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgbWF0Y2hlZCBieSBhbGwgcGFyZW50IHJvdXRlcy4gVGhlIGN1cnJlbnQgcGF0aG5hbWUgYmFzZSBpcyBcIiR7cGFyZW50UGF0aG5hbWVCYXNlfVwiIGJ1dCBwYXRobmFtZSBcIiR7cGFyc2VkTG9jYXRpb25BcmcucGF0aG5hbWV9XCIgd2FzIGdpdmVuIGluIHRoZSBcXGBsb2NhdGlvblxcYCBwcm9wLmBcbiAgICApO1xuICAgIGxvY2F0aW9uID0gcGFyc2VkTG9jYXRpb25Bcmc7XG4gIH0gZWxzZSB7XG4gICAgbG9jYXRpb24gPSBsb2NhdGlvbkZyb21Db250ZXh0O1xuICB9XG4gIGxldCBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lIHx8IFwiL1wiO1xuICBsZXQgcmVtYWluaW5nUGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgaWYgKHBhcmVudFBhdGhuYW1lQmFzZSAhPT0gXCIvXCIpIHtcbiAgICBsZXQgcGFyZW50U2VnbWVudHMgPSBwYXJlbnRQYXRobmFtZUJhc2UucmVwbGFjZSgvXlxcLy8sIFwiXCIpLnNwbGl0KFwiL1wiKTtcbiAgICBsZXQgc2VnbWVudHMgPSBwYXRobmFtZS5yZXBsYWNlKC9eXFwvLywgXCJcIikuc3BsaXQoXCIvXCIpO1xuICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gXCIvXCIgKyBzZWdtZW50cy5zbGljZShwYXJlbnRTZWdtZW50cy5sZW5ndGgpLmpvaW4oXCIvXCIpO1xuICB9XG4gIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzLCB7IHBhdGhuYW1lOiByZW1haW5pbmdQYXRobmFtZSB9KTtcbiAgaWYgKEVOQUJMRV9ERVZfV0FSTklOR1MpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgcGFyZW50Um91dGUgfHwgbWF0Y2hlcyAhPSBudWxsLFxuICAgICAgYE5vIHJvdXRlcyBtYXRjaGVkIGxvY2F0aW9uIFwiJHtsb2NhdGlvbi5wYXRobmFtZX0ke2xvY2F0aW9uLnNlYXJjaH0ke2xvY2F0aW9uLmhhc2h9XCIgYFxuICAgICk7XG4gICAgd2FybmluZyhcbiAgICAgIG1hdGNoZXMgPT0gbnVsbCB8fCBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuZWxlbWVudCAhPT0gdm9pZCAwIHx8IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5yb3V0ZS5Db21wb25lbnQgIT09IHZvaWQgMCB8fCBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUubGF6eSAhPT0gdm9pZCAwLFxuICAgICAgYE1hdGNoZWQgbGVhZiByb3V0ZSBhdCBsb2NhdGlvbiBcIiR7bG9jYXRpb24ucGF0aG5hbWV9JHtsb2NhdGlvbi5zZWFyY2h9JHtsb2NhdGlvbi5oYXNofVwiIGRvZXMgbm90IGhhdmUgYW4gZWxlbWVudCBvciBDb21wb25lbnQuIFRoaXMgbWVhbnMgaXQgd2lsbCByZW5kZXIgYW4gPE91dGxldCAvPiB3aXRoIGEgbnVsbCB2YWx1ZSBieSBkZWZhdWx0IHJlc3VsdGluZyBpbiBhbiBcImVtcHR5XCIgcGFnZS5gXG4gICAgKTtcbiAgfVxuICBsZXQgcmVuZGVyZWRNYXRjaGVzID0gX3JlbmRlck1hdGNoZXMoXG4gICAgbWF0Y2hlcyAmJiBtYXRjaGVzLm1hcChcbiAgICAgIChtYXRjaCkgPT4gT2JqZWN0LmFzc2lnbih7fSwgbWF0Y2gsIHtcbiAgICAgICAgcGFyYW1zOiBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnRQYXJhbXMsIG1hdGNoLnBhcmFtcyksXG4gICAgICAgIHBhdGhuYW1lOiBqb2luUGF0aHMoW1xuICAgICAgICAgIHBhcmVudFBhdGhuYW1lQmFzZSxcbiAgICAgICAgICAvLyBSZS1lbmNvZGUgcGF0aG5hbWVzIHRoYXQgd2VyZSBkZWNvZGVkIGluc2lkZSBtYXRjaFJvdXRlc1xuICAgICAgICAgIG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbiA/IG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbihtYXRjaC5wYXRobmFtZSkucGF0aG5hbWUgOiBtYXRjaC5wYXRobmFtZVxuICAgICAgICBdKSxcbiAgICAgICAgcGF0aG5hbWVCYXNlOiBtYXRjaC5wYXRobmFtZUJhc2UgPT09IFwiL1wiID8gcGFyZW50UGF0aG5hbWVCYXNlIDogam9pblBhdGhzKFtcbiAgICAgICAgICBwYXJlbnRQYXRobmFtZUJhc2UsXG4gICAgICAgICAgLy8gUmUtZW5jb2RlIHBhdGhuYW1lcyB0aGF0IHdlcmUgZGVjb2RlZCBpbnNpZGUgbWF0Y2hSb3V0ZXNcbiAgICAgICAgICBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24gPyBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24obWF0Y2gucGF0aG5hbWVCYXNlKS5wYXRobmFtZSA6IG1hdGNoLnBhdGhuYW1lQmFzZVxuICAgICAgICBdKVxuICAgICAgfSlcbiAgICApLFxuICAgIHBhcmVudE1hdGNoZXMsXG4gICAgZGF0YVJvdXRlclN0YXRlLFxuICAgIGZ1dHVyZVxuICApO1xuICBpZiAobG9jYXRpb25BcmcgJiYgcmVuZGVyZWRNYXRjaGVzKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcbiAgICAgIExvY2F0aW9uQ29udGV4dC5Qcm92aWRlcixcbiAgICAgIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBsb2NhdGlvbjoge1xuICAgICAgICAgICAgcGF0aG5hbWU6IFwiL1wiLFxuICAgICAgICAgICAgc2VhcmNoOiBcIlwiLFxuICAgICAgICAgICAgaGFzaDogXCJcIixcbiAgICAgICAgICAgIHN0YXRlOiBudWxsLFxuICAgICAgICAgICAga2V5OiBcImRlZmF1bHRcIixcbiAgICAgICAgICAgIC4uLmxvY2F0aW9uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBuYXZpZ2F0aW9uVHlwZTogXCJQT1BcIiAvKiBQb3AgKi9cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlbmRlcmVkTWF0Y2hlc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlbmRlcmVkTWF0Y2hlcztcbn1cbmZ1bmN0aW9uIERlZmF1bHRFcnJvckNvbXBvbmVudCgpIHtcbiAgbGV0IGVycm9yID0gdXNlUm91dGVFcnJvcigpO1xuICBsZXQgbWVzc2FnZSA9IGlzUm91dGVFcnJvclJlc3BvbnNlKGVycm9yKSA/IGAke2Vycm9yLnN0YXR1c30gJHtlcnJvci5zdGF0dXNUZXh0fWAgOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbiAgbGV0IHN0YWNrID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLnN0YWNrIDogbnVsbDtcbiAgbGV0IGxpZ2h0Z3JleSA9IFwicmdiYSgyMDAsMjAwLDIwMCwgMC41KVwiO1xuICBsZXQgcHJlU3R5bGVzID0geyBwYWRkaW5nOiBcIjAuNXJlbVwiLCBiYWNrZ3JvdW5kQ29sb3I6IGxpZ2h0Z3JleSB9O1xuICBsZXQgY29kZVN0eWxlcyA9IHsgcGFkZGluZzogXCIycHggNHB4XCIsIGJhY2tncm91bmRDb2xvcjogbGlnaHRncmV5IH07XG4gIGxldCBkZXZJbmZvID0gbnVsbDtcbiAgaWYgKEVOQUJMRV9ERVZfV0FSTklOR1MpIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgXCJFcnJvciBoYW5kbGVkIGJ5IFJlYWN0IFJvdXRlciBkZWZhdWx0IEVycm9yQm91bmRhcnk6XCIsXG4gICAgICBlcnJvclxuICAgICk7XG4gICAgZGV2SW5mbyA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChSZWFjdDIuRnJhZ21lbnQsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcInBcIiwgbnVsbCwgXCJcXHV7MUY0QkZ9IEhleSBkZXZlbG9wZXIgXFx1ezFGNDRCfVwiKSwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFwicFwiLCBudWxsLCBcIllvdSBjYW4gcHJvdmlkZSBhIHdheSBiZXR0ZXIgVVggdGhhbiB0aGlzIHdoZW4geW91ciBhcHAgdGhyb3dzIGVycm9ycyBieSBwcm92aWRpbmcgeW91ciBvd24gXCIsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcImNvZGVcIiwgeyBzdHlsZTogY29kZVN0eWxlcyB9LCBcIkVycm9yQm91bmRhcnlcIiksIFwiIG9yXCIsIFwiIFwiLCAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXCJjb2RlXCIsIHsgc3R5bGU6IGNvZGVTdHlsZXMgfSwgXCJlcnJvckVsZW1lbnRcIiksIFwiIHByb3Agb24geW91ciByb3V0ZS5cIikpO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoUmVhY3QyLkZyYWdtZW50LCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXCJoMlwiLCBudWxsLCBcIlVuZXhwZWN0ZWQgQXBwbGljYXRpb24gRXJyb3IhXCIpLCAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXCJoM1wiLCB7IHN0eWxlOiB7IGZvbnRTdHlsZTogXCJpdGFsaWNcIiB9IH0sIG1lc3NhZ2UpLCBzdGFjayA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcInByZVwiLCB7IHN0eWxlOiBwcmVTdHlsZXMgfSwgc3RhY2spIDogbnVsbCwgZGV2SW5mbyk7XG59XG52YXIgZGVmYXVsdEVycm9yRWxlbWVudCA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChEZWZhdWx0RXJyb3JDb21wb25lbnQsIG51bGwpO1xudmFyIFJlbmRlckVycm9yQm91bmRhcnkgPSBjbGFzcyBleHRlbmRzIFJlYWN0Mi5Db21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgbG9jYXRpb246IHByb3BzLmxvY2F0aW9uLFxuICAgICAgcmV2YWxpZGF0aW9uOiBwcm9wcy5yZXZhbGlkYXRpb24sXG4gICAgICBlcnJvcjogcHJvcHMuZXJyb3JcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4geyBlcnJvciB9O1xuICB9XG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMocHJvcHMsIHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmxvY2F0aW9uICE9PSBwcm9wcy5sb2NhdGlvbiB8fCBzdGF0ZS5yZXZhbGlkYXRpb24gIT09IFwiaWRsZVwiICYmIHByb3BzLnJldmFsaWRhdGlvbiA9PT0gXCJpZGxlXCIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiBwcm9wcy5lcnJvcixcbiAgICAgICAgbG9jYXRpb246IHByb3BzLmxvY2F0aW9uLFxuICAgICAgICByZXZhbGlkYXRpb246IHByb3BzLnJldmFsaWRhdGlvblxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yOiBwcm9wcy5lcnJvciAhPT0gdm9pZCAwID8gcHJvcHMuZXJyb3IgOiBzdGF0ZS5lcnJvcixcbiAgICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIHJldmFsaWRhdGlvbjogcHJvcHMucmV2YWxpZGF0aW9uIHx8IHN0YXRlLnJldmFsaWRhdGlvblxuICAgIH07XG4gIH1cbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIGVycm9ySW5mbykge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBcIlJlYWN0IFJvdXRlciBjYXVnaHQgdGhlIGZvbGxvd2luZyBlcnJvciBkdXJpbmcgcmVuZGVyXCIsXG4gICAgICBlcnJvcixcbiAgICAgIGVycm9ySW5mb1xuICAgICk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmVycm9yICE9PSB2b2lkIDAgPyAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoUm91dGVDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB0aGlzLnByb3BzLnJvdXRlQ29udGV4dCB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBSb3V0ZUVycm9yQ29udGV4dC5Qcm92aWRlcixcbiAgICAgIHtcbiAgICAgICAgdmFsdWU6IHRoaXMuc3RhdGUuZXJyb3IsXG4gICAgICAgIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNvbXBvbmVudFxuICAgICAgfVxuICAgICkpIDogdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgfVxufTtcbmZ1bmN0aW9uIFJlbmRlcmVkUm91dGUoeyByb3V0ZUNvbnRleHQsIG1hdGNoLCBjaGlsZHJlbiB9KSB7XG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IFJlYWN0Mi51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcbiAgaWYgKGRhdGFSb3V0ZXJDb250ZXh0ICYmIGRhdGFSb3V0ZXJDb250ZXh0LnN0YXRpYyAmJiBkYXRhUm91dGVyQ29udGV4dC5zdGF0aWNDb250ZXh0ICYmIChtYXRjaC5yb3V0ZS5lcnJvckVsZW1lbnQgfHwgbWF0Y2gucm91dGUuRXJyb3JCb3VuZGFyeSkpIHtcbiAgICBkYXRhUm91dGVyQ29udGV4dC5zdGF0aWNDb250ZXh0Ll9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkID0gbWF0Y2gucm91dGUuaWQ7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChSb3V0ZUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHJvdXRlQ29udGV4dCB9LCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBfcmVuZGVyTWF0Y2hlcyhtYXRjaGVzLCBwYXJlbnRNYXRjaGVzID0gW10sIGRhdGFSb3V0ZXJTdGF0ZSA9IG51bGwsIGZ1dHVyZSA9IG51bGwpIHtcbiAgaWYgKG1hdGNoZXMgPT0gbnVsbCkge1xuICAgIGlmICghZGF0YVJvdXRlclN0YXRlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGRhdGFSb3V0ZXJTdGF0ZS5lcnJvcnMpIHtcbiAgICAgIG1hdGNoZXMgPSBkYXRhUm91dGVyU3RhdGUubWF0Y2hlcztcbiAgICB9IGVsc2UgaWYgKHBhcmVudE1hdGNoZXMubGVuZ3RoID09PSAwICYmICFkYXRhUm91dGVyU3RhdGUuaW5pdGlhbGl6ZWQgJiYgZGF0YVJvdXRlclN0YXRlLm1hdGNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgbWF0Y2hlcyA9IGRhdGFSb3V0ZXJTdGF0ZS5tYXRjaGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgbGV0IHJlbmRlcmVkTWF0Y2hlcyA9IG1hdGNoZXM7XG4gIGxldCBlcnJvcnMgPSBkYXRhUm91dGVyU3RhdGU/LmVycm9ycztcbiAgaWYgKGVycm9ycyAhPSBudWxsKSB7XG4gICAgbGV0IGVycm9ySW5kZXggPSByZW5kZXJlZE1hdGNoZXMuZmluZEluZGV4KFxuICAgICAgKG0pID0+IG0ucm91dGUuaWQgJiYgZXJyb3JzPy5bbS5yb3V0ZS5pZF0gIT09IHZvaWQgMFxuICAgICk7XG4gICAgaW52YXJpYW50KFxuICAgICAgZXJyb3JJbmRleCA+PSAwLFxuICAgICAgYENvdWxkIG5vdCBmaW5kIGEgbWF0Y2hpbmcgcm91dGUgZm9yIGVycm9ycyBvbiByb3V0ZSBJRHM6ICR7T2JqZWN0LmtleXMoXG4gICAgICAgIGVycm9yc1xuICAgICAgKS5qb2luKFwiLFwiKX1gXG4gICAgKTtcbiAgICByZW5kZXJlZE1hdGNoZXMgPSByZW5kZXJlZE1hdGNoZXMuc2xpY2UoXG4gICAgICAwLFxuICAgICAgTWF0aC5taW4ocmVuZGVyZWRNYXRjaGVzLmxlbmd0aCwgZXJyb3JJbmRleCArIDEpXG4gICAgKTtcbiAgfVxuICBsZXQgcmVuZGVyRmFsbGJhY2sgPSBmYWxzZTtcbiAgbGV0IGZhbGxiYWNrSW5kZXggPSAtMTtcbiAgaWYgKGRhdGFSb3V0ZXJTdGF0ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVuZGVyZWRNYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgbWF0Y2ggPSByZW5kZXJlZE1hdGNoZXNbaV07XG4gICAgICBpZiAobWF0Y2gucm91dGUuSHlkcmF0ZUZhbGxiYWNrIHx8IG1hdGNoLnJvdXRlLmh5ZHJhdGVGYWxsYmFja0VsZW1lbnQpIHtcbiAgICAgICAgZmFsbGJhY2tJbmRleCA9IGk7XG4gICAgICB9XG4gICAgICBpZiAobWF0Y2gucm91dGUuaWQpIHtcbiAgICAgICAgbGV0IHsgbG9hZGVyRGF0YSwgZXJyb3JzOiBlcnJvcnMyIH0gPSBkYXRhUm91dGVyU3RhdGU7XG4gICAgICAgIGxldCBuZWVkc1RvUnVuTG9hZGVyID0gbWF0Y2gucm91dGUubG9hZGVyICYmICFsb2FkZXJEYXRhLmhhc093blByb3BlcnR5KG1hdGNoLnJvdXRlLmlkKSAmJiAoIWVycm9yczIgfHwgZXJyb3JzMlttYXRjaC5yb3V0ZS5pZF0gPT09IHZvaWQgMCk7XG4gICAgICAgIGlmIChtYXRjaC5yb3V0ZS5sYXp5IHx8IG5lZWRzVG9SdW5Mb2FkZXIpIHtcbiAgICAgICAgICByZW5kZXJGYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgaWYgKGZhbGxiYWNrSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgcmVuZGVyZWRNYXRjaGVzID0gcmVuZGVyZWRNYXRjaGVzLnNsaWNlKDAsIGZhbGxiYWNrSW5kZXggKyAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVuZGVyZWRNYXRjaGVzID0gW3JlbmRlcmVkTWF0Y2hlc1swXV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZW5kZXJlZE1hdGNoZXMucmVkdWNlUmlnaHQoKG91dGxldCwgbWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgbGV0IGVycm9yO1xuICAgIGxldCBzaG91bGRSZW5kZXJIeWRyYXRlRmFsbGJhY2sgPSBmYWxzZTtcbiAgICBsZXQgZXJyb3JFbGVtZW50ID0gbnVsbDtcbiAgICBsZXQgaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCA9IG51bGw7XG4gICAgaWYgKGRhdGFSb3V0ZXJTdGF0ZSkge1xuICAgICAgZXJyb3IgPSBlcnJvcnMgJiYgbWF0Y2gucm91dGUuaWQgPyBlcnJvcnNbbWF0Y2gucm91dGUuaWRdIDogdm9pZCAwO1xuICAgICAgZXJyb3JFbGVtZW50ID0gbWF0Y2gucm91dGUuZXJyb3JFbGVtZW50IHx8IGRlZmF1bHRFcnJvckVsZW1lbnQ7XG4gICAgICBpZiAocmVuZGVyRmFsbGJhY2spIHtcbiAgICAgICAgaWYgKGZhbGxiYWNrSW5kZXggPCAwICYmIGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgd2FybmluZ09uY2UoXG4gICAgICAgICAgICBcInJvdXRlLWZhbGxiYWNrXCIsXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIFwiTm8gYEh5ZHJhdGVGYWxsYmFja2AgZWxlbWVudCBwcm92aWRlZCB0byByZW5kZXIgZHVyaW5nIGluaXRpYWwgaHlkcmF0aW9uXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIHNob3VsZFJlbmRlckh5ZHJhdGVGYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoZmFsbGJhY2tJbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgICAgICBzaG91bGRSZW5kZXJIeWRyYXRlRmFsbGJhY2sgPSB0cnVlO1xuICAgICAgICAgIGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQgPSBtYXRjaC5yb3V0ZS5oeWRyYXRlRmFsbGJhY2tFbGVtZW50IHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IG1hdGNoZXMyID0gcGFyZW50TWF0Y2hlcy5jb25jYXQocmVuZGVyZWRNYXRjaGVzLnNsaWNlKDAsIGluZGV4ICsgMSkpO1xuICAgIGxldCBnZXRDaGlsZHJlbiA9ICgpID0+IHtcbiAgICAgIGxldCBjaGlsZHJlbjtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjaGlsZHJlbiA9IGVycm9yRWxlbWVudDtcbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkUmVuZGVySHlkcmF0ZUZhbGxiYWNrKSB7XG4gICAgICAgIGNoaWxkcmVuID0gaHlkcmF0ZUZhbGxiYWNrRWxlbWVudDtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2gucm91dGUuQ29tcG9uZW50KSB7XG4gICAgICAgIGNoaWxkcmVuID0gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KG1hdGNoLnJvdXRlLkNvbXBvbmVudCwgbnVsbCk7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoLnJvdXRlLmVsZW1lbnQpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBtYXRjaC5yb3V0ZS5lbGVtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGRyZW4gPSBvdXRsZXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFxuICAgICAgICBSZW5kZXJlZFJvdXRlLFxuICAgICAgICB7XG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgcm91dGVDb250ZXh0OiB7XG4gICAgICAgICAgICBvdXRsZXQsXG4gICAgICAgICAgICBtYXRjaGVzOiBtYXRjaGVzMixcbiAgICAgICAgICAgIGlzRGF0YVJvdXRlOiBkYXRhUm91dGVyU3RhdGUgIT0gbnVsbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9O1xuICAgIHJldHVybiBkYXRhUm91dGVyU3RhdGUgJiYgKG1hdGNoLnJvdXRlLkVycm9yQm91bmRhcnkgfHwgbWF0Y2gucm91dGUuZXJyb3JFbGVtZW50IHx8IGluZGV4ID09PSAwKSA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcbiAgICAgIFJlbmRlckVycm9yQm91bmRhcnksXG4gICAgICB7XG4gICAgICAgIGxvY2F0aW9uOiBkYXRhUm91dGVyU3RhdGUubG9jYXRpb24sXG4gICAgICAgIHJldmFsaWRhdGlvbjogZGF0YVJvdXRlclN0YXRlLnJldmFsaWRhdGlvbixcbiAgICAgICAgY29tcG9uZW50OiBlcnJvckVsZW1lbnQsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBjaGlsZHJlbjogZ2V0Q2hpbGRyZW4oKSxcbiAgICAgICAgcm91dGVDb250ZXh0OiB7IG91dGxldDogbnVsbCwgbWF0Y2hlczogbWF0Y2hlczIsIGlzRGF0YVJvdXRlOiB0cnVlIH1cbiAgICAgIH1cbiAgICApIDogZ2V0Q2hpbGRyZW4oKTtcbiAgfSwgbnVsbCk7XG59XG5mdW5jdGlvbiBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSB7XG4gIHJldHVybiBgJHtob29rTmFtZX0gbXVzdCBiZSB1c2VkIHdpdGhpbiBhIGRhdGEgcm91dGVyLiAgU2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2VuL21haW4vcm91dGVycy9waWNraW5nLWEtcm91dGVyLmA7XG59XG5mdW5jdGlvbiB1c2VEYXRhUm91dGVyQ29udGV4dChob29rTmFtZSkge1xuICBsZXQgY3R4ID0gUmVhY3QyLnVzZUNvbnRleHQoRGF0YVJvdXRlckNvbnRleHQpO1xuICBpbnZhcmlhbnQoY3R4LCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSk7XG4gIHJldHVybiBjdHg7XG59XG5mdW5jdGlvbiB1c2VEYXRhUm91dGVyU3RhdGUoaG9va05hbWUpIHtcbiAgbGV0IHN0YXRlID0gUmVhY3QyLnVzZUNvbnRleHQoRGF0YVJvdXRlclN0YXRlQ29udGV4dCk7XG4gIGludmFyaWFudChzdGF0ZSwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkpO1xuICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiB1c2VSb3V0ZUNvbnRleHQoaG9va05hbWUpIHtcbiAgbGV0IHJvdXRlID0gUmVhY3QyLnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgaW52YXJpYW50KHJvdXRlLCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSk7XG4gIHJldHVybiByb3V0ZTtcbn1cbmZ1bmN0aW9uIHVzZUN1cnJlbnRSb3V0ZUlkKGhvb2tOYW1lKSB7XG4gIGxldCByb3V0ZSA9IHVzZVJvdXRlQ29udGV4dChob29rTmFtZSk7XG4gIGxldCB0aGlzUm91dGUgPSByb3V0ZS5tYXRjaGVzW3JvdXRlLm1hdGNoZXMubGVuZ3RoIC0gMV07XG4gIGludmFyaWFudChcbiAgICB0aGlzUm91dGUucm91dGUuaWQsXG4gICAgYCR7aG9va05hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gcm91dGVzIHRoYXQgY29udGFpbiBhIHVuaXF1ZSBcImlkXCJgXG4gICk7XG4gIHJldHVybiB0aGlzUm91dGUucm91dGUuaWQ7XG59XG5mdW5jdGlvbiB1c2VSb3V0ZUlkKCkge1xuICByZXR1cm4gdXNlQ3VycmVudFJvdXRlSWQoXCJ1c2VSb3V0ZUlkXCIgLyogVXNlUm91dGVJZCAqLyk7XG59XG5mdW5jdGlvbiB1c2VOYXZpZ2F0aW9uKCkge1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoXCJ1c2VOYXZpZ2F0aW9uXCIgLyogVXNlTmF2aWdhdGlvbiAqLyk7XG4gIHJldHVybiBzdGF0ZS5uYXZpZ2F0aW9uO1xufVxuZnVuY3Rpb24gdXNlUmV2YWxpZGF0b3IoKSB7XG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KFwidXNlUmV2YWxpZGF0b3JcIiAvKiBVc2VSZXZhbGlkYXRvciAqLyk7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShcInVzZVJldmFsaWRhdG9yXCIgLyogVXNlUmV2YWxpZGF0b3IgKi8pO1xuICBsZXQgcmV2YWxpZGF0ZSA9IFJlYWN0Mi51c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZGF0YVJvdXRlckNvbnRleHQucm91dGVyLnJldmFsaWRhdGUoKTtcbiAgfSwgW2RhdGFSb3V0ZXJDb250ZXh0LnJvdXRlcl0pO1xuICByZXR1cm4gUmVhY3QyLnVzZU1lbW8oXG4gICAgKCkgPT4gKHsgcmV2YWxpZGF0ZSwgc3RhdGU6IHN0YXRlLnJldmFsaWRhdGlvbiB9KSxcbiAgICBbcmV2YWxpZGF0ZSwgc3RhdGUucmV2YWxpZGF0aW9uXVxuICApO1xufVxuZnVuY3Rpb24gdXNlTWF0Y2hlcygpIHtcbiAgbGV0IHsgbWF0Y2hlcywgbG9hZGVyRGF0YSB9ID0gdXNlRGF0YVJvdXRlclN0YXRlKFxuICAgIFwidXNlTWF0Y2hlc1wiIC8qIFVzZU1hdGNoZXMgKi9cbiAgKTtcbiAgcmV0dXJuIFJlYWN0Mi51c2VNZW1vKFxuICAgICgpID0+IG1hdGNoZXMubWFwKChtKSA9PiBjb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaChtLCBsb2FkZXJEYXRhKSksXG4gICAgW21hdGNoZXMsIGxvYWRlckRhdGFdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VMb2FkZXJEYXRhKCkge1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoXCJ1c2VMb2FkZXJEYXRhXCIgLyogVXNlTG9hZGVyRGF0YSAqLyk7XG4gIGxldCByb3V0ZUlkID0gdXNlQ3VycmVudFJvdXRlSWQoXCJ1c2VMb2FkZXJEYXRhXCIgLyogVXNlTG9hZGVyRGF0YSAqLyk7XG4gIHJldHVybiBzdGF0ZS5sb2FkZXJEYXRhW3JvdXRlSWRdO1xufVxuZnVuY3Rpb24gdXNlUm91dGVMb2FkZXJEYXRhKHJvdXRlSWQpIHtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKFwidXNlUm91dGVMb2FkZXJEYXRhXCIgLyogVXNlUm91dGVMb2FkZXJEYXRhICovKTtcbiAgcmV0dXJuIHN0YXRlLmxvYWRlckRhdGFbcm91dGVJZF07XG59XG5mdW5jdGlvbiB1c2VBY3Rpb25EYXRhKCkge1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoXCJ1c2VBY3Rpb25EYXRhXCIgLyogVXNlQWN0aW9uRGF0YSAqLyk7XG4gIGxldCByb3V0ZUlkID0gdXNlQ3VycmVudFJvdXRlSWQoXCJ1c2VMb2FkZXJEYXRhXCIgLyogVXNlTG9hZGVyRGF0YSAqLyk7XG4gIHJldHVybiBzdGF0ZS5hY3Rpb25EYXRhID8gc3RhdGUuYWN0aW9uRGF0YVtyb3V0ZUlkXSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIHVzZVJvdXRlRXJyb3IoKSB7XG4gIGxldCBlcnJvciA9IFJlYWN0Mi51c2VDb250ZXh0KFJvdXRlRXJyb3JDb250ZXh0KTtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKFwidXNlUm91dGVFcnJvclwiIC8qIFVzZVJvdXRlRXJyb3IgKi8pO1xuICBsZXQgcm91dGVJZCA9IHVzZUN1cnJlbnRSb3V0ZUlkKFwidXNlUm91dGVFcnJvclwiIC8qIFVzZVJvdXRlRXJyb3IgKi8pO1xuICBpZiAoZXJyb3IgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICByZXR1cm4gc3RhdGUuZXJyb3JzPy5bcm91dGVJZF07XG59XG5mdW5jdGlvbiB1c2VBc3luY1ZhbHVlKCkge1xuICBsZXQgdmFsdWUgPSBSZWFjdDIudXNlQ29udGV4dChBd2FpdENvbnRleHQpO1xuICByZXR1cm4gdmFsdWU/Ll9kYXRhO1xufVxuZnVuY3Rpb24gdXNlQXN5bmNFcnJvcigpIHtcbiAgbGV0IHZhbHVlID0gUmVhY3QyLnVzZUNvbnRleHQoQXdhaXRDb250ZXh0KTtcbiAgcmV0dXJuIHZhbHVlPy5fZXJyb3I7XG59XG52YXIgYmxvY2tlcklkID0gMDtcbmZ1bmN0aW9uIHVzZUJsb2NrZXIoc2hvdWxkQmxvY2spIHtcbiAgbGV0IHsgcm91dGVyLCBiYXNlbmFtZSB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoXCJ1c2VCbG9ja2VyXCIgLyogVXNlQmxvY2tlciAqLyk7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShcInVzZUJsb2NrZXJcIiAvKiBVc2VCbG9ja2VyICovKTtcbiAgbGV0IFtibG9ja2VyS2V5LCBzZXRCbG9ja2VyS2V5XSA9IFJlYWN0Mi51c2VTdGF0ZShcIlwiKTtcbiAgbGV0IGJsb2NrZXJGdW5jdGlvbiA9IFJlYWN0Mi51c2VDYWxsYmFjayhcbiAgICAoYXJnKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHNob3VsZEJsb2NrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuICEhc2hvdWxkQmxvY2s7XG4gICAgICB9XG4gICAgICBpZiAoYmFzZW5hbWUgPT09IFwiL1wiKSB7XG4gICAgICAgIHJldHVybiBzaG91bGRCbG9jayhhcmcpO1xuICAgICAgfVxuICAgICAgbGV0IHsgY3VycmVudExvY2F0aW9uLCBuZXh0TG9jYXRpb24sIGhpc3RvcnlBY3Rpb24gfSA9IGFyZztcbiAgICAgIHJldHVybiBzaG91bGRCbG9jayh7XG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbjoge1xuICAgICAgICAgIC4uLmN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgICBwYXRobmFtZTogc3RyaXBCYXNlbmFtZShjdXJyZW50TG9jYXRpb24ucGF0aG5hbWUsIGJhc2VuYW1lKSB8fCBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWVcbiAgICAgICAgfSxcbiAgICAgICAgbmV4dExvY2F0aW9uOiB7XG4gICAgICAgICAgLi4ubmV4dExvY2F0aW9uLFxuICAgICAgICAgIHBhdGhuYW1lOiBzdHJpcEJhc2VuYW1lKG5leHRMb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IG5leHRMb2NhdGlvbi5wYXRobmFtZVxuICAgICAgICB9LFxuICAgICAgICBoaXN0b3J5QWN0aW9uXG4gICAgICB9KTtcbiAgICB9LFxuICAgIFtiYXNlbmFtZSwgc2hvdWxkQmxvY2tdXG4gICk7XG4gIFJlYWN0Mi51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBrZXkgPSBTdHJpbmcoKytibG9ja2VySWQpO1xuICAgIHNldEJsb2NrZXJLZXkoa2V5KTtcbiAgICByZXR1cm4gKCkgPT4gcm91dGVyLmRlbGV0ZUJsb2NrZXIoa2V5KTtcbiAgfSwgW3JvdXRlcl0pO1xuICBSZWFjdDIudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYmxvY2tlcktleSAhPT0gXCJcIikge1xuICAgICAgcm91dGVyLmdldEJsb2NrZXIoYmxvY2tlcktleSwgYmxvY2tlckZ1bmN0aW9uKTtcbiAgICB9XG4gIH0sIFtyb3V0ZXIsIGJsb2NrZXJLZXksIGJsb2NrZXJGdW5jdGlvbl0pO1xuICByZXR1cm4gYmxvY2tlcktleSAmJiBzdGF0ZS5ibG9ja2Vycy5oYXMoYmxvY2tlcktleSkgPyBzdGF0ZS5ibG9ja2Vycy5nZXQoYmxvY2tlcktleSkgOiBJRExFX0JMT0NLRVI7XG59XG5mdW5jdGlvbiB1c2VOYXZpZ2F0ZVN0YWJsZSgpIHtcbiAgbGV0IHsgcm91dGVyIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dChcInVzZU5hdmlnYXRlXCIgLyogVXNlTmF2aWdhdGVTdGFibGUgKi8pO1xuICBsZXQgaWQgPSB1c2VDdXJyZW50Um91dGVJZChcInVzZU5hdmlnYXRlXCIgLyogVXNlTmF2aWdhdGVTdGFibGUgKi8pO1xuICBsZXQgYWN0aXZlUmVmID0gUmVhY3QyLnVzZVJlZihmYWxzZSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGFjdGl2ZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgfSk7XG4gIGxldCBuYXZpZ2F0ZSA9IFJlYWN0Mi51c2VDYWxsYmFjayhcbiAgICBhc3luYyAodG8sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgd2FybmluZyhhY3RpdmVSZWYuY3VycmVudCwgbmF2aWdhdGVFZmZlY3RXYXJuaW5nKTtcbiAgICAgIGlmICghYWN0aXZlUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcm91dGVyLm5hdmlnYXRlKHRvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IHJvdXRlci5uYXZpZ2F0ZSh0bywgeyBmcm9tUm91dGVJZDogaWQsIC4uLm9wdGlvbnMgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbcm91dGVyLCBpZF1cbiAgKTtcbiAgcmV0dXJuIG5hdmlnYXRlO1xufVxudmFyIGFscmVhZHlXYXJuZWQgPSB7fTtcbmZ1bmN0aW9uIHdhcm5pbmdPbmNlKGtleSwgY29uZCwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmQgJiYgIWFscmVhZHlXYXJuZWRba2V5XSkge1xuICAgIGFscmVhZHlXYXJuZWRba2V5XSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgbWVzc2FnZSk7XG4gIH1cbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL3dhcm5pbmdzLnRzXG52YXIgYWxyZWFkeVdhcm5lZDIgPSB7fTtcbmZ1bmN0aW9uIHdhcm5PbmNlKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbiAmJiAhYWxyZWFkeVdhcm5lZDJbbWVzc2FnZV0pIHtcbiAgICBhbHJlYWR5V2FybmVkMlttZXNzYWdlXSA9IHRydWU7XG4gICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICB9XG59XG5cbi8vIGxpYi9jb21wb25lbnRzLnRzeFxuZnVuY3Rpb24gbWFwUm91dGVQcm9wZXJ0aWVzKHJvdXRlKSB7XG4gIGxldCB1cGRhdGVzID0ge1xuICAgIC8vIE5vdGU6IHRoaXMgY2hlY2sgYWxzbyBvY2N1cnMgaW4gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuIHNvIHVwZGF0ZVxuICAgIC8vIHRoZXJlIGlmIHlvdSBjaGFuZ2UgdGhpcyAtLSBwbGVhc2UgYW5kIHRoYW5rIHlvdSFcbiAgICBoYXNFcnJvckJvdW5kYXJ5OiByb3V0ZS5oYXNFcnJvckJvdW5kYXJ5IHx8IHJvdXRlLkVycm9yQm91bmRhcnkgIT0gbnVsbCB8fCByb3V0ZS5lcnJvckVsZW1lbnQgIT0gbnVsbFxuICB9O1xuICBpZiAocm91dGUuQ29tcG9uZW50KSB7XG4gICAgaWYgKEVOQUJMRV9ERVZfV0FSTklOR1MpIHtcbiAgICAgIGlmIChyb3V0ZS5lbGVtZW50KSB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJZb3Ugc2hvdWxkIG5vdCBpbmNsdWRlIGJvdGggYENvbXBvbmVudGAgYW5kIGBlbGVtZW50YCBvbiB5b3VyIHJvdXRlIC0gYENvbXBvbmVudGAgd2lsbCBiZSB1c2VkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24odXBkYXRlcywge1xuICAgICAgZWxlbWVudDogUmVhY3QzLmNyZWF0ZUVsZW1lbnQocm91dGUuQ29tcG9uZW50KSxcbiAgICAgIENvbXBvbmVudDogdm9pZCAwXG4gICAgfSk7XG4gIH1cbiAgaWYgKHJvdXRlLkh5ZHJhdGVGYWxsYmFjaykge1xuICAgIGlmIChFTkFCTEVfREVWX1dBUk5JTkdTKSB7XG4gICAgICBpZiAocm91dGUuaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCkge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiWW91IHNob3VsZCBub3QgaW5jbHVkZSBib3RoIGBIeWRyYXRlRmFsbGJhY2tgIGFuZCBgaHlkcmF0ZUZhbGxiYWNrRWxlbWVudGAgb24geW91ciByb3V0ZSAtIGBIeWRyYXRlRmFsbGJhY2tgIHdpbGwgYmUgdXNlZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHVwZGF0ZXMsIHtcbiAgICAgIGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQ6IFJlYWN0My5jcmVhdGVFbGVtZW50KHJvdXRlLkh5ZHJhdGVGYWxsYmFjayksXG4gICAgICBIeWRyYXRlRmFsbGJhY2s6IHZvaWQgMFxuICAgIH0pO1xuICB9XG4gIGlmIChyb3V0ZS5FcnJvckJvdW5kYXJ5KSB7XG4gICAgaWYgKEVOQUJMRV9ERVZfV0FSTklOR1MpIHtcbiAgICAgIGlmIChyb3V0ZS5lcnJvckVsZW1lbnQpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcIllvdSBzaG91bGQgbm90IGluY2x1ZGUgYm90aCBgRXJyb3JCb3VuZGFyeWAgYW5kIGBlcnJvckVsZW1lbnRgIG9uIHlvdXIgcm91dGUgLSBgRXJyb3JCb3VuZGFyeWAgd2lsbCBiZSB1c2VkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24odXBkYXRlcywge1xuICAgICAgZXJyb3JFbGVtZW50OiBSZWFjdDMuY3JlYXRlRWxlbWVudChyb3V0ZS5FcnJvckJvdW5kYXJ5KSxcbiAgICAgIEVycm9yQm91bmRhcnk6IHZvaWQgMFxuICAgIH0pO1xuICB9XG4gIHJldHVybiB1cGRhdGVzO1xufVxudmFyIGh5ZHJhdGlvblJvdXRlUHJvcGVydGllcyA9IFtcbiAgXCJIeWRyYXRlRmFsbGJhY2tcIixcbiAgXCJoeWRyYXRlRmFsbGJhY2tFbGVtZW50XCJcbl07XG5mdW5jdGlvbiBjcmVhdGVNZW1vcnlSb3V0ZXIocm91dGVzLCBvcHRzKSB7XG4gIHJldHVybiBjcmVhdGVSb3V0ZXIoe1xuICAgIGJhc2VuYW1lOiBvcHRzPy5iYXNlbmFtZSxcbiAgICB1bnN0YWJsZV9nZXRDb250ZXh0OiBvcHRzPy51bnN0YWJsZV9nZXRDb250ZXh0LFxuICAgIGZ1dHVyZTogb3B0cz8uZnV0dXJlLFxuICAgIGhpc3Rvcnk6IGNyZWF0ZU1lbW9yeUhpc3Rvcnkoe1xuICAgICAgaW5pdGlhbEVudHJpZXM6IG9wdHM/LmluaXRpYWxFbnRyaWVzLFxuICAgICAgaW5pdGlhbEluZGV4OiBvcHRzPy5pbml0aWFsSW5kZXhcbiAgICB9KSxcbiAgICBoeWRyYXRpb25EYXRhOiBvcHRzPy5oeWRyYXRpb25EYXRhLFxuICAgIHJvdXRlcyxcbiAgICBoeWRyYXRpb25Sb3V0ZVByb3BlcnRpZXMsXG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzLFxuICAgIGRhdGFTdHJhdGVneTogb3B0cz8uZGF0YVN0cmF0ZWd5LFxuICAgIHBhdGNoUm91dGVzT25OYXZpZ2F0aW9uOiBvcHRzPy5wYXRjaFJvdXRlc09uTmF2aWdhdGlvblxuICB9KS5pbml0aWFsaXplKCk7XG59XG52YXIgRGVmZXJyZWQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5yZXNvbHZlID0gKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgICB0aGlzLnN0YXR1cyA9IFwicmVzb2x2ZWRcIjtcbiAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMucmVqZWN0ID0gKHJlYXNvbikgPT4ge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgdGhpcy5zdGF0dXMgPSBcInJlamVjdGVkXCI7XG4gICAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBSb3V0ZXJQcm92aWRlcih7XG4gIHJvdXRlcixcbiAgZmx1c2hTeW5jOiByZWFjdERvbUZsdXNoU3luY0ltcGxcbn0pIHtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0My51c2VTdGF0ZShyb3V0ZXIuc3RhdGUpO1xuICBsZXQgW3BlbmRpbmdTdGF0ZSwgc2V0UGVuZGluZ1N0YXRlXSA9IFJlYWN0My51c2VTdGF0ZSgpO1xuICBsZXQgW3Z0Q29udGV4dCwgc2V0VnRDb250ZXh0XSA9IFJlYWN0My51c2VTdGF0ZSh7XG4gICAgaXNUcmFuc2l0aW9uaW5nOiBmYWxzZVxuICB9KTtcbiAgbGV0IFtyZW5kZXJEZmQsIHNldFJlbmRlckRmZF0gPSBSZWFjdDMudXNlU3RhdGUoKTtcbiAgbGV0IFt0cmFuc2l0aW9uLCBzZXRUcmFuc2l0aW9uXSA9IFJlYWN0My51c2VTdGF0ZSgpO1xuICBsZXQgW2ludGVycnVwdGlvbiwgc2V0SW50ZXJydXB0aW9uXSA9IFJlYWN0My51c2VTdGF0ZSgpO1xuICBsZXQgZmV0Y2hlckRhdGEgPSBSZWFjdDMudXNlUmVmKC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICBsZXQgc2V0U3RhdGUgPSBSZWFjdDMudXNlQ2FsbGJhY2soXG4gICAgKG5ld1N0YXRlLCB7IGRlbGV0ZWRGZXRjaGVycywgZmx1c2hTeW5jLCB2aWV3VHJhbnNpdGlvbk9wdHMgfSkgPT4ge1xuICAgICAgbmV3U3RhdGUuZmV0Y2hlcnMuZm9yRWFjaCgoZmV0Y2hlciwga2V5KSA9PiB7XG4gICAgICAgIGlmIChmZXRjaGVyLmRhdGEgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGZldGNoZXJEYXRhLmN1cnJlbnQuc2V0KGtleSwgZmV0Y2hlci5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBkZWxldGVkRmV0Y2hlcnMuZm9yRWFjaCgoa2V5KSA9PiBmZXRjaGVyRGF0YS5jdXJyZW50LmRlbGV0ZShrZXkpKTtcbiAgICAgIHdhcm5PbmNlKFxuICAgICAgICBmbHVzaFN5bmMgPT09IGZhbHNlIHx8IHJlYWN0RG9tRmx1c2hTeW5jSW1wbCAhPSBudWxsLFxuICAgICAgICAnWW91IHByb3ZpZGVkIHRoZSBgZmx1c2hTeW5jYCBvcHRpb24gdG8gYSByb3V0ZXIgdXBkYXRlLCBidXQgeW91IGFyZSBub3QgdXNpbmcgdGhlIGA8Um91dGVyUHJvdmlkZXI+YCBmcm9tIGByZWFjdC1yb3V0ZXIvZG9tYCBzbyBgUmVhY3RET00uZmx1c2hTeW5jKClgIGlzIHVuYXZhaWxhYmxlLiAgUGxlYXNlIHVwZGF0ZSB5b3VyIGFwcCB0byBgaW1wb3J0IHsgUm91dGVyUHJvdmlkZXIgfSBmcm9tIFwicmVhY3Qtcm91dGVyL2RvbVwiYCBhbmQgZW5zdXJlIHlvdSBoYXZlIGByZWFjdC1kb21gIGluc3RhbGxlZCBhcyBhIGRlcGVuZGVuY3kgdG8gdXNlIHRoZSBgZmx1c2hTeW5jYCBvcHRpb24uJ1xuICAgICAgKTtcbiAgICAgIGxldCBpc1ZpZXdUcmFuc2l0aW9uQXZhaWxhYmxlID0gcm91dGVyLndpbmRvdyAhPSBudWxsICYmIHJvdXRlci53aW5kb3cuZG9jdW1lbnQgIT0gbnVsbCAmJiB0eXBlb2Ygcm91dGVyLndpbmRvdy5kb2N1bWVudC5zdGFydFZpZXdUcmFuc2l0aW9uID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICB3YXJuT25jZShcbiAgICAgICAgdmlld1RyYW5zaXRpb25PcHRzID09IG51bGwgfHwgaXNWaWV3VHJhbnNpdGlvbkF2YWlsYWJsZSxcbiAgICAgICAgXCJZb3UgcHJvdmlkZWQgdGhlIGB2aWV3VHJhbnNpdGlvbmAgb3B0aW9uIHRvIGEgcm91dGVyIHVwZGF0ZSwgYnV0IHlvdSBkbyBub3QgYXBwZWFyIHRvIGJlIHJ1bm5pbmcgaW4gYSBET00gZW52aXJvbm1lbnQgYXMgYHdpbmRvdy5zdGFydFZpZXdUcmFuc2l0aW9uYCBpcyBub3QgYXZhaWxhYmxlLlwiXG4gICAgICApO1xuICAgICAgaWYgKCF2aWV3VHJhbnNpdGlvbk9wdHMgfHwgIWlzVmlld1RyYW5zaXRpb25BdmFpbGFibGUpIHtcbiAgICAgICAgaWYgKHJlYWN0RG9tRmx1c2hTeW5jSW1wbCAmJiBmbHVzaFN5bmMpIHtcbiAgICAgICAgICByZWFjdERvbUZsdXNoU3luY0ltcGwoKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgUmVhY3QzLnN0YXJ0VHJhbnNpdGlvbigoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocmVhY3REb21GbHVzaFN5bmNJbXBsICYmIGZsdXNoU3luYykge1xuICAgICAgICByZWFjdERvbUZsdXNoU3luY0ltcGwoKCkgPT4ge1xuICAgICAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICByZW5kZXJEZmQgJiYgcmVuZGVyRGZkLnJlc29sdmUoKTtcbiAgICAgICAgICAgIHRyYW5zaXRpb24uc2tpcFRyYW5zaXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0VnRDb250ZXh0KHtcbiAgICAgICAgICAgIGlzVHJhbnNpdGlvbmluZzogdHJ1ZSxcbiAgICAgICAgICAgIGZsdXNoU3luYzogdHJ1ZSxcbiAgICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbjogdmlld1RyYW5zaXRpb25PcHRzLmN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgICAgIG5leHRMb2NhdGlvbjogdmlld1RyYW5zaXRpb25PcHRzLm5leHRMb2NhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHQgPSByb3V0ZXIud2luZG93LmRvY3VtZW50LnN0YXJ0Vmlld1RyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICAgIHJlYWN0RG9tRmx1c2hTeW5jSW1wbCgoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHQuZmluaXNoZWQuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgcmVhY3REb21GbHVzaFN5bmNJbXBsKCgpID0+IHtcbiAgICAgICAgICAgIHNldFJlbmRlckRmZCh2b2lkIDApO1xuICAgICAgICAgICAgc2V0VHJhbnNpdGlvbih2b2lkIDApO1xuICAgICAgICAgICAgc2V0UGVuZGluZ1N0YXRlKHZvaWQgMCk7XG4gICAgICAgICAgICBzZXRWdENvbnRleHQoeyBpc1RyYW5zaXRpb25pbmc6IGZhbHNlIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVhY3REb21GbHVzaFN5bmNJbXBsKCgpID0+IHNldFRyYW5zaXRpb24odCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICByZW5kZXJEZmQgJiYgcmVuZGVyRGZkLnJlc29sdmUoKTtcbiAgICAgICAgdHJhbnNpdGlvbi5za2lwVHJhbnNpdGlvbigpO1xuICAgICAgICBzZXRJbnRlcnJ1cHRpb24oe1xuICAgICAgICAgIHN0YXRlOiBuZXdTdGF0ZSxcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5jdXJyZW50TG9jYXRpb24sXG4gICAgICAgICAgbmV4dExvY2F0aW9uOiB2aWV3VHJhbnNpdGlvbk9wdHMubmV4dExvY2F0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0UGVuZGluZ1N0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgc2V0VnRDb250ZXh0KHtcbiAgICAgICAgICBpc1RyYW5zaXRpb25pbmc6IHRydWUsXG4gICAgICAgICAgZmx1c2hTeW5jOiBmYWxzZSxcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5jdXJyZW50TG9jYXRpb24sXG4gICAgICAgICAgbmV4dExvY2F0aW9uOiB2aWV3VHJhbnNpdGlvbk9wdHMubmV4dExvY2F0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgW3JvdXRlci53aW5kb3csIHJlYWN0RG9tRmx1c2hTeW5jSW1wbCwgdHJhbnNpdGlvbiwgcmVuZGVyRGZkXVxuICApO1xuICBSZWFjdDMudXNlTGF5b3V0RWZmZWN0KCgpID0+IHJvdXRlci5zdWJzY3JpYmUoc2V0U3RhdGUpLCBbcm91dGVyLCBzZXRTdGF0ZV0pO1xuICBSZWFjdDMudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodnRDb250ZXh0LmlzVHJhbnNpdGlvbmluZyAmJiAhdnRDb250ZXh0LmZsdXNoU3luYykge1xuICAgICAgc2V0UmVuZGVyRGZkKG5ldyBEZWZlcnJlZCgpKTtcbiAgICB9XG4gIH0sIFt2dENvbnRleHRdKTtcbiAgUmVhY3QzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHJlbmRlckRmZCAmJiBwZW5kaW5nU3RhdGUgJiYgcm91dGVyLndpbmRvdykge1xuICAgICAgbGV0IG5ld1N0YXRlID0gcGVuZGluZ1N0YXRlO1xuICAgICAgbGV0IHJlbmRlclByb21pc2UgPSByZW5kZXJEZmQucHJvbWlzZTtcbiAgICAgIGxldCB0cmFuc2l0aW9uMiA9IHJvdXRlci53aW5kb3cuZG9jdW1lbnQuc3RhcnRWaWV3VHJhbnNpdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICAgIFJlYWN0My5zdGFydFRyYW5zaXRpb24oKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSk7XG4gICAgICAgIGF3YWl0IHJlbmRlclByb21pc2U7XG4gICAgICB9KTtcbiAgICAgIHRyYW5zaXRpb24yLmZpbmlzaGVkLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICBzZXRSZW5kZXJEZmQodm9pZCAwKTtcbiAgICAgICAgc2V0VHJhbnNpdGlvbih2b2lkIDApO1xuICAgICAgICBzZXRQZW5kaW5nU3RhdGUodm9pZCAwKTtcbiAgICAgICAgc2V0VnRDb250ZXh0KHsgaXNUcmFuc2l0aW9uaW5nOiBmYWxzZSB9KTtcbiAgICAgIH0pO1xuICAgICAgc2V0VHJhbnNpdGlvbih0cmFuc2l0aW9uMik7XG4gICAgfVxuICB9LCBbcGVuZGluZ1N0YXRlLCByZW5kZXJEZmQsIHJvdXRlci53aW5kb3ddKTtcbiAgUmVhY3QzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHJlbmRlckRmZCAmJiBwZW5kaW5nU3RhdGUgJiYgc3RhdGUubG9jYXRpb24ua2V5ID09PSBwZW5kaW5nU3RhdGUubG9jYXRpb24ua2V5KSB7XG4gICAgICByZW5kZXJEZmQucmVzb2x2ZSgpO1xuICAgIH1cbiAgfSwgW3JlbmRlckRmZCwgdHJhbnNpdGlvbiwgc3RhdGUubG9jYXRpb24sIHBlbmRpbmdTdGF0ZV0pO1xuICBSZWFjdDMudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXZ0Q29udGV4dC5pc1RyYW5zaXRpb25pbmcgJiYgaW50ZXJydXB0aW9uKSB7XG4gICAgICBzZXRQZW5kaW5nU3RhdGUoaW50ZXJydXB0aW9uLnN0YXRlKTtcbiAgICAgIHNldFZ0Q29udGV4dCh7XG4gICAgICAgIGlzVHJhbnNpdGlvbmluZzogdHJ1ZSxcbiAgICAgICAgZmx1c2hTeW5jOiBmYWxzZSxcbiAgICAgICAgY3VycmVudExvY2F0aW9uOiBpbnRlcnJ1cHRpb24uY3VycmVudExvY2F0aW9uLFxuICAgICAgICBuZXh0TG9jYXRpb246IGludGVycnVwdGlvbi5uZXh0TG9jYXRpb25cbiAgICAgIH0pO1xuICAgICAgc2V0SW50ZXJydXB0aW9uKHZvaWQgMCk7XG4gICAgfVxuICB9LCBbdnRDb250ZXh0LmlzVHJhbnNpdGlvbmluZywgaW50ZXJydXB0aW9uXSk7XG4gIGxldCBuYXZpZ2F0b3IgPSBSZWFjdDMudXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNyZWF0ZUhyZWY6IHJvdXRlci5jcmVhdGVIcmVmLFxuICAgICAgZW5jb2RlTG9jYXRpb246IHJvdXRlci5lbmNvZGVMb2NhdGlvbixcbiAgICAgIGdvOiAobikgPT4gcm91dGVyLm5hdmlnYXRlKG4pLFxuICAgICAgcHVzaDogKHRvLCBzdGF0ZTIsIG9wdHMpID0+IHJvdXRlci5uYXZpZ2F0ZSh0bywge1xuICAgICAgICBzdGF0ZTogc3RhdGUyLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdHM/LnByZXZlbnRTY3JvbGxSZXNldFxuICAgICAgfSksXG4gICAgICByZXBsYWNlOiAodG8sIHN0YXRlMiwgb3B0cykgPT4gcm91dGVyLm5hdmlnYXRlKHRvLCB7XG4gICAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICAgIHN0YXRlOiBzdGF0ZTIsXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0cz8ucHJldmVudFNjcm9sbFJlc2V0XG4gICAgICB9KVxuICAgIH07XG4gIH0sIFtyb3V0ZXJdKTtcbiAgbGV0IGJhc2VuYW1lID0gcm91dGVyLmJhc2VuYW1lIHx8IFwiL1wiO1xuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSBSZWFjdDMudXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgcm91dGVyLFxuICAgICAgbmF2aWdhdG9yLFxuICAgICAgc3RhdGljOiBmYWxzZSxcbiAgICAgIGJhc2VuYW1lXG4gICAgfSksXG4gICAgW3JvdXRlciwgbmF2aWdhdG9yLCBiYXNlbmFtZV1cbiAgKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChSZWFjdDMuRnJhZ21lbnQsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChEYXRhUm91dGVyQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogZGF0YVJvdXRlckNvbnRleHQgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHN0YXRlIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChGZXRjaGVyc0NvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGZldGNoZXJEYXRhLmN1cnJlbnQgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KFZpZXdUcmFuc2l0aW9uQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdnRDb250ZXh0IH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChcbiAgICBSb3V0ZXIsXG4gICAge1xuICAgICAgYmFzZW5hbWUsXG4gICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuaGlzdG9yeUFjdGlvbixcbiAgICAgIG5hdmlnYXRvclxuICAgIH0sXG4gICAgLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KFxuICAgICAgTWVtb2l6ZWREYXRhUm91dGVzLFxuICAgICAge1xuICAgICAgICByb3V0ZXM6IHJvdXRlci5yb3V0ZXMsXG4gICAgICAgIGZ1dHVyZTogcm91dGVyLmZ1dHVyZSxcbiAgICAgICAgc3RhdGVcbiAgICAgIH1cbiAgICApXG4gICkpKSkpLCBudWxsKTtcbn1cbnZhciBNZW1vaXplZERhdGFSb3V0ZXMgPSBSZWFjdDMubWVtbyhEYXRhUm91dGVzKTtcbmZ1bmN0aW9uIERhdGFSb3V0ZXMoe1xuICByb3V0ZXMsXG4gIGZ1dHVyZSxcbiAgc3RhdGVcbn0pIHtcbiAgcmV0dXJuIHVzZVJvdXRlc0ltcGwocm91dGVzLCB2b2lkIDAsIHN0YXRlLCBmdXR1cmUpO1xufVxuZnVuY3Rpb24gTWVtb3J5Um91dGVyKHtcbiAgYmFzZW5hbWUsXG4gIGNoaWxkcmVuLFxuICBpbml0aWFsRW50cmllcyxcbiAgaW5pdGlhbEluZGV4XG59KSB7XG4gIGxldCBoaXN0b3J5UmVmID0gUmVhY3QzLnVzZVJlZigpO1xuICBpZiAoaGlzdG9yeVJlZi5jdXJyZW50ID09IG51bGwpIHtcbiAgICBoaXN0b3J5UmVmLmN1cnJlbnQgPSBjcmVhdGVNZW1vcnlIaXN0b3J5KHtcbiAgICAgIGluaXRpYWxFbnRyaWVzLFxuICAgICAgaW5pdGlhbEluZGV4LFxuICAgICAgdjVDb21wYXQ6IHRydWVcbiAgICB9KTtcbiAgfVxuICBsZXQgaGlzdG9yeSA9IGhpc3RvcnlSZWYuY3VycmVudDtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0My51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICB9KTtcbiAgbGV0IHNldFN0YXRlID0gUmVhY3QzLnVzZUNhbGxiYWNrKFxuICAgIChuZXdTdGF0ZSkgPT4ge1xuICAgICAgUmVhY3QzLnN0YXJ0VHJhbnNpdGlvbigoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICB9LFxuICAgIFtzZXRTdGF0ZUltcGxdXG4gICk7XG4gIFJlYWN0My51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeSwgc2V0U3RhdGVdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChcbiAgICBSb3V0ZXIsXG4gICAge1xuICAgICAgYmFzZW5hbWUsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5hY3Rpb24sXG4gICAgICBuYXZpZ2F0b3I6IGhpc3RvcnlcbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBOYXZpZ2F0ZSh7XG4gIHRvLFxuICByZXBsYWNlOiByZXBsYWNlMixcbiAgc3RhdGUsXG4gIHJlbGF0aXZlXG59KSB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZlxuICAgIC8vIHRoZSByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYDxOYXZpZ2F0ZT4gbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG4gIGxldCB7IHN0YXRpYzogaXNTdGF0aWMgfSA9IFJlYWN0My51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgd2FybmluZyhcbiAgICAhaXNTdGF0aWMsXG4gICAgYDxOYXZpZ2F0ZT4gbXVzdCBub3QgYmUgdXNlZCBvbiB0aGUgaW5pdGlhbCByZW5kZXIgaW4gYSA8U3RhdGljUm91dGVyPi4gVGhpcyBpcyBhIG5vLW9wLCBidXQgeW91IHNob3VsZCBtb2RpZnkgeW91ciBjb2RlIHNvIHRoZSA8TmF2aWdhdGU+IGlzIG9ubHkgZXZlciByZW5kZXJlZCBpbiByZXNwb25zZSB0byBzb21lIHVzZXIgaW50ZXJhY3Rpb24gb3Igc3RhdGUgY2hhbmdlLmBcbiAgKTtcbiAgbGV0IHsgbWF0Y2hlcyB9ID0gUmVhY3QzLnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHsgcGF0aG5hbWU6IGxvY2F0aW9uUGF0aG5hbWUgfSA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBuYXZpZ2F0ZSA9IHVzZU5hdmlnYXRlKCk7XG4gIGxldCBwYXRoID0gcmVzb2x2ZVRvKFxuICAgIHRvLFxuICAgIGdldFJlc29sdmVUb01hdGNoZXMobWF0Y2hlcyksXG4gICAgbG9jYXRpb25QYXRobmFtZSxcbiAgICByZWxhdGl2ZSA9PT0gXCJwYXRoXCJcbiAgKTtcbiAgbGV0IGpzb25QYXRoID0gSlNPTi5zdHJpbmdpZnkocGF0aCk7XG4gIFJlYWN0My51c2VFZmZlY3QoKCkgPT4ge1xuICAgIG5hdmlnYXRlKEpTT04ucGFyc2UoanNvblBhdGgpLCB7IHJlcGxhY2U6IHJlcGxhY2UyLCBzdGF0ZSwgcmVsYXRpdmUgfSk7XG4gIH0sIFtuYXZpZ2F0ZSwganNvblBhdGgsIHJlbGF0aXZlLCByZXBsYWNlMiwgc3RhdGVdKTtcbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBPdXRsZXQocHJvcHMpIHtcbiAgcmV0dXJuIHVzZU91dGxldChwcm9wcy5jb250ZXh0KTtcbn1cbmZ1bmN0aW9uIFJvdXRlKF9wcm9wcykge1xuICBpbnZhcmlhbnQoXG4gICAgZmFsc2UsXG4gICAgYEEgPFJvdXRlPiBpcyBvbmx5IGV2ZXIgdG8gYmUgdXNlZCBhcyB0aGUgY2hpbGQgb2YgPFJvdXRlcz4gZWxlbWVudCwgbmV2ZXIgcmVuZGVyZWQgZGlyZWN0bHkuIFBsZWFzZSB3cmFwIHlvdXIgPFJvdXRlPiBpbiBhIDxSb3V0ZXM+LmBcbiAgKTtcbn1cbmZ1bmN0aW9uIFJvdXRlcih7XG4gIGJhc2VuYW1lOiBiYXNlbmFtZVByb3AgPSBcIi9cIixcbiAgY2hpbGRyZW4gPSBudWxsLFxuICBsb2NhdGlvbjogbG9jYXRpb25Qcm9wLFxuICBuYXZpZ2F0aW9uVHlwZSA9IFwiUE9QXCIgLyogUG9wICovLFxuICBuYXZpZ2F0b3IsXG4gIHN0YXRpYzogc3RhdGljUHJvcCA9IGZhbHNlXG59KSB7XG4gIGludmFyaWFudChcbiAgICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgYFlvdSBjYW5ub3QgcmVuZGVyIGEgPFJvdXRlcj4gaW5zaWRlIGFub3RoZXIgPFJvdXRlcj4uIFlvdSBzaG91bGQgbmV2ZXIgaGF2ZSBtb3JlIHRoYW4gb25lIGluIHlvdXIgYXBwLmBcbiAgKTtcbiAgbGV0IGJhc2VuYW1lID0gYmFzZW5hbWVQcm9wLnJlcGxhY2UoL15cXC8qLywgXCIvXCIpO1xuICBsZXQgbmF2aWdhdGlvbkNvbnRleHQgPSBSZWFjdDMudXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgYmFzZW5hbWUsXG4gICAgICBuYXZpZ2F0b3IsXG4gICAgICBzdGF0aWM6IHN0YXRpY1Byb3AsXG4gICAgICBmdXR1cmU6IHt9XG4gICAgfSksXG4gICAgW2Jhc2VuYW1lLCBuYXZpZ2F0b3IsIHN0YXRpY1Byb3BdXG4gICk7XG4gIGlmICh0eXBlb2YgbG9jYXRpb25Qcm9wID09PSBcInN0cmluZ1wiKSB7XG4gICAgbG9jYXRpb25Qcm9wID0gcGFyc2VQYXRoKGxvY2F0aW9uUHJvcCk7XG4gIH1cbiAgbGV0IHtcbiAgICBwYXRobmFtZSA9IFwiL1wiLFxuICAgIHNlYXJjaCA9IFwiXCIsXG4gICAgaGFzaCA9IFwiXCIsXG4gICAgc3RhdGUgPSBudWxsLFxuICAgIGtleSA9IFwiZGVmYXVsdFwiXG4gIH0gPSBsb2NhdGlvblByb3A7XG4gIGxldCBsb2NhdGlvbkNvbnRleHQgPSBSZWFjdDMudXNlTWVtbygoKSA9PiB7XG4gICAgbGV0IHRyYWlsaW5nUGF0aG5hbWUgPSBzdHJpcEJhc2VuYW1lKHBhdGhuYW1lLCBiYXNlbmFtZSk7XG4gICAgaWYgKHRyYWlsaW5nUGF0aG5hbWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBsb2NhdGlvbjoge1xuICAgICAgICBwYXRobmFtZTogdHJhaWxpbmdQYXRobmFtZSxcbiAgICAgICAgc2VhcmNoLFxuICAgICAgICBoYXNoLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAga2V5XG4gICAgICB9LFxuICAgICAgbmF2aWdhdGlvblR5cGVcbiAgICB9O1xuICB9LCBbYmFzZW5hbWUsIHBhdGhuYW1lLCBzZWFyY2gsIGhhc2gsIHN0YXRlLCBrZXksIG5hdmlnYXRpb25UeXBlXSk7XG4gIHdhcm5pbmcoXG4gICAgbG9jYXRpb25Db250ZXh0ICE9IG51bGwsXG4gICAgYDxSb3V0ZXIgYmFzZW5hbWU9XCIke2Jhc2VuYW1lfVwiPiBpcyBub3QgYWJsZSB0byBtYXRjaCB0aGUgVVJMIFwiJHtwYXRobmFtZX0ke3NlYXJjaH0ke2hhc2h9XCIgYmVjYXVzZSBpdCBkb2VzIG5vdCBzdGFydCB3aXRoIHRoZSBiYXNlbmFtZSwgc28gdGhlIDxSb3V0ZXI+IHdvbid0IHJlbmRlciBhbnl0aGluZy5gXG4gICk7XG4gIGlmIChsb2NhdGlvbkNvbnRleHQgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoTmF2aWdhdGlvbkNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IG5hdmlnYXRpb25Db250ZXh0IH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChMb2NhdGlvbkNvbnRleHQuUHJvdmlkZXIsIHsgY2hpbGRyZW4sIHZhbHVlOiBsb2NhdGlvbkNvbnRleHQgfSkpO1xufVxuZnVuY3Rpb24gUm91dGVzKHtcbiAgY2hpbGRyZW4sXG4gIGxvY2F0aW9uXG59KSB7XG4gIHJldHVybiB1c2VSb3V0ZXMoY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKGNoaWxkcmVuKSwgbG9jYXRpb24pO1xufVxuZnVuY3Rpb24gQXdhaXQoe1xuICBjaGlsZHJlbixcbiAgZXJyb3JFbGVtZW50LFxuICByZXNvbHZlXG59KSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoQXdhaXRFcnJvckJvdW5kYXJ5LCB7IHJlc29sdmUsIGVycm9yRWxlbWVudCB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoUmVzb2x2ZUF3YWl0LCBudWxsLCBjaGlsZHJlbikpO1xufVxudmFyIEF3YWl0RXJyb3JCb3VuZGFyeSA9IGNsYXNzIGV4dGVuZHMgUmVhY3QzLkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7IGVycm9yOiBudWxsIH07XG4gIH1cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikge1xuICAgIHJldHVybiB7IGVycm9yIH07XG4gIH1cbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIGVycm9ySW5mbykge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBcIjxBd2FpdD4gY2F1Z2h0IHRoZSBmb2xsb3dpbmcgZXJyb3IgZHVyaW5nIHJlbmRlclwiLFxuICAgICAgZXJyb3IsXG4gICAgICBlcnJvckluZm9cbiAgICApO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBsZXQgeyBjaGlsZHJlbiwgZXJyb3JFbGVtZW50LCByZXNvbHZlIH0gPSB0aGlzLnByb3BzO1xuICAgIGxldCBwcm9taXNlID0gbnVsbDtcbiAgICBsZXQgc3RhdHVzID0gMCAvKiBwZW5kaW5nICovO1xuICAgIGlmICghKHJlc29sdmUgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgc3RhdHVzID0gMSAvKiBzdWNjZXNzICovO1xuICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX3RyYWNrZWRcIiwgeyBnZXQ6ICgpID0+IHRydWUgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZGF0YVwiLCB7IGdldDogKCkgPT4gcmVzb2x2ZSB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUuZXJyb3IpIHtcbiAgICAgIHN0YXR1cyA9IDIgLyogZXJyb3IgKi87XG4gICAgICBsZXQgcmVuZGVyRXJyb3IgPSB0aGlzLnN0YXRlLmVycm9yO1xuICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVqZWN0KCkuY2F0Y2goKCkgPT4ge1xuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfdHJhY2tlZFwiLCB7IGdldDogKCkgPT4gdHJ1ZSB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9lcnJvclwiLCB7IGdldDogKCkgPT4gcmVuZGVyRXJyb3IgfSk7XG4gICAgfSBlbHNlIGlmIChyZXNvbHZlLl90cmFja2VkKSB7XG4gICAgICBwcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgIHN0YXR1cyA9IFwiX2Vycm9yXCIgaW4gcHJvbWlzZSA/IDIgLyogZXJyb3IgKi8gOiBcIl9kYXRhXCIgaW4gcHJvbWlzZSA/IDEgLyogc3VjY2VzcyAqLyA6IDAgLyogcGVuZGluZyAqLztcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdHVzID0gMCAvKiBwZW5kaW5nICovO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc29sdmUsIFwiX3RyYWNrZWRcIiwgeyBnZXQ6ICgpID0+IHRydWUgfSk7XG4gICAgICBwcm9taXNlID0gcmVzb2x2ZS50aGVuKFxuICAgICAgICAoZGF0YTIpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNvbHZlLCBcIl9kYXRhXCIsIHsgZ2V0OiAoKSA9PiBkYXRhMiB9KSxcbiAgICAgICAgKGVycm9yKSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzb2x2ZSwgXCJfZXJyb3JcIiwgeyBnZXQ6ICgpID0+IGVycm9yIH0pXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSAyIC8qIGVycm9yICovICYmICFlcnJvckVsZW1lbnQpIHtcbiAgICAgIHRocm93IHByb21pc2UuX2Vycm9yO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSAyIC8qIGVycm9yICovKSB7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KEF3YWl0Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogcHJvbWlzZSwgY2hpbGRyZW46IGVycm9yRWxlbWVudCB9KTtcbiAgICB9XG4gICAgaWYgKHN0YXR1cyA9PT0gMSAvKiBzdWNjZXNzICovKSB7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KEF3YWl0Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogcHJvbWlzZSwgY2hpbGRyZW4gfSk7XG4gICAgfVxuICAgIHRocm93IHByb21pc2U7XG4gIH1cbn07XG5mdW5jdGlvbiBSZXNvbHZlQXdhaXQoe1xuICBjaGlsZHJlblxufSkge1xuICBsZXQgZGF0YTIgPSB1c2VBc3luY1ZhbHVlKCk7XG4gIGxldCB0b1JlbmRlciA9IHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiID8gY2hpbGRyZW4oZGF0YTIpIDogY2hpbGRyZW47XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoUmVhY3QzLkZyYWdtZW50LCBudWxsLCB0b1JlbmRlcik7XG59XG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oY2hpbGRyZW4sIHBhcmVudFBhdGggPSBbXSkge1xuICBsZXQgcm91dGVzID0gW107XG4gIFJlYWN0My5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICBpZiAoIVJlYWN0My5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgdHJlZVBhdGggPSBbLi4ucGFyZW50UGF0aCwgaW5kZXhdO1xuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJlYWN0My5GcmFnbWVudCkge1xuICAgICAgcm91dGVzLnB1c2guYXBwbHkoXG4gICAgICAgIHJvdXRlcyxcbiAgICAgICAgY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKGVsZW1lbnQucHJvcHMuY2hpbGRyZW4sIHRyZWVQYXRoKVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW52YXJpYW50KFxuICAgICAgZWxlbWVudC50eXBlID09PSBSb3V0ZSxcbiAgICAgIGBbJHt0eXBlb2YgZWxlbWVudC50eXBlID09PSBcInN0cmluZ1wiID8gZWxlbWVudC50eXBlIDogZWxlbWVudC50eXBlLm5hbWV9XSBpcyBub3QgYSA8Um91dGU+IGNvbXBvbmVudC4gQWxsIGNvbXBvbmVudCBjaGlsZHJlbiBvZiA8Um91dGVzPiBtdXN0IGJlIGEgPFJvdXRlPiBvciA8UmVhY3QuRnJhZ21lbnQ+YFxuICAgICk7XG4gICAgaW52YXJpYW50KFxuICAgICAgIWVsZW1lbnQucHJvcHMuaW5kZXggfHwgIWVsZW1lbnQucHJvcHMuY2hpbGRyZW4sXG4gICAgICBcIkFuIGluZGV4IHJvdXRlIGNhbm5vdCBoYXZlIGNoaWxkIHJvdXRlcy5cIlxuICAgICk7XG4gICAgbGV0IHJvdXRlID0ge1xuICAgICAgaWQ6IGVsZW1lbnQucHJvcHMuaWQgfHwgdHJlZVBhdGguam9pbihcIi1cIiksXG4gICAgICBjYXNlU2Vuc2l0aXZlOiBlbGVtZW50LnByb3BzLmNhc2VTZW5zaXRpdmUsXG4gICAgICBlbGVtZW50OiBlbGVtZW50LnByb3BzLmVsZW1lbnQsXG4gICAgICBDb21wb25lbnQ6IGVsZW1lbnQucHJvcHMuQ29tcG9uZW50LFxuICAgICAgaW5kZXg6IGVsZW1lbnQucHJvcHMuaW5kZXgsXG4gICAgICBwYXRoOiBlbGVtZW50LnByb3BzLnBhdGgsXG4gICAgICBsb2FkZXI6IGVsZW1lbnQucHJvcHMubG9hZGVyLFxuICAgICAgYWN0aW9uOiBlbGVtZW50LnByb3BzLmFjdGlvbixcbiAgICAgIGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQ6IGVsZW1lbnQucHJvcHMuaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCxcbiAgICAgIEh5ZHJhdGVGYWxsYmFjazogZWxlbWVudC5wcm9wcy5IeWRyYXRlRmFsbGJhY2ssXG4gICAgICBlcnJvckVsZW1lbnQ6IGVsZW1lbnQucHJvcHMuZXJyb3JFbGVtZW50LFxuICAgICAgRXJyb3JCb3VuZGFyeTogZWxlbWVudC5wcm9wcy5FcnJvckJvdW5kYXJ5LFxuICAgICAgaGFzRXJyb3JCb3VuZGFyeTogZWxlbWVudC5wcm9wcy5oYXNFcnJvckJvdW5kYXJ5ID09PSB0cnVlIHx8IGVsZW1lbnQucHJvcHMuRXJyb3JCb3VuZGFyeSAhPSBudWxsIHx8IGVsZW1lbnQucHJvcHMuZXJyb3JFbGVtZW50ICE9IG51bGwsXG4gICAgICBzaG91bGRSZXZhbGlkYXRlOiBlbGVtZW50LnByb3BzLnNob3VsZFJldmFsaWRhdGUsXG4gICAgICBoYW5kbGU6IGVsZW1lbnQucHJvcHMuaGFuZGxlLFxuICAgICAgbGF6eTogZWxlbWVudC5wcm9wcy5sYXp5XG4gICAgfTtcbiAgICBpZiAoZWxlbWVudC5wcm9wcy5jaGlsZHJlbikge1xuICAgICAgcm91dGUuY2hpbGRyZW4gPSBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oXG4gICAgICAgIGVsZW1lbnQucHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIHRyZWVQYXRoXG4gICAgICApO1xuICAgIH1cbiAgICByb3V0ZXMucHVzaChyb3V0ZSk7XG4gIH0pO1xuICByZXR1cm4gcm91dGVzO1xufVxudmFyIGNyZWF0ZVJvdXRlc0Zyb21FbGVtZW50cyA9IGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbjtcbmZ1bmN0aW9uIHJlbmRlck1hdGNoZXMobWF0Y2hlcykge1xuICByZXR1cm4gX3JlbmRlck1hdGNoZXMobWF0Y2hlcyk7XG59XG5mdW5jdGlvbiB3aXRoQ29tcG9uZW50UHJvcHMoQ29tcG9uZW50NCkge1xuICByZXR1cm4gZnVuY3Rpb24gV2l0aENvbXBvbmVudFByb3BzKCkge1xuICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgcGFyYW1zOiB1c2VQYXJhbXMoKSxcbiAgICAgIGxvYWRlckRhdGE6IHVzZUxvYWRlckRhdGEoKSxcbiAgICAgIGFjdGlvbkRhdGE6IHVzZUFjdGlvbkRhdGEoKSxcbiAgICAgIG1hdGNoZXM6IHVzZU1hdGNoZXMoKVxuICAgIH07XG4gICAgcmV0dXJuIFJlYWN0My5jcmVhdGVFbGVtZW50KENvbXBvbmVudDQsIHByb3BzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHdpdGhIeWRyYXRlRmFsbGJhY2tQcm9wcyhIeWRyYXRlRmFsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdpdGhIeWRyYXRlRmFsbGJhY2tQcm9wcygpIHtcbiAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgIHBhcmFtczogdXNlUGFyYW1zKCksXG4gICAgICBsb2FkZXJEYXRhOiB1c2VMb2FkZXJEYXRhKCksXG4gICAgICBhY3Rpb25EYXRhOiB1c2VBY3Rpb25EYXRhKClcbiAgICB9O1xuICAgIHJldHVybiBSZWFjdDMuY3JlYXRlRWxlbWVudChIeWRyYXRlRmFsbGJhY2ssIHByb3BzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHdpdGhFcnJvckJvdW5kYXJ5UHJvcHMoRXJyb3JCb3VuZGFyeSkge1xuICByZXR1cm4gZnVuY3Rpb24gV2l0aEVycm9yQm91bmRhcnlQcm9wcygpIHtcbiAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgIHBhcmFtczogdXNlUGFyYW1zKCksXG4gICAgICBsb2FkZXJEYXRhOiB1c2VMb2FkZXJEYXRhKCksXG4gICAgICBhY3Rpb25EYXRhOiB1c2VBY3Rpb25EYXRhKCksXG4gICAgICBlcnJvcjogdXNlUm91dGVFcnJvcigpXG4gICAgfTtcbiAgICByZXR1cm4gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoRXJyb3JCb3VuZGFyeSwgcHJvcHMpO1xuICB9O1xufVxuXG4vLyBsaWIvZG9tL2xpYi50c3hcbnZhciBSZWFjdDEwID0gX190b0VTTShyZXF1aXJlKFwicmVhY3RcIikpO1xuXG4vLyBsaWIvZG9tL2RvbS50c1xudmFyIGRlZmF1bHRNZXRob2QgPSBcImdldFwiO1xudmFyIGRlZmF1bHRFbmNUeXBlID0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIjtcbmZ1bmN0aW9uIGlzSHRtbEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0LnRhZ05hbWUgPT09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBpc0J1dHRvbkVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiBpc0h0bWxFbGVtZW50KG9iamVjdCkgJiYgb2JqZWN0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJidXR0b25cIjtcbn1cbmZ1bmN0aW9uIGlzRm9ybUVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiBpc0h0bWxFbGVtZW50KG9iamVjdCkgJiYgb2JqZWN0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJmb3JtXCI7XG59XG5mdW5jdGlvbiBpc0lucHV0RWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIGlzSHRtbEVsZW1lbnQob2JqZWN0KSAmJiBvYmplY3QudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCI7XG59XG5mdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuICEhKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc2hpZnRLZXkpO1xufVxuZnVuY3Rpb24gc2hvdWxkUHJvY2Vzc0xpbmtDbGljayhldmVudCwgdGFyZ2V0KSB7XG4gIHJldHVybiBldmVudC5idXR0b24gPT09IDAgJiYgLy8gSWdub3JlIGV2ZXJ5dGhpbmcgYnV0IGxlZnQgY2xpY2tzXG4gICghdGFyZ2V0IHx8IHRhcmdldCA9PT0gXCJfc2VsZlwiKSAmJiAvLyBMZXQgYnJvd3NlciBoYW5kbGUgXCJ0YXJnZXQ9X2JsYW5rXCIgZXRjLlxuICAhaXNNb2RpZmllZEV2ZW50KGV2ZW50KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlYXJjaFBhcmFtcyhpbml0ID0gXCJcIikge1xuICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtcyhcbiAgICB0eXBlb2YgaW5pdCA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KGluaXQpIHx8IGluaXQgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMgPyBpbml0IDogT2JqZWN0LmtleXMoaW5pdCkucmVkdWNlKChtZW1vMiwga2V5KSA9PiB7XG4gICAgICBsZXQgdmFsdWUgPSBpbml0W2tleV07XG4gICAgICByZXR1cm4gbWVtbzIuY29uY2F0KFxuICAgICAgICBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcCgodikgPT4gW2tleSwgdl0pIDogW1trZXksIHZhbHVlXV1cbiAgICAgICk7XG4gICAgfSwgW10pXG4gICk7XG59XG5mdW5jdGlvbiBnZXRTZWFyY2hQYXJhbXNGb3JMb2NhdGlvbihsb2NhdGlvblNlYXJjaCwgZGVmYXVsdFNlYXJjaFBhcmFtcykge1xuICBsZXQgc2VhcmNoUGFyYW1zID0gY3JlYXRlU2VhcmNoUGFyYW1zKGxvY2F0aW9uU2VhcmNoKTtcbiAgaWYgKGRlZmF1bHRTZWFyY2hQYXJhbXMpIHtcbiAgICBkZWZhdWx0U2VhcmNoUGFyYW1zLmZvckVhY2goKF8sIGtleSkgPT4ge1xuICAgICAgaWYgKCFzZWFyY2hQYXJhbXMuaGFzKGtleSkpIHtcbiAgICAgICAgZGVmYXVsdFNlYXJjaFBhcmFtcy5nZXRBbGwoa2V5KS5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBzZWFyY2hQYXJhbXM7XG59XG52YXIgX2Zvcm1EYXRhU3VwcG9ydHNTdWJtaXR0ZXIgPSBudWxsO1xuZnVuY3Rpb24gaXNGb3JtRGF0YVN1Ym1pdHRlclN1cHBvcnRlZCgpIHtcbiAgaWYgKF9mb3JtRGF0YVN1cHBvcnRzU3VibWl0dGVyID09PSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBGb3JtRGF0YShcbiAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvcm1cIiksXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgaWYgRm9ybURhdGEgc3VwcG9ydHMgdGhlIHN1Ym1pdHRlciBwYXJhbWV0ZXIsIHRoaXMgd2lsbCB0aHJvd1xuICAgICAgICAwXG4gICAgICApO1xuICAgICAgX2Zvcm1EYXRhU3VwcG9ydHNTdWJtaXR0ZXIgPSBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlciA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlcjtcbn1cbnZhciBzdXBwb3J0ZWRGb3JtRW5jVHlwZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsXG4gIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiLFxuICBcInRleHQvcGxhaW5cIlxuXSk7XG5mdW5jdGlvbiBnZXRGb3JtRW5jVHlwZShlbmNUeXBlKSB7XG4gIGlmIChlbmNUeXBlICE9IG51bGwgJiYgIXN1cHBvcnRlZEZvcm1FbmNUeXBlcy5oYXMoZW5jVHlwZSkpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgZmFsc2UsXG4gICAgICBgXCIke2VuY1R5cGV9XCIgaXMgbm90IGEgdmFsaWQgXFxgZW5jVHlwZVxcYCBmb3IgXFxgPEZvcm0+XFxgL1xcYDxmZXRjaGVyLkZvcm0+XFxgIGFuZCB3aWxsIGRlZmF1bHQgdG8gXCIke2RlZmF1bHRFbmNUeXBlfVwiYFxuICAgICk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGVuY1R5cGU7XG59XG5mdW5jdGlvbiBnZXRGb3JtU3VibWlzc2lvbkluZm8odGFyZ2V0LCBiYXNlbmFtZSkge1xuICBsZXQgbWV0aG9kO1xuICBsZXQgYWN0aW9uO1xuICBsZXQgZW5jVHlwZTtcbiAgbGV0IGZvcm1EYXRhO1xuICBsZXQgYm9keTtcbiAgaWYgKGlzRm9ybUVsZW1lbnQodGFyZ2V0KSkge1xuICAgIGxldCBhdHRyID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImFjdGlvblwiKTtcbiAgICBhY3Rpb24gPSBhdHRyID8gc3RyaXBCYXNlbmFtZShhdHRyLCBiYXNlbmFtZSkgOiBudWxsO1xuICAgIG1ldGhvZCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJtZXRob2RcIikgfHwgZGVmYXVsdE1ldGhvZDtcbiAgICBlbmNUeXBlID0gZ2V0Rm9ybUVuY1R5cGUodGFyZ2V0LmdldEF0dHJpYnV0ZShcImVuY3R5cGVcIikpIHx8IGRlZmF1bHRFbmNUeXBlO1xuICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKHRhcmdldCk7XG4gIH0gZWxzZSBpZiAoaXNCdXR0b25FbGVtZW50KHRhcmdldCkgfHwgaXNJbnB1dEVsZW1lbnQodGFyZ2V0KSAmJiAodGFyZ2V0LnR5cGUgPT09IFwic3VibWl0XCIgfHwgdGFyZ2V0LnR5cGUgPT09IFwiaW1hZ2VcIikpIHtcbiAgICBsZXQgZm9ybSA9IHRhcmdldC5mb3JtO1xuICAgIGlmIChmb3JtID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBzdWJtaXQgYSA8YnV0dG9uPiBvciA8aW5wdXQgdHlwZT1cInN1Ym1pdFwiPiB3aXRob3V0IGEgPGZvcm0+YFxuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IGF0dHIgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybWFjdGlvblwiKSB8fCBmb3JtLmdldEF0dHJpYnV0ZShcImFjdGlvblwiKTtcbiAgICBhY3Rpb24gPSBhdHRyID8gc3RyaXBCYXNlbmFtZShhdHRyLCBiYXNlbmFtZSkgOiBudWxsO1xuICAgIG1ldGhvZCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJmb3JtbWV0aG9kXCIpIHx8IGZvcm0uZ2V0QXR0cmlidXRlKFwibWV0aG9kXCIpIHx8IGRlZmF1bHRNZXRob2Q7XG4gICAgZW5jVHlwZSA9IGdldEZvcm1FbmNUeXBlKHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJmb3JtZW5jdHlwZVwiKSkgfHwgZ2V0Rm9ybUVuY1R5cGUoZm9ybS5nZXRBdHRyaWJ1dGUoXCJlbmN0eXBlXCIpKSB8fCBkZWZhdWx0RW5jVHlwZTtcbiAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YShmb3JtLCB0YXJnZXQpO1xuICAgIGlmICghaXNGb3JtRGF0YVN1Ym1pdHRlclN1cHBvcnRlZCgpKSB7XG4gICAgICBsZXQgeyBuYW1lLCB0eXBlLCB2YWx1ZSB9ID0gdGFyZ2V0O1xuICAgICAgaWYgKHR5cGUgPT09IFwiaW1hZ2VcIikge1xuICAgICAgICBsZXQgcHJlZml4ID0gbmFtZSA/IGAke25hbWV9LmAgOiBcIlwiO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoYCR7cHJlZml4fXhgLCBcIjBcIik7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChgJHtwcmVmaXh9eWAsIFwiMFwiKTtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSkge1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc0h0bWxFbGVtZW50KHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQ2Fubm90IHN1Ym1pdCBlbGVtZW50IHRoYXQgaXMgbm90IDxmb3JtPiwgPGJ1dHRvbj4sIG9yIDxpbnB1dCB0eXBlPVwic3VibWl0fGltYWdlXCI+YFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgbWV0aG9kID0gZGVmYXVsdE1ldGhvZDtcbiAgICBhY3Rpb24gPSBudWxsO1xuICAgIGVuY1R5cGUgPSBkZWZhdWx0RW5jVHlwZTtcbiAgICBib2R5ID0gdGFyZ2V0O1xuICB9XG4gIGlmIChmb3JtRGF0YSAmJiBlbmNUeXBlID09PSBcInRleHQvcGxhaW5cIikge1xuICAgIGJvZHkgPSBmb3JtRGF0YTtcbiAgICBmb3JtRGF0YSA9IHZvaWQgMDtcbiAgfVxuICByZXR1cm4geyBhY3Rpb24sIG1ldGhvZDogbWV0aG9kLnRvTG93ZXJDYXNlKCksIGVuY1R5cGUsIGZvcm1EYXRhLCBib2R5IH07XG59XG5cbi8vIGxpYi9kb20vc3NyL2NvbXBvbmVudHMudHN4XG52YXIgUmVhY3Q5ID0gX190b0VTTShyZXF1aXJlKFwicmVhY3RcIikpO1xuXG4vLyBsaWIvZG9tL3Nzci9pbnZhcmlhbnQudHNcbmZ1bmN0aW9uIGludmFyaWFudDIodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cblxuLy8gbGliL2RvbS9zc3Ivcm91dGVNb2R1bGVzLnRzXG5hc3luYyBmdW5jdGlvbiBsb2FkUm91dGVNb2R1bGUocm91dGUsIHJvdXRlTW9kdWxlc0NhY2hlKSB7XG4gIGlmIChyb3V0ZS5pZCBpbiByb3V0ZU1vZHVsZXNDYWNoZSkge1xuICAgIHJldHVybiByb3V0ZU1vZHVsZXNDYWNoZVtyb3V0ZS5pZF07XG4gIH1cbiAgdHJ5IHtcbiAgICBsZXQgcm91dGVNb2R1bGUgPSBhd2FpdCBpbXBvcnQoXG4gICAgICAvKiBAdml0ZS1pZ25vcmUgKi9cbiAgICAgIC8qIHdlYnBhY2tJZ25vcmU6IHRydWUgKi9cbiAgICAgIHJvdXRlLm1vZHVsZVxuICAgICk7XG4gICAgcm91dGVNb2R1bGVzQ2FjaGVbcm91dGUuaWRdID0gcm91dGVNb2R1bGU7XG4gICAgcmV0dXJuIHJvdXRlTW9kdWxlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBgRXJyb3IgbG9hZGluZyByb3V0ZSBtb2R1bGUgXFxgJHtyb3V0ZS5tb2R1bGV9XFxgLCByZWxvYWRpbmcgcGFnZS4uLmBcbiAgICApO1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIGlmICh3aW5kb3cuX19yZWFjdFJvdXRlckNvbnRleHQgJiYgd2luZG93Ll9fcmVhY3RSb3V0ZXJDb250ZXh0LmlzU3BhTW9kZSAmJiAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgdm9pZCAwKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB7XG4gICAgfSk7XG4gIH1cbn1cblxuLy8gbGliL2RvbS9zc3IvbGlua3MudHNcbmZ1bmN0aW9uIGdldEtleWVkTGlua3NGb3JNYXRjaGVzKG1hdGNoZXMsIHJvdXRlTW9kdWxlcywgbWFuaWZlc3QpIHtcbiAgbGV0IGRlc2NyaXB0b3JzID0gbWF0Y2hlcy5tYXAoKG1hdGNoKSA9PiB7XG4gICAgbGV0IG1vZHVsZTIgPSByb3V0ZU1vZHVsZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgIGxldCByb3V0ZSA9IG1hbmlmZXN0LnJvdXRlc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgcmV0dXJuIFtcbiAgICAgIHJvdXRlICYmIHJvdXRlLmNzcyA/IHJvdXRlLmNzcy5tYXAoKGhyZWYyKSA9PiAoeyByZWw6IFwic3R5bGVzaGVldFwiLCBocmVmOiBocmVmMiB9KSkgOiBbXSxcbiAgICAgIG1vZHVsZTI/LmxpbmtzPy4oKSB8fCBbXVxuICAgIF07XG4gIH0pLmZsYXQoMik7XG4gIGxldCBwcmVsb2FkcyA9IGdldE1vZHVsZUxpbmtIcmVmcyhtYXRjaGVzLCBtYW5pZmVzdCk7XG4gIHJldHVybiBkZWR1cGVMaW5rRGVzY3JpcHRvcnMoZGVzY3JpcHRvcnMsIHByZWxvYWRzKTtcbn1cbmZ1bmN0aW9uIGdldFJvdXRlQ3NzRGVzY3JpcHRvcnMocm91dGUpIHtcbiAgaWYgKCFyb3V0ZS5jc3MpIHJldHVybiBbXTtcbiAgcmV0dXJuIHJvdXRlLmNzcy5tYXAoKGhyZWYyKSA9PiAoeyByZWw6IFwic3R5bGVzaGVldFwiLCBocmVmOiBocmVmMiB9KSk7XG59XG5hc3luYyBmdW5jdGlvbiBwcmVmZXRjaFJvdXRlQ3NzKHJvdXRlKSB7XG4gIGlmICghcm91dGUuY3NzKSByZXR1cm47XG4gIGxldCBkZXNjcmlwdG9ycyA9IGdldFJvdXRlQ3NzRGVzY3JpcHRvcnMocm91dGUpO1xuICBhd2FpdCBQcm9taXNlLmFsbChkZXNjcmlwdG9ycy5tYXAocHJlZmV0Y2hTdHlsZUxpbmspKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByZWZldGNoU3R5bGVMaW5rcyhyb3V0ZSwgcm91dGVNb2R1bGUpIHtcbiAgaWYgKCFyb3V0ZS5jc3MgJiYgIXJvdXRlTW9kdWxlLmxpbmtzIHx8ICFpc1ByZWxvYWRTdXBwb3J0ZWQoKSkgcmV0dXJuO1xuICBsZXQgZGVzY3JpcHRvcnMgPSBbXTtcbiAgaWYgKHJvdXRlLmNzcykge1xuICAgIGRlc2NyaXB0b3JzLnB1c2goLi4uZ2V0Um91dGVDc3NEZXNjcmlwdG9ycyhyb3V0ZSkpO1xuICB9XG4gIGlmIChyb3V0ZU1vZHVsZS5saW5rcykge1xuICAgIGRlc2NyaXB0b3JzLnB1c2goLi4ucm91dGVNb2R1bGUubGlua3MoKSk7XG4gIH1cbiAgaWYgKGRlc2NyaXB0b3JzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICBsZXQgc3R5bGVMaW5rcyA9IFtdO1xuICBmb3IgKGxldCBkZXNjcmlwdG9yIG9mIGRlc2NyaXB0b3JzKSB7XG4gICAgaWYgKCFpc1BhZ2VMaW5rRGVzY3JpcHRvcihkZXNjcmlwdG9yKSAmJiBkZXNjcmlwdG9yLnJlbCA9PT0gXCJzdHlsZXNoZWV0XCIpIHtcbiAgICAgIHN0eWxlTGlua3MucHVzaCh7XG4gICAgICAgIC4uLmRlc2NyaXB0b3IsXG4gICAgICAgIHJlbDogXCJwcmVsb2FkXCIsXG4gICAgICAgIGFzOiBcInN0eWxlXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBhd2FpdCBQcm9taXNlLmFsbChzdHlsZUxpbmtzLm1hcChwcmVmZXRjaFN0eWxlTGluaykpO1xufVxuYXN5bmMgZnVuY3Rpb24gcHJlZmV0Y2hTdHlsZUxpbmsoZGVzY3JpcHRvcikge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBpZiAoZGVzY3JpcHRvci5tZWRpYSAmJiAhd2luZG93Lm1hdGNoTWVkaWEoZGVzY3JpcHRvci5tZWRpYSkubWF0Y2hlcyB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgYGxpbmtbcmVsPVwic3R5bGVzaGVldFwiXVtocmVmPVwiJHtkZXNjcmlwdG9yLmhyZWZ9XCJdYFxuICAgICkpIHtcbiAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgfVxuICAgIGxldCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG4gICAgT2JqZWN0LmFzc2lnbihsaW5rLCBkZXNjcmlwdG9yKTtcbiAgICBmdW5jdGlvbiByZW1vdmVMaW5rKCkge1xuICAgICAgaWYgKGRvY3VtZW50LmhlYWQuY29udGFpbnMobGluaykpIHtcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZChsaW5rKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGluay5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICByZW1vdmVMaW5rKCk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfTtcbiAgICBsaW5rLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICByZW1vdmVMaW5rKCk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfTtcbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGxpbmspO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGlzUGFnZUxpbmtEZXNjcmlwdG9yKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgdHlwZW9mIG9iamVjdC5wYWdlID09PSBcInN0cmluZ1wiO1xufVxuZnVuY3Rpb24gaXNIdG1sTGlua0Rlc2NyaXB0b3Iob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAob2JqZWN0LmhyZWYgPT0gbnVsbCkge1xuICAgIHJldHVybiBvYmplY3QucmVsID09PSBcInByZWxvYWRcIiAmJiB0eXBlb2Ygb2JqZWN0LmltYWdlU3JjU2V0ID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBvYmplY3QuaW1hZ2VTaXplcyA9PT0gXCJzdHJpbmdcIjtcbiAgfVxuICByZXR1cm4gdHlwZW9mIG9iamVjdC5yZWwgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIG9iamVjdC5ocmVmID09PSBcInN0cmluZ1wiO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0S2V5ZWRQcmVmZXRjaExpbmtzKG1hdGNoZXMsIG1hbmlmZXN0LCByb3V0ZU1vZHVsZXMpIHtcbiAgbGV0IGxpbmtzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgbWF0Y2hlcy5tYXAoYXN5bmMgKG1hdGNoKSA9PiB7XG4gICAgICBsZXQgcm91dGUgPSBtYW5pZmVzdC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgICAgaWYgKHJvdXRlKSB7XG4gICAgICAgIGxldCBtb2QgPSBhd2FpdCBsb2FkUm91dGVNb2R1bGUocm91dGUsIHJvdXRlTW9kdWxlcyk7XG4gICAgICAgIHJldHVybiBtb2QubGlua3MgPyBtb2QubGlua3MoKSA6IFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0pXG4gICk7XG4gIHJldHVybiBkZWR1cGVMaW5rRGVzY3JpcHRvcnMoXG4gICAgbGlua3MuZmxhdCgxKS5maWx0ZXIoaXNIdG1sTGlua0Rlc2NyaXB0b3IpLmZpbHRlcigobGluaykgPT4gbGluay5yZWwgPT09IFwic3R5bGVzaGVldFwiIHx8IGxpbmsucmVsID09PSBcInByZWxvYWRcIikubWFwKFxuICAgICAgKGxpbmspID0+IGxpbmsucmVsID09PSBcInN0eWxlc2hlZXRcIiA/IHsgLi4ubGluaywgcmVsOiBcInByZWZldGNoXCIsIGFzOiBcInN0eWxlXCIgfSA6IHsgLi4ubGluaywgcmVsOiBcInByZWZldGNoXCIgfVxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldE5ld01hdGNoZXNGb3JMaW5rcyhwYWdlLCBuZXh0TWF0Y2hlcywgY3VycmVudE1hdGNoZXMsIG1hbmlmZXN0LCBsb2NhdGlvbiwgbW9kZSkge1xuICBsZXQgaXNOZXcgPSAobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgaWYgKCFjdXJyZW50TWF0Y2hlc1tpbmRleF0pIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBtYXRjaC5yb3V0ZS5pZCAhPT0gY3VycmVudE1hdGNoZXNbaW5kZXhdLnJvdXRlLmlkO1xuICB9O1xuICBsZXQgbWF0Y2hQYXRoQ2hhbmdlZCA9IChtYXRjaCwgaW5kZXgpID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgLy8gcGFyYW0gY2hhbmdlLCAvdXNlcnMvMTIzIC0+IC91c2Vycy80NTZcbiAgICAgIGN1cnJlbnRNYXRjaGVzW2luZGV4XS5wYXRobmFtZSAhPT0gbWF0Y2gucGF0aG5hbWUgfHwgLy8gc3BsYXQgcGFyYW0gY2hhbmdlZCwgd2hpY2ggaXMgbm90IHByZXNlbnQgaW4gbWF0Y2gucGF0aFxuICAgICAgLy8gZS5nLiAvZmlsZXMvaW1hZ2VzL2F2YXRhci5qcGcgLT4gZmlsZXMvZmluYW5jZXMueGxzXG4gICAgICBjdXJyZW50TWF0Y2hlc1tpbmRleF0ucm91dGUucGF0aD8uZW5kc1dpdGgoXCIqXCIpICYmIGN1cnJlbnRNYXRjaGVzW2luZGV4XS5wYXJhbXNbXCIqXCJdICE9PSBtYXRjaC5wYXJhbXNbXCIqXCJdXG4gICAgKTtcbiAgfTtcbiAgaWYgKG1vZGUgPT09IFwiYXNzZXRzXCIpIHtcbiAgICByZXR1cm4gbmV4dE1hdGNoZXMuZmlsdGVyKFxuICAgICAgKG1hdGNoLCBpbmRleCkgPT4gaXNOZXcobWF0Y2gsIGluZGV4KSB8fCBtYXRjaFBhdGhDaGFuZ2VkKG1hdGNoLCBpbmRleClcbiAgICApO1xuICB9XG4gIGlmIChtb2RlID09PSBcImRhdGFcIikge1xuICAgIHJldHVybiBuZXh0TWF0Y2hlcy5maWx0ZXIoKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgICAgbGV0IG1hbmlmZXN0Um91dGUgPSBtYW5pZmVzdC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgICAgaWYgKCFtYW5pZmVzdFJvdXRlIHx8ICFtYW5pZmVzdFJvdXRlLmhhc0xvYWRlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNOZXcobWF0Y2gsIGluZGV4KSB8fCBtYXRjaFBhdGhDaGFuZ2VkKG1hdGNoLCBpbmRleCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAobWF0Y2gucm91dGUuc2hvdWxkUmV2YWxpZGF0ZSkge1xuICAgICAgICBsZXQgcm91dGVDaG9pY2UgPSBtYXRjaC5yb3V0ZS5zaG91bGRSZXZhbGlkYXRlKHtcbiAgICAgICAgICBjdXJyZW50VXJsOiBuZXcgVVJMKFxuICAgICAgICAgICAgbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggKyBsb2NhdGlvbi5oYXNoLFxuICAgICAgICAgICAgd2luZG93Lm9yaWdpblxuICAgICAgICAgICksXG4gICAgICAgICAgY3VycmVudFBhcmFtczogY3VycmVudE1hdGNoZXNbMF0/LnBhcmFtcyB8fCB7fSxcbiAgICAgICAgICBuZXh0VXJsOiBuZXcgVVJMKHBhZ2UsIHdpbmRvdy5vcmlnaW4pLFxuICAgICAgICAgIG5leHRQYXJhbXM6IG1hdGNoLnBhcmFtcyxcbiAgICAgICAgICBkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiByb3V0ZUNob2ljZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICByZXR1cm4gcm91dGVDaG9pY2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIGdldE1vZHVsZUxpbmtIcmVmcyhtYXRjaGVzLCBtYW5pZmVzdCwgeyBpbmNsdWRlSHlkcmF0ZUZhbGxiYWNrIH0gPSB7fSkge1xuICByZXR1cm4gZGVkdXBlSHJlZnMoXG4gICAgbWF0Y2hlcy5tYXAoKG1hdGNoKSA9PiB7XG4gICAgICBsZXQgcm91dGUgPSBtYW5pZmVzdC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgICAgaWYgKCFyb3V0ZSkgcmV0dXJuIFtdO1xuICAgICAgbGV0IGhyZWZzID0gW3JvdXRlLm1vZHVsZV07XG4gICAgICBpZiAocm91dGUuY2xpZW50QWN0aW9uTW9kdWxlKSB7XG4gICAgICAgIGhyZWZzID0gaHJlZnMuY29uY2F0KHJvdXRlLmNsaWVudEFjdGlvbk1vZHVsZSk7XG4gICAgICB9XG4gICAgICBpZiAocm91dGUuY2xpZW50TG9hZGVyTW9kdWxlKSB7XG4gICAgICAgIGhyZWZzID0gaHJlZnMuY29uY2F0KHJvdXRlLmNsaWVudExvYWRlck1vZHVsZSk7XG4gICAgICB9XG4gICAgICBpZiAoaW5jbHVkZUh5ZHJhdGVGYWxsYmFjayAmJiByb3V0ZS5oeWRyYXRlRmFsbGJhY2tNb2R1bGUpIHtcbiAgICAgICAgaHJlZnMgPSBocmVmcy5jb25jYXQocm91dGUuaHlkcmF0ZUZhbGxiYWNrTW9kdWxlKTtcbiAgICAgIH1cbiAgICAgIGlmIChyb3V0ZS5pbXBvcnRzKSB7XG4gICAgICAgIGhyZWZzID0gaHJlZnMuY29uY2F0KHJvdXRlLmltcG9ydHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhyZWZzO1xuICAgIH0pLmZsYXQoMSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGRlZHVwZUhyZWZzKGhyZWZzKSB7XG4gIHJldHVybiBbLi4ubmV3IFNldChocmVmcyldO1xufVxuZnVuY3Rpb24gc29ydEtleXMob2JqKSB7XG4gIGxldCBzb3J0ZWQgPSB7fTtcbiAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopLnNvcnQoKTtcbiAgZm9yIChsZXQga2V5IG9mIGtleXMpIHtcbiAgICBzb3J0ZWRba2V5XSA9IG9ialtrZXldO1xuICB9XG4gIHJldHVybiBzb3J0ZWQ7XG59XG5mdW5jdGlvbiBkZWR1cGVMaW5rRGVzY3JpcHRvcnMoZGVzY3JpcHRvcnMsIHByZWxvYWRzKSB7XG4gIGxldCBzZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgcHJlbG9hZHNTZXQgPSBuZXcgU2V0KHByZWxvYWRzKTtcbiAgcmV0dXJuIGRlc2NyaXB0b3JzLnJlZHVjZSgoZGVkdXBlZCwgZGVzY3JpcHRvcikgPT4ge1xuICAgIGxldCBhbHJlYWR5TW9kdWxlUHJlbG9hZCA9IHByZWxvYWRzICYmICFpc1BhZ2VMaW5rRGVzY3JpcHRvcihkZXNjcmlwdG9yKSAmJiBkZXNjcmlwdG9yLmFzID09PSBcInNjcmlwdFwiICYmIGRlc2NyaXB0b3IuaHJlZiAmJiBwcmVsb2Fkc1NldC5oYXMoZGVzY3JpcHRvci5ocmVmKTtcbiAgICBpZiAoYWxyZWFkeU1vZHVsZVByZWxvYWQpIHtcbiAgICAgIHJldHVybiBkZWR1cGVkO1xuICAgIH1cbiAgICBsZXQga2V5ID0gSlNPTi5zdHJpbmdpZnkoc29ydEtleXMoZGVzY3JpcHRvcikpO1xuICAgIGlmICghc2V0LmhhcyhrZXkpKSB7XG4gICAgICBzZXQuYWRkKGtleSk7XG4gICAgICBkZWR1cGVkLnB1c2goeyBrZXksIGxpbms6IGRlc2NyaXB0b3IgfSk7XG4gICAgfVxuICAgIHJldHVybiBkZWR1cGVkO1xuICB9LCBbXSk7XG59XG52YXIgX2lzUHJlbG9hZFN1cHBvcnRlZDtcbmZ1bmN0aW9uIGlzUHJlbG9hZFN1cHBvcnRlZCgpIHtcbiAgaWYgKF9pc1ByZWxvYWRTdXBwb3J0ZWQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBfaXNQcmVsb2FkU3VwcG9ydGVkO1xuICB9XG4gIGxldCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuICBfaXNQcmVsb2FkU3VwcG9ydGVkID0gZWwucmVsTGlzdC5zdXBwb3J0cyhcInByZWxvYWRcIik7XG4gIGVsID0gbnVsbDtcbiAgcmV0dXJuIF9pc1ByZWxvYWRTdXBwb3J0ZWQ7XG59XG5cbi8vIGxpYi9kb20vc3NyL21hcmt1cC50c1xudmFyIEVTQ0FQRV9MT09LVVAgPSB7XG4gIFwiJlwiOiBcIlxcXFx1MDAyNlwiLFxuICBcIj5cIjogXCJcXFxcdTAwM2VcIixcbiAgXCI8XCI6IFwiXFxcXHUwMDNjXCIsXG4gIFwiXFx1MjAyOFwiOiBcIlxcXFx1MjAyOFwiLFxuICBcIlxcdTIwMjlcIjogXCJcXFxcdTIwMjlcIlxufTtcbnZhciBFU0NBUEVfUkVHRVggPSAvWyY+PFxcdTIwMjhcXHUyMDI5XS9nO1xuZnVuY3Rpb24gZXNjYXBlSHRtbChodG1sKSB7XG4gIHJldHVybiBodG1sLnJlcGxhY2UoRVNDQVBFX1JFR0VYLCAobWF0Y2gpID0+IEVTQ0FQRV9MT09LVVBbbWF0Y2hdKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUh0bWwoaHRtbCkge1xuICByZXR1cm4geyBfX2h0bWw6IGh0bWwgfTtcbn1cblxuLy8gbGliL2RvbS9zc3Ivc2luZ2xlLWZldGNoLnRzeFxudmFyIFJlYWN0NCA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpKTtcblxuLy8gdmVuZG9yL3R1cmJvLXN0cmVhbS12Mi91dGlscy50c1xudmFyIEhPTEUgPSAtMTtcbnZhciBOQU4gPSAtMjtcbnZhciBORUdBVElWRV9JTkZJTklUWSA9IC0zO1xudmFyIE5FR0FUSVZFX1pFUk8gPSAtNDtcbnZhciBOVUxMID0gLTU7XG52YXIgUE9TSVRJVkVfSU5GSU5JVFkgPSAtNjtcbnZhciBVTkRFRklORUQgPSAtNztcbnZhciBUWVBFX0JJR0lOVCA9IFwiQlwiO1xudmFyIFRZUEVfREFURSA9IFwiRFwiO1xudmFyIFRZUEVfRVJST1IgPSBcIkVcIjtcbnZhciBUWVBFX01BUCA9IFwiTVwiO1xudmFyIFRZUEVfTlVMTF9PQkpFQ1QgPSBcIk5cIjtcbnZhciBUWVBFX1BST01JU0UgPSBcIlBcIjtcbnZhciBUWVBFX1JFR0VYUCA9IFwiUlwiO1xudmFyIFRZUEVfU0VUID0gXCJTXCI7XG52YXIgVFlQRV9TWU1CT0wgPSBcIllcIjtcbnZhciBUWVBFX1VSTCA9IFwiVVwiO1xudmFyIFRZUEVfUFJFVklPVVNfUkVTT0xWRUQgPSBcIlpcIjtcbnZhciBEZWZlcnJlZDIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUxpbmVTcGxpdHRpbmdUcmFuc2Zvcm0oKSB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgbGV0IGxlZnRvdmVyID0gXCJcIjtcbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgY29uc3Qgc3RyID0gZGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgICAgY29uc3QgcGFydHMgPSAobGVmdG92ZXIgKyBzdHIpLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgbGVmdG92ZXIgPSBwYXJ0cy5wb3AoKSB8fCBcIlwiO1xuICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShwYXJ0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgIGlmIChsZWZ0b3Zlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUobGVmdG92ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbi8vIHZlbmRvci90dXJiby1zdHJlYW0tdjIvZmxhdHRlbi50c1xuZnVuY3Rpb24gZmxhdHRlbihpbnB1dCkge1xuICBjb25zdCB7IGluZGljZXMgfSA9IHRoaXM7XG4gIGNvbnN0IGV4aXN0aW5nID0gaW5kaWNlcy5nZXQoaW5wdXQpO1xuICBpZiAoZXhpc3RpbmcpIHJldHVybiBbZXhpc3RpbmddO1xuICBpZiAoaW5wdXQgPT09IHZvaWQgMCkgcmV0dXJuIFVOREVGSU5FRDtcbiAgaWYgKGlucHV0ID09PSBudWxsKSByZXR1cm4gTlVMTDtcbiAgaWYgKE51bWJlci5pc05hTihpbnB1dCkpIHJldHVybiBOQU47XG4gIGlmIChpbnB1dCA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSByZXR1cm4gUE9TSVRJVkVfSU5GSU5JVFk7XG4gIGlmIChpbnB1dCA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSByZXR1cm4gTkVHQVRJVkVfSU5GSU5JVFk7XG4gIGlmIChpbnB1dCA9PT0gMCAmJiAxIC8gaW5wdXQgPCAwKSByZXR1cm4gTkVHQVRJVkVfWkVSTztcbiAgY29uc3QgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gIGluZGljZXMuc2V0KGlucHV0LCBpbmRleCk7XG4gIHN0cmluZ2lmeS5jYWxsKHRoaXMsIGlucHV0LCBpbmRleCk7XG4gIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeShpbnB1dCwgaW5kZXgpIHtcbiAgY29uc3QgeyBkZWZlcnJlZCwgcGx1Z2lucywgcG9zdFBsdWdpbnMgfSA9IHRoaXM7XG4gIGNvbnN0IHN0ciA9IHRoaXMuc3RyaW5naWZpZWQ7XG4gIGNvbnN0IHN0YWNrID0gW1tpbnB1dCwgaW5kZXhdXTtcbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBbaW5wdXQyLCBpbmRleDJdID0gc3RhY2sucG9wKCk7XG4gICAgY29uc3QgcGFydHNGb3JPYmogPSAob2JqKSA9PiBPYmplY3Qua2V5cyhvYmopLm1hcCgoaykgPT4gYFwiXyR7ZmxhdHRlbi5jYWxsKHRoaXMsIGspfVwiOiR7ZmxhdHRlbi5jYWxsKHRoaXMsIG9ialtrXSl9YCkuam9pbihcIixcIik7XG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICBzd2l0Y2ggKHR5cGVvZiBpbnB1dDIpIHtcbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIHN0cltpbmRleDJdID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgIHN0cltpbmRleDJdID0gYFtcIiR7VFlQRV9CSUdJTlR9XCIsXCIke2lucHV0Mn1cIl1gO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzeW1ib2xcIjoge1xuICAgICAgICBjb25zdCBrZXlGb3IgPSBTeW1ib2wua2V5Rm9yKGlucHV0Mik7XG4gICAgICAgIGlmICgha2V5Rm9yKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkNhbm5vdCBlbmNvZGUgc3ltYm9sIHVubGVzcyBjcmVhdGVkIHdpdGggU3ltYm9sLmZvcigpXCJcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cltpbmRleDJdID0gYFtcIiR7VFlQRV9TWU1CT0x9XCIsJHtKU09OLnN0cmluZ2lmeShrZXlGb3IpfV1gO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIm9iamVjdFwiOiB7XG4gICAgICAgIGlmICghaW5wdXQyKSB7XG4gICAgICAgICAgc3RyW2luZGV4Ml0gPSBgJHtOVUxMfWA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoaW5wdXQyKTtcbiAgICAgICAgbGV0IHBsdWdpbkhhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFpc0FycmF5ICYmIHBsdWdpbnMpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwbHVnaW5zKSB7XG4gICAgICAgICAgICBjb25zdCBwbHVnaW5SZXN1bHQgPSBwbHVnaW4oaW5wdXQyKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBsdWdpblJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgcGx1Z2luSGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbnN0IFtwbHVnaW5JZGVudGlmaWVyLCAuLi5yZXN0XSA9IHBsdWdpblJlc3VsdDtcbiAgICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgWyR7SlNPTi5zdHJpbmdpZnkocGx1Z2luSWRlbnRpZmllcil9YDtcbiAgICAgICAgICAgICAgaWYgKHJlc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHN0cltpbmRleDJdICs9IGAsJHtyZXN0Lm1hcCgodikgPT4gZmxhdHRlbi5jYWxsKHRoaXMsIHYpKS5qb2luKFwiLFwiKX1gO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0cltpbmRleDJdICs9IFwiXVwiO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwbHVnaW5IYW5kbGVkKSB7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGlzQXJyYXkgPyBcIltcIiA6IFwie1wiO1xuICAgICAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Mi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IChpID8gXCIsXCIgOiBcIlwiKSArIChpIGluIGlucHV0MiA/IGZsYXR0ZW4uY2FsbCh0aGlzLCBpbnB1dDJbaV0pIDogSE9MRSk7XG4gICAgICAgICAgICBzdHJbaW5kZXgyXSA9IGAke3Jlc3VsdH1dYDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0MiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHN0cltpbmRleDJdID0gYFtcIiR7VFlQRV9EQVRFfVwiLCR7aW5wdXQyLmdldFRpbWUoKX1dYDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0MiBpbnN0YW5jZW9mIFVSTCkge1xuICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgW1wiJHtUWVBFX1VSTH1cIiwke0pTT04uc3RyaW5naWZ5KGlucHV0Mi5ocmVmKX1dYDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0MiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgW1wiJHtUWVBFX1JFR0VYUH1cIiwke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICBpbnB1dDIuc291cmNlXG4gICAgICAgICAgICApfSwke0pTT04uc3RyaW5naWZ5KGlucHV0Mi5mbGFncyl9XWA7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbnB1dDIgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dDIuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgW1wiJHtUWVBFX1NFVH1cIiwke1suLi5pbnB1dDJdLm1hcCgodmFsKSA9PiBmbGF0dGVuLmNhbGwodGhpcywgdmFsKSkuam9pbihcIixcIil9XWA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJbaW5kZXgyXSA9IGBbXCIke1RZUEVfU0VUfVwiXWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChpbnB1dDIgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgIGlmIChpbnB1dDIuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgW1wiJHtUWVBFX01BUH1cIiwke1suLi5pbnB1dDJdLmZsYXRNYXAoKFtrLCB2XSkgPT4gW1xuICAgICAgICAgICAgICAgIGZsYXR0ZW4uY2FsbCh0aGlzLCBrKSxcbiAgICAgICAgICAgICAgICBmbGF0dGVuLmNhbGwodGhpcywgdilcbiAgICAgICAgICAgICAgXSkuam9pbihcIixcIil9XWA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJbaW5kZXgyXSA9IGBbXCIke1RZUEVfTUFQfVwiXWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChpbnB1dDIgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICBzdHJbaW5kZXgyXSA9IGBbXCIke1RZUEVfUFJPTUlTRX1cIiwke2luZGV4Mn1dYDtcbiAgICAgICAgICAgIGRlZmVycmVkW2luZGV4Ml0gPSBpbnB1dDI7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbnB1dDIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgW1wiJHtUWVBFX0VSUk9SfVwiLCR7SlNPTi5zdHJpbmdpZnkoaW5wdXQyLm1lc3NhZ2UpfWA7XG4gICAgICAgICAgICBpZiAoaW5wdXQyLm5hbWUgIT09IFwiRXJyb3JcIikge1xuICAgICAgICAgICAgICBzdHJbaW5kZXgyXSArPSBgLCR7SlNPTi5zdHJpbmdpZnkoaW5wdXQyLm5hbWUpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJbaW5kZXgyXSArPSBcIl1cIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZihpbnB1dDIpID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdHJbaW5kZXgyXSA9IGBbXCIke1RZUEVfTlVMTF9PQkpFQ1R9XCIseyR7cGFydHNGb3JPYmooaW5wdXQyKX19XWA7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGlucHV0MikpIHtcbiAgICAgICAgICAgIHN0cltpbmRleDJdID0gYHske3BhcnRzRm9yT2JqKGlucHV0Mil9fWA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKFwiQ2Fubm90IGVuY29kZSBvYmplY3Qgd2l0aCBwcm90b3R5cGVcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShpbnB1dDIpO1xuICAgICAgICBsZXQgcGx1Z2luSGFuZGxlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoIWlzQXJyYXkgJiYgcGx1Z2lucykge1xuICAgICAgICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHBsdWdpbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBsdWdpblJlc3VsdCA9IHBsdWdpbihpbnB1dDIpO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGx1Z2luUmVzdWx0KSkge1xuICAgICAgICAgICAgICBwbHVnaW5IYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY29uc3QgW3BsdWdpbklkZW50aWZpZXIsIC4uLnJlc3RdID0gcGx1Z2luUmVzdWx0O1xuICAgICAgICAgICAgICBzdHJbaW5kZXgyXSA9IGBbJHtKU09OLnN0cmluZ2lmeShwbHVnaW5JZGVudGlmaWVyKX1gO1xuICAgICAgICAgICAgICBpZiAocmVzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgc3RyW2luZGV4Ml0gKz0gYCwke3Jlc3QubWFwKCh2KSA9PiBmbGF0dGVuLmNhbGwodGhpcywgdikpLmpvaW4oXCIsXCIpfWA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RyW2luZGV4Ml0gKz0gXCJdXCI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBsdWdpbkhhbmRsZWQpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihcIkNhbm5vdCBlbmNvZGUgZnVuY3Rpb24gb3IgdW5leHBlY3RlZCB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlcnJvcikge1xuICAgICAgbGV0IHBsdWdpbkhhbmRsZWQgPSBmYWxzZTtcbiAgICAgIGlmIChwb3N0UGx1Z2lucykge1xuICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwb3N0UGx1Z2lucykge1xuICAgICAgICAgIGNvbnN0IHBsdWdpblJlc3VsdCA9IHBsdWdpbihpbnB1dDIpO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBsdWdpblJlc3VsdCkpIHtcbiAgICAgICAgICAgIHBsdWdpbkhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgW3BsdWdpbklkZW50aWZpZXIsIC4uLnJlc3RdID0gcGx1Z2luUmVzdWx0O1xuICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgWyR7SlNPTi5zdHJpbmdpZnkocGx1Z2luSWRlbnRpZmllcil9YDtcbiAgICAgICAgICAgIGlmIChyZXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgc3RyW2luZGV4Ml0gKz0gYCwke3Jlc3QubWFwKCh2KSA9PiBmbGF0dGVuLmNhbGwodGhpcywgdikpLmpvaW4oXCIsXCIpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJbaW5kZXgyXSArPSBcIl1cIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFwbHVnaW5IYW5kbGVkKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxudmFyIG9iamVjdFByb3RvTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPYmplY3QucHJvdG90eXBlKS5zb3J0KCkuam9pbihcIlxcMFwiKTtcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodGhpbmcpIHtcbiAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpbmcpO1xuICByZXR1cm4gcHJvdG8gPT09IE9iamVjdC5wcm90b3R5cGUgfHwgcHJvdG8gPT09IG51bGwgfHwgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pLnNvcnQoKS5qb2luKFwiXFwwXCIpID09PSBvYmplY3RQcm90b05hbWVzO1xufVxuXG4vLyB2ZW5kb3IvdHVyYm8tc3RyZWFtLXYyL3VuZmxhdHRlbi50c1xudmFyIGdsb2JhbE9iaiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiB2b2lkIDA7XG5mdW5jdGlvbiB1bmZsYXR0ZW4ocGFyc2VkKSB7XG4gIGNvbnN0IHsgaHlkcmF0ZWQsIHZhbHVlcyB9ID0gdGhpcztcbiAgaWYgKHR5cGVvZiBwYXJzZWQgPT09IFwibnVtYmVyXCIpIHJldHVybiBoeWRyYXRlLmNhbGwodGhpcywgcGFyc2VkKTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhcnNlZCkgfHwgIXBhcnNlZC5sZW5ndGgpIHRocm93IG5ldyBTeW50YXhFcnJvcigpO1xuICBjb25zdCBzdGFydEluZGV4ID0gdmFsdWVzLmxlbmd0aDtcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiBwYXJzZWQpIHtcbiAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gIH1cbiAgaHlkcmF0ZWQubGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcbiAgcmV0dXJuIGh5ZHJhdGUuY2FsbCh0aGlzLCBzdGFydEluZGV4KTtcbn1cbmZ1bmN0aW9uIGh5ZHJhdGUoaW5kZXgpIHtcbiAgY29uc3QgeyBoeWRyYXRlZCwgdmFsdWVzLCBkZWZlcnJlZCwgcGx1Z2lucyB9ID0gdGhpcztcbiAgbGV0IHJlc3VsdDtcbiAgY29uc3Qgc3RhY2sgPSBbXG4gICAgW1xuICAgICAgaW5kZXgsXG4gICAgICAodikgPT4ge1xuICAgICAgICByZXN1bHQgPSB2O1xuICAgICAgfVxuICAgIF1cbiAgXTtcbiAgbGV0IHBvc3RSdW4gPSBbXTtcbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBbaW5kZXgyLCBzZXRdID0gc3RhY2sucG9wKCk7XG4gICAgc3dpdGNoIChpbmRleDIpIHtcbiAgICAgIGNhc2UgVU5ERUZJTkVEOlxuICAgICAgICBzZXQodm9pZCAwKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICBjYXNlIE5VTEw6XG4gICAgICAgIHNldChudWxsKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICBjYXNlIE5BTjpcbiAgICAgICAgc2V0KE5hTik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY2FzZSBQT1NJVElWRV9JTkZJTklUWTpcbiAgICAgICAgc2V0KEluZmluaXR5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICBjYXNlIE5FR0FUSVZFX0lORklOSVRZOlxuICAgICAgICBzZXQoLUluZmluaXR5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICBjYXNlIE5FR0FUSVZFX1pFUk86XG4gICAgICAgIHNldCgtMCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaHlkcmF0ZWRbaW5kZXgyXSkge1xuICAgICAgc2V0KGh5ZHJhdGVkW2luZGV4Ml0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2luZGV4Ml07XG4gICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGh5ZHJhdGVkW2luZGV4Ml0gPSB2YWx1ZTtcbiAgICAgIHNldCh2YWx1ZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlWzBdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IFt0eXBlLCBiLCBjXSA9IHZhbHVlO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFRZUEVfREFURTpcbiAgICAgICAgICAgIHNldChoeWRyYXRlZFtpbmRleDJdID0gbmV3IERhdGUoYikpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSBUWVBFX1VSTDpcbiAgICAgICAgICAgIHNldChoeWRyYXRlZFtpbmRleDJdID0gbmV3IFVSTChiKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFRZUEVfQklHSU5UOlxuICAgICAgICAgICAgc2V0KGh5ZHJhdGVkW2luZGV4Ml0gPSBCaWdJbnQoYikpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSBUWVBFX1JFR0VYUDpcbiAgICAgICAgICAgIHNldChoeWRyYXRlZFtpbmRleDJdID0gbmV3IFJlZ0V4cChiLCBjKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFRZUEVfU1lNQk9MOlxuICAgICAgICAgICAgc2V0KGh5ZHJhdGVkW2luZGV4Ml0gPSBTeW1ib2wuZm9yKGIpKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgVFlQRV9TRVQ6XG4gICAgICAgICAgICBjb25zdCBuZXdTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICAgICAgaHlkcmF0ZWRbaW5kZXgyXSA9IG5ld1NldDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB2YWx1ZS5sZW5ndGggLSAxOyBpID4gMDsgaS0tKVxuICAgICAgICAgICAgICBzdGFjay5wdXNoKFtcbiAgICAgICAgICAgICAgICB2YWx1ZVtpXSxcbiAgICAgICAgICAgICAgICAodikgPT4ge1xuICAgICAgICAgICAgICAgICAgbmV3U2V0LmFkZCh2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgc2V0KG5ld1NldCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFRZUEVfTUFQOlxuICAgICAgICAgICAgY29uc3QgbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGh5ZHJhdGVkW2luZGV4Ml0gPSBtYXA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdmFsdWUubGVuZ3RoIC0gMjsgaSA+IDA7IGkgLT0gMikge1xuICAgICAgICAgICAgICBjb25zdCByID0gW107XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2goW1xuICAgICAgICAgICAgICAgIHZhbHVlW2kgKyAxXSxcbiAgICAgICAgICAgICAgICAodikgPT4ge1xuICAgICAgICAgICAgICAgICAgclsxXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgc3RhY2sucHVzaChbXG4gICAgICAgICAgICAgICAgdmFsdWVbaV0sXG4gICAgICAgICAgICAgICAgKGspID0+IHtcbiAgICAgICAgICAgICAgICAgIHJbMF0gPSBrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgIHBvc3RSdW4ucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgbWFwLnNldChyWzBdLCByWzFdKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXQobWFwKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgVFlQRV9OVUxMX09CSkVDVDpcbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgaHlkcmF0ZWRbaW5kZXgyXSA9IG9iajtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGIpLnJldmVyc2UoKSkge1xuICAgICAgICAgICAgICBjb25zdCByID0gW107XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2goW1xuICAgICAgICAgICAgICAgIGJba2V5XSxcbiAgICAgICAgICAgICAgICAodikgPT4ge1xuICAgICAgICAgICAgICAgICAgclsxXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgc3RhY2sucHVzaChbXG4gICAgICAgICAgICAgICAgTnVtYmVyKGtleS5zbGljZSgxKSksXG4gICAgICAgICAgICAgICAgKGspID0+IHtcbiAgICAgICAgICAgICAgICAgIHJbMF0gPSBrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgIHBvc3RSdW4ucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgb2JqW3JbMF1dID0gclsxXTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXQob2JqKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgVFlQRV9QUk9NSVNFOlxuICAgICAgICAgICAgaWYgKGh5ZHJhdGVkW2JdKSB7XG4gICAgICAgICAgICAgIHNldChoeWRyYXRlZFtpbmRleDJdID0gaHlkcmF0ZWRbYl0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgZCA9IG5ldyBEZWZlcnJlZDIoKTtcbiAgICAgICAgICAgICAgZGVmZXJyZWRbYl0gPSBkO1xuICAgICAgICAgICAgICBzZXQoaHlkcmF0ZWRbaW5kZXgyXSA9IGQucHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFRZUEVfRVJST1I6XG4gICAgICAgICAgICBjb25zdCBbLCBtZXNzYWdlLCBlcnJvclR5cGVdID0gdmFsdWU7XG4gICAgICAgICAgICBsZXQgZXJyb3IgPSBlcnJvclR5cGUgJiYgZ2xvYmFsT2JqICYmIGdsb2JhbE9ialtlcnJvclR5cGVdID8gbmV3IGdsb2JhbE9ialtlcnJvclR5cGVdKG1lc3NhZ2UpIDogbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgaHlkcmF0ZWRbaW5kZXgyXSA9IGVycm9yO1xuICAgICAgICAgICAgc2V0KGVycm9yKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgVFlQRV9QUkVWSU9VU19SRVNPTFZFRDpcbiAgICAgICAgICAgIHNldChoeWRyYXRlZFtpbmRleDJdID0gaHlkcmF0ZWRbYl0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBsdWdpbnMpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHIgPSBbXTtcbiAgICAgICAgICAgICAgY29uc3QgdmFscyA9IHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gdmFsc1tpXTtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKFtcbiAgICAgICAgICAgICAgICAgIHYsXG4gICAgICAgICAgICAgICAgICAodjIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcltpXSA9IHYyO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBvc3RSdW4ucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0MiA9IHBsdWdpbih2YWx1ZVswXSwgLi4ucik7XG4gICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Mikge1xuICAgICAgICAgICAgICAgICAgICBzZXQoaHlkcmF0ZWRbaW5kZXgyXSA9IHJlc3VsdDIudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcigpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBbXTtcbiAgICAgICAgaHlkcmF0ZWRbaW5kZXgyXSA9IGFycmF5O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbiA9IHZhbHVlW2ldO1xuICAgICAgICAgIGlmIChuICE9PSBIT0xFKSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFtcbiAgICAgICAgICAgICAgbixcbiAgICAgICAgICAgICAgKHYpID0+IHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IHY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXQoYXJyYXkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb2JqZWN0ID0ge307XG4gICAgICBoeWRyYXRlZFtpbmRleDJdID0gb2JqZWN0O1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModmFsdWUpLnJldmVyc2UoKSkge1xuICAgICAgICBjb25zdCByID0gW107XG4gICAgICAgIHN0YWNrLnB1c2goW1xuICAgICAgICAgIHZhbHVlW2tleV0sXG4gICAgICAgICAgKHYpID0+IHtcbiAgICAgICAgICAgIHJbMV0gPSB2O1xuICAgICAgICAgIH1cbiAgICAgICAgXSk7XG4gICAgICAgIHN0YWNrLnB1c2goW1xuICAgICAgICAgIE51bWJlcihrZXkuc2xpY2UoMSkpLFxuICAgICAgICAgIChrKSA9PiB7XG4gICAgICAgICAgICByWzBdID0gaztcbiAgICAgICAgICB9XG4gICAgICAgIF0pO1xuICAgICAgICBwb3N0UnVuLnB1c2goKCkgPT4ge1xuICAgICAgICAgIG9iamVjdFtyWzBdXSA9IHJbMV07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgc2V0KG9iamVjdCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKHBvc3RSdW4ubGVuZ3RoID4gMCkge1xuICAgIHBvc3RSdW4ucG9wKCkoKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyB2ZW5kb3IvdHVyYm8tc3RyZWFtLXYyL3R1cmJvLXN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24gZGVjb2RlKHJlYWRhYmxlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgcGx1Z2lucyB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgY29uc3QgZG9uZSA9IG5ldyBEZWZlcnJlZDIoKTtcbiAgY29uc3QgcmVhZGVyID0gcmVhZGFibGUucGlwZVRocm91Z2goY3JlYXRlTGluZVNwbGl0dGluZ1RyYW5zZm9ybSgpKS5nZXRSZWFkZXIoKTtcbiAgY29uc3QgZGVjb2RlciA9IHtcbiAgICB2YWx1ZXM6IFtdLFxuICAgIGh5ZHJhdGVkOiBbXSxcbiAgICBkZWZlcnJlZDoge30sXG4gICAgcGx1Z2luc1xuICB9O1xuICBjb25zdCBkZWNvZGVkID0gYXdhaXQgZGVjb2RlSW5pdGlhbC5jYWxsKGRlY29kZXIsIHJlYWRlcik7XG4gIGxldCBkb25lUHJvbWlzZSA9IGRvbmUucHJvbWlzZTtcbiAgaWYgKGRlY29kZWQuZG9uZSkge1xuICAgIGRvbmUucmVzb2x2ZSgpO1xuICB9IGVsc2Uge1xuICAgIGRvbmVQcm9taXNlID0gZGVjb2RlRGVmZXJyZWQuY2FsbChkZWNvZGVyLCByZWFkZXIpLnRoZW4oZG9uZS5yZXNvbHZlKS5jYXRjaCgocmVhc29uKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGRlZmVycmVkIG9mIE9iamVjdC52YWx1ZXMoZGVjb2Rlci5kZWZlcnJlZCkpIHtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KHJlYXNvbik7XG4gICAgICB9XG4gICAgICBkb25lLnJlamVjdChyZWFzb24pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgZG9uZTogZG9uZVByb21pc2UudGhlbigoKSA9PiByZWFkZXIuY2xvc2VkKSxcbiAgICB2YWx1ZTogZGVjb2RlZC52YWx1ZVxuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gZGVjb2RlSW5pdGlhbChyZWFkZXIpIHtcbiAgY29uc3QgcmVhZCA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gIGlmICghcmVhZC52YWx1ZSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcigpO1xuICB9XG4gIGxldCBsaW5lO1xuICB0cnkge1xuICAgIGxpbmUgPSBKU09OLnBhcnNlKHJlYWQudmFsdWUpO1xuICB9IGNhdGNoIChyZWFzb24pIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRvbmU6IHJlYWQuZG9uZSxcbiAgICB2YWx1ZTogdW5mbGF0dGVuLmNhbGwodGhpcywgbGluZSlcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGRlY29kZURlZmVycmVkKHJlYWRlcikge1xuICBsZXQgcmVhZCA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gIHdoaWxlICghcmVhZC5kb25lKSB7XG4gICAgaWYgKCFyZWFkLnZhbHVlKSBjb250aW51ZTtcbiAgICBjb25zdCBsaW5lID0gcmVhZC52YWx1ZTtcbiAgICBzd2l0Y2ggKGxpbmVbMF0pIHtcbiAgICAgIGNhc2UgVFlQRV9QUk9NSVNFOiB7XG4gICAgICAgIGNvbnN0IGNvbG9uSW5kZXggPSBsaW5lLmluZGV4T2YoXCI6XCIpO1xuICAgICAgICBjb25zdCBkZWZlcnJlZElkID0gTnVtYmVyKGxpbmUuc2xpY2UoMSwgY29sb25JbmRleCkpO1xuICAgICAgICBjb25zdCBkZWZlcnJlZCA9IHRoaXMuZGVmZXJyZWRbZGVmZXJyZWRJZF07XG4gICAgICAgIGlmICghZGVmZXJyZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERlZmVycmVkIElEICR7ZGVmZXJyZWRJZH0gbm90IGZvdW5kIGluIHN0cmVhbWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpbmVEYXRhID0gbGluZS5zbGljZShjb2xvbkluZGV4ICsgMSk7XG4gICAgICAgIGxldCBqc29uTGluZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBqc29uTGluZSA9IEpTT04ucGFyc2UobGluZURhdGEpO1xuICAgICAgICB9IGNhdGNoIChyZWFzb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHVuZmxhdHRlbi5jYWxsKHRoaXMsIGpzb25MaW5lKTtcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBUWVBFX0VSUk9SOiB7XG4gICAgICAgIGNvbnN0IGNvbG9uSW5kZXggPSBsaW5lLmluZGV4T2YoXCI6XCIpO1xuICAgICAgICBjb25zdCBkZWZlcnJlZElkID0gTnVtYmVyKGxpbmUuc2xpY2UoMSwgY29sb25JbmRleCkpO1xuICAgICAgICBjb25zdCBkZWZlcnJlZCA9IHRoaXMuZGVmZXJyZWRbZGVmZXJyZWRJZF07XG4gICAgICAgIGlmICghZGVmZXJyZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERlZmVycmVkIElEICR7ZGVmZXJyZWRJZH0gbm90IGZvdW5kIGluIHN0cmVhbWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpbmVEYXRhID0gbGluZS5zbGljZShjb2xvbkluZGV4ICsgMSk7XG4gICAgICAgIGxldCBqc29uTGluZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBqc29uTGluZSA9IEpTT04ucGFyc2UobGluZURhdGEpO1xuICAgICAgICB9IGNhdGNoIChyZWFzb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHVuZmxhdHRlbi5jYWxsKHRoaXMsIGpzb25MaW5lKTtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoKTtcbiAgICB9XG4gICAgcmVhZCA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVuY29kZShpbnB1dCwgb3B0aW9ucykge1xuICBjb25zdCB7IHBsdWdpbnMsIHBvc3RQbHVnaW5zLCBzaWduYWwgfSA9IG9wdGlvbnMgPz8ge307XG4gIGNvbnN0IGVuY29kZXIyID0ge1xuICAgIGRlZmVycmVkOiB7fSxcbiAgICBpbmRleDogMCxcbiAgICBpbmRpY2VzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgIHN0cmluZ2lmaWVkOiBbXSxcbiAgICBwbHVnaW5zLFxuICAgIHBvc3RQbHVnaW5zLFxuICAgIHNpZ25hbFxuICB9O1xuICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBsZXQgbGFzdFNlbnRJbmRleCA9IDA7XG4gIGNvbnN0IHJlYWRhYmxlID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBpZCA9IGZsYXR0ZW4uY2FsbChlbmNvZGVyMiwgaW5wdXQpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlblwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChpZCA8IDApIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRleHRFbmNvZGVyLmVuY29kZShgJHtpZH1cbmApKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoYFske2VuY29kZXIyLnN0cmluZ2lmaWVkLmpvaW4oXCIsXCIpfV1cbmApXG4gICAgICAgICk7XG4gICAgICAgIGxhc3RTZW50SW5kZXggPSBlbmNvZGVyMi5zdHJpbmdpZmllZC5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2VlblByb21pc2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG4gICAgICBpZiAoT2JqZWN0LmtleXMoZW5jb2RlcjIuZGVmZXJyZWQpLmxlbmd0aCkge1xuICAgICAgICBsZXQgcmFjZURvbmU7XG4gICAgICAgIGNvbnN0IHJhY2VQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHJhY2VEb25lID0gcmVzb2x2ZTtcbiAgICAgICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgICAgICBjb25zdCByZWplY3RQcm9taXNlID0gKCkgPT4gcmVqZWN0KHNpZ25hbC5yZWFzb24gfHwgbmV3IEVycm9yKFwiU2lnbmFsIHdhcyBhYm9ydGVkLlwiKSk7XG4gICAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgcmVqZWN0UHJvbWlzZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3RQcm9taXNlKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlIChPYmplY3Qua2V5cyhlbmNvZGVyMi5kZWZlcnJlZCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGZvciAoY29uc3QgW2RlZmVycmVkSWQsIGRlZmVycmVkXSBvZiBPYmplY3QuZW50cmllcyhcbiAgICAgICAgICAgIGVuY29kZXIyLmRlZmVycmVkXG4gICAgICAgICAgKSkge1xuICAgICAgICAgICAgaWYgKHNlZW5Qcm9taXNlcy5oYXMoZGVmZXJyZWQpKSBjb250aW51ZTtcbiAgICAgICAgICAgIHNlZW5Qcm9taXNlcy5hZGQoXG4gICAgICAgICAgICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9Bc3NpZ25JbkV4cHJlc3Npb25zOiA8ZXhwbGFuYXRpb24+XG4gICAgICAgICAgICAgIGVuY29kZXIyLmRlZmVycmVkW051bWJlcihkZWZlcnJlZElkKV0gPSBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgICAgIHJhY2VQcm9taXNlLFxuICAgICAgICAgICAgICAgIGRlZmVycmVkXG4gICAgICAgICAgICAgIF0pLnRoZW4oXG4gICAgICAgICAgICAgICAgKHJlc29sdmVkKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBpZDIgPSBmbGF0dGVuLmNhbGwoZW5jb2RlcjIsIHJlc29sdmVkKTtcbiAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGlkMikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke1RZUEVfUFJPTUlTRX0ke2RlZmVycmVkSWR9OltbXCIke1RZUEVfUFJFVklPVVNfUkVTT0xWRUR9XCIsJHtpZDJbMF19XV1cbmBcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kZXIyLmluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTZW50SW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaWQyIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgICAgICAgICAgICAgYCR7VFlQRV9QUk9NSVNFfSR7ZGVmZXJyZWRJZH06JHtpZDJ9XG5gXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gZW5jb2RlcjIuc3RyaW5naWZpZWQuc2xpY2UobGFzdFNlbnRJbmRleCArIDEpLmpvaW4oXCIsXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgICAgICAgICAgICAgYCR7VFlQRV9QUk9NSVNFfSR7ZGVmZXJyZWRJZH06WyR7dmFsdWVzfV1cbmBcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTZW50SW5kZXggPSBlbmNvZGVyMi5zdHJpbmdpZmllZC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKCFyZWFzb24gfHwgdHlwZW9mIHJlYXNvbiAhPT0gXCJvYmplY3RcIiB8fCAhKHJlYXNvbiBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBuZXcgRXJyb3IoXCJBbiB1bmtub3duIGVycm9yIG9jY3VycmVkXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY29uc3QgaWQyID0gZmxhdHRlbi5jYWxsKGVuY29kZXIyLCByZWFzb24pO1xuICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaWQyKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgICAgICAgICAgICAgYCR7VFlQRV9FUlJPUn0ke2RlZmVycmVkSWR9OltbXCIke1RZUEVfUFJFVklPVVNfUkVTT0xWRUR9XCIsJHtpZDJbMF19XV1cbmBcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kZXIyLmluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTZW50SW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaWQyIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKGAke1RZUEVfRVJST1J9JHtkZWZlcnJlZElkfToke2lkMn1cbmApXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBlbmNvZGVyMi5zdHJpbmdpZmllZC5zbGljZShsYXN0U2VudEluZGV4ICsgMSkuam9pbihcIixcIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBgJHtUWVBFX0VSUk9SfSR7ZGVmZXJyZWRJZH06WyR7dmFsdWVzfV1cbmBcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTZW50SW5kZXggPSBlbmNvZGVyMi5zdHJpbmdpZmllZC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZW5jb2RlcjIuZGVmZXJyZWRbTnVtYmVyKGRlZmVycmVkSWQpXTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IFByb21pc2UucmFjZShPYmplY3QudmFsdWVzKGVuY29kZXIyLmRlZmVycmVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmFjZURvbmUoKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC52YWx1ZXMoZW5jb2RlcjIuZGVmZXJyZWQpKTtcbiAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVhZGFibGU7XG59XG5cbi8vIGxpYi9kb20vc3NyL2RhdGEudHNcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3RJbml0KHJlcXVlc3QpIHtcbiAgbGV0IGluaXQgPSB7IHNpZ25hbDogcmVxdWVzdC5zaWduYWwgfTtcbiAgaWYgKHJlcXVlc3QubWV0aG9kICE9PSBcIkdFVFwiKSB7XG4gICAgaW5pdC5tZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcbiAgICBsZXQgY29udGVudFR5cGUgPSByZXF1ZXN0LmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpO1xuICAgIGlmIChjb250ZW50VHlwZSAmJiAvXFxiYXBwbGljYXRpb25cXC9qc29uXFxiLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgICAgaW5pdC5oZWFkZXJzID0geyBcIkNvbnRlbnQtVHlwZVwiOiBjb250ZW50VHlwZSB9O1xuICAgICAgaW5pdC5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoYXdhaXQgcmVxdWVzdC5qc29uKCkpO1xuICAgIH0gZWxzZSBpZiAoY29udGVudFR5cGUgJiYgL1xcYnRleHRcXC9wbGFpblxcYi8udGVzdChjb250ZW50VHlwZSkpIHtcbiAgICAgIGluaXQuaGVhZGVycyA9IHsgXCJDb250ZW50LVR5cGVcIjogY29udGVudFR5cGUgfTtcbiAgICAgIGluaXQuYm9keSA9IGF3YWl0IHJlcXVlc3QudGV4dCgpO1xuICAgIH0gZWxzZSBpZiAoY29udGVudFR5cGUgJiYgL1xcYmFwcGxpY2F0aW9uXFwveC13d3ctZm9ybS11cmxlbmNvZGVkXFxiLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgICAgaW5pdC5ib2R5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhhd2FpdCByZXF1ZXN0LnRleHQoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluaXQuYm9keSA9IGF3YWl0IHJlcXVlc3QuZm9ybURhdGEoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluaXQ7XG59XG5cbi8vIGxpYi9kb20vc3NyL3NpbmdsZS1mZXRjaC50c3hcbnZhciBTaW5nbGVGZXRjaFJlZGlyZWN0U3ltYm9sID0gU3ltYm9sKFwiU2luZ2xlRmV0Y2hSZWRpcmVjdFwiKTtcbnZhciBTaW5nbGVGZXRjaE5vUmVzdWx0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbn07XG52YXIgU0lOR0xFX0ZFVENIX1JFRElSRUNUX1NUQVRVUyA9IDIwMjtcbnZhciBOT19CT0RZX1NUQVRVU19DT0RFUyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFsxMDAsIDEwMSwgMjA0LCAyMDVdKTtcbmZ1bmN0aW9uIFN0cmVhbVRyYW5zZmVyKHtcbiAgY29udGV4dCxcbiAgaWRlbnRpZmllcixcbiAgcmVhZGVyLFxuICB0ZXh0RGVjb2RlcixcbiAgbm9uY2Vcbn0pIHtcbiAgaWYgKCFjb250ZXh0LnJlbmRlck1ldGEgfHwgIWNvbnRleHQucmVuZGVyTWV0YS5kaWRSZW5kZXJTY3JpcHRzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKCFjb250ZXh0LnJlbmRlck1ldGEuc3RyZWFtQ2FjaGUpIHtcbiAgICBjb250ZXh0LnJlbmRlck1ldGEuc3RyZWFtQ2FjaGUgPSB7fTtcbiAgfVxuICBsZXQgeyBzdHJlYW1DYWNoZSB9ID0gY29udGV4dC5yZW5kZXJNZXRhO1xuICBsZXQgcHJvbWlzZSA9IHN0cmVhbUNhY2hlW2lkZW50aWZpZXJdO1xuICBpZiAoIXByb21pc2UpIHtcbiAgICBwcm9taXNlID0gc3RyZWFtQ2FjaGVbaWRlbnRpZmllcl0gPSByZWFkZXIucmVhZCgpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgc3RyZWFtQ2FjaGVbaWRlbnRpZmllcl0ucmVzdWx0ID0ge1xuICAgICAgICBkb25lOiByZXN1bHQuZG9uZSxcbiAgICAgICAgdmFsdWU6IHRleHREZWNvZGVyLmRlY29kZShyZXN1bHQudmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pXG4gICAgICB9O1xuICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICBzdHJlYW1DYWNoZVtpZGVudGlmaWVyXS5lcnJvciA9IGU7XG4gICAgfSk7XG4gIH1cbiAgaWYgKHByb21pc2UuZXJyb3IpIHtcbiAgICB0aHJvdyBwcm9taXNlLmVycm9yO1xuICB9XG4gIGlmIChwcm9taXNlLnJlc3VsdCA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgcHJvbWlzZTtcbiAgfVxuICBsZXQgeyBkb25lLCB2YWx1ZSB9ID0gcHJvbWlzZS5yZXN1bHQ7XG4gIGxldCBzY3JpcHRUYWcgPSB2YWx1ZSA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDQuY3JlYXRlRWxlbWVudChcbiAgICBcInNjcmlwdFwiLFxuICAgIHtcbiAgICAgIG5vbmNlLFxuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgX19odG1sOiBgd2luZG93Ll9fcmVhY3RSb3V0ZXJDb250ZXh0LnN0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZSgke2VzY2FwZUh0bWwoXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkodmFsdWUpXG4gICAgICAgICl9KTtgXG4gICAgICB9XG4gICAgfVxuICApIDogbnVsbDtcbiAgaWYgKGRvbmUpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0NC5jcmVhdGVFbGVtZW50KFJlYWN0NC5GcmFnbWVudCwgbnVsbCwgc2NyaXB0VGFnLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcInNjcmlwdFwiLFxuICAgICAge1xuICAgICAgICBub25jZSxcbiAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgICBfX2h0bWw6IGB3aW5kb3cuX19yZWFjdFJvdXRlckNvbnRleHQuc3RyZWFtQ29udHJvbGxlci5jbG9zZSgpO2BcbiAgICAgICAgfVxuICAgICAgfVxuICAgICkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q0LmNyZWF0ZUVsZW1lbnQoUmVhY3Q0LkZyYWdtZW50LCBudWxsLCBzY3JpcHRUYWcsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDQuY3JlYXRlRWxlbWVudChSZWFjdDQuU3VzcGVuc2UsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDQuY3JlYXRlRWxlbWVudChcbiAgICAgIFN0cmVhbVRyYW5zZmVyLFxuICAgICAge1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyICsgMSxcbiAgICAgICAgcmVhZGVyLFxuICAgICAgICB0ZXh0RGVjb2RlcixcbiAgICAgICAgbm9uY2VcbiAgICAgIH1cbiAgICApKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFR1cmJvU3RyZWFtU2luZ2xlRmV0Y2hEYXRhU3RyYXRlZ3koZ2V0Um91dGVyLCBtYW5pZmVzdCwgcm91dGVNb2R1bGVzLCBzc3IsIGJhc2VuYW1lKSB7XG4gIGxldCBkYXRhU3RyYXRlZ3kgPSBnZXRTaW5nbGVGZXRjaERhdGFTdHJhdGVneUltcGwoXG4gICAgZ2V0Um91dGVyLFxuICAgIChtYXRjaCkgPT4ge1xuICAgICAgbGV0IG1hbmlmZXN0Um91dGUgPSBtYW5pZmVzdC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgICAgaW52YXJpYW50MihtYW5pZmVzdFJvdXRlLCBcIlJvdXRlIG5vdCBmb3VuZCBpbiBtYW5pZmVzdFwiKTtcbiAgICAgIGxldCByb3V0ZU1vZHVsZSA9IHJvdXRlTW9kdWxlc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoYXNMb2FkZXI6IG1hbmlmZXN0Um91dGUuaGFzTG9hZGVyLFxuICAgICAgICBoYXNDbGllbnRMb2FkZXI6IG1hbmlmZXN0Um91dGUuaGFzQ2xpZW50TG9hZGVyLFxuICAgICAgICBoYXNTaG91bGRSZXZhbGlkYXRlOiBCb29sZWFuKHJvdXRlTW9kdWxlPy5zaG91bGRSZXZhbGlkYXRlKVxuICAgICAgfTtcbiAgICB9LFxuICAgIGZldGNoQW5kRGVjb2RlVmlhVHVyYm9TdHJlYW0sXG4gICAgc3NyLFxuICAgIGJhc2VuYW1lXG4gICk7XG4gIHJldHVybiBhc3luYyAoYXJncykgPT4gYXJncy51bnN0YWJsZV9ydW5DbGllbnRNaWRkbGV3YXJlKGRhdGFTdHJhdGVneSk7XG59XG5mdW5jdGlvbiBnZXRTaW5nbGVGZXRjaERhdGFTdHJhdGVneUltcGwoZ2V0Um91dGVyLCBnZXRSb3V0ZUluZm8sIGZldGNoQW5kRGVjb2RlLCBzc3IsIGJhc2VuYW1lKSB7XG4gIHJldHVybiBhc3luYyAoYXJncykgPT4ge1xuICAgIGxldCB7IHJlcXVlc3QsIG1hdGNoZXMsIGZldGNoZXJLZXkgfSA9IGFyZ3M7XG4gICAgbGV0IHJvdXRlciA9IGdldFJvdXRlcigpO1xuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCAhPT0gXCJHRVRcIikge1xuICAgICAgcmV0dXJuIHNpbmdsZUZldGNoQWN0aW9uU3RyYXRlZ3koYXJncywgZmV0Y2hBbmREZWNvZGUsIGJhc2VuYW1lKTtcbiAgICB9XG4gICAgbGV0IGZvdW5kUmV2YWxpZGF0aW5nU2VydmVyTG9hZGVyID0gbWF0Y2hlcy5zb21lKChtKSA9PiB7XG4gICAgICBsZXQgeyBoYXNMb2FkZXIsIGhhc0NsaWVudExvYWRlciB9ID0gZ2V0Um91dGVJbmZvKG0pO1xuICAgICAgcmV0dXJuIG0udW5zdGFibGVfc2hvdWxkQ2FsbEhhbmRsZXIoKSAmJiBoYXNMb2FkZXIgJiYgIWhhc0NsaWVudExvYWRlcjtcbiAgICB9KTtcbiAgICBpZiAoIXNzciAmJiAhZm91bmRSZXZhbGlkYXRpbmdTZXJ2ZXJMb2FkZXIpIHtcbiAgICAgIHJldHVybiBub25Tc3JTdHJhdGVneShhcmdzLCBnZXRSb3V0ZUluZm8sIGZldGNoQW5kRGVjb2RlLCBiYXNlbmFtZSk7XG4gICAgfVxuICAgIGlmIChmZXRjaGVyS2V5KSB7XG4gICAgICByZXR1cm4gc2luZ2xlRmV0Y2hMb2FkZXJGZXRjaGVyU3RyYXRlZ3koYXJncywgZmV0Y2hBbmREZWNvZGUsIGJhc2VuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpbmdsZUZldGNoTG9hZGVyTmF2aWdhdGlvblN0cmF0ZWd5KFxuICAgICAgYXJncyxcbiAgICAgIHJvdXRlcixcbiAgICAgIGdldFJvdXRlSW5mbyxcbiAgICAgIGZldGNoQW5kRGVjb2RlLFxuICAgICAgc3NyLFxuICAgICAgYmFzZW5hbWVcbiAgICApO1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gc2luZ2xlRmV0Y2hBY3Rpb25TdHJhdGVneShhcmdzLCBmZXRjaEFuZERlY29kZSwgYmFzZW5hbWUpIHtcbiAgbGV0IGFjdGlvbk1hdGNoID0gYXJncy5tYXRjaGVzLmZpbmQoKG0pID0+IG0udW5zdGFibGVfc2hvdWxkQ2FsbEhhbmRsZXIoKSk7XG4gIGludmFyaWFudDIoYWN0aW9uTWF0Y2gsIFwiTm8gYWN0aW9uIG1hdGNoIGZvdW5kXCIpO1xuICBsZXQgYWN0aW9uU3RhdHVzID0gdm9pZCAwO1xuICBsZXQgcmVzdWx0ID0gYXdhaXQgYWN0aW9uTWF0Y2gucmVzb2x2ZShhc3luYyAoaGFuZGxlcikgPT4ge1xuICAgIGxldCByZXN1bHQyID0gYXdhaXQgaGFuZGxlcihhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgeyBkYXRhOiBkYXRhMiwgc3RhdHVzIH0gPSBhd2FpdCBmZXRjaEFuZERlY29kZShhcmdzLCBiYXNlbmFtZSwgW1xuICAgICAgICBhY3Rpb25NYXRjaC5yb3V0ZS5pZFxuICAgICAgXSk7XG4gICAgICBhY3Rpb25TdGF0dXMgPSBzdGF0dXM7XG4gICAgICByZXR1cm4gdW53cmFwU2luZ2xlRmV0Y2hSZXN1bHQoZGF0YTIsIGFjdGlvbk1hdGNoLnJvdXRlLmlkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0MjtcbiAgfSk7XG4gIGlmIChpc1Jlc3BvbnNlKHJlc3VsdC5yZXN1bHQpIHx8IGlzUm91dGVFcnJvclJlc3BvbnNlKHJlc3VsdC5yZXN1bHQpIHx8IGlzRGF0YVdpdGhSZXNwb25zZUluaXQocmVzdWx0LnJlc3VsdCkpIHtcbiAgICByZXR1cm4geyBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHtcbiAgICAgIHR5cGU6IHJlc3VsdC50eXBlLFxuICAgICAgcmVzdWx0OiBkYXRhKHJlc3VsdC5yZXN1bHQsIGFjdGlvblN0YXR1cylcbiAgICB9XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBub25Tc3JTdHJhdGVneShhcmdzLCBnZXRSb3V0ZUluZm8sIGZldGNoQW5kRGVjb2RlLCBiYXNlbmFtZSkge1xuICBsZXQgbWF0Y2hlc1RvTG9hZCA9IGFyZ3MubWF0Y2hlcy5maWx0ZXIoXG4gICAgKG0pID0+IG0udW5zdGFibGVfc2hvdWxkQ2FsbEhhbmRsZXIoKVxuICApO1xuICBsZXQgcmVzdWx0cyA9IHt9O1xuICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICBtYXRjaGVzVG9Mb2FkLm1hcChcbiAgICAgIChtKSA9PiBtLnJlc29sdmUoYXN5bmMgKGhhbmRsZXIpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgeyBoYXNDbGllbnRMb2FkZXIgfSA9IGdldFJvdXRlSW5mbyhtKTtcbiAgICAgICAgICBsZXQgcm91dGVJZCA9IG0ucm91dGUuaWQ7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGhhc0NsaWVudExvYWRlciA/IGF3YWl0IGhhbmRsZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHsgZGF0YTogZGF0YTIgfSA9IGF3YWl0IGZldGNoQW5kRGVjb2RlKGFyZ3MsIGJhc2VuYW1lLCBbcm91dGVJZF0pO1xuICAgICAgICAgICAgcmV0dXJuIHVud3JhcFNpbmdsZUZldGNoUmVzdWx0KGRhdGEyLCByb3V0ZUlkKTtcbiAgICAgICAgICB9KSA6IGF3YWl0IGhhbmRsZXIoKTtcbiAgICAgICAgICByZXN1bHRzW20ucm91dGUuaWRdID0geyB0eXBlOiBcImRhdGFcIiwgcmVzdWx0IH07XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXN1bHRzW20ucm91dGUuaWRdID0geyB0eXBlOiBcImVycm9yXCIsIHJlc3VsdDogZSB9O1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIClcbiAgKTtcbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5hc3luYyBmdW5jdGlvbiBzaW5nbGVGZXRjaExvYWRlck5hdmlnYXRpb25TdHJhdGVneShhcmdzLCByb3V0ZXIsIGdldFJvdXRlSW5mbywgZmV0Y2hBbmREZWNvZGUsIHNzciwgYmFzZW5hbWUpIHtcbiAgbGV0IHJvdXRlc1BhcmFtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBmb3VuZE9wdE91dFJvdXRlID0gZmFsc2U7XG4gIGxldCByb3V0ZURmZHMgPSBhcmdzLm1hdGNoZXMubWFwKCgpID0+IGNyZWF0ZURlZmVycmVkMigpKTtcbiAgbGV0IHNpbmdsZUZldGNoRGZkID0gY3JlYXRlRGVmZXJyZWQyKCk7XG4gIGxldCByZXN1bHRzID0ge307XG4gIGxldCByZXNvbHZlUHJvbWlzZSA9IFByb21pc2UuYWxsKFxuICAgIGFyZ3MubWF0Y2hlcy5tYXAoXG4gICAgICBhc3luYyAobSwgaSkgPT4gbS5yZXNvbHZlKGFzeW5jIChoYW5kbGVyKSA9PiB7XG4gICAgICAgIHJvdXRlRGZkc1tpXS5yZXNvbHZlKCk7XG4gICAgICAgIGxldCByb3V0ZUlkID0gbS5yb3V0ZS5pZDtcbiAgICAgICAgbGV0IHsgaGFzTG9hZGVyLCBoYXNDbGllbnRMb2FkZXIsIGhhc1Nob3VsZFJldmFsaWRhdGUgfSA9IGdldFJvdXRlSW5mbyhtKTtcbiAgICAgICAgbGV0IGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlID0gIW0udW5zdGFibGVfc2hvdWxkUmV2YWxpZGF0ZUFyZ3MgfHwgbS51bnN0YWJsZV9zaG91bGRSZXZhbGlkYXRlQXJncy5hY3Rpb25TdGF0dXMgPT0gbnVsbCB8fCBtLnVuc3RhYmxlX3Nob3VsZFJldmFsaWRhdGVBcmdzLmFjdGlvblN0YXR1cyA8IDQwMDtcbiAgICAgICAgbGV0IHNob3VsZENhbGwgPSBtLnVuc3RhYmxlX3Nob3VsZENhbGxIYW5kbGVyKGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlKTtcbiAgICAgICAgaWYgKCFzaG91bGRDYWxsKSB7XG4gICAgICAgICAgZm91bmRPcHRPdXRSb3V0ZSB8fCAoZm91bmRPcHRPdXRSb3V0ZSA9IG0udW5zdGFibGVfc2hvdWxkUmV2YWxpZGF0ZUFyZ3MgIT0gbnVsbCAmJiAvLyBUaGlzIGlzIGEgcmV2YWxpZGF0aW9uLFxuICAgICAgICAgIGhhc0xvYWRlciAmJiAvLyBmb3IgYSByb3V0ZSB3aXRoIGEgc2VydmVyIGxvYWRlcixcbiAgICAgICAgICBoYXNTaG91bGRSZXZhbGlkYXRlID09PSB0cnVlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0NsaWVudExvYWRlcikge1xuICAgICAgICAgIGlmIChoYXNMb2FkZXIpIHtcbiAgICAgICAgICAgIGZvdW5kT3B0T3V0Um91dGUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGhhbmRsZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICBsZXQgeyBkYXRhOiBkYXRhMiB9ID0gYXdhaXQgZmV0Y2hBbmREZWNvZGUoYXJncywgYmFzZW5hbWUsIFtyb3V0ZUlkXSk7XG4gICAgICAgICAgICAgIHJldHVybiB1bndyYXBTaW5nbGVGZXRjaFJlc3VsdChkYXRhMiwgcm91dGVJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3VsdHNbcm91dGVJZF0gPSB7IHR5cGU6IFwiZGF0YVwiLCByZXN1bHQgfTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXN1bHRzW3JvdXRlSWRdID0geyB0eXBlOiBcImVycm9yXCIsIHJlc3VsdDogZSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0xvYWRlcikge1xuICAgICAgICAgIHJvdXRlc1BhcmFtcy5hZGQocm91dGVJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgaGFuZGxlcihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgZGF0YTIgPSBhd2FpdCBzaW5nbGVGZXRjaERmZC5wcm9taXNlO1xuICAgICAgICAgICAgcmV0dXJuIHVud3JhcFNpbmdsZUZldGNoUmVzdWx0KGRhdGEyLCByb3V0ZUlkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXN1bHRzW3JvdXRlSWRdID0geyB0eXBlOiBcImRhdGFcIiwgcmVzdWx0IH07XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXN1bHRzW3JvdXRlSWRdID0geyB0eXBlOiBcImVycm9yXCIsIHJlc3VsdDogZSB9O1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIClcbiAgKTtcbiAgYXdhaXQgUHJvbWlzZS5hbGwocm91dGVEZmRzLm1hcCgoZCkgPT4gZC5wcm9taXNlKSk7XG4gIGxldCBpc0luaXRpYWxMb2FkID0gIXJvdXRlci5zdGF0ZS5pbml0aWFsaXplZCAmJiByb3V0ZXIuc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJpZGxlXCI7XG4gIGlmICgoaXNJbml0aWFsTG9hZCB8fCByb3V0ZXNQYXJhbXMuc2l6ZSA9PT0gMCkgJiYgIXdpbmRvdy5fX3JlYWN0Um91dGVySGRyQWN0aXZlKSB7XG4gICAgc2luZ2xlRmV0Y2hEZmQucmVzb2x2ZSh7IHJvdXRlczoge30gfSk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHRhcmdldFJvdXRlcyA9IHNzciAmJiBmb3VuZE9wdE91dFJvdXRlICYmIHJvdXRlc1BhcmFtcy5zaXplID4gMCA/IFsuLi5yb3V0ZXNQYXJhbXMua2V5cygpXSA6IHZvaWQgMDtcbiAgICB0cnkge1xuICAgICAgbGV0IGRhdGEyID0gYXdhaXQgZmV0Y2hBbmREZWNvZGUoYXJncywgYmFzZW5hbWUsIHRhcmdldFJvdXRlcyk7XG4gICAgICBzaW5nbGVGZXRjaERmZC5yZXNvbHZlKGRhdGEyLmRhdGEpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHNpbmdsZUZldGNoRGZkLnJlamVjdChlKTtcbiAgICB9XG4gIH1cbiAgYXdhaXQgcmVzb2x2ZVByb21pc2U7XG4gIGF3YWl0IGJ1YmJsZU1pZGRsZXdhcmVFcnJvcnMoXG4gICAgc2luZ2xlRmV0Y2hEZmQucHJvbWlzZSxcbiAgICBhcmdzLm1hdGNoZXMsXG4gICAgcm91dGVzUGFyYW1zLFxuICAgIHJlc3VsdHNcbiAgKTtcbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5hc3luYyBmdW5jdGlvbiBidWJibGVNaWRkbGV3YXJlRXJyb3JzKHNpbmdsZUZldGNoUHJvbWlzZSwgbWF0Y2hlcywgcm91dGVzUGFyYW1zLCByZXN1bHRzKSB7XG4gIHRyeSB7XG4gICAgbGV0IG1pZGRsZXdhcmVFcnJvcjtcbiAgICBsZXQgZmV0Y2hlZERhdGEgPSBhd2FpdCBzaW5nbGVGZXRjaFByb21pc2U7XG4gICAgaWYgKFwicm91dGVzXCIgaW4gZmV0Y2hlZERhdGEpIHtcbiAgICAgIGZvciAobGV0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICAgICAgaWYgKG1hdGNoLnJvdXRlLmlkIGluIGZldGNoZWREYXRhLnJvdXRlcykge1xuICAgICAgICAgIGxldCByb3V0ZVJlc3VsdCA9IGZldGNoZWREYXRhLnJvdXRlc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgICAgICAgaWYgKFwiZXJyb3JcIiBpbiByb3V0ZVJlc3VsdCkge1xuICAgICAgICAgICAgbWlkZGxld2FyZUVycm9yID0gcm91dGVSZXN1bHQuZXJyb3I7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1pZGRsZXdhcmVFcnJvciAhPT0gdm9pZCAwKSB7XG4gICAgICBBcnJheS5mcm9tKHJvdXRlc1BhcmFtcy52YWx1ZXMoKSkuZm9yRWFjaCgocm91dGVJZCkgPT4ge1xuICAgICAgICBpZiAocmVzdWx0c1tyb3V0ZUlkXS5yZXN1bHQgaW5zdGFuY2VvZiBTaW5nbGVGZXRjaE5vUmVzdWx0RXJyb3IpIHtcbiAgICAgICAgICByZXN1bHRzW3JvdXRlSWRdLnJlc3VsdCA9IG1pZGRsZXdhcmVFcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHNpbmdsZUZldGNoTG9hZGVyRmV0Y2hlclN0cmF0ZWd5KGFyZ3MsIGZldGNoQW5kRGVjb2RlLCBiYXNlbmFtZSkge1xuICBsZXQgZmV0Y2hlck1hdGNoID0gYXJncy5tYXRjaGVzLmZpbmQoKG0pID0+IG0udW5zdGFibGVfc2hvdWxkQ2FsbEhhbmRsZXIoKSk7XG4gIGludmFyaWFudDIoZmV0Y2hlck1hdGNoLCBcIk5vIGZldGNoZXIgbWF0Y2ggZm91bmRcIik7XG4gIGxldCByb3V0ZUlkID0gZmV0Y2hlck1hdGNoLnJvdXRlLmlkO1xuICBsZXQgcmVzdWx0ID0gYXdhaXQgZmV0Y2hlck1hdGNoLnJlc29sdmUoXG4gICAgYXN5bmMgKGhhbmRsZXIpID0+IGhhbmRsZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHsgZGF0YTogZGF0YTIgfSA9IGF3YWl0IGZldGNoQW5kRGVjb2RlKGFyZ3MsIGJhc2VuYW1lLCBbcm91dGVJZF0pO1xuICAgICAgcmV0dXJuIHVud3JhcFNpbmdsZUZldGNoUmVzdWx0KGRhdGEyLCByb3V0ZUlkKTtcbiAgICB9KVxuICApO1xuICByZXR1cm4geyBbZmV0Y2hlck1hdGNoLnJvdXRlLmlkXTogcmVzdWx0IH07XG59XG5mdW5jdGlvbiBzdHJpcEluZGV4UGFyYW0odXJsKSB7XG4gIGxldCBpbmRleFZhbHVlcyA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0QWxsKFwiaW5kZXhcIik7XG4gIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKFwiaW5kZXhcIik7XG4gIGxldCBpbmRleFZhbHVlc1RvS2VlcCA9IFtdO1xuICBmb3IgKGxldCBpbmRleFZhbHVlIG9mIGluZGV4VmFsdWVzKSB7XG4gICAgaWYgKGluZGV4VmFsdWUpIHtcbiAgICAgIGluZGV4VmFsdWVzVG9LZWVwLnB1c2goaW5kZXhWYWx1ZSk7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IHRvS2VlcCBvZiBpbmRleFZhbHVlc1RvS2VlcCkge1xuICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwiaW5kZXhcIiwgdG9LZWVwKTtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuZnVuY3Rpb24gc2luZ2xlRmV0Y2hVcmwocmVxVXJsLCBiYXNlbmFtZSkge1xuICBsZXQgdXJsID0gdHlwZW9mIHJlcVVybCA9PT0gXCJzdHJpbmdcIiA/IG5ldyBVUkwoXG4gICAgcmVxVXJsLFxuICAgIC8vIFRoaXMgY2FuIGJlIGNhbGxlZCBkdXJpbmcgdGhlIFNTUiBmbG93IHZpYSBQcmVmZXRjaFBhZ2VMaW5rc0ltcGwgc29cbiAgICAvLyBkb24ndCBhc3N1bWUgd2luZG93IGlzIGF2YWlsYWJsZVxuICAgIHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyBcInNlcnZlcjovL3NpbmdsZWZldGNoL1wiIDogd2luZG93LmxvY2F0aW9uLm9yaWdpblxuICApIDogcmVxVXJsO1xuICBpZiAodXJsLnBhdGhuYW1lID09PSBcIi9cIikge1xuICAgIHVybC5wYXRobmFtZSA9IFwiX3Jvb3QuZGF0YVwiO1xuICB9IGVsc2UgaWYgKGJhc2VuYW1lICYmIHN0cmlwQmFzZW5hbWUodXJsLnBhdGhuYW1lLCBiYXNlbmFtZSkgPT09IFwiL1wiKSB7XG4gICAgdXJsLnBhdGhuYW1lID0gYCR7YmFzZW5hbWUucmVwbGFjZSgvXFwvJC8sIFwiXCIpfS9fcm9vdC5kYXRhYDtcbiAgfSBlbHNlIHtcbiAgICB1cmwucGF0aG5hbWUgPSBgJHt1cmwucGF0aG5hbWUucmVwbGFjZSgvXFwvJC8sIFwiXCIpfS5kYXRhYDtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hBbmREZWNvZGVWaWFUdXJib1N0cmVhbShhcmdzLCBiYXNlbmFtZSwgdGFyZ2V0Um91dGVzKSB7XG4gIGxldCB7IHJlcXVlc3QgfSA9IGFyZ3M7XG4gIGxldCB1cmwgPSBzaW5nbGVGZXRjaFVybChyZXF1ZXN0LnVybCwgYmFzZW5hbWUpO1xuICBpZiAocmVxdWVzdC5tZXRob2QgPT09IFwiR0VUXCIpIHtcbiAgICB1cmwgPSBzdHJpcEluZGV4UGFyYW0odXJsKTtcbiAgICBpZiAodGFyZ2V0Um91dGVzKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcIl9yb3V0ZXNcIiwgdGFyZ2V0Um91dGVzLmpvaW4oXCIsXCIpKTtcbiAgICB9XG4gIH1cbiAgbGV0IHJlcyA9IGF3YWl0IGZldGNoKHVybCwgYXdhaXQgY3JlYXRlUmVxdWVzdEluaXQocmVxdWVzdCkpO1xuICBpZiAocmVzLnN0YXR1cyA9PT0gNDA0ICYmICFyZXMuaGVhZGVycy5oYXMoXCJYLVJlbWl4LVJlc3BvbnNlXCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yUmVzcG9uc2VJbXBsKDQwNCwgXCJOb3QgRm91bmRcIiwgdHJ1ZSk7XG4gIH1cbiAgaWYgKHJlcy5zdGF0dXMgPT09IDIwNCAmJiByZXMuaGVhZGVycy5oYXMoXCJYLVJlbWl4LVJlZGlyZWN0XCIpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogU0lOR0xFX0ZFVENIX1JFRElSRUNUX1NUQVRVUyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcmVkaXJlY3Q6IHtcbiAgICAgICAgICByZWRpcmVjdDogcmVzLmhlYWRlcnMuZ2V0KFwiWC1SZW1peC1SZWRpcmVjdFwiKSxcbiAgICAgICAgICBzdGF0dXM6IE51bWJlcihyZXMuaGVhZGVycy5nZXQoXCJYLVJlbWl4LVN0YXR1c1wiKSB8fCBcIjMwMlwiKSxcbiAgICAgICAgICByZXZhbGlkYXRlOiByZXMuaGVhZGVycy5nZXQoXCJYLVJlbWl4LVJldmFsaWRhdGVcIikgPT09IFwidHJ1ZVwiLFxuICAgICAgICAgIHJlbG9hZDogcmVzLmhlYWRlcnMuZ2V0KFwiWC1SZW1peC1SZWxvYWQtRG9jdW1lbnRcIikgPT09IFwidHJ1ZVwiLFxuICAgICAgICAgIHJlcGxhY2U6IHJlcy5oZWFkZXJzLmdldChcIlgtUmVtaXgtUmVwbGFjZVwiKSA9PT0gXCJ0cnVlXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgaWYgKE5PX0JPRFlfU1RBVFVTX0NPREVTLmhhcyhyZXMuc3RhdHVzKSkge1xuICAgIGxldCByb3V0ZXMgPSB7fTtcbiAgICBpZiAodGFyZ2V0Um91dGVzICYmIHJlcXVlc3QubWV0aG9kICE9PSBcIkdFVFwiKSB7XG4gICAgICByb3V0ZXNbdGFyZ2V0Um91dGVzWzBdXSA9IHsgZGF0YTogdm9pZCAwIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6IHJlcy5zdGF0dXMsXG4gICAgICBkYXRhOiB7IHJvdXRlcyB9XG4gICAgfTtcbiAgfVxuICBpbnZhcmlhbnQyKHJlcy5ib2R5LCBcIk5vIHJlc3BvbnNlIGJvZHkgdG8gZGVjb2RlXCIpO1xuICB0cnkge1xuICAgIGxldCBkZWNvZGVkID0gYXdhaXQgZGVjb2RlVmlhVHVyYm9TdHJlYW0ocmVzLmJvZHksIHdpbmRvdyk7XG4gICAgbGV0IGRhdGEyO1xuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gXCJHRVRcIikge1xuICAgICAgbGV0IHR5cGVkID0gZGVjb2RlZC52YWx1ZTtcbiAgICAgIGlmIChTaW5nbGVGZXRjaFJlZGlyZWN0U3ltYm9sIGluIHR5cGVkKSB7XG4gICAgICAgIGRhdGEyID0geyByZWRpcmVjdDogdHlwZWRbU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbF0gfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEyID0geyByb3V0ZXM6IHR5cGVkIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB0eXBlZCA9IGRlY29kZWQudmFsdWU7XG4gICAgICBsZXQgcm91dGVJZCA9IHRhcmdldFJvdXRlcz8uWzBdO1xuICAgICAgaW52YXJpYW50Mihyb3V0ZUlkLCBcIk5vIHJvdXRlSWQgZm91bmQgZm9yIHNpbmdsZSBmZXRjaCBjYWxsIGRlY29kaW5nXCIpO1xuICAgICAgaWYgKFwicmVkaXJlY3RcIiBpbiB0eXBlZCkge1xuICAgICAgICBkYXRhMiA9IHsgcmVkaXJlY3Q6IHR5cGVkIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhMiA9IHsgcm91dGVzOiB7IFtyb3V0ZUlkXTogdHlwZWQgfSB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdGF0dXM6IHJlcy5zdGF0dXMsIGRhdGE6IGRhdGEyIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZGVjb2RlIHR1cmJvLXN0cmVhbSByZXNwb25zZVwiKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVjb2RlVmlhVHVyYm9TdHJlYW0oYm9keSwgZ2xvYmFsMikge1xuICByZXR1cm4gZGVjb2RlKGJvZHksIHtcbiAgICBwbHVnaW5zOiBbXG4gICAgICAodHlwZSwgLi4ucmVzdCkgPT4ge1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJTYW5pdGl6ZWRFcnJvclwiKSB7XG4gICAgICAgICAgbGV0IFtuYW1lLCBtZXNzYWdlLCBzdGFja10gPSByZXN0O1xuICAgICAgICAgIGxldCBDb25zdHJ1Y3RvciA9IEVycm9yO1xuICAgICAgICAgIGlmIChuYW1lICYmIG5hbWUgaW4gZ2xvYmFsMiAmJiB0eXBlb2YgZ2xvYmFsMltuYW1lXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBDb25zdHJ1Y3RvciA9IGdsb2JhbDJbbmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBlcnJvciA9IG5ldyBDb25zdHJ1Y3RvcihtZXNzYWdlKTtcbiAgICAgICAgICBlcnJvci5zdGFjayA9IHN0YWNrO1xuICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBlcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBcIkVycm9yUmVzcG9uc2VcIikge1xuICAgICAgICAgIGxldCBbZGF0YTIsIHN0YXR1cywgc3RhdHVzVGV4dF0gPSByZXN0O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogbmV3IEVycm9yUmVzcG9uc2VJbXBsKHN0YXR1cywgc3RhdHVzVGV4dCwgZGF0YTIpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gXCJTaW5nbGVGZXRjaFJlZGlyZWN0XCIpIHtcbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogeyBbU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbF06IHJlc3RbMF0gfSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBcIlNpbmdsZUZldGNoQ2xhc3NJbnN0YW5jZVwiKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHJlc3RbMF0gfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gXCJTaW5nbGVGZXRjaEZhbGxiYWNrXCIpIHtcbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdm9pZCAwIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdXG4gIH0pO1xufVxuZnVuY3Rpb24gdW53cmFwU2luZ2xlRmV0Y2hSZXN1bHQocmVzdWx0LCByb3V0ZUlkKSB7XG4gIGlmIChcInJlZGlyZWN0XCIgaW4gcmVzdWx0KSB7XG4gICAgbGV0IHtcbiAgICAgIHJlZGlyZWN0OiBsb2NhdGlvbixcbiAgICAgIHJldmFsaWRhdGUsXG4gICAgICByZWxvYWQsXG4gICAgICByZXBsYWNlOiByZXBsYWNlMixcbiAgICAgIHN0YXR1c1xuICAgIH0gPSByZXN1bHQucmVkaXJlY3Q7XG4gICAgdGhyb3cgcmVkaXJlY3QobG9jYXRpb24sIHtcbiAgICAgIHN0YXR1cyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgLy8gVGhyZWUgUidzIG9mIHJlZGlyZWN0aW5nIChsb2wgVmVlcClcbiAgICAgICAgLi4ucmV2YWxpZGF0ZSA/IHsgXCJYLVJlbWl4LVJldmFsaWRhdGVcIjogXCJ5ZXNcIiB9IDogbnVsbCxcbiAgICAgICAgLi4ucmVsb2FkID8geyBcIlgtUmVtaXgtUmVsb2FkLURvY3VtZW50XCI6IFwieWVzXCIgfSA6IG51bGwsXG4gICAgICAgIC4uLnJlcGxhY2UyID8geyBcIlgtUmVtaXgtUmVwbGFjZVwiOiBcInllc1wiIH0gOiBudWxsXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbGV0IHJvdXRlUmVzdWx0ID0gcmVzdWx0LnJvdXRlc1tyb3V0ZUlkXTtcbiAgaWYgKHJvdXRlUmVzdWx0ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgU2luZ2xlRmV0Y2hOb1Jlc3VsdEVycm9yKFxuICAgICAgYE5vIHJlc3VsdCBmb3VuZCBmb3Igcm91dGVJZCBcIiR7cm91dGVJZH1cImBcbiAgICApO1xuICB9IGVsc2UgaWYgKFwiZXJyb3JcIiBpbiByb3V0ZVJlc3VsdCkge1xuICAgIHRocm93IHJvdXRlUmVzdWx0LmVycm9yO1xuICB9IGVsc2UgaWYgKFwiZGF0YVwiIGluIHJvdXRlUmVzdWx0KSB7XG4gICAgcmV0dXJuIHJvdXRlUmVzdWx0LmRhdGE7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJlc3BvbnNlIGZvdW5kIGZvciByb3V0ZUlkIFwiJHtyb3V0ZUlkfVwiYCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZURlZmVycmVkMigpIHtcbiAgbGV0IHJlc29sdmU7XG4gIGxldCByZWplY3Q7XG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgcmVzb2x2ZSA9IGFzeW5jICh2YWwpID0+IHtcbiAgICAgIHJlcyh2YWwpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJlamVjdCA9IGFzeW5jIChlcnJvcikgPT4ge1xuICAgICAgcmVqKGVycm9yKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHByb21pc2U7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcHJvbWlzZSxcbiAgICAvL0B0cy1pZ25vcmVcbiAgICByZXNvbHZlLFxuICAgIC8vQHRzLWlnbm9yZVxuICAgIHJlamVjdFxuICB9O1xufVxuXG4vLyBsaWIvZG9tL3Nzci9mb2ctb2Ytd2FyLnRzXG52YXIgUmVhY3Q4ID0gX190b0VTTShyZXF1aXJlKFwicmVhY3RcIikpO1xuXG4vLyBsaWIvZG9tL3Nzci9yb3V0ZXMudHN4XG52YXIgUmVhY3Q3ID0gX190b0VTTShyZXF1aXJlKFwicmVhY3RcIikpO1xuXG4vLyBsaWIvZG9tL3Nzci9lcnJvckJvdW5kYXJpZXMudHN4XG52YXIgUmVhY3Q1ID0gX190b0VTTShyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIFJlbWl4RXJyb3JCb3VuZGFyeSA9IGNsYXNzIGV4dGVuZHMgUmVhY3Q1LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7IGVycm9yOiBwcm9wcy5lcnJvciB8fCBudWxsLCBsb2NhdGlvbjogcHJvcHMubG9jYXRpb24gfTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIHsgZXJyb3IgfTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzLCBzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5sb2NhdGlvbiAhPT0gcHJvcHMubG9jYXRpb24pIHtcbiAgICAgIHJldHVybiB7IGVycm9yOiBwcm9wcy5lcnJvciB8fCBudWxsLCBsb2NhdGlvbjogcHJvcHMubG9jYXRpb24gfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZXJyb3I6IHByb3BzLmVycm9yIHx8IHN0YXRlLmVycm9yLCBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24gfTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuZXJyb3IpIHtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIFJlbWl4Um9vdERlZmF1bHRFcnJvckJvdW5kYXJ5LFxuICAgICAgICB7XG4gICAgICAgICAgZXJyb3I6IHRoaXMuc3RhdGUuZXJyb3IsXG4gICAgICAgICAgaXNPdXRzaWRlUmVtaXhBcHA6IHRydWVcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gUmVtaXhSb290RGVmYXVsdEVycm9yQm91bmRhcnkoe1xuICBlcnJvcixcbiAgaXNPdXRzaWRlUmVtaXhBcHBcbn0pIHtcbiAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gIGxldCBoZXlEZXZlbG9wZXIgPSAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJzY3JpcHRcIixcbiAgICB7XG4gICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgICBfX2h0bWw6IGBcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgXCJcXHV7MUY0QkZ9IEhleSBkZXZlbG9wZXIgXFx1ezFGNDRCfS4gWW91IGNhbiBwcm92aWRlIGEgd2F5IGJldHRlciBVWCB0aGFuIHRoaXMgd2hlbiB5b3VyIGFwcCB0aHJvd3MgZXJyb3JzLiBDaGVjayBvdXQgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG93LXRvL2Vycm9yLWJvdW5kYXJ5IGZvciBtb3JlIGluZm9ybWF0aW9uLlwiXG4gICAgICAgICk7XG4gICAgICBgXG4gICAgICB9XG4gICAgfVxuICApO1xuICBpZiAoaXNSb3V0ZUVycm9yUmVzcG9uc2UoZXJyb3IpKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChCb3VuZGFyeVNoZWxsLCB7IHRpdGxlOiBcIlVuaGFuZGxlZCBUaHJvd24gUmVzcG9uc2UhXCIgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFwiaDFcIiwgeyBzdHlsZTogeyBmb250U2l6ZTogXCIyNHB4XCIgfSB9LCBlcnJvci5zdGF0dXMsIFwiIFwiLCBlcnJvci5zdGF0dXNUZXh0KSwgRU5BQkxFX0RFVl9XQVJOSU5HUyA/IGhleURldmVsb3BlciA6IG51bGwpO1xuICB9XG4gIGxldCBlcnJvckluc3RhbmNlO1xuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIGVycm9ySW5zdGFuY2UgPSBlcnJvcjtcbiAgfSBlbHNlIHtcbiAgICBsZXQgZXJyb3JTdHJpbmcgPSBlcnJvciA9PSBudWxsID8gXCJVbmtub3duIEVycm9yXCIgOiB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiYgXCJ0b1N0cmluZ1wiIGluIGVycm9yID8gZXJyb3IudG9TdHJpbmcoKSA6IEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbiAgICBlcnJvckluc3RhbmNlID0gbmV3IEVycm9yKGVycm9yU3RyaW5nKTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFxuICAgIEJvdW5kYXJ5U2hlbGwsXG4gICAge1xuICAgICAgdGl0bGU6IFwiQXBwbGljYXRpb24gRXJyb3IhXCIsXG4gICAgICBpc091dHNpZGVSZW1peEFwcFxuICAgIH0sXG4gICAgLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFwiaDFcIiwgeyBzdHlsZTogeyBmb250U2l6ZTogXCIyNHB4XCIgfSB9LCBcIkFwcGxpY2F0aW9uIEVycm9yXCIpLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcbiAgICAgIFwicHJlXCIsXG4gICAgICB7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgcGFkZGluZzogXCIycmVtXCIsXG4gICAgICAgICAgYmFja2dyb3VuZDogXCJoc2xhKDEwLCA1MCUsIDUwJSwgMC4xKVwiLFxuICAgICAgICAgIGNvbG9yOiBcInJlZFwiLFxuICAgICAgICAgIG92ZXJmbG93OiBcImF1dG9cIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXJyb3JJbnN0YW5jZS5zdGFja1xuICAgICksXG4gICAgaGV5RGV2ZWxvcGVyXG4gICk7XG59XG5mdW5jdGlvbiBCb3VuZGFyeVNoZWxsKHtcbiAgdGl0bGUsXG4gIHJlbmRlclNjcmlwdHMsXG4gIGlzT3V0c2lkZVJlbWl4QXBwLFxuICBjaGlsZHJlblxufSkge1xuICBsZXQgeyByb3V0ZU1vZHVsZXMgfSA9IHVzZUZyYW1ld29ya0NvbnRleHQoKTtcbiAgaWYgKHJvdXRlTW9kdWxlcy5yb290Py5MYXlvdXQgJiYgIWlzT3V0c2lkZVJlbWl4QXBwKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoXCJodG1sXCIsIHsgbGFuZzogXCJlblwiIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcImhlYWRcIiwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7IGNoYXJTZXQ6IFwidXRmLThcIiB9KSwgLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFxuICAgIFwibWV0YVwiLFxuICAgIHtcbiAgICAgIG5hbWU6IFwidmlld3BvcnRcIixcbiAgICAgIGNvbnRlbnQ6IFwid2lkdGg9ZGV2aWNlLXdpZHRoLGluaXRpYWwtc2NhbGU9MSx2aWV3cG9ydC1maXQ9Y292ZXJcIlxuICAgIH1cbiAgKSwgLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFwidGl0bGVcIiwgbnVsbCwgdGl0bGUpKSwgLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFwiYm9keVwiLCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoXCJtYWluXCIsIHsgc3R5bGU6IHsgZm9udEZhbWlseTogXCJzeXN0ZW0tdWksIHNhbnMtc2VyaWZcIiwgcGFkZGluZzogXCIycmVtXCIgfSB9LCBjaGlsZHJlbiwgcmVuZGVyU2NyaXB0cyA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChTY3JpcHRzLCBudWxsKSA6IG51bGwpKSk7XG59XG5cbi8vIGxpYi9kb20vc3NyL2ZhbGxiYWNrLnRzeFxudmFyIFJlYWN0NiA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpKTtcbmZ1bmN0aW9uIFJlbWl4Um9vdERlZmF1bHRIeWRyYXRlRmFsbGJhY2soKSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q2LmNyZWF0ZUVsZW1lbnQoQm91bmRhcnlTaGVsbCwgeyB0aXRsZTogXCJMb2FkaW5nLi4uXCIsIHJlbmRlclNjcmlwdHM6IHRydWUgfSwgRU5BQkxFX0RFVl9XQVJOSU5HUyA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDYuY3JlYXRlRWxlbWVudChcbiAgICBcInNjcmlwdFwiLFxuICAgIHtcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgIF9faHRtbDogYFxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICBcIlxcdXsxRjRCRn0gSGV5IGRldmVsb3BlciBcXHV7MUY0NEJ9LiBZb3UgY2FuIHByb3ZpZGUgYSB3YXkgYmV0dGVyIFVYIHRoYW4gdGhpcyBcIiArXG4gICAgICAgICAgICAgICAgXCJ3aGVuIHlvdXIgYXBwIGlzIGxvYWRpbmcgSlMgbW9kdWxlcyBhbmQvb3IgcnVubmluZyBcXGBjbGllbnRMb2FkZXJcXGAgXCIgK1xuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25zLiBDaGVjayBvdXQgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vc3RhcnQvZnJhbWV3b3JrL3JvdXRlLW1vZHVsZSNoeWRyYXRlZmFsbGJhY2sgXCIgK1xuICAgICAgICAgICAgICAgIFwiZm9yIG1vcmUgaW5mb3JtYXRpb24uXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGBcbiAgICAgIH1cbiAgICB9XG4gICkgOiBudWxsKTtcbn1cblxuLy8gbGliL2RvbS9zc3Ivcm91dGVzLnRzeFxuZnVuY3Rpb24gZ3JvdXBSb3V0ZXNCeVBhcmVudElkKG1hbmlmZXN0KSB7XG4gIGxldCByb3V0ZXMgPSB7fTtcbiAgT2JqZWN0LnZhbHVlcyhtYW5pZmVzdCkuZm9yRWFjaCgocm91dGUpID0+IHtcbiAgICBpZiAocm91dGUpIHtcbiAgICAgIGxldCBwYXJlbnRJZCA9IHJvdXRlLnBhcmVudElkIHx8IFwiXCI7XG4gICAgICBpZiAoIXJvdXRlc1twYXJlbnRJZF0pIHtcbiAgICAgICAgcm91dGVzW3BhcmVudElkXSA9IFtdO1xuICAgICAgfVxuICAgICAgcm91dGVzW3BhcmVudElkXS5wdXNoKHJvdXRlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcm91dGVzO1xufVxuZnVuY3Rpb24gZ2V0Um91dGVDb21wb25lbnRzKHJvdXRlLCByb3V0ZU1vZHVsZSwgaXNTcGFNb2RlKSB7XG4gIGxldCBDb21wb25lbnQ0ID0gZ2V0Um91dGVNb2R1bGVDb21wb25lbnQocm91dGVNb2R1bGUpO1xuICBsZXQgSHlkcmF0ZUZhbGxiYWNrID0gcm91dGVNb2R1bGUuSHlkcmF0ZUZhbGxiYWNrICYmICghaXNTcGFNb2RlIHx8IHJvdXRlLmlkID09PSBcInJvb3RcIikgPyByb3V0ZU1vZHVsZS5IeWRyYXRlRmFsbGJhY2sgOiByb3V0ZS5pZCA9PT0gXCJyb290XCIgPyBSZW1peFJvb3REZWZhdWx0SHlkcmF0ZUZhbGxiYWNrIDogdm9pZCAwO1xuICBsZXQgRXJyb3JCb3VuZGFyeSA9IHJvdXRlTW9kdWxlLkVycm9yQm91bmRhcnkgPyByb3V0ZU1vZHVsZS5FcnJvckJvdW5kYXJ5IDogcm91dGUuaWQgPT09IFwicm9vdFwiID8gKCkgPT4gLyogQF9fUFVSRV9fICovIFJlYWN0Ny5jcmVhdGVFbGVtZW50KFJlbWl4Um9vdERlZmF1bHRFcnJvckJvdW5kYXJ5LCB7IGVycm9yOiB1c2VSb3V0ZUVycm9yKCkgfSkgOiB2b2lkIDA7XG4gIGlmIChyb3V0ZS5pZCA9PT0gXCJyb290XCIgJiYgcm91dGVNb2R1bGUuTGF5b3V0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkNvbXBvbmVudDQgPyB7XG4gICAgICAgIGVsZW1lbnQ6IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChyb3V0ZU1vZHVsZS5MYXlvdXQsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChDb21wb25lbnQ0LCBudWxsKSlcbiAgICAgIH0gOiB7IENvbXBvbmVudDogQ29tcG9uZW50NCB9LFxuICAgICAgLi4uRXJyb3JCb3VuZGFyeSA/IHtcbiAgICAgICAgZXJyb3JFbGVtZW50OiAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQocm91dGVNb2R1bGUuTGF5b3V0LCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQoRXJyb3JCb3VuZGFyeSwgbnVsbCkpXG4gICAgICB9IDogeyBFcnJvckJvdW5kYXJ5IH0sXG4gICAgICAuLi5IeWRyYXRlRmFsbGJhY2sgPyB7XG4gICAgICAgIGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQ6IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChyb3V0ZU1vZHVsZS5MYXlvdXQsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChIeWRyYXRlRmFsbGJhY2ssIG51bGwpKVxuICAgICAgfSA6IHsgSHlkcmF0ZUZhbGxiYWNrIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiB7IENvbXBvbmVudDogQ29tcG9uZW50NCwgRXJyb3JCb3VuZGFyeSwgSHlkcmF0ZUZhbGxiYWNrIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTZXJ2ZXJSb3V0ZXMobWFuaWZlc3QsIHJvdXRlTW9kdWxlcywgZnV0dXJlLCBpc1NwYU1vZGUsIHBhcmVudElkID0gXCJcIiwgcm91dGVzQnlQYXJlbnRJZCA9IGdyb3VwUm91dGVzQnlQYXJlbnRJZChtYW5pZmVzdCksIHNwYU1vZGVMYXp5UHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh7IENvbXBvbmVudDogKCkgPT4gbnVsbCB9KSkge1xuICByZXR1cm4gKHJvdXRlc0J5UGFyZW50SWRbcGFyZW50SWRdIHx8IFtdKS5tYXAoKHJvdXRlKSA9PiB7XG4gICAgbGV0IHJvdXRlTW9kdWxlID0gcm91dGVNb2R1bGVzW3JvdXRlLmlkXTtcbiAgICBpbnZhcmlhbnQyKFxuICAgICAgcm91dGVNb2R1bGUsXG4gICAgICBcIk5vIGByb3V0ZU1vZHVsZWAgYXZhaWxhYmxlIHRvIGNyZWF0ZSBzZXJ2ZXIgcm91dGVzXCJcbiAgICApO1xuICAgIGxldCBkYXRhUm91dGUgPSB7XG4gICAgICAuLi5nZXRSb3V0ZUNvbXBvbmVudHMocm91dGUsIHJvdXRlTW9kdWxlLCBpc1NwYU1vZGUpLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogcm91dGUuY2FzZVNlbnNpdGl2ZSxcbiAgICAgIGlkOiByb3V0ZS5pZCxcbiAgICAgIGluZGV4OiByb3V0ZS5pbmRleCxcbiAgICAgIHBhdGg6IHJvdXRlLnBhdGgsXG4gICAgICBoYW5kbGU6IHJvdXRlTW9kdWxlLmhhbmRsZSxcbiAgICAgIC8vIEZvciBTUEEgTW9kZSwgYWxsIHJvdXRlcyBhcmUgbGF6eSBleGNlcHQgcm9vdC4gIEhvd2V2ZXIgd2UgdGVsbCB0aGVcbiAgICAgIC8vIHJvdXRlciByb290IGlzIGFsc28gbGF6eSBoZXJlIHRvbyBzaW5jZSB3ZSBkb24ndCBuZWVkIGEgZnVsbFxuICAgICAgLy8gaW1wbGVtZW50YXRpb24gLSB3ZSBqdXN0IG5lZWQgYSBgbGF6eWAgcHJvcCB0byB0ZWxsIHRoZSBSUiByZW5kZXJpbmdcbiAgICAgIC8vIHdoZXJlIHRvIHN0b3Agd2hpY2ggaXMgYWx3YXlzIGF0IHRoZSByb290IHJvdXRlIGluIFNQQSBtb2RlXG4gICAgICBsYXp5OiBpc1NwYU1vZGUgPyAoKSA9PiBzcGFNb2RlTGF6eVByb21pc2UgOiB2b2lkIDAsXG4gICAgICAvLyBGb3IgcGFydGlhbCBoeWRyYXRpb24gcmVuZGVyaW5nLCB3ZSBuZWVkIHRvIGluZGljYXRlIHdoZW4gdGhlIHJvdXRlXG4gICAgICAvLyBoYXMgYSBsb2FkZXIvY2xpZW50TG9hZGVyLCBidXQgaXQgd29uJ3QgZXZlciBiZSBjYWxsZWQgZHVyaW5nIHRoZSBzdGF0aWNcbiAgICAgIC8vIHJlbmRlciwgc28ganVzdCBnaXZlIGl0IGEgbm8tb3AgZnVuY3Rpb24gc28gd2UgY2FuIHJlbmRlciBkb3duIHRvIHRoZVxuICAgICAgLy8gcHJvcGVyIGZhbGxiYWNrXG4gICAgICBsb2FkZXI6IHJvdXRlLmhhc0xvYWRlciB8fCByb3V0ZS5oYXNDbGllbnRMb2FkZXIgPyAoKSA9PiBudWxsIDogdm9pZCAwXG4gICAgICAvLyBXZSBkb24ndCBuZWVkIG1pZGRsZXdhcmUvYWN0aW9uL3Nob3VsZFJldmFsaWRhdGUgb24gdGhlc2Ugcm91dGVzIHNpbmNlXG4gICAgICAvLyB0aGV5J3JlIGZvciBhIHN0YXRpYyByZW5kZXJcbiAgICB9O1xuICAgIGxldCBjaGlsZHJlbiA9IGNyZWF0ZVNlcnZlclJvdXRlcyhcbiAgICAgIG1hbmlmZXN0LFxuICAgICAgcm91dGVNb2R1bGVzLFxuICAgICAgZnV0dXJlLFxuICAgICAgaXNTcGFNb2RlLFxuICAgICAgcm91dGUuaWQsXG4gICAgICByb3V0ZXNCeVBhcmVudElkLFxuICAgICAgc3BhTW9kZUxhenlQcm9taXNlXG4gICAgKTtcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkgZGF0YVJvdXRlLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgcmV0dXJuIGRhdGFSb3V0ZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVDbGllbnRSb3V0ZXNXaXRoSE1SUmV2YWxpZGF0aW9uT3B0T3V0KG5lZWRzUmV2YWxpZGF0aW9uLCBtYW5pZmVzdCwgcm91dGVNb2R1bGVzQ2FjaGUsIGluaXRpYWxTdGF0ZSwgc3NyLCBpc1NwYU1vZGUpIHtcbiAgcmV0dXJuIGNyZWF0ZUNsaWVudFJvdXRlcyhcbiAgICBtYW5pZmVzdCxcbiAgICByb3V0ZU1vZHVsZXNDYWNoZSxcbiAgICBpbml0aWFsU3RhdGUsXG4gICAgc3NyLFxuICAgIGlzU3BhTW9kZSxcbiAgICBcIlwiLFxuICAgIGdyb3VwUm91dGVzQnlQYXJlbnRJZChtYW5pZmVzdCksXG4gICAgbmVlZHNSZXZhbGlkYXRpb25cbiAgKTtcbn1cbmZ1bmN0aW9uIHByZXZlbnRJbnZhbGlkU2VydmVySGFuZGxlckNhbGwodHlwZSwgcm91dGUpIHtcbiAgaWYgKHR5cGUgPT09IFwibG9hZGVyXCIgJiYgIXJvdXRlLmhhc0xvYWRlciB8fCB0eXBlID09PSBcImFjdGlvblwiICYmICFyb3V0ZS5oYXNBY3Rpb24pIHtcbiAgICBsZXQgZm4gPSB0eXBlID09PSBcImFjdGlvblwiID8gXCJzZXJ2ZXJBY3Rpb24oKVwiIDogXCJzZXJ2ZXJMb2FkZXIoKVwiO1xuICAgIGxldCBtc2cgPSBgWW91IGFyZSB0cnlpbmcgdG8gY2FsbCAke2ZufSBvbiBhIHJvdXRlIHRoYXQgZG9lcyBub3QgaGF2ZSBhIHNlcnZlciAke3R5cGV9IChyb3V0ZUlkOiBcIiR7cm91dGUuaWR9XCIpYDtcbiAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgdGhyb3cgbmV3IEVycm9yUmVzcG9uc2VJbXBsKDQwMCwgXCJCYWQgUmVxdWVzdFwiLCBuZXcgRXJyb3IobXNnKSwgdHJ1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vQWN0aW9uRGVmaW5lZEVycm9yKHR5cGUsIHJvdXRlSWQpIHtcbiAgbGV0IGFydGljbGUgPSB0eXBlID09PSBcImNsaWVudEFjdGlvblwiID8gXCJhXCIgOiBcImFuXCI7XG4gIGxldCBtc2cgPSBgUm91dGUgXCIke3JvdXRlSWR9XCIgZG9lcyBub3QgaGF2ZSAke2FydGljbGV9ICR7dHlwZX0sIGJ1dCB5b3UgYXJlIHRyeWluZyB0byBzdWJtaXQgdG8gaXQuIFRvIGZpeCB0aGlzLCBwbGVhc2UgYWRkICR7YXJ0aWNsZX0gXFxgJHt0eXBlfVxcYCBmdW5jdGlvbiB0byB0aGUgcm91dGVgO1xuICBjb25zb2xlLmVycm9yKG1zZyk7XG4gIHRocm93IG5ldyBFcnJvclJlc3BvbnNlSW1wbCg0MDUsIFwiTWV0aG9kIE5vdCBBbGxvd2VkXCIsIG5ldyBFcnJvcihtc2cpLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudFJvdXRlcyhtYW5pZmVzdCwgcm91dGVNb2R1bGVzQ2FjaGUsIGluaXRpYWxTdGF0ZSwgc3NyLCBpc1NwYU1vZGUsIHBhcmVudElkID0gXCJcIiwgcm91dGVzQnlQYXJlbnRJZCA9IGdyb3VwUm91dGVzQnlQYXJlbnRJZChtYW5pZmVzdCksIG5lZWRzUmV2YWxpZGF0aW9uKSB7XG4gIHJldHVybiAocm91dGVzQnlQYXJlbnRJZFtwYXJlbnRJZF0gfHwgW10pLm1hcCgocm91dGUpID0+IHtcbiAgICBsZXQgcm91dGVNb2R1bGUgPSByb3V0ZU1vZHVsZXNDYWNoZVtyb3V0ZS5pZF07XG4gICAgZnVuY3Rpb24gZmV0Y2hTZXJ2ZXJIYW5kbGVyKHNpbmdsZUZldGNoKSB7XG4gICAgICBpbnZhcmlhbnQyKFxuICAgICAgICB0eXBlb2Ygc2luZ2xlRmV0Y2ggPT09IFwiZnVuY3Rpb25cIixcbiAgICAgICAgXCJObyBzaW5nbGUgZmV0Y2ggZnVuY3Rpb24gYXZhaWxhYmxlIGZvciByb3V0ZSBoYW5kbGVyXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gc2luZ2xlRmV0Y2goKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmV0Y2hTZXJ2ZXJMb2FkZXIoc2luZ2xlRmV0Y2gpIHtcbiAgICAgIGlmICghcm91dGUuaGFzTG9hZGVyKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgcmV0dXJuIGZldGNoU2VydmVySGFuZGxlcihzaW5nbGVGZXRjaCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZldGNoU2VydmVyQWN0aW9uKHNpbmdsZUZldGNoKSB7XG4gICAgICBpZiAoIXJvdXRlLmhhc0FjdGlvbikge1xuICAgICAgICB0aHJvdyBub0FjdGlvbkRlZmluZWRFcnJvcihcImFjdGlvblwiLCByb3V0ZS5pZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmV0Y2hTZXJ2ZXJIYW5kbGVyKHNpbmdsZUZldGNoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlZmV0Y2hNb2R1bGUobW9kdWxlUGF0aCkge1xuICAgICAgaW1wb3J0KFxuICAgICAgICAvKiBAdml0ZS1pZ25vcmUgKi9cbiAgICAgICAgLyogd2VicGFja0lnbm9yZTogdHJ1ZSAqL1xuICAgICAgICBtb2R1bGVQYXRoXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVmZXRjaFJvdXRlTW9kdWxlQ2h1bmtzKHJvdXRlMikge1xuICAgICAgaWYgKHJvdXRlMi5jbGllbnRBY3Rpb25Nb2R1bGUpIHtcbiAgICAgICAgcHJlZmV0Y2hNb2R1bGUocm91dGUyLmNsaWVudEFjdGlvbk1vZHVsZSk7XG4gICAgICB9XG4gICAgICBpZiAocm91dGUyLmNsaWVudExvYWRlck1vZHVsZSkge1xuICAgICAgICBwcmVmZXRjaE1vZHVsZShyb3V0ZTIuY2xpZW50TG9hZGVyTW9kdWxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gcHJlZmV0Y2hTdHlsZXNBbmRDYWxsSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICBsZXQgY2FjaGVkTW9kdWxlID0gcm91dGVNb2R1bGVzQ2FjaGVbcm91dGUuaWRdO1xuICAgICAgbGV0IGxpbmtQcmVmZXRjaFByb21pc2UgPSBjYWNoZWRNb2R1bGUgPyBwcmVmZXRjaFN0eWxlTGlua3Mocm91dGUsIGNhY2hlZE1vZHVsZSkgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVyKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBhd2FpdCBsaW5rUHJlZmV0Y2hQcm9taXNlO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgZGF0YVJvdXRlID0ge1xuICAgICAgaWQ6IHJvdXRlLmlkLFxuICAgICAgaW5kZXg6IHJvdXRlLmluZGV4LFxuICAgICAgcGF0aDogcm91dGUucGF0aFxuICAgIH07XG4gICAgaWYgKHJvdXRlTW9kdWxlKSB7XG4gICAgICBPYmplY3QuYXNzaWduKGRhdGFSb3V0ZSwge1xuICAgICAgICAuLi5kYXRhUm91dGUsXG4gICAgICAgIC4uLmdldFJvdXRlQ29tcG9uZW50cyhyb3V0ZSwgcm91dGVNb2R1bGUsIGlzU3BhTW9kZSksXG4gICAgICAgIHVuc3RhYmxlX21pZGRsZXdhcmU6IHJvdXRlTW9kdWxlLnVuc3RhYmxlX2NsaWVudE1pZGRsZXdhcmUsXG4gICAgICAgIGhhbmRsZTogcm91dGVNb2R1bGUuaGFuZGxlLFxuICAgICAgICBzaG91bGRSZXZhbGlkYXRlOiBnZXRTaG91bGRSZXZhbGlkYXRlRnVuY3Rpb24oXG4gICAgICAgICAgZGF0YVJvdXRlLnBhdGgsXG4gICAgICAgICAgcm91dGVNb2R1bGUsXG4gICAgICAgICAgcm91dGUsXG4gICAgICAgICAgc3NyLFxuICAgICAgICAgIG5lZWRzUmV2YWxpZGF0aW9uXG4gICAgICAgIClcbiAgICAgIH0pO1xuICAgICAgbGV0IGhhc0luaXRpYWxEYXRhID0gaW5pdGlhbFN0YXRlICYmIGluaXRpYWxTdGF0ZS5sb2FkZXJEYXRhICYmIHJvdXRlLmlkIGluIGluaXRpYWxTdGF0ZS5sb2FkZXJEYXRhO1xuICAgICAgbGV0IGluaXRpYWxEYXRhID0gaGFzSW5pdGlhbERhdGEgPyBpbml0aWFsU3RhdGU/LmxvYWRlckRhdGE/Lltyb3V0ZS5pZF0gOiB2b2lkIDA7XG4gICAgICBsZXQgaGFzSW5pdGlhbEVycm9yID0gaW5pdGlhbFN0YXRlICYmIGluaXRpYWxTdGF0ZS5lcnJvcnMgJiYgcm91dGUuaWQgaW4gaW5pdGlhbFN0YXRlLmVycm9ycztcbiAgICAgIGxldCBpbml0aWFsRXJyb3IgPSBoYXNJbml0aWFsRXJyb3IgPyBpbml0aWFsU3RhdGU/LmVycm9ycz8uW3JvdXRlLmlkXSA6IHZvaWQgMDtcbiAgICAgIGxldCBpc0h5ZHJhdGlvblJlcXVlc3QgPSBuZWVkc1JldmFsaWRhdGlvbiA9PSBudWxsICYmIChyb3V0ZU1vZHVsZS5jbGllbnRMb2FkZXI/Lmh5ZHJhdGUgPT09IHRydWUgfHwgIXJvdXRlLmhhc0xvYWRlcik7XG4gICAgICBkYXRhUm91dGUubG9hZGVyID0gYXN5bmMgKHsgcmVxdWVzdCwgcGFyYW1zLCBjb250ZXh0IH0sIHNpbmdsZUZldGNoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHByZWZldGNoU3R5bGVzQW5kQ2FsbEhhbmRsZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaW52YXJpYW50MihcbiAgICAgICAgICAgICAgcm91dGVNb2R1bGUsXG4gICAgICAgICAgICAgIFwiTm8gYHJvdXRlTW9kdWxlYCBhdmFpbGFibGUgZm9yIGNyaXRpY2FsLXJvdXRlIGxvYWRlclwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCFyb3V0ZU1vZHVsZS5jbGllbnRMb2FkZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZldGNoU2VydmVyTG9hZGVyKHNpbmdsZUZldGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByb3V0ZU1vZHVsZS5jbGllbnRMb2FkZXIoe1xuICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgIGFzeW5jIHNlcnZlckxvYWRlcigpIHtcbiAgICAgICAgICAgICAgICBwcmV2ZW50SW52YWxpZFNlcnZlckhhbmRsZXJDYWxsKFwibG9hZGVyXCIsIHJvdXRlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNIeWRyYXRpb25SZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaGFzSW5pdGlhbERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluaXRpYWxEYXRhO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGhhc0luaXRpYWxFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbml0aWFsRXJyb3I7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaFNlcnZlckxvYWRlcihzaW5nbGVGZXRjaCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaXNIeWRyYXRpb25SZXF1ZXN0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBkYXRhUm91dGUubG9hZGVyLmh5ZHJhdGUgPSBzaG91bGRIeWRyYXRlUm91dGVMb2FkZXIoXG4gICAgICAgIHJvdXRlLmlkLFxuICAgICAgICByb3V0ZU1vZHVsZS5jbGllbnRMb2FkZXIsXG4gICAgICAgIHJvdXRlLmhhc0xvYWRlcixcbiAgICAgICAgaXNTcGFNb2RlXG4gICAgICApO1xuICAgICAgZGF0YVJvdXRlLmFjdGlvbiA9ICh7IHJlcXVlc3QsIHBhcmFtcywgY29udGV4dCB9LCBzaW5nbGVGZXRjaCkgPT4ge1xuICAgICAgICByZXR1cm4gcHJlZmV0Y2hTdHlsZXNBbmRDYWxsSGFuZGxlcihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgaW52YXJpYW50MihcbiAgICAgICAgICAgIHJvdXRlTW9kdWxlLFxuICAgICAgICAgICAgXCJObyBgcm91dGVNb2R1bGVgIGF2YWlsYWJsZSBmb3IgY3JpdGljYWwtcm91dGUgYWN0aW9uXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICghcm91dGVNb2R1bGUuY2xpZW50QWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoaXNTcGFNb2RlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5vQWN0aW9uRGVmaW5lZEVycm9yKFwiY2xpZW50QWN0aW9uXCIsIHJvdXRlLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmZXRjaFNlcnZlckFjdGlvbihzaW5nbGVGZXRjaCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByb3V0ZU1vZHVsZS5jbGllbnRBY3Rpb24oe1xuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICBhc3luYyBzZXJ2ZXJBY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHByZXZlbnRJbnZhbGlkU2VydmVySGFuZGxlckNhbGwoXCJhY3Rpb25cIiwgcm91dGUpO1xuICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hTZXJ2ZXJBY3Rpb24oc2luZ2xlRmV0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghcm91dGUuaGFzQ2xpZW50TG9hZGVyKSB7XG4gICAgICAgIGRhdGFSb3V0ZS5sb2FkZXIgPSAoXywgc2luZ2xlRmV0Y2gpID0+IHByZWZldGNoU3R5bGVzQW5kQ2FsbEhhbmRsZXIoKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBmZXRjaFNlcnZlckxvYWRlcihzaW5nbGVGZXRjaCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFyb3V0ZS5oYXNDbGllbnRBY3Rpb24pIHtcbiAgICAgICAgZGF0YVJvdXRlLmFjdGlvbiA9IChfLCBzaW5nbGVGZXRjaCkgPT4gcHJlZmV0Y2hTdHlsZXNBbmRDYWxsSGFuZGxlcigoKSA9PiB7XG4gICAgICAgICAgaWYgKGlzU3BhTW9kZSkge1xuICAgICAgICAgICAgdGhyb3cgbm9BY3Rpb25EZWZpbmVkRXJyb3IoXCJjbGllbnRBY3Rpb25cIiwgcm91dGUuaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmV0Y2hTZXJ2ZXJBY3Rpb24oc2luZ2xlRmV0Y2gpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGxldCBsYXp5Um91dGVQcm9taXNlO1xuICAgICAgYXN5bmMgZnVuY3Rpb24gZ2V0TGF6eVJvdXRlKCkge1xuICAgICAgICBpZiAobGF6eVJvdXRlUHJvbWlzZSkge1xuICAgICAgICAgIHJldHVybiBhd2FpdCBsYXp5Um91dGVQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGxhenlSb3V0ZVByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGlmIChyb3V0ZS5jbGllbnRMb2FkZXJNb2R1bGUgfHwgcm91dGUuY2xpZW50QWN0aW9uTW9kdWxlKSB7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAwKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCByb3V0ZU1vZHVsZVByb21pc2UgPSBsb2FkUm91dGVNb2R1bGVXaXRoQmxvY2tpbmdMaW5rcyhcbiAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgcm91dGVNb2R1bGVzQ2FjaGVcbiAgICAgICAgICApO1xuICAgICAgICAgIHByZWZldGNoUm91dGVNb2R1bGVDaHVua3Mocm91dGUpO1xuICAgICAgICAgIHJldHVybiBhd2FpdCByb3V0ZU1vZHVsZVByb21pc2U7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBsYXp5Um91dGVQcm9taXNlO1xuICAgICAgfVxuICAgICAgZGF0YVJvdXRlLmxhenkgPSB7XG4gICAgICAgIGxvYWRlcjogcm91dGUuaGFzQ2xpZW50TG9hZGVyID8gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGxldCB7IGNsaWVudExvYWRlciB9ID0gcm91dGUuY2xpZW50TG9hZGVyTW9kdWxlID8gYXdhaXQgaW1wb3J0KFxuICAgICAgICAgICAgLyogQHZpdGUtaWdub3JlICovXG4gICAgICAgICAgICAvKiB3ZWJwYWNrSWdub3JlOiB0cnVlICovXG4gICAgICAgICAgICByb3V0ZS5jbGllbnRMb2FkZXJNb2R1bGVcbiAgICAgICAgICApIDogYXdhaXQgZ2V0TGF6eVJvdXRlKCk7XG4gICAgICAgICAgaW52YXJpYW50MihjbGllbnRMb2FkZXIsIFwiTm8gYGNsaWVudExvYWRlcmAgZXhwb3J0IGZvdW5kXCIpO1xuICAgICAgICAgIHJldHVybiAoYXJncywgc2luZ2xlRmV0Y2gpID0+IGNsaWVudExvYWRlcih7XG4gICAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgICAgYXN5bmMgc2VydmVyTG9hZGVyKCkge1xuICAgICAgICAgICAgICBwcmV2ZW50SW52YWxpZFNlcnZlckhhbmRsZXJDYWxsKFwibG9hZGVyXCIsIHJvdXRlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZldGNoU2VydmVyTG9hZGVyKHNpbmdsZUZldGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSA6IHZvaWQgMCxcbiAgICAgICAgYWN0aW9uOiByb3V0ZS5oYXNDbGllbnRBY3Rpb24gPyBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgbGV0IGNsaWVudEFjdGlvblByb21pc2UgPSByb3V0ZS5jbGllbnRBY3Rpb25Nb2R1bGUgPyBpbXBvcnQoXG4gICAgICAgICAgICAvKiBAdml0ZS1pZ25vcmUgKi9cbiAgICAgICAgICAgIC8qIHdlYnBhY2tJZ25vcmU6IHRydWUgKi9cbiAgICAgICAgICAgIHJvdXRlLmNsaWVudEFjdGlvbk1vZHVsZVxuICAgICAgICAgICkgOiBnZXRMYXp5Um91dGUoKTtcbiAgICAgICAgICBwcmVmZXRjaFJvdXRlTW9kdWxlQ2h1bmtzKHJvdXRlKTtcbiAgICAgICAgICBsZXQgeyBjbGllbnRBY3Rpb24gfSA9IGF3YWl0IGNsaWVudEFjdGlvblByb21pc2U7XG4gICAgICAgICAgaW52YXJpYW50MihjbGllbnRBY3Rpb24sIFwiTm8gYGNsaWVudEFjdGlvbmAgZXhwb3J0IGZvdW5kXCIpO1xuICAgICAgICAgIHJldHVybiAoYXJncywgc2luZ2xlRmV0Y2gpID0+IGNsaWVudEFjdGlvbih7XG4gICAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgICAgYXN5bmMgc2VydmVyQWN0aW9uKCkge1xuICAgICAgICAgICAgICBwcmV2ZW50SW52YWxpZFNlcnZlckhhbmRsZXJDYWxsKFwiYWN0aW9uXCIsIHJvdXRlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZldGNoU2VydmVyQWN0aW9uKHNpbmdsZUZldGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSA6IHZvaWQgMCxcbiAgICAgICAgdW5zdGFibGVfbWlkZGxld2FyZTogcm91dGUuaGFzQ2xpZW50TWlkZGxld2FyZSA/IGFzeW5jICgpID0+IHtcbiAgICAgICAgICBsZXQgeyB1bnN0YWJsZV9jbGllbnRNaWRkbGV3YXJlIH0gPSByb3V0ZS5jbGllbnRNaWRkbGV3YXJlTW9kdWxlID8gYXdhaXQgaW1wb3J0KFxuICAgICAgICAgICAgLyogQHZpdGUtaWdub3JlICovXG4gICAgICAgICAgICAvKiB3ZWJwYWNrSWdub3JlOiB0cnVlICovXG4gICAgICAgICAgICByb3V0ZS5jbGllbnRNaWRkbGV3YXJlTW9kdWxlXG4gICAgICAgICAgKSA6IGF3YWl0IGdldExhenlSb3V0ZSgpO1xuICAgICAgICAgIGludmFyaWFudDIoXG4gICAgICAgICAgICB1bnN0YWJsZV9jbGllbnRNaWRkbGV3YXJlLFxuICAgICAgICAgICAgXCJObyBgdW5zdGFibGVfY2xpZW50TWlkZGxld2FyZWAgZXhwb3J0IGZvdW5kXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiB1bnN0YWJsZV9jbGllbnRNaWRkbGV3YXJlO1xuICAgICAgICB9IDogdm9pZCAwLFxuICAgICAgICBzaG91bGRSZXZhbGlkYXRlOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgbGV0IGxhenlSb3V0ZSA9IGF3YWl0IGdldExhenlSb3V0ZSgpO1xuICAgICAgICAgIHJldHVybiBnZXRTaG91bGRSZXZhbGlkYXRlRnVuY3Rpb24oXG4gICAgICAgICAgICBkYXRhUm91dGUucGF0aCxcbiAgICAgICAgICAgIGxhenlSb3V0ZSxcbiAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgc3NyLFxuICAgICAgICAgICAgbmVlZHNSZXZhbGlkYXRpb25cbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBoYW5kbGU6IGFzeW5jICgpID0+IChhd2FpdCBnZXRMYXp5Um91dGUoKSkuaGFuZGxlLFxuICAgICAgICAvLyBObyBuZWVkIHRvIHdyYXAgdGhlc2UgaW4gbGF5b3V0IHNpbmNlIHRoZSByb290IHJvdXRlIGlzIG5ldmVyXG4gICAgICAgIC8vIGxvYWRlZCB2aWEgcm91dGUubGF6eSgpXG4gICAgICAgIENvbXBvbmVudDogYXN5bmMgKCkgPT4gKGF3YWl0IGdldExhenlSb3V0ZSgpKS5Db21wb25lbnQsXG4gICAgICAgIEVycm9yQm91bmRhcnk6IHJvdXRlLmhhc0Vycm9yQm91bmRhcnkgPyBhc3luYyAoKSA9PiAoYXdhaXQgZ2V0TGF6eVJvdXRlKCkpLkVycm9yQm91bmRhcnkgOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfVxuICAgIGxldCBjaGlsZHJlbiA9IGNyZWF0ZUNsaWVudFJvdXRlcyhcbiAgICAgIG1hbmlmZXN0LFxuICAgICAgcm91dGVNb2R1bGVzQ2FjaGUsXG4gICAgICBpbml0aWFsU3RhdGUsXG4gICAgICBzc3IsXG4gICAgICBpc1NwYU1vZGUsXG4gICAgICByb3V0ZS5pZCxcbiAgICAgIHJvdXRlc0J5UGFyZW50SWQsXG4gICAgICBuZWVkc1JldmFsaWRhdGlvblxuICAgICk7XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIGRhdGFSb3V0ZS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHJldHVybiBkYXRhUm91dGU7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0U2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uKHBhdGgsIHJvdXRlLCBtYW5pZmVzdFJvdXRlLCBzc3IsIG5lZWRzUmV2YWxpZGF0aW9uKSB7XG4gIGlmIChuZWVkc1JldmFsaWRhdGlvbikge1xuICAgIHJldHVybiB3cmFwU2hvdWxkUmV2YWxpZGF0ZUZvckhkcihcbiAgICAgIG1hbmlmZXN0Um91dGUuaWQsXG4gICAgICByb3V0ZS5zaG91bGRSZXZhbGlkYXRlLFxuICAgICAgbmVlZHNSZXZhbGlkYXRpb25cbiAgICApO1xuICB9XG4gIGlmICghc3NyICYmIG1hbmlmZXN0Um91dGUuaGFzTG9hZGVyICYmICFtYW5pZmVzdFJvdXRlLmhhc0NsaWVudExvYWRlcikge1xuICAgIGxldCBteVBhcmFtcyA9IHBhdGggPyBjb21waWxlUGF0aChwYXRoKVsxXS5tYXAoKHApID0+IHAucGFyYW1OYW1lKSA6IFtdO1xuICAgIGNvbnN0IGRpZFBhcmFtc0NoYW5nZSA9IChvcHRzKSA9PiBteVBhcmFtcy5zb21lKChwKSA9PiBvcHRzLmN1cnJlbnRQYXJhbXNbcF0gIT09IG9wdHMubmV4dFBhcmFtc1twXSk7XG4gICAgaWYgKHJvdXRlLnNob3VsZFJldmFsaWRhdGUpIHtcbiAgICAgIGxldCBmbiA9IHJvdXRlLnNob3VsZFJldmFsaWRhdGU7XG4gICAgICByZXR1cm4gKG9wdHMpID0+IGZuKHtcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgZGVmYXVsdFNob3VsZFJldmFsaWRhdGU6IGRpZFBhcmFtc0NoYW5nZShvcHRzKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAob3B0cykgPT4gZGlkUGFyYW1zQ2hhbmdlKG9wdHMpO1xuICAgIH1cbiAgfVxuICBpZiAoc3NyICYmIHJvdXRlLnNob3VsZFJldmFsaWRhdGUpIHtcbiAgICBsZXQgZm4gPSByb3V0ZS5zaG91bGRSZXZhbGlkYXRlO1xuICAgIHJldHVybiAob3B0cykgPT4gZm4oeyAuLi5vcHRzLCBkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZTogdHJ1ZSB9KTtcbiAgfVxuICByZXR1cm4gcm91dGUuc2hvdWxkUmV2YWxpZGF0ZTtcbn1cbmZ1bmN0aW9uIHdyYXBTaG91bGRSZXZhbGlkYXRlRm9ySGRyKHJvdXRlSWQsIHJvdXRlU2hvdWxkUmV2YWxpZGF0ZSwgbmVlZHNSZXZhbGlkYXRpb24pIHtcbiAgbGV0IGhhbmRsZWRSZXZhbGlkYXRpb24gPSBmYWxzZTtcbiAgcmV0dXJuIChhcmcpID0+IHtcbiAgICBpZiAoIWhhbmRsZWRSZXZhbGlkYXRpb24pIHtcbiAgICAgIGhhbmRsZWRSZXZhbGlkYXRpb24gPSB0cnVlO1xuICAgICAgcmV0dXJuIG5lZWRzUmV2YWxpZGF0aW9uLmhhcyhyb3V0ZUlkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJvdXRlU2hvdWxkUmV2YWxpZGF0ZSA/IHJvdXRlU2hvdWxkUmV2YWxpZGF0ZShhcmcpIDogYXJnLmRlZmF1bHRTaG91bGRSZXZhbGlkYXRlO1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZFJvdXRlTW9kdWxlV2l0aEJsb2NraW5nTGlua3Mocm91dGUsIHJvdXRlTW9kdWxlcykge1xuICBsZXQgcm91dGVNb2R1bGVQcm9taXNlID0gbG9hZFJvdXRlTW9kdWxlKHJvdXRlLCByb3V0ZU1vZHVsZXMpO1xuICBsZXQgcHJlZmV0Y2hSb3V0ZUNzc1Byb21pc2UgPSBwcmVmZXRjaFJvdXRlQ3NzKHJvdXRlKTtcbiAgbGV0IHJvdXRlTW9kdWxlID0gYXdhaXQgcm91dGVNb2R1bGVQcm9taXNlO1xuICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgcHJlZmV0Y2hSb3V0ZUNzc1Byb21pc2UsXG4gICAgcHJlZmV0Y2hTdHlsZUxpbmtzKHJvdXRlLCByb3V0ZU1vZHVsZSlcbiAgXSk7XG4gIHJldHVybiB7XG4gICAgQ29tcG9uZW50OiBnZXRSb3V0ZU1vZHVsZUNvbXBvbmVudChyb3V0ZU1vZHVsZSksXG4gICAgRXJyb3JCb3VuZGFyeTogcm91dGVNb2R1bGUuRXJyb3JCb3VuZGFyeSxcbiAgICB1bnN0YWJsZV9jbGllbnRNaWRkbGV3YXJlOiByb3V0ZU1vZHVsZS51bnN0YWJsZV9jbGllbnRNaWRkbGV3YXJlLFxuICAgIGNsaWVudEFjdGlvbjogcm91dGVNb2R1bGUuY2xpZW50QWN0aW9uLFxuICAgIGNsaWVudExvYWRlcjogcm91dGVNb2R1bGUuY2xpZW50TG9hZGVyLFxuICAgIGhhbmRsZTogcm91dGVNb2R1bGUuaGFuZGxlLFxuICAgIGxpbmtzOiByb3V0ZU1vZHVsZS5saW5rcyxcbiAgICBtZXRhOiByb3V0ZU1vZHVsZS5tZXRhLFxuICAgIHNob3VsZFJldmFsaWRhdGU6IHJvdXRlTW9kdWxlLnNob3VsZFJldmFsaWRhdGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFJvdXRlTW9kdWxlQ29tcG9uZW50KHJvdXRlTW9kdWxlKSB7XG4gIGlmIChyb3V0ZU1vZHVsZS5kZWZhdWx0ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gIGxldCBpc0VtcHR5T2JqZWN0ID0gdHlwZW9mIHJvdXRlTW9kdWxlLmRlZmF1bHQgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmtleXMocm91dGVNb2R1bGUuZGVmYXVsdCkubGVuZ3RoID09PSAwO1xuICBpZiAoIWlzRW1wdHlPYmplY3QpIHtcbiAgICByZXR1cm4gcm91dGVNb2R1bGUuZGVmYXVsdDtcbiAgfVxufVxuZnVuY3Rpb24gc2hvdWxkSHlkcmF0ZVJvdXRlTG9hZGVyKHJvdXRlSWQsIGNsaWVudExvYWRlciwgaGFzTG9hZGVyLCBpc1NwYU1vZGUpIHtcbiAgcmV0dXJuIGlzU3BhTW9kZSAmJiByb3V0ZUlkICE9PSBcInJvb3RcIiB8fCBjbGllbnRMb2FkZXIgIT0gbnVsbCAmJiAoY2xpZW50TG9hZGVyLmh5ZHJhdGUgPT09IHRydWUgfHwgaGFzTG9hZGVyICE9PSB0cnVlKTtcbn1cblxuLy8gbGliL2RvbS9zc3IvZm9nLW9mLXdhci50c1xudmFyIG5leHRQYXRocyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG52YXIgZGlzY292ZXJlZFBhdGhzTWF4U2l6ZSA9IDFlMztcbnZhciBkaXNjb3ZlcmVkUGF0aHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xudmFyIFVSTF9MSU1JVCA9IDc2ODA7XG5mdW5jdGlvbiBpc0ZvZ09mV2FyRW5hYmxlZChyb3V0ZURpc2NvdmVyeSwgc3NyKSB7XG4gIHJldHVybiByb3V0ZURpc2NvdmVyeS5tb2RlID09PSBcImxhenlcIiAmJiBzc3IgPT09IHRydWU7XG59XG5mdW5jdGlvbiBnZXRQYXJ0aWFsTWFuaWZlc3QoeyBzcmksIC4uLm1hbmlmZXN0IH0sIHJvdXRlcikge1xuICBsZXQgcm91dGVJZHMgPSBuZXcgU2V0KHJvdXRlci5zdGF0ZS5tYXRjaGVzLm1hcCgobSkgPT4gbS5yb3V0ZS5pZCkpO1xuICBsZXQgc2VnbWVudHMgPSByb3V0ZXIuc3RhdGUubG9jYXRpb24ucGF0aG5hbWUuc3BsaXQoXCIvXCIpLmZpbHRlcihCb29sZWFuKTtcbiAgbGV0IHBhdGhzID0gW1wiL1wiXTtcbiAgc2VnbWVudHMucG9wKCk7XG4gIHdoaWxlIChzZWdtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgcGF0aHMucHVzaChgLyR7c2VnbWVudHMuam9pbihcIi9cIil9YCk7XG4gICAgc2VnbWVudHMucG9wKCk7XG4gIH1cbiAgcGF0aHMuZm9yRWFjaCgocGF0aCkgPT4ge1xuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVyLnJvdXRlcywgcGF0aCwgcm91dGVyLmJhc2VuYW1lKTtcbiAgICBpZiAobWF0Y2hlcykge1xuICAgICAgbWF0Y2hlcy5mb3JFYWNoKChtKSA9PiByb3V0ZUlkcy5hZGQobS5yb3V0ZS5pZCkpO1xuICAgIH1cbiAgfSk7XG4gIGxldCBpbml0aWFsUm91dGVzID0gWy4uLnJvdXRlSWRzXS5yZWR1Y2UoXG4gICAgKGFjYywgaWQpID0+IE9iamVjdC5hc3NpZ24oYWNjLCB7IFtpZF06IG1hbmlmZXN0LnJvdXRlc1tpZF0gfSksXG4gICAge31cbiAgKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5tYW5pZmVzdCxcbiAgICByb3V0ZXM6IGluaXRpYWxSb3V0ZXMsXG4gICAgc3JpOiBzcmkgPyB0cnVlIDogdm9pZCAwXG4gIH07XG59XG5mdW5jdGlvbiBnZXRQYXRjaFJvdXRlc09uTmF2aWdhdGlvbkZ1bmN0aW9uKG1hbmlmZXN0LCByb3V0ZU1vZHVsZXMsIHNzciwgcm91dGVEaXNjb3ZlcnksIGlzU3BhTW9kZSwgYmFzZW5hbWUpIHtcbiAgaWYgKCFpc0ZvZ09mV2FyRW5hYmxlZChyb3V0ZURpc2NvdmVyeSwgc3NyKSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIGFzeW5jICh7IHBhdGgsIHBhdGNoLCBzaWduYWwsIGZldGNoZXJLZXkgfSkgPT4ge1xuICAgIGlmIChkaXNjb3ZlcmVkUGF0aHMuaGFzKHBhdGgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IGZldGNoQW5kQXBwbHlNYW5pZmVzdFBhdGNoZXMoXG4gICAgICBbcGF0aF0sXG4gICAgICBmZXRjaGVyS2V5ID8gd2luZG93LmxvY2F0aW9uLmhyZWYgOiBwYXRoLFxuICAgICAgbWFuaWZlc3QsXG4gICAgICByb3V0ZU1vZHVsZXMsXG4gICAgICBzc3IsXG4gICAgICBpc1NwYU1vZGUsXG4gICAgICBiYXNlbmFtZSxcbiAgICAgIHJvdXRlRGlzY292ZXJ5Lm1hbmlmZXN0UGF0aCxcbiAgICAgIHBhdGNoLFxuICAgICAgc2lnbmFsXG4gICAgKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZUZvZ09GV2FyRGlzY292ZXJ5KHJvdXRlciwgbWFuaWZlc3QsIHJvdXRlTW9kdWxlcywgc3NyLCByb3V0ZURpc2NvdmVyeSwgaXNTcGFNb2RlKSB7XG4gIFJlYWN0OC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNGb2dPZldhckVuYWJsZWQocm91dGVEaXNjb3ZlcnksIHNzcikgfHwgLy8gQHRzLWV4cGVjdC1lcnJvciAtIFRTIGRvZXNuJ3Qga25vdyBhYm91dCB0aGlzIHlldFxuICAgIHdpbmRvdy5uYXZpZ2F0b3I/LmNvbm5lY3Rpb24/LnNhdmVEYXRhID09PSB0cnVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyRWxlbWVudChlbCkge1xuICAgICAgbGV0IHBhdGggPSBlbC50YWdOYW1lID09PSBcIkZPUk1cIiA/IGVsLmdldEF0dHJpYnV0ZShcImFjdGlvblwiKSA6IGVsLmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG4gICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHBhdGhuYW1lID0gZWwudGFnTmFtZSA9PT0gXCJBXCIgPyBlbC5wYXRobmFtZSA6IG5ldyBVUkwocGF0aCwgd2luZG93LmxvY2F0aW9uLm9yaWdpbikucGF0aG5hbWU7XG4gICAgICBpZiAoIWRpc2NvdmVyZWRQYXRocy5oYXMocGF0aG5hbWUpKSB7XG4gICAgICAgIG5leHRQYXRocy5hZGQocGF0aG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBmZXRjaFBhdGNoZXMoKSB7XG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiYVtkYXRhLWRpc2NvdmVyXSwgZm9ybVtkYXRhLWRpc2NvdmVyXVwiKS5mb3JFYWNoKHJlZ2lzdGVyRWxlbWVudCk7XG4gICAgICBsZXQgbGF6eVBhdGhzID0gQXJyYXkuZnJvbShuZXh0UGF0aHMua2V5cygpKS5maWx0ZXIoKHBhdGgpID0+IHtcbiAgICAgICAgaWYgKGRpc2NvdmVyZWRQYXRocy5oYXMocGF0aCkpIHtcbiAgICAgICAgICBuZXh0UGF0aHMuZGVsZXRlKHBhdGgpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGxhenlQYXRocy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZmV0Y2hBbmRBcHBseU1hbmlmZXN0UGF0Y2hlcyhcbiAgICAgICAgICBsYXp5UGF0aHMsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgICByb3V0ZU1vZHVsZXMsXG4gICAgICAgICAgc3NyLFxuICAgICAgICAgIGlzU3BhTW9kZSxcbiAgICAgICAgICByb3V0ZXIuYmFzZW5hbWUsXG4gICAgICAgICAgcm91dGVEaXNjb3ZlcnkubWFuaWZlc3RQYXRoLFxuICAgICAgICAgIHJvdXRlci5wYXRjaFJvdXRlc1xuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGZldGNoIG1hbmlmZXN0IHBhdGNoZXNcIiwgZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBkZWJvdW5jZWRGZXRjaFBhdGNoZXMgPSBkZWJvdW5jZShmZXRjaFBhdGNoZXMsIDEwMCk7XG4gICAgZmV0Y2hQYXRjaGVzKCk7XG4gICAgbGV0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4gZGVib3VuY2VkRmV0Y2hQYXRjaGVzKCkpO1xuICAgIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7XG4gICAgICBzdWJ0cmVlOiB0cnVlLFxuICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgIGF0dHJpYnV0ZUZpbHRlcjogW1wiZGF0YS1kaXNjb3ZlclwiLCBcImhyZWZcIiwgXCJhY3Rpb25cIl1cbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4gb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9LCBbc3NyLCBpc1NwYU1vZGUsIG1hbmlmZXN0LCByb3V0ZU1vZHVsZXMsIHJvdXRlciwgcm91dGVEaXNjb3ZlcnldKTtcbn1cbmZ1bmN0aW9uIGdldE1hbmlmZXN0UGF0aChfbWFuaWZlc3RQYXRoLCBiYXNlbmFtZSkge1xuICBsZXQgbWFuaWZlc3RQYXRoID0gX21hbmlmZXN0UGF0aCB8fCBcIi9fX21hbmlmZXN0XCI7XG4gIGlmIChiYXNlbmFtZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG1hbmlmZXN0UGF0aDtcbiAgfVxuICByZXR1cm4gYCR7YmFzZW5hbWV9JHttYW5pZmVzdFBhdGh9YC5yZXBsYWNlKC9cXC8rL2csIFwiL1wiKTtcbn1cbnZhciBNQU5JRkVTVF9WRVJTSU9OX1NUT1JBR0VfS0VZID0gXCJyZWFjdC1yb3V0ZXItbWFuaWZlc3QtdmVyc2lvblwiO1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hBbmRBcHBseU1hbmlmZXN0UGF0Y2hlcyhwYXRocywgZXJyb3JSZWxvYWRQYXRoLCBtYW5pZmVzdCwgcm91dGVNb2R1bGVzLCBzc3IsIGlzU3BhTW9kZSwgYmFzZW5hbWUsIG1hbmlmZXN0UGF0aCwgcGF0Y2hSb3V0ZXMsIHNpZ25hbCkge1xuICBsZXQgdXJsID0gbmV3IFVSTChcbiAgICBnZXRNYW5pZmVzdFBhdGgobWFuaWZlc3RQYXRoLCBiYXNlbmFtZSksXG4gICAgd2luZG93LmxvY2F0aW9uLm9yaWdpblxuICApO1xuICBwYXRocy5zb3J0KCkuZm9yRWFjaCgocGF0aCkgPT4gdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJwXCIsIHBhdGgpKTtcbiAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJ2ZXJzaW9uXCIsIG1hbmlmZXN0LnZlcnNpb24pO1xuICBpZiAodXJsLnRvU3RyaW5nKCkubGVuZ3RoID4gVVJMX0xJTUlUKSB7XG4gICAgbmV4dFBhdGhzLmNsZWFyKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBzZXJ2ZXJQYXRjaGVzO1xuICB0cnkge1xuICAgIGxldCByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIHsgc2lnbmFsIH0pO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cmVzLnN0YXR1c30gJHtyZXMuc3RhdHVzVGV4dH1gKTtcbiAgICB9IGVsc2UgaWYgKHJlcy5zdGF0dXMgPT09IDIwNCAmJiByZXMuaGVhZGVycy5oYXMoXCJYLVJlbWl4LVJlbG9hZC1Eb2N1bWVudFwiKSkge1xuICAgICAgaWYgKCFlcnJvclJlbG9hZFBhdGgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiRGV0ZWN0ZWQgYSBtYW5pZmVzdCB2ZXJzaW9uIG1pc21hdGNoIGR1cmluZyBlYWdlciByb3V0ZSBkaXNjb3ZlcnkuIFRoZSBuZXh0IG5hdmlnYXRpb24vZmV0Y2ggdG8gYW4gdW5kaXNjb3ZlcmVkIHJvdXRlIHdpbGwgcmVzdWx0IGluIGEgbmV3IGRvY3VtZW50IG5hdmlnYXRpb24gdG8gc3luYyB1cCB3aXRoIHRoZSBsYXRlc3QgbWFuaWZlc3QuXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oTUFOSUZFU1RfVkVSU0lPTl9TVE9SQUdFX0tFWSkgPT09IG1hbmlmZXN0LnZlcnNpb24pIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlVuYWJsZSB0byBkaXNjb3ZlciByb3V0ZXMgZHVlIHRvIG1hbmlmZXN0IHZlcnNpb24gbWlzbWF0Y2guXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShNQU5JRkVTVF9WRVJTSU9OX1NUT1JBR0VfS0VZLCBtYW5pZmVzdC52ZXJzaW9uKTtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gZXJyb3JSZWxvYWRQYXRoO1xuICAgICAgY29uc29sZS53YXJuKFwiRGV0ZWN0ZWQgbWFuaWZlc3QgdmVyc2lvbiBtaXNtYXRjaCwgcmVsb2FkaW5nLi4uXCIpO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKCkgPT4ge1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChyZXMuc3RhdHVzID49IDQwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGF3YWl0IHJlcy50ZXh0KCkpO1xuICAgIH1cbiAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKE1BTklGRVNUX1ZFUlNJT05fU1RPUkFHRV9LRVkpO1xuICAgIHNlcnZlclBhdGNoZXMgPSBhd2FpdCByZXMuanNvbigpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHNpZ25hbD8uYWJvcnRlZCkgcmV0dXJuO1xuICAgIHRocm93IGU7XG4gIH1cbiAgbGV0IGtub3duUm91dGVzID0gbmV3IFNldChPYmplY3Qua2V5cyhtYW5pZmVzdC5yb3V0ZXMpKTtcbiAgbGV0IHBhdGNoZXMgPSBPYmplY3QudmFsdWVzKHNlcnZlclBhdGNoZXMpLnJlZHVjZSgoYWNjLCByb3V0ZSkgPT4ge1xuICAgIGlmIChyb3V0ZSAmJiAha25vd25Sb3V0ZXMuaGFzKHJvdXRlLmlkKSkge1xuICAgICAgYWNjW3JvdXRlLmlkXSA9IHJvdXRlO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIE9iamVjdC5hc3NpZ24obWFuaWZlc3Qucm91dGVzLCBwYXRjaGVzKTtcbiAgcGF0aHMuZm9yRWFjaCgocCkgPT4gYWRkVG9GaWZvUXVldWUocCwgZGlzY292ZXJlZFBhdGhzKSk7XG4gIGxldCBwYXJlbnRJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBPYmplY3QudmFsdWVzKHBhdGNoZXMpLmZvckVhY2goKHBhdGNoKSA9PiB7XG4gICAgaWYgKHBhdGNoICYmICghcGF0Y2gucGFyZW50SWQgfHwgIXBhdGNoZXNbcGF0Y2gucGFyZW50SWRdKSkge1xuICAgICAgcGFyZW50SWRzLmFkZChwYXRjaC5wYXJlbnRJZCk7XG4gICAgfVxuICB9KTtcbiAgcGFyZW50SWRzLmZvckVhY2goXG4gICAgKHBhcmVudElkKSA9PiBwYXRjaFJvdXRlcyhcbiAgICAgIHBhcmVudElkIHx8IG51bGwsXG4gICAgICBjcmVhdGVDbGllbnRSb3V0ZXMocGF0Y2hlcywgcm91dGVNb2R1bGVzLCBudWxsLCBzc3IsIGlzU3BhTW9kZSwgcGFyZW50SWQpXG4gICAgKVxuICApO1xufVxuZnVuY3Rpb24gYWRkVG9GaWZvUXVldWUocGF0aCwgcXVldWUpIHtcbiAgaWYgKHF1ZXVlLnNpemUgPj0gZGlzY292ZXJlZFBhdGhzTWF4U2l6ZSkge1xuICAgIGxldCBmaXJzdCA9IHF1ZXVlLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcbiAgICBxdWV1ZS5kZWxldGUoZmlyc3QpO1xuICB9XG4gIHF1ZXVlLmFkZChwYXRoKTtcbn1cbmZ1bmN0aW9uIGRlYm91bmNlKGNhbGxiYWNrLCB3YWl0KSB7XG4gIGxldCB0aW1lb3V0SWQ7XG4gIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICB0aW1lb3V0SWQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiBjYWxsYmFjayguLi5hcmdzKSwgd2FpdCk7XG4gIH07XG59XG5cbi8vIGxpYi9kb20vc3NyL2NvbXBvbmVudHMudHN4XG5mdW5jdGlvbiB1c2VEYXRhUm91dGVyQ29udGV4dDIoKSB7XG4gIGxldCBjb250ZXh0ID0gUmVhY3Q5LnVzZUNvbnRleHQoRGF0YVJvdXRlckNvbnRleHQpO1xuICBpbnZhcmlhbnQyKFxuICAgIGNvbnRleHQsXG4gICAgXCJZb3UgbXVzdCByZW5kZXIgdGhpcyBlbGVtZW50IGluc2lkZSBhIDxEYXRhUm91dGVyQ29udGV4dC5Qcm92aWRlcj4gZWxlbWVudFwiXG4gICk7XG4gIHJldHVybiBjb250ZXh0O1xufVxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlclN0YXRlQ29udGV4dCgpIHtcbiAgbGV0IGNvbnRleHQgPSBSZWFjdDkudXNlQ29udGV4dChEYXRhUm91dGVyU3RhdGVDb250ZXh0KTtcbiAgaW52YXJpYW50MihcbiAgICBjb250ZXh0LFxuICAgIFwiWW91IG11c3QgcmVuZGVyIHRoaXMgZWxlbWVudCBpbnNpZGUgYSA8RGF0YVJvdXRlclN0YXRlQ29udGV4dC5Qcm92aWRlcj4gZWxlbWVudFwiXG4gICk7XG4gIHJldHVybiBjb250ZXh0O1xufVxudmFyIEZyYW1ld29ya0NvbnRleHQgPSBSZWFjdDkuY3JlYXRlQ29udGV4dCh2b2lkIDApO1xuRnJhbWV3b3JrQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiRnJhbWV3b3JrQ29udGV4dFwiO1xuZnVuY3Rpb24gdXNlRnJhbWV3b3JrQ29udGV4dCgpIHtcbiAgbGV0IGNvbnRleHQgPSBSZWFjdDkudXNlQ29udGV4dChGcmFtZXdvcmtDb250ZXh0KTtcbiAgaW52YXJpYW50MihcbiAgICBjb250ZXh0LFxuICAgIFwiWW91IG11c3QgcmVuZGVyIHRoaXMgZWxlbWVudCBpbnNpZGUgYSA8SHlkcmF0ZWRSb3V0ZXI+IGVsZW1lbnRcIlxuICApO1xuICByZXR1cm4gY29udGV4dDtcbn1cbmZ1bmN0aW9uIHVzZVByZWZldGNoQmVoYXZpb3IocHJlZmV0Y2gsIHRoZWlyRWxlbWVudFByb3BzKSB7XG4gIGxldCBmcmFtZXdvcmtDb250ZXh0ID0gUmVhY3Q5LnVzZUNvbnRleHQoRnJhbWV3b3JrQ29udGV4dCk7XG4gIGxldCBbbWF5YmVQcmVmZXRjaCwgc2V0TWF5YmVQcmVmZXRjaF0gPSBSZWFjdDkudXNlU3RhdGUoZmFsc2UpO1xuICBsZXQgW3Nob3VsZFByZWZldGNoLCBzZXRTaG91bGRQcmVmZXRjaF0gPSBSZWFjdDkudXNlU3RhdGUoZmFsc2UpO1xuICBsZXQgeyBvbkZvY3VzLCBvbkJsdXIsIG9uTW91c2VFbnRlciwgb25Nb3VzZUxlYXZlLCBvblRvdWNoU3RhcnQgfSA9IHRoZWlyRWxlbWVudFByb3BzO1xuICBsZXQgcmVmID0gUmVhY3Q5LnVzZVJlZihudWxsKTtcbiAgUmVhY3Q5LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHByZWZldGNoID09PSBcInJlbmRlclwiKSB7XG4gICAgICBzZXRTaG91bGRQcmVmZXRjaCh0cnVlKTtcbiAgICB9XG4gICAgaWYgKHByZWZldGNoID09PSBcInZpZXdwb3J0XCIpIHtcbiAgICAgIGxldCBjYWxsYmFjayA9IChlbnRyaWVzKSA9PiB7XG4gICAgICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgICAgICBzZXRTaG91bGRQcmVmZXRjaChlbnRyeS5pc0ludGVyc2VjdGluZyk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGxldCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihjYWxsYmFjaywgeyB0aHJlc2hvbGQ6IDAuNSB9KTtcbiAgICAgIGlmIChyZWYuY3VycmVudCkgb2JzZXJ2ZXIub2JzZXJ2ZShyZWYuY3VycmVudCk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW3ByZWZldGNoXSk7XG4gIFJlYWN0OS51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChtYXliZVByZWZldGNoKSB7XG4gICAgICBsZXQgaWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc2V0U2hvdWxkUHJlZmV0Y2godHJ1ZSk7XG4gICAgICB9LCAxMDApO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbbWF5YmVQcmVmZXRjaF0pO1xuICBsZXQgc2V0SW50ZW50ID0gKCkgPT4ge1xuICAgIHNldE1heWJlUHJlZmV0Y2godHJ1ZSk7XG4gIH07XG4gIGxldCBjYW5jZWxJbnRlbnQgPSAoKSA9PiB7XG4gICAgc2V0TWF5YmVQcmVmZXRjaChmYWxzZSk7XG4gICAgc2V0U2hvdWxkUHJlZmV0Y2goZmFsc2UpO1xuICB9O1xuICBpZiAoIWZyYW1ld29ya0NvbnRleHQpIHtcbiAgICByZXR1cm4gW2ZhbHNlLCByZWYsIHt9XTtcbiAgfVxuICBpZiAocHJlZmV0Y2ggIT09IFwiaW50ZW50XCIpIHtcbiAgICByZXR1cm4gW3Nob3VsZFByZWZldGNoLCByZWYsIHt9XTtcbiAgfVxuICByZXR1cm4gW1xuICAgIHNob3VsZFByZWZldGNoLFxuICAgIHJlZixcbiAgICB7XG4gICAgICBvbkZvY3VzOiBjb21wb3NlRXZlbnRIYW5kbGVycyhvbkZvY3VzLCBzZXRJbnRlbnQpLFxuICAgICAgb25CbHVyOiBjb21wb3NlRXZlbnRIYW5kbGVycyhvbkJsdXIsIGNhbmNlbEludGVudCksXG4gICAgICBvbk1vdXNlRW50ZXI6IGNvbXBvc2VFdmVudEhhbmRsZXJzKG9uTW91c2VFbnRlciwgc2V0SW50ZW50KSxcbiAgICAgIG9uTW91c2VMZWF2ZTogY29tcG9zZUV2ZW50SGFuZGxlcnMob25Nb3VzZUxlYXZlLCBjYW5jZWxJbnRlbnQpLFxuICAgICAgb25Ub3VjaFN0YXJ0OiBjb21wb3NlRXZlbnRIYW5kbGVycyhvblRvdWNoU3RhcnQsIHNldEludGVudClcbiAgICB9XG4gIF07XG59XG5mdW5jdGlvbiBjb21wb3NlRXZlbnRIYW5kbGVycyh0aGVpckhhbmRsZXIsIG91ckhhbmRsZXIpIHtcbiAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgIHRoZWlySGFuZGxlciAmJiB0aGVpckhhbmRsZXIoZXZlbnQpO1xuICAgIGlmICghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgb3VySGFuZGxlcihldmVudCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0QWN0aXZlTWF0Y2hlcyhtYXRjaGVzLCBlcnJvcnMsIGlzU3BhTW9kZSkge1xuICBpZiAoaXNTcGFNb2RlICYmICFpc0h5ZHJhdGVkKSB7XG4gICAgcmV0dXJuIFttYXRjaGVzWzBdXTtcbiAgfVxuICBpZiAoZXJyb3JzKSB7XG4gICAgbGV0IGVycm9ySWR4ID0gbWF0Y2hlcy5maW5kSW5kZXgoKG0pID0+IGVycm9yc1ttLnJvdXRlLmlkXSAhPT0gdm9pZCAwKTtcbiAgICByZXR1cm4gbWF0Y2hlcy5zbGljZSgwLCBlcnJvcklkeCArIDEpO1xuICB9XG4gIHJldHVybiBtYXRjaGVzO1xufVxuZnVuY3Rpb24gTGlua3MoKSB7XG4gIGxldCB7IGlzU3BhTW9kZSwgbWFuaWZlc3QsIHJvdXRlTW9kdWxlcywgY3JpdGljYWxDc3MgfSA9IHVzZUZyYW1ld29ya0NvbnRleHQoKTtcbiAgbGV0IHsgZXJyb3JzLCBtYXRjaGVzOiByb3V0ZXJNYXRjaGVzIH0gPSB1c2VEYXRhUm91dGVyU3RhdGVDb250ZXh0KCk7XG4gIGxldCBtYXRjaGVzID0gZ2V0QWN0aXZlTWF0Y2hlcyhyb3V0ZXJNYXRjaGVzLCBlcnJvcnMsIGlzU3BhTW9kZSk7XG4gIGxldCBrZXllZExpbmtzID0gUmVhY3Q5LnVzZU1lbW8oXG4gICAgKCkgPT4gZ2V0S2V5ZWRMaW5rc0Zvck1hdGNoZXMobWF0Y2hlcywgcm91dGVNb2R1bGVzLCBtYW5pZmVzdCksXG4gICAgW21hdGNoZXMsIHJvdXRlTW9kdWxlcywgbWFuaWZlc3RdXG4gICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoUmVhY3Q5LkZyYWdtZW50LCBudWxsLCB0eXBlb2YgY3JpdGljYWxDc3MgPT09IFwic3RyaW5nXCIgPyAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiLCB7IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7IF9faHRtbDogY3JpdGljYWxDc3MgfSB9KSA6IG51bGwsIHR5cGVvZiBjcml0aWNhbENzcyA9PT0gXCJvYmplY3RcIiA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcImxpbmtcIiwgeyByZWw6IFwic3R5bGVzaGVldFwiLCBocmVmOiBjcml0aWNhbENzcy5ocmVmIH0pIDogbnVsbCwga2V5ZWRMaW5rcy5tYXAoXG4gICAgKHsga2V5LCBsaW5rIH0pID0+IGlzUGFnZUxpbmtEZXNjcmlwdG9yKGxpbmspID8gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFByZWZldGNoUGFnZUxpbmtzLCB7IGtleSwgLi4ubGluayB9KSA6IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcImxpbmtcIiwgeyBrZXksIC4uLmxpbmsgfSlcbiAgKSk7XG59XG5mdW5jdGlvbiBQcmVmZXRjaFBhZ2VMaW5rcyh7XG4gIHBhZ2UsXG4gIC4uLmRhdGFMaW5rUHJvcHNcbn0pIHtcbiAgbGV0IHsgcm91dGVyIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dDIoKTtcbiAgbGV0IG1hdGNoZXMgPSBSZWFjdDkudXNlTWVtbyhcbiAgICAoKSA9PiBtYXRjaFJvdXRlcyhyb3V0ZXIucm91dGVzLCBwYWdlLCByb3V0ZXIuYmFzZW5hbWUpLFxuICAgIFtyb3V0ZXIucm91dGVzLCBwYWdlLCByb3V0ZXIuYmFzZW5hbWVdXG4gICk7XG4gIGlmICghbWF0Y2hlcykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoUHJlZmV0Y2hQYWdlTGlua3NJbXBsLCB7IHBhZ2UsIG1hdGNoZXMsIC4uLmRhdGFMaW5rUHJvcHMgfSk7XG59XG5mdW5jdGlvbiB1c2VLZXllZFByZWZldGNoTGlua3MobWF0Y2hlcykge1xuICBsZXQgeyBtYW5pZmVzdCwgcm91dGVNb2R1bGVzIH0gPSB1c2VGcmFtZXdvcmtDb250ZXh0KCk7XG4gIGxldCBba2V5ZWRQcmVmZXRjaExpbmtzLCBzZXRLZXllZFByZWZldGNoTGlua3NdID0gUmVhY3Q5LnVzZVN0YXRlKFtdKTtcbiAgUmVhY3Q5LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGludGVycnVwdGVkID0gZmFsc2U7XG4gICAgdm9pZCBnZXRLZXllZFByZWZldGNoTGlua3MobWF0Y2hlcywgbWFuaWZlc3QsIHJvdXRlTW9kdWxlcykudGhlbihcbiAgICAgIChsaW5rcykgPT4ge1xuICAgICAgICBpZiAoIWludGVycnVwdGVkKSB7XG4gICAgICAgICAgc2V0S2V5ZWRQcmVmZXRjaExpbmtzKGxpbmtzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGludGVycnVwdGVkID0gdHJ1ZTtcbiAgICB9O1xuICB9LCBbbWF0Y2hlcywgbWFuaWZlc3QsIHJvdXRlTW9kdWxlc10pO1xuICByZXR1cm4ga2V5ZWRQcmVmZXRjaExpbmtzO1xufVxuZnVuY3Rpb24gUHJlZmV0Y2hQYWdlTGlua3NJbXBsKHtcbiAgcGFnZSxcbiAgbWF0Y2hlczogbmV4dE1hdGNoZXMsXG4gIC4uLmxpbmtQcm9wc1xufSkge1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgeyBtYW5pZmVzdCwgcm91dGVNb2R1bGVzIH0gPSB1c2VGcmFtZXdvcmtDb250ZXh0KCk7XG4gIGxldCB7IGJhc2VuYW1lIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dDIoKTtcbiAgbGV0IHsgbG9hZGVyRGF0YSwgbWF0Y2hlcyB9ID0gdXNlRGF0YVJvdXRlclN0YXRlQ29udGV4dCgpO1xuICBsZXQgbmV3TWF0Y2hlc0ZvckRhdGEgPSBSZWFjdDkudXNlTWVtbyhcbiAgICAoKSA9PiBnZXROZXdNYXRjaGVzRm9yTGlua3MoXG4gICAgICBwYWdlLFxuICAgICAgbmV4dE1hdGNoZXMsXG4gICAgICBtYXRjaGVzLFxuICAgICAgbWFuaWZlc3QsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIFwiZGF0YVwiXG4gICAgKSxcbiAgICBbcGFnZSwgbmV4dE1hdGNoZXMsIG1hdGNoZXMsIG1hbmlmZXN0LCBsb2NhdGlvbl1cbiAgKTtcbiAgbGV0IG5ld01hdGNoZXNGb3JBc3NldHMgPSBSZWFjdDkudXNlTWVtbyhcbiAgICAoKSA9PiBnZXROZXdNYXRjaGVzRm9yTGlua3MoXG4gICAgICBwYWdlLFxuICAgICAgbmV4dE1hdGNoZXMsXG4gICAgICBtYXRjaGVzLFxuICAgICAgbWFuaWZlc3QsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIFwiYXNzZXRzXCJcbiAgICApLFxuICAgIFtwYWdlLCBuZXh0TWF0Y2hlcywgbWF0Y2hlcywgbWFuaWZlc3QsIGxvY2F0aW9uXVxuICApO1xuICBsZXQgZGF0YUhyZWZzID0gUmVhY3Q5LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmIChwYWdlID09PSBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaCArIGxvY2F0aW9uLmhhc2gpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgbGV0IHJvdXRlc1BhcmFtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgbGV0IGZvdW5kT3B0T3V0Um91dGUgPSBmYWxzZTtcbiAgICBuZXh0TWF0Y2hlcy5mb3JFYWNoKChtKSA9PiB7XG4gICAgICBsZXQgbWFuaWZlc3RSb3V0ZSA9IG1hbmlmZXN0LnJvdXRlc1ttLnJvdXRlLmlkXTtcbiAgICAgIGlmICghbWFuaWZlc3RSb3V0ZSB8fCAhbWFuaWZlc3RSb3V0ZS5oYXNMb2FkZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFuZXdNYXRjaGVzRm9yRGF0YS5zb21lKChtMikgPT4gbTIucm91dGUuaWQgPT09IG0ucm91dGUuaWQpICYmIG0ucm91dGUuaWQgaW4gbG9hZGVyRGF0YSAmJiByb3V0ZU1vZHVsZXNbbS5yb3V0ZS5pZF0/LnNob3VsZFJldmFsaWRhdGUpIHtcbiAgICAgICAgZm91bmRPcHRPdXRSb3V0ZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG1hbmlmZXN0Um91dGUuaGFzQ2xpZW50TG9hZGVyKSB7XG4gICAgICAgIGZvdW5kT3B0T3V0Um91dGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm91dGVzUGFyYW1zLmFkZChtLnJvdXRlLmlkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAocm91dGVzUGFyYW1zLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgbGV0IHVybCA9IHNpbmdsZUZldGNoVXJsKHBhZ2UsIGJhc2VuYW1lKTtcbiAgICBpZiAoZm91bmRPcHRPdXRSb3V0ZSAmJiByb3V0ZXNQYXJhbXMuc2l6ZSA+IDApIHtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFxuICAgICAgICBcIl9yb3V0ZXNcIixcbiAgICAgICAgbmV4dE1hdGNoZXMuZmlsdGVyKChtKSA9PiByb3V0ZXNQYXJhbXMuaGFzKG0ucm91dGUuaWQpKS5tYXAoKG0pID0+IG0ucm91dGUuaWQpLmpvaW4oXCIsXCIpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gW3VybC5wYXRobmFtZSArIHVybC5zZWFyY2hdO1xuICB9LCBbXG4gICAgYmFzZW5hbWUsXG4gICAgbG9hZGVyRGF0YSxcbiAgICBsb2NhdGlvbixcbiAgICBtYW5pZmVzdCxcbiAgICBuZXdNYXRjaGVzRm9yRGF0YSxcbiAgICBuZXh0TWF0Y2hlcyxcbiAgICBwYWdlLFxuICAgIHJvdXRlTW9kdWxlc1xuICBdKTtcbiAgbGV0IG1vZHVsZUhyZWZzID0gUmVhY3Q5LnVzZU1lbW8oXG4gICAgKCkgPT4gZ2V0TW9kdWxlTGlua0hyZWZzKG5ld01hdGNoZXNGb3JBc3NldHMsIG1hbmlmZXN0KSxcbiAgICBbbmV3TWF0Y2hlc0ZvckFzc2V0cywgbWFuaWZlc3RdXG4gICk7XG4gIGxldCBrZXllZFByZWZldGNoTGlua3MgPSB1c2VLZXllZFByZWZldGNoTGlua3MobmV3TWF0Y2hlc0ZvckFzc2V0cyk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoUmVhY3Q5LkZyYWdtZW50LCBudWxsLCBkYXRhSHJlZnMubWFwKChocmVmMikgPT4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFwibGlua1wiLCB7IGtleTogaHJlZjIsIHJlbDogXCJwcmVmZXRjaFwiLCBhczogXCJmZXRjaFwiLCBocmVmOiBocmVmMiwgLi4ubGlua1Byb3BzIH0pKSwgbW9kdWxlSHJlZnMubWFwKChocmVmMikgPT4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFwibGlua1wiLCB7IGtleTogaHJlZjIsIHJlbDogXCJtb2R1bGVwcmVsb2FkXCIsIGhyZWY6IGhyZWYyLCAuLi5saW5rUHJvcHMgfSkpLCBrZXllZFByZWZldGNoTGlua3MubWFwKCh7IGtleSwgbGluayB9KSA9PiAoXG4gICAgLy8gdGhlc2UgZG9uJ3Qgc3ByZWFkIGBsaW5rUHJvcHNgIGJlY2F1c2UgdGhleSBhcmUgZnVsbCBsaW5rIGRlc2NyaXB0b3JzXG4gICAgLy8gYWxyZWFkeSB3aXRoIHRoZWlyIG93biBwcm9wc1xuICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcImxpbmtcIiwgeyBrZXksIC4uLmxpbmsgfSlcbiAgKSkpO1xufVxuZnVuY3Rpb24gTWV0YSgpIHtcbiAgbGV0IHsgaXNTcGFNb2RlLCByb3V0ZU1vZHVsZXMgfSA9IHVzZUZyYW1ld29ya0NvbnRleHQoKTtcbiAgbGV0IHtcbiAgICBlcnJvcnMsXG4gICAgbWF0Y2hlczogcm91dGVyTWF0Y2hlcyxcbiAgICBsb2FkZXJEYXRhXG4gIH0gPSB1c2VEYXRhUm91dGVyU3RhdGVDb250ZXh0KCk7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBfbWF0Y2hlcyA9IGdldEFjdGl2ZU1hdGNoZXMocm91dGVyTWF0Y2hlcywgZXJyb3JzLCBpc1NwYU1vZGUpO1xuICBsZXQgZXJyb3IgPSBudWxsO1xuICBpZiAoZXJyb3JzKSB7XG4gICAgZXJyb3IgPSBlcnJvcnNbX21hdGNoZXNbX21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuaWRdO1xuICB9XG4gIGxldCBtZXRhID0gW107XG4gIGxldCBsZWFmTWV0YSA9IG51bGw7XG4gIGxldCBtYXRjaGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgX21hdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgX21hdGNoID0gX21hdGNoZXNbaV07XG4gICAgbGV0IHJvdXRlSWQgPSBfbWF0Y2gucm91dGUuaWQ7XG4gICAgbGV0IGRhdGEyID0gbG9hZGVyRGF0YVtyb3V0ZUlkXTtcbiAgICBsZXQgcGFyYW1zID0gX21hdGNoLnBhcmFtcztcbiAgICBsZXQgcm91dGVNb2R1bGUgPSByb3V0ZU1vZHVsZXNbcm91dGVJZF07XG4gICAgbGV0IHJvdXRlTWV0YSA9IFtdO1xuICAgIGxldCBtYXRjaCA9IHtcbiAgICAgIGlkOiByb3V0ZUlkLFxuICAgICAgZGF0YTogZGF0YTIsXG4gICAgICBtZXRhOiBbXSxcbiAgICAgIHBhcmFtczogX21hdGNoLnBhcmFtcyxcbiAgICAgIHBhdGhuYW1lOiBfbWF0Y2gucGF0aG5hbWUsXG4gICAgICBoYW5kbGU6IF9tYXRjaC5yb3V0ZS5oYW5kbGUsXG4gICAgICBlcnJvclxuICAgIH07XG4gICAgbWF0Y2hlc1tpXSA9IG1hdGNoO1xuICAgIGlmIChyb3V0ZU1vZHVsZT8ubWV0YSkge1xuICAgICAgcm91dGVNZXRhID0gdHlwZW9mIHJvdXRlTW9kdWxlLm1ldGEgPT09IFwiZnVuY3Rpb25cIiA/IHJvdXRlTW9kdWxlLm1ldGEoe1xuICAgICAgICBkYXRhOiBkYXRhMixcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgZXJyb3JcbiAgICAgIH0pIDogQXJyYXkuaXNBcnJheShyb3V0ZU1vZHVsZS5tZXRhKSA/IFsuLi5yb3V0ZU1vZHVsZS5tZXRhXSA6IHJvdXRlTW9kdWxlLm1ldGE7XG4gICAgfSBlbHNlIGlmIChsZWFmTWV0YSkge1xuICAgICAgcm91dGVNZXRhID0gWy4uLmxlYWZNZXRhXTtcbiAgICB9XG4gICAgcm91dGVNZXRhID0gcm91dGVNZXRhIHx8IFtdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShyb3V0ZU1ldGEpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiVGhlIHJvdXRlIGF0IFwiICsgX21hdGNoLnJvdXRlLnBhdGggKyBcIiByZXR1cm5zIGFuIGludmFsaWQgdmFsdWUuIEFsbCByb3V0ZSBtZXRhIGZ1bmN0aW9ucyBtdXN0IHJldHVybiBhbiBhcnJheSBvZiBtZXRhIG9iamVjdHMuXFxuXFxuVG8gcmVmZXJlbmNlIHRoZSBtZXRhIGZ1bmN0aW9uIEFQSSwgc2VlIGh0dHBzOi8vcmVtaXgucnVuL3JvdXRlL21ldGFcIlxuICAgICAgKTtcbiAgICB9XG4gICAgbWF0Y2gubWV0YSA9IHJvdXRlTWV0YTtcbiAgICBtYXRjaGVzW2ldID0gbWF0Y2g7XG4gICAgbWV0YSA9IFsuLi5yb3V0ZU1ldGFdO1xuICAgIGxlYWZNZXRhID0gbWV0YTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFJlYWN0OS5GcmFnbWVudCwgbnVsbCwgbWV0YS5mbGF0KCkubWFwKChtZXRhUHJvcHMpID0+IHtcbiAgICBpZiAoIW1ldGFQcm9wcykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChcInRhZ05hbWVcIiBpbiBtZXRhUHJvcHMpIHtcbiAgICAgIGxldCB7IHRhZ05hbWUsIC4uLnJlc3QgfSA9IG1ldGFQcm9wcztcbiAgICAgIGlmICghaXNWYWxpZE1ldGFUYWcodGFnTmFtZSkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBBIG1ldGEgb2JqZWN0IHVzZXMgYW4gaW52YWxpZCB0YWdOYW1lOiAke3RhZ05hbWV9LiBFeHBlY3RlZCBlaXRoZXIgJ2xpbmsnIG9yICdtZXRhJ2BcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBsZXQgQ29tcCA9IHRhZ05hbWU7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KENvbXAsIHsga2V5OiBKU09OLnN0cmluZ2lmeShyZXN0KSwgLi4ucmVzdCB9KTtcbiAgICB9XG4gICAgaWYgKFwidGl0bGVcIiBpbiBtZXRhUHJvcHMpIHtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXCJ0aXRsZVwiLCB7IGtleTogXCJ0aXRsZVwiIH0sIFN0cmluZyhtZXRhUHJvcHMudGl0bGUpKTtcbiAgICB9XG4gICAgaWYgKFwiY2hhcnNldFwiIGluIG1ldGFQcm9wcykge1xuICAgICAgbWV0YVByb3BzLmNoYXJTZXQgPz8gKG1ldGFQcm9wcy5jaGFyU2V0ID0gbWV0YVByb3BzLmNoYXJzZXQpO1xuICAgICAgZGVsZXRlIG1ldGFQcm9wcy5jaGFyc2V0O1xuICAgIH1cbiAgICBpZiAoXCJjaGFyU2V0XCIgaW4gbWV0YVByb3BzICYmIG1ldGFQcm9wcy5jaGFyU2V0ICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgbWV0YVByb3BzLmNoYXJTZXQgPT09IFwic3RyaW5nXCIgPyAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHsga2V5OiBcImNoYXJTZXRcIiwgY2hhclNldDogbWV0YVByb3BzLmNoYXJTZXQgfSkgOiBudWxsO1xuICAgIH1cbiAgICBpZiAoXCJzY3JpcHQ6bGQranNvblwiIGluIG1ldGFQcm9wcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IGpzb24gPSBKU09OLnN0cmluZ2lmeShtZXRhUHJvcHNbXCJzY3JpcHQ6bGQranNvblwiXSk7XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgXCJzY3JpcHRcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IGBzY3JpcHQ6bGQranNvbjoke2pzb259YCxcbiAgICAgICAgICAgIHR5cGU6IFwiYXBwbGljYXRpb24vbGQranNvblwiLFxuICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHsgX19odG1sOiBqc29uIH1cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHsga2V5OiBKU09OLnN0cmluZ2lmeShtZXRhUHJvcHMpLCAuLi5tZXRhUHJvcHMgfSk7XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRNZXRhVGFnKHRhZ05hbWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0YWdOYW1lID09PSBcInN0cmluZ1wiICYmIC9eKG1ldGF8bGluaykkLy50ZXN0KHRhZ05hbWUpO1xufVxudmFyIGlzSHlkcmF0ZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIFNjcmlwdHMocHJvcHMpIHtcbiAgbGV0IHtcbiAgICBtYW5pZmVzdCxcbiAgICBzZXJ2ZXJIYW5kb2ZmU3RyaW5nLFxuICAgIGlzU3BhTW9kZSxcbiAgICByZW5kZXJNZXRhLFxuICAgIHJvdXRlRGlzY292ZXJ5LFxuICAgIHNzclxuICB9ID0gdXNlRnJhbWV3b3JrQ29udGV4dCgpO1xuICBsZXQgeyByb3V0ZXIsIHN0YXRpYzogaXNTdGF0aWMsIHN0YXRpY0NvbnRleHQgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0MigpO1xuICBsZXQgeyBtYXRjaGVzOiByb3V0ZXJNYXRjaGVzIH0gPSB1c2VEYXRhUm91dGVyU3RhdGVDb250ZXh0KCk7XG4gIGxldCBlbmFibGVGb2dPZldhciA9IGlzRm9nT2ZXYXJFbmFibGVkKHJvdXRlRGlzY292ZXJ5LCBzc3IpO1xuICBpZiAocmVuZGVyTWV0YSkge1xuICAgIHJlbmRlck1ldGEuZGlkUmVuZGVyU2NyaXB0cyA9IHRydWU7XG4gIH1cbiAgbGV0IG1hdGNoZXMgPSBnZXRBY3RpdmVNYXRjaGVzKHJvdXRlck1hdGNoZXMsIG51bGwsIGlzU3BhTW9kZSk7XG4gIFJlYWN0OS51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlzSHlkcmF0ZWQgPSB0cnVlO1xuICB9LCBbXSk7XG4gIGxldCBpbml0aWFsU2NyaXB0cyA9IFJlYWN0OS51c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgc3RyZWFtU2NyaXB0ID0gXCJ3aW5kb3cuX19yZWFjdFJvdXRlckNvbnRleHQuc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtzdGFydChjb250cm9sbGVyKXt3aW5kb3cuX19yZWFjdFJvdXRlckNvbnRleHQuc3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7fX0pLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKTtcIjtcbiAgICBsZXQgY29udGV4dFNjcmlwdCA9IHN0YXRpY0NvbnRleHQgPyBgd2luZG93Ll9fcmVhY3RSb3V0ZXJDb250ZXh0ID0gJHtzZXJ2ZXJIYW5kb2ZmU3RyaW5nfTske3N0cmVhbVNjcmlwdH1gIDogXCIgXCI7XG4gICAgbGV0IHJvdXRlTW9kdWxlc1NjcmlwdCA9ICFpc1N0YXRpYyA/IFwiIFwiIDogYCR7bWFuaWZlc3QuaG1yPy5ydW50aW1lID8gYGltcG9ydCAke0pTT04uc3RyaW5naWZ5KG1hbmlmZXN0Lmhtci5ydW50aW1lKX07YCA6IFwiXCJ9JHshZW5hYmxlRm9nT2ZXYXIgPyBgaW1wb3J0ICR7SlNPTi5zdHJpbmdpZnkobWFuaWZlc3QudXJsKX1gIDogXCJcIn07XG4ke21hdGNoZXMubWFwKChtYXRjaCwgcm91dGVJbmRleCkgPT4ge1xuICAgICAgbGV0IHJvdXRlVmFyTmFtZSA9IGByb3V0ZSR7cm91dGVJbmRleH1gO1xuICAgICAgbGV0IG1hbmlmZXN0RW50cnkgPSBtYW5pZmVzdC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgICAgaW52YXJpYW50MihtYW5pZmVzdEVudHJ5LCBgUm91dGUgJHttYXRjaC5yb3V0ZS5pZH0gbm90IGZvdW5kIGluIG1hbmlmZXN0YCk7XG4gICAgICBsZXQge1xuICAgICAgICBjbGllbnRBY3Rpb25Nb2R1bGUsXG4gICAgICAgIGNsaWVudExvYWRlck1vZHVsZSxcbiAgICAgICAgY2xpZW50TWlkZGxld2FyZU1vZHVsZSxcbiAgICAgICAgaHlkcmF0ZUZhbGxiYWNrTW9kdWxlLFxuICAgICAgICBtb2R1bGU6IG1vZHVsZTJcbiAgICAgIH0gPSBtYW5pZmVzdEVudHJ5O1xuICAgICAgbGV0IGNodW5rcyA9IFtcbiAgICAgICAgLi4uY2xpZW50QWN0aW9uTW9kdWxlID8gW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1vZHVsZTogY2xpZW50QWN0aW9uTW9kdWxlLFxuICAgICAgICAgICAgdmFyTmFtZTogYCR7cm91dGVWYXJOYW1lfV9jbGllbnRBY3Rpb25gXG4gICAgICAgICAgfVxuICAgICAgICBdIDogW10sXG4gICAgICAgIC4uLmNsaWVudExvYWRlck1vZHVsZSA/IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtb2R1bGU6IGNsaWVudExvYWRlck1vZHVsZSxcbiAgICAgICAgICAgIHZhck5hbWU6IGAke3JvdXRlVmFyTmFtZX1fY2xpZW50TG9hZGVyYFxuICAgICAgICAgIH1cbiAgICAgICAgXSA6IFtdLFxuICAgICAgICAuLi5jbGllbnRNaWRkbGV3YXJlTW9kdWxlID8gW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1vZHVsZTogY2xpZW50TWlkZGxld2FyZU1vZHVsZSxcbiAgICAgICAgICAgIHZhck5hbWU6IGAke3JvdXRlVmFyTmFtZX1fY2xpZW50TWlkZGxld2FyZWBcbiAgICAgICAgICB9XG4gICAgICAgIF0gOiBbXSxcbiAgICAgICAgLi4uaHlkcmF0ZUZhbGxiYWNrTW9kdWxlID8gW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1vZHVsZTogaHlkcmF0ZUZhbGxiYWNrTW9kdWxlLFxuICAgICAgICAgICAgdmFyTmFtZTogYCR7cm91dGVWYXJOYW1lfV9IeWRyYXRlRmFsbGJhY2tgXG4gICAgICAgICAgfVxuICAgICAgICBdIDogW10sXG4gICAgICAgIHsgbW9kdWxlOiBtb2R1bGUyLCB2YXJOYW1lOiBgJHtyb3V0ZVZhck5hbWV9X21haW5gIH1cbiAgICAgIF07XG4gICAgICBpZiAoY2h1bmtzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gYGltcG9ydCAqIGFzICR7cm91dGVWYXJOYW1lfSBmcm9tICR7SlNPTi5zdHJpbmdpZnkobW9kdWxlMil9O2A7XG4gICAgICB9XG4gICAgICBsZXQgY2h1bmtJbXBvcnRzU25pcHBldCA9IGNodW5rcy5tYXAoKGNodW5rKSA9PiBgaW1wb3J0ICogYXMgJHtjaHVuay52YXJOYW1lfSBmcm9tIFwiJHtjaHVuay5tb2R1bGV9XCI7YCkuam9pbihcIlxcblwiKTtcbiAgICAgIGxldCBtZXJnZWRDaHVua3NTbmlwcGV0ID0gYGNvbnN0ICR7cm91dGVWYXJOYW1lfSA9IHske2NodW5rcy5tYXAoKGNodW5rKSA9PiBgLi4uJHtjaHVuay52YXJOYW1lfWApLmpvaW4oXCIsXCIpfX07YDtcbiAgICAgIHJldHVybiBbY2h1bmtJbXBvcnRzU25pcHBldCwgbWVyZ2VkQ2h1bmtzU25pcHBldF0uam9pbihcIlxcblwiKTtcbiAgICB9KS5qb2luKFwiXFxuXCIpfVxuICAke2VuYWJsZUZvZ09mV2FyID8gKFxuICAgICAgLy8gSW5saW5lIGEgbWluaW1hbCBtYW5pZmVzdCB3aXRoIHRoZSBTU1IgbWF0Y2hlc1xuICAgICAgYHdpbmRvdy5fX3JlYWN0Um91dGVyTWFuaWZlc3QgPSAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICBnZXRQYXJ0aWFsTWFuaWZlc3QobWFuaWZlc3QsIHJvdXRlciksXG4gICAgICAgIG51bGwsXG4gICAgICAgIDJcbiAgICAgICl9O2BcbiAgICApIDogXCJcIn1cbiAgd2luZG93Ll9fcmVhY3RSb3V0ZXJSb3V0ZU1vZHVsZXMgPSB7JHttYXRjaGVzLm1hcCgobWF0Y2gsIGluZGV4KSA9PiBgJHtKU09OLnN0cmluZ2lmeShtYXRjaC5yb3V0ZS5pZCl9OnJvdXRlJHtpbmRleH1gKS5qb2luKFwiLFwiKX19O1xuXG5pbXBvcnQoJHtKU09OLnN0cmluZ2lmeShtYW5pZmVzdC5lbnRyeS5tb2R1bGUpfSk7YDtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFJlYWN0OS5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFxuICAgICAgXCJzY3JpcHRcIixcbiAgICAgIHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogdHJ1ZSxcbiAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IGNyZWF0ZUh0bWwoY29udGV4dFNjcmlwdCksXG4gICAgICAgIHR5cGU6IHZvaWQgMFxuICAgICAgfVxuICAgICksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcbiAgICAgIFwic2NyaXB0XCIsXG4gICAgICB7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6IHRydWUsXG4gICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiBjcmVhdGVIdG1sKHJvdXRlTW9kdWxlc1NjcmlwdCksXG4gICAgICAgIHR5cGU6IFwibW9kdWxlXCIsXG4gICAgICAgIGFzeW5jOiB0cnVlXG4gICAgICB9XG4gICAgKSk7XG4gIH0sIFtdKTtcbiAgbGV0IHByZWxvYWRzID0gaXNIeWRyYXRlZCA/IFtdIDogZGVkdXBlKFxuICAgIG1hbmlmZXN0LmVudHJ5LmltcG9ydHMuY29uY2F0KFxuICAgICAgZ2V0TW9kdWxlTGlua0hyZWZzKG1hdGNoZXMsIG1hbmlmZXN0LCB7XG4gICAgICAgIGluY2x1ZGVIeWRyYXRlRmFsbGJhY2s6IHRydWVcbiAgICAgIH0pXG4gICAgKVxuICApO1xuICBsZXQgc3JpID0gdHlwZW9mIG1hbmlmZXN0LnNyaSA9PT0gXCJvYmplY3RcIiA/IG1hbmlmZXN0LnNyaSA6IHt9O1xuICByZXR1cm4gaXNIeWRyYXRlZCA/IG51bGwgOiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoUmVhY3Q5LkZyYWdtZW50LCBudWxsLCB0eXBlb2YgbWFuaWZlc3Quc3JpID09PSBcIm9iamVjdFwiID8gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFxuICAgIFwic2NyaXB0XCIsXG4gICAge1xuICAgICAgXCJyci1pbXBvcnRtYXBcIjogXCJcIixcbiAgICAgIHR5cGU6IFwiaW1wb3J0bWFwXCIsXG4gICAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6IHRydWUsXG4gICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgICBfX2h0bWw6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBpbnRlZ3JpdHk6IHNyaVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgKSA6IG51bGwsICFlbmFibGVGb2dPZldhciA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcbiAgICBcImxpbmtcIixcbiAgICB7XG4gICAgICByZWw6IFwibW9kdWxlcHJlbG9hZFwiLFxuICAgICAgaHJlZjogbWFuaWZlc3QudXJsLFxuICAgICAgY3Jvc3NPcmlnaW46IHByb3BzLmNyb3NzT3JpZ2luLFxuICAgICAgaW50ZWdyaXR5OiBzcmlbbWFuaWZlc3QudXJsXSxcbiAgICAgIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogdHJ1ZVxuICAgIH1cbiAgKSA6IG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcbiAgICBcImxpbmtcIixcbiAgICB7XG4gICAgICByZWw6IFwibW9kdWxlcHJlbG9hZFwiLFxuICAgICAgaHJlZjogbWFuaWZlc3QuZW50cnkubW9kdWxlLFxuICAgICAgY3Jvc3NPcmlnaW46IHByb3BzLmNyb3NzT3JpZ2luLFxuICAgICAgaW50ZWdyaXR5OiBzcmlbbWFuaWZlc3QuZW50cnkubW9kdWxlXSxcbiAgICAgIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogdHJ1ZVxuICAgIH1cbiAgKSwgcHJlbG9hZHMubWFwKChwYXRoKSA9PiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJsaW5rXCIsXG4gICAge1xuICAgICAga2V5OiBwYXRoLFxuICAgICAgcmVsOiBcIm1vZHVsZXByZWxvYWRcIixcbiAgICAgIGhyZWY6IHBhdGgsXG4gICAgICBjcm9zc09yaWdpbjogcHJvcHMuY3Jvc3NPcmlnaW4sXG4gICAgICBpbnRlZ3JpdHk6IHNyaVtwYXRoXSxcbiAgICAgIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogdHJ1ZVxuICAgIH1cbiAgKSksIGluaXRpYWxTY3JpcHRzKTtcbn1cbmZ1bmN0aW9uIGRlZHVwZShhcnJheSkge1xuICByZXR1cm4gWy4uLm5ldyBTZXQoYXJyYXkpXTtcbn1cbmZ1bmN0aW9uIG1lcmdlUmVmcyguLi5yZWZzKSB7XG4gIHJldHVybiAodmFsdWUpID0+IHtcbiAgICByZWZzLmZvckVhY2goKHJlZikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiByZWYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZWYodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChyZWYgIT0gbnVsbCkge1xuICAgICAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuXG4vLyBsaWIvZG9tL2xpYi50c3hcbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xudHJ5IHtcbiAgaWYgKGlzQnJvd3Nlcikge1xuICAgIHdpbmRvdy5fX3JlYWN0Um91dGVyVmVyc2lvbiA9IFwiNy42LjJcIjtcbiAgfVxufSBjYXRjaCAoZSkge1xufVxuZnVuY3Rpb24gY3JlYXRlQnJvd3NlclJvdXRlcihyb3V0ZXMsIG9wdHMpIHtcbiAgcmV0dXJuIGNyZWF0ZVJvdXRlcih7XG4gICAgYmFzZW5hbWU6IG9wdHM/LmJhc2VuYW1lLFxuICAgIHVuc3RhYmxlX2dldENvbnRleHQ6IG9wdHM/LnVuc3RhYmxlX2dldENvbnRleHQsXG4gICAgZnV0dXJlOiBvcHRzPy5mdXR1cmUsXG4gICAgaGlzdG9yeTogY3JlYXRlQnJvd3Nlckhpc3RvcnkoeyB3aW5kb3c6IG9wdHM/LndpbmRvdyB9KSxcbiAgICBoeWRyYXRpb25EYXRhOiBvcHRzPy5oeWRyYXRpb25EYXRhIHx8IHBhcnNlSHlkcmF0aW9uRGF0YSgpLFxuICAgIHJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgaHlkcmF0aW9uUm91dGVQcm9wZXJ0aWVzLFxuICAgIGRhdGFTdHJhdGVneTogb3B0cz8uZGF0YVN0cmF0ZWd5LFxuICAgIHBhdGNoUm91dGVzT25OYXZpZ2F0aW9uOiBvcHRzPy5wYXRjaFJvdXRlc09uTmF2aWdhdGlvbixcbiAgICB3aW5kb3c6IG9wdHM/LndpbmRvd1xuICB9KS5pbml0aWFsaXplKCk7XG59XG5mdW5jdGlvbiBjcmVhdGVIYXNoUm91dGVyKHJvdXRlcywgb3B0cykge1xuICByZXR1cm4gY3JlYXRlUm91dGVyKHtcbiAgICBiYXNlbmFtZTogb3B0cz8uYmFzZW5hbWUsXG4gICAgdW5zdGFibGVfZ2V0Q29udGV4dDogb3B0cz8udW5zdGFibGVfZ2V0Q29udGV4dCxcbiAgICBmdXR1cmU6IG9wdHM/LmZ1dHVyZSxcbiAgICBoaXN0b3J5OiBjcmVhdGVIYXNoSGlzdG9yeSh7IHdpbmRvdzogb3B0cz8ud2luZG93IH0pLFxuICAgIGh5ZHJhdGlvbkRhdGE6IG9wdHM/Lmh5ZHJhdGlvbkRhdGEgfHwgcGFyc2VIeWRyYXRpb25EYXRhKCksXG4gICAgcm91dGVzLFxuICAgIG1hcFJvdXRlUHJvcGVydGllcyxcbiAgICBoeWRyYXRpb25Sb3V0ZVByb3BlcnRpZXMsXG4gICAgZGF0YVN0cmF0ZWd5OiBvcHRzPy5kYXRhU3RyYXRlZ3ksXG4gICAgcGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb246IG9wdHM/LnBhdGNoUm91dGVzT25OYXZpZ2F0aW9uLFxuICAgIHdpbmRvdzogb3B0cz8ud2luZG93XG4gIH0pLmluaXRpYWxpemUoKTtcbn1cbmZ1bmN0aW9uIHBhcnNlSHlkcmF0aW9uRGF0YSgpIHtcbiAgbGV0IHN0YXRlID0gd2luZG93Py5fX3N0YXRpY1JvdXRlckh5ZHJhdGlvbkRhdGE7XG4gIGlmIChzdGF0ZSAmJiBzdGF0ZS5lcnJvcnMpIHtcbiAgICBzdGF0ZSA9IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgZXJyb3JzOiBkZXNlcmlhbGl6ZUVycm9ycyhzdGF0ZS5lcnJvcnMpXG4gICAgfTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUVycm9ycyhlcnJvcnMpIHtcbiAgaWYgKCFlcnJvcnMpIHJldHVybiBudWxsO1xuICBsZXQgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGVycm9ycyk7XG4gIGxldCBzZXJpYWxpemVkID0ge307XG4gIGZvciAobGV0IFtrZXksIHZhbF0gb2YgZW50cmllcykge1xuICAgIGlmICh2YWwgJiYgdmFsLl9fdHlwZSA9PT0gXCJSb3V0ZUVycm9yUmVzcG9uc2VcIikge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0gbmV3IEVycm9yUmVzcG9uc2VJbXBsKFxuICAgICAgICB2YWwuc3RhdHVzLFxuICAgICAgICB2YWwuc3RhdHVzVGV4dCxcbiAgICAgICAgdmFsLmRhdGEsXG4gICAgICAgIHZhbC5pbnRlcm5hbCA9PT0gdHJ1ZVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHZhbCAmJiB2YWwuX190eXBlID09PSBcIkVycm9yXCIpIHtcbiAgICAgIGlmICh2YWwuX19zdWJUeXBlKSB7XG4gICAgICAgIGxldCBFcnJvckNvbnN0cnVjdG9yID0gd2luZG93W3ZhbC5fX3N1YlR5cGVdO1xuICAgICAgICBpZiAodHlwZW9mIEVycm9yQ29uc3RydWN0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3JDb25zdHJ1Y3Rvcih2YWwubWVzc2FnZSk7XG4gICAgICAgICAgICBlcnJvci5zdGFjayA9IFwiXCI7XG4gICAgICAgICAgICBzZXJpYWxpemVkW2tleV0gPSBlcnJvcjtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2VyaWFsaXplZFtrZXldID09IG51bGwpIHtcbiAgICAgICAgbGV0IGVycm9yID0gbmV3IEVycm9yKHZhbC5tZXNzYWdlKTtcbiAgICAgICAgZXJyb3Iuc3RhY2sgPSBcIlwiO1xuICAgICAgICBzZXJpYWxpemVkW2tleV0gPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VyaWFsaXplZDtcbn1cbmZ1bmN0aW9uIEJyb3dzZXJSb3V0ZXIoe1xuICBiYXNlbmFtZSxcbiAgY2hpbGRyZW4sXG4gIHdpbmRvdzogd2luZG93MlxufSkge1xuICBsZXQgaGlzdG9yeVJlZiA9IFJlYWN0MTAudXNlUmVmKCk7XG4gIGlmIChoaXN0b3J5UmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgIGhpc3RvcnlSZWYuY3VycmVudCA9IGNyZWF0ZUJyb3dzZXJIaXN0b3J5KHsgd2luZG93OiB3aW5kb3cyLCB2NUNvbXBhdDogdHJ1ZSB9KTtcbiAgfVxuICBsZXQgaGlzdG9yeSA9IGhpc3RvcnlSZWYuY3VycmVudDtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0MTAudXNlU3RhdGUoe1xuICAgIGFjdGlvbjogaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb25cbiAgfSk7XG4gIGxldCBzZXRTdGF0ZSA9IFJlYWN0MTAudXNlQ2FsbGJhY2soXG4gICAgKG5ld1N0YXRlKSA9PiB7XG4gICAgICBSZWFjdDEwLnN0YXJ0VHJhbnNpdGlvbigoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICB9LFxuICAgIFtzZXRTdGF0ZUltcGxdXG4gICk7XG4gIFJlYWN0MTAudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnksIHNldFN0YXRlXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QxMC5jcmVhdGVFbGVtZW50KFxuICAgIFJvdXRlcixcbiAgICB7XG4gICAgICBiYXNlbmFtZSxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgICAgbmF2aWdhdGlvblR5cGU6IHN0YXRlLmFjdGlvbixcbiAgICAgIG5hdmlnYXRvcjogaGlzdG9yeVxuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIEhhc2hSb3V0ZXIoeyBiYXNlbmFtZSwgY2hpbGRyZW4sIHdpbmRvdzogd2luZG93MiB9KSB7XG4gIGxldCBoaXN0b3J5UmVmID0gUmVhY3QxMC51c2VSZWYoKTtcbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlSGFzaEhpc3RvcnkoeyB3aW5kb3c6IHdpbmRvdzIsIHY1Q29tcGF0OiB0cnVlIH0pO1xuICB9XG4gIGxldCBoaXN0b3J5ID0gaGlzdG9yeVJlZi5jdXJyZW50O1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3QxMC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICB9KTtcbiAgbGV0IHNldFN0YXRlID0gUmVhY3QxMC51c2VDYWxsYmFjayhcbiAgICAobmV3U3RhdGUpID0+IHtcbiAgICAgIFJlYWN0MTAuc3RhcnRUcmFuc2l0aW9uKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgIH0sXG4gICAgW3NldFN0YXRlSW1wbF1cbiAgKTtcbiAgUmVhY3QxMC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeSwgc2V0U3RhdGVdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEwLmNyZWF0ZUVsZW1lbnQoXG4gICAgUm91dGVyLFxuICAgIHtcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuYWN0aW9uLFxuICAgICAgbmF2aWdhdG9yOiBoaXN0b3J5XG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gSGlzdG9yeVJvdXRlcih7XG4gIGJhc2VuYW1lLFxuICBjaGlsZHJlbixcbiAgaGlzdG9yeVxufSkge1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3QxMC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICB9KTtcbiAgbGV0IHNldFN0YXRlID0gUmVhY3QxMC51c2VDYWxsYmFjayhcbiAgICAobmV3U3RhdGUpID0+IHtcbiAgICAgIFJlYWN0MTAuc3RhcnRUcmFuc2l0aW9uKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgIH0sXG4gICAgW3NldFN0YXRlSW1wbF1cbiAgKTtcbiAgUmVhY3QxMC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeSwgc2V0U3RhdGVdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEwLmNyZWF0ZUVsZW1lbnQoXG4gICAgUm91dGVyLFxuICAgIHtcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuYWN0aW9uLFxuICAgICAgbmF2aWdhdG9yOiBoaXN0b3J5XG4gICAgfVxuICApO1xufVxuSGlzdG9yeVJvdXRlci5kaXNwbGF5TmFtZSA9IFwidW5zdGFibGVfSGlzdG9yeVJvdXRlclwiO1xudmFyIEFCU09MVVRFX1VSTF9SRUdFWDIgPSAvXig/OlthLXpdW2EtejAtOSsuLV0qOnxcXC9cXC8pL2k7XG52YXIgTGluayA9IFJlYWN0MTAuZm9yd2FyZFJlZihcbiAgZnVuY3Rpb24gTGlua1dpdGhSZWYoe1xuICAgIG9uQ2xpY2ssXG4gICAgZGlzY292ZXIgPSBcInJlbmRlclwiLFxuICAgIHByZWZldGNoID0gXCJub25lXCIsXG4gICAgcmVsYXRpdmUsXG4gICAgcmVsb2FkRG9jdW1lbnQsXG4gICAgcmVwbGFjZTogcmVwbGFjZTIsXG4gICAgc3RhdGUsXG4gICAgdGFyZ2V0LFxuICAgIHRvLFxuICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICB2aWV3VHJhbnNpdGlvbixcbiAgICAuLi5yZXN0XG4gIH0sIGZvcndhcmRlZFJlZikge1xuICAgIGxldCB7IGJhc2VuYW1lIH0gPSBSZWFjdDEwLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICAgIGxldCBpc0Fic29sdXRlID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiICYmIEFCU09MVVRFX1VSTF9SRUdFWDIudGVzdCh0byk7XG4gICAgbGV0IGFic29sdXRlSHJlZjtcbiAgICBsZXQgaXNFeHRlcm5hbCA9IGZhbHNlO1xuICAgIGlmICh0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgJiYgaXNBYnNvbHV0ZSkge1xuICAgICAgYWJzb2x1dGVIcmVmID0gdG87XG4gICAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IGN1cnJlbnRVcmwgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgICBsZXQgdGFyZ2V0VXJsID0gdG8uc3RhcnRzV2l0aChcIi8vXCIpID8gbmV3IFVSTChjdXJyZW50VXJsLnByb3RvY29sICsgdG8pIDogbmV3IFVSTCh0byk7XG4gICAgICAgICAgbGV0IHBhdGggPSBzdHJpcEJhc2VuYW1lKHRhcmdldFVybC5wYXRobmFtZSwgYmFzZW5hbWUpO1xuICAgICAgICAgIGlmICh0YXJnZXRVcmwub3JpZ2luID09PSBjdXJyZW50VXJsLm9yaWdpbiAmJiBwYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRvID0gcGF0aCArIHRhcmdldFVybC5zZWFyY2ggKyB0YXJnZXRVcmwuaGFzaDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNFeHRlcm5hbCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgYDxMaW5rIHRvPVwiJHt0b31cIj4gY29udGFpbnMgYW4gaW52YWxpZCBVUkwgd2hpY2ggd2lsbCBwcm9iYWJseSBicmVhayB3aGVuIGNsaWNrZWQgLSBwbGVhc2UgdXBkYXRlIHRvIGEgdmFsaWQgVVJMIHBhdGguYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGhyZWYyID0gdXNlSHJlZih0bywgeyByZWxhdGl2ZSB9KTtcbiAgICBsZXQgW3Nob3VsZFByZWZldGNoLCBwcmVmZXRjaFJlZiwgcHJlZmV0Y2hIYW5kbGVyc10gPSB1c2VQcmVmZXRjaEJlaGF2aW9yKFxuICAgICAgcHJlZmV0Y2gsXG4gICAgICByZXN0XG4gICAgKTtcbiAgICBsZXQgaW50ZXJuYWxPbkNsaWNrID0gdXNlTGlua0NsaWNrSGFuZGxlcih0bywge1xuICAgICAgcmVwbGFjZTogcmVwbGFjZTIsXG4gICAgICBzdGF0ZSxcbiAgICAgIHRhcmdldCxcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIHJlbGF0aXZlLFxuICAgICAgdmlld1RyYW5zaXRpb25cbiAgICB9KTtcbiAgICBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgICAgaWYgKG9uQ2xpY2spIG9uQ2xpY2soZXZlbnQpO1xuICAgICAgaWYgKCFldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIGludGVybmFsT25DbGljayhldmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBsaW5rID0gKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzeC1hMTF5L2FuY2hvci1oYXMtY29udGVudFxuICAgICAgLyogQF9fUFVSRV9fICovIFJlYWN0MTAuY3JlYXRlRWxlbWVudChcbiAgICAgICAgXCJhXCIsXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5yZXN0LFxuICAgICAgICAgIC4uLnByZWZldGNoSGFuZGxlcnMsXG4gICAgICAgICAgaHJlZjogYWJzb2x1dGVIcmVmIHx8IGhyZWYyLFxuICAgICAgICAgIG9uQ2xpY2s6IGlzRXh0ZXJuYWwgfHwgcmVsb2FkRG9jdW1lbnQgPyBvbkNsaWNrIDogaGFuZGxlQ2xpY2ssXG4gICAgICAgICAgcmVmOiBtZXJnZVJlZnMoZm9yd2FyZGVkUmVmLCBwcmVmZXRjaFJlZiksXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIFwiZGF0YS1kaXNjb3ZlclwiOiAhaXNBYnNvbHV0ZSAmJiBkaXNjb3ZlciA9PT0gXCJyZW5kZXJcIiA/IFwidHJ1ZVwiIDogdm9pZCAwXG4gICAgICAgIH1cbiAgICAgIClcbiAgICApO1xuICAgIHJldHVybiBzaG91bGRQcmVmZXRjaCAmJiAhaXNBYnNvbHV0ZSA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEwLmNyZWF0ZUVsZW1lbnQoUmVhY3QxMC5GcmFnbWVudCwgbnVsbCwgbGluaywgLyogQF9fUFVSRV9fICovIFJlYWN0MTAuY3JlYXRlRWxlbWVudChQcmVmZXRjaFBhZ2VMaW5rcywgeyBwYWdlOiBocmVmMiB9KSkgOiBsaW5rO1xuICB9XG4pO1xuTGluay5kaXNwbGF5TmFtZSA9IFwiTGlua1wiO1xudmFyIE5hdkxpbmsgPSBSZWFjdDEwLmZvcndhcmRSZWYoXG4gIGZ1bmN0aW9uIE5hdkxpbmtXaXRoUmVmKHtcbiAgICBcImFyaWEtY3VycmVudFwiOiBhcmlhQ3VycmVudFByb3AgPSBcInBhZ2VcIixcbiAgICBjYXNlU2Vuc2l0aXZlID0gZmFsc2UsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVQcm9wID0gXCJcIixcbiAgICBlbmQgPSBmYWxzZSxcbiAgICBzdHlsZTogc3R5bGVQcm9wLFxuICAgIHRvLFxuICAgIHZpZXdUcmFuc2l0aW9uLFxuICAgIGNoaWxkcmVuLFxuICAgIC4uLnJlc3RcbiAgfSwgcmVmKSB7XG4gICAgbGV0IHBhdGggPSB1c2VSZXNvbHZlZFBhdGgodG8sIHsgcmVsYXRpdmU6IHJlc3QucmVsYXRpdmUgfSk7XG4gICAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgICBsZXQgcm91dGVyU3RhdGUgPSBSZWFjdDEwLnVzZUNvbnRleHQoRGF0YVJvdXRlclN0YXRlQ29udGV4dCk7XG4gICAgbGV0IHsgbmF2aWdhdG9yLCBiYXNlbmFtZSB9ID0gUmVhY3QxMC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgICBsZXQgaXNUcmFuc2l0aW9uaW5nID0gcm91dGVyU3RhdGUgIT0gbnVsbCAmJiAvLyBDb25kaXRpb25hbCB1c2FnZSBpcyBPSyBoZXJlIGJlY2F1c2UgdGhlIHVzYWdlIG9mIGEgZGF0YSByb3V0ZXIgaXMgc3RhdGljXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgdXNlVmlld1RyYW5zaXRpb25TdGF0ZShwYXRoKSAmJiB2aWV3VHJhbnNpdGlvbiA9PT0gdHJ1ZTtcbiAgICBsZXQgdG9QYXRobmFtZSA9IG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbiA/IG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbihwYXRoKS5wYXRobmFtZSA6IHBhdGgucGF0aG5hbWU7XG4gICAgbGV0IGxvY2F0aW9uUGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgICBsZXQgbmV4dExvY2F0aW9uUGF0aG5hbWUgPSByb3V0ZXJTdGF0ZSAmJiByb3V0ZXJTdGF0ZS5uYXZpZ2F0aW9uICYmIHJvdXRlclN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24gPyByb3V0ZXJTdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uLnBhdGhuYW1lIDogbnVsbDtcbiAgICBpZiAoIWNhc2VTZW5zaXRpdmUpIHtcbiAgICAgIGxvY2F0aW9uUGF0aG5hbWUgPSBsb2NhdGlvblBhdGhuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBuZXh0TG9jYXRpb25QYXRobmFtZSA9IG5leHRMb2NhdGlvblBhdGhuYW1lID8gbmV4dExvY2F0aW9uUGF0aG5hbWUudG9Mb3dlckNhc2UoKSA6IG51bGw7XG4gICAgICB0b1BhdGhuYW1lID0gdG9QYXRobmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBpZiAobmV4dExvY2F0aW9uUGF0aG5hbWUgJiYgYmFzZW5hbWUpIHtcbiAgICAgIG5leHRMb2NhdGlvblBhdGhuYW1lID0gc3RyaXBCYXNlbmFtZShuZXh0TG9jYXRpb25QYXRobmFtZSwgYmFzZW5hbWUpIHx8IG5leHRMb2NhdGlvblBhdGhuYW1lO1xuICAgIH1cbiAgICBjb25zdCBlbmRTbGFzaFBvc2l0aW9uID0gdG9QYXRobmFtZSAhPT0gXCIvXCIgJiYgdG9QYXRobmFtZS5lbmRzV2l0aChcIi9cIikgPyB0b1BhdGhuYW1lLmxlbmd0aCAtIDEgOiB0b1BhdGhuYW1lLmxlbmd0aDtcbiAgICBsZXQgaXNBY3RpdmUgPSBsb2NhdGlvblBhdGhuYW1lID09PSB0b1BhdGhuYW1lIHx8ICFlbmQgJiYgbG9jYXRpb25QYXRobmFtZS5zdGFydHNXaXRoKHRvUGF0aG5hbWUpICYmIGxvY2F0aW9uUGF0aG5hbWUuY2hhckF0KGVuZFNsYXNoUG9zaXRpb24pID09PSBcIi9cIjtcbiAgICBsZXQgaXNQZW5kaW5nID0gbmV4dExvY2F0aW9uUGF0aG5hbWUgIT0gbnVsbCAmJiAobmV4dExvY2F0aW9uUGF0aG5hbWUgPT09IHRvUGF0aG5hbWUgfHwgIWVuZCAmJiBuZXh0TG9jYXRpb25QYXRobmFtZS5zdGFydHNXaXRoKHRvUGF0aG5hbWUpICYmIG5leHRMb2NhdGlvblBhdGhuYW1lLmNoYXJBdCh0b1BhdGhuYW1lLmxlbmd0aCkgPT09IFwiL1wiKTtcbiAgICBsZXQgcmVuZGVyUHJvcHMgPSB7XG4gICAgICBpc0FjdGl2ZSxcbiAgICAgIGlzUGVuZGluZyxcbiAgICAgIGlzVHJhbnNpdGlvbmluZ1xuICAgIH07XG4gICAgbGV0IGFyaWFDdXJyZW50ID0gaXNBY3RpdmUgPyBhcmlhQ3VycmVudFByb3AgOiB2b2lkIDA7XG4gICAgbGV0IGNsYXNzTmFtZTtcbiAgICBpZiAodHlwZW9mIGNsYXNzTmFtZVByb3AgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lUHJvcChyZW5kZXJQcm9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsYXNzTmFtZSA9IFtcbiAgICAgICAgY2xhc3NOYW1lUHJvcCxcbiAgICAgICAgaXNBY3RpdmUgPyBcImFjdGl2ZVwiIDogbnVsbCxcbiAgICAgICAgaXNQZW5kaW5nID8gXCJwZW5kaW5nXCIgOiBudWxsLFxuICAgICAgICBpc1RyYW5zaXRpb25pbmcgPyBcInRyYW5zaXRpb25pbmdcIiA6IG51bGxcbiAgICAgIF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgICBsZXQgc3R5bGUgPSB0eXBlb2Ygc3R5bGVQcm9wID09PSBcImZ1bmN0aW9uXCIgPyBzdHlsZVByb3AocmVuZGVyUHJvcHMpIDogc3R5bGVQcm9wO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QxMC5jcmVhdGVFbGVtZW50KFxuICAgICAgTGluayxcbiAgICAgIHtcbiAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgXCJhcmlhLWN1cnJlbnRcIjogYXJpYUN1cnJlbnQsXG4gICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgcmVmLFxuICAgICAgICBzdHlsZSxcbiAgICAgICAgdG8sXG4gICAgICAgIHZpZXdUcmFuc2l0aW9uXG4gICAgICB9LFxuICAgICAgdHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIgPyBjaGlsZHJlbihyZW5kZXJQcm9wcykgOiBjaGlsZHJlblxuICAgICk7XG4gIH1cbik7XG5OYXZMaW5rLmRpc3BsYXlOYW1lID0gXCJOYXZMaW5rXCI7XG52YXIgRm9ybSA9IFJlYWN0MTAuZm9yd2FyZFJlZihcbiAgKHtcbiAgICBkaXNjb3ZlciA9IFwicmVuZGVyXCIsXG4gICAgZmV0Y2hlcktleSxcbiAgICBuYXZpZ2F0ZSxcbiAgICByZWxvYWREb2N1bWVudCxcbiAgICByZXBsYWNlOiByZXBsYWNlMixcbiAgICBzdGF0ZSxcbiAgICBtZXRob2QgPSBkZWZhdWx0TWV0aG9kLFxuICAgIGFjdGlvbixcbiAgICBvblN1Ym1pdCxcbiAgICByZWxhdGl2ZSxcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgdmlld1RyYW5zaXRpb24sXG4gICAgLi4ucHJvcHNcbiAgfSwgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgbGV0IHN1Ym1pdCA9IHVzZVN1Ym1pdCgpO1xuICAgIGxldCBmb3JtQWN0aW9uID0gdXNlRm9ybUFjdGlvbihhY3Rpb24sIHsgcmVsYXRpdmUgfSk7XG4gICAgbGV0IGZvcm1NZXRob2QgPSBtZXRob2QudG9Mb3dlckNhc2UoKSA9PT0gXCJnZXRcIiA/IFwiZ2V0XCIgOiBcInBvc3RcIjtcbiAgICBsZXQgaXNBYnNvbHV0ZSA9IHR5cGVvZiBhY3Rpb24gPT09IFwic3RyaW5nXCIgJiYgQUJTT0xVVEVfVVJMX1JFR0VYMi50ZXN0KGFjdGlvbik7XG4gICAgbGV0IHN1Ym1pdEhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgIG9uU3VibWl0ICYmIG9uU3VibWl0KGV2ZW50KTtcbiAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgbGV0IHN1Ym1pdHRlciA9IGV2ZW50Lm5hdGl2ZUV2ZW50LnN1Ym1pdHRlcjtcbiAgICAgIGxldCBzdWJtaXRNZXRob2QgPSBzdWJtaXR0ZXI/LmdldEF0dHJpYnV0ZShcImZvcm1tZXRob2RcIikgfHwgbWV0aG9kO1xuICAgICAgc3VibWl0KHN1Ym1pdHRlciB8fCBldmVudC5jdXJyZW50VGFyZ2V0LCB7XG4gICAgICAgIGZldGNoZXJLZXksXG4gICAgICAgIG1ldGhvZDogc3VibWl0TWV0aG9kLFxuICAgICAgICBuYXZpZ2F0ZSxcbiAgICAgICAgcmVwbGFjZTogcmVwbGFjZTIsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICByZWxhdGl2ZSxcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICB2aWV3VHJhbnNpdGlvblxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0MTAuY3JlYXRlRWxlbWVudChcbiAgICAgIFwiZm9ybVwiLFxuICAgICAge1xuICAgICAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICAgICAgbWV0aG9kOiBmb3JtTWV0aG9kLFxuICAgICAgICBhY3Rpb246IGZvcm1BY3Rpb24sXG4gICAgICAgIG9uU3VibWl0OiByZWxvYWREb2N1bWVudCA/IG9uU3VibWl0IDogc3VibWl0SGFuZGxlcixcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIFwiZGF0YS1kaXNjb3ZlclwiOiAhaXNBYnNvbHV0ZSAmJiBkaXNjb3ZlciA9PT0gXCJyZW5kZXJcIiA/IFwidHJ1ZVwiIDogdm9pZCAwXG4gICAgICB9XG4gICAgKTtcbiAgfVxuKTtcbkZvcm0uZGlzcGxheU5hbWUgPSBcIkZvcm1cIjtcbmZ1bmN0aW9uIFNjcm9sbFJlc3RvcmF0aW9uKHtcbiAgZ2V0S2V5LFxuICBzdG9yYWdlS2V5LFxuICAuLi5wcm9wc1xufSkge1xuICBsZXQgcmVtaXhDb250ZXh0ID0gUmVhY3QxMC51c2VDb250ZXh0KEZyYW1ld29ya0NvbnRleHQpO1xuICBsZXQgeyBiYXNlbmFtZSB9ID0gUmVhY3QxMC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IG1hdGNoZXMgPSB1c2VNYXRjaGVzKCk7XG4gIHVzZVNjcm9sbFJlc3RvcmF0aW9uKHsgZ2V0S2V5LCBzdG9yYWdlS2V5IH0pO1xuICBsZXQgc3NyS2V5ID0gUmVhY3QxMC51c2VNZW1vKFxuICAgICgpID0+IHtcbiAgICAgIGlmICghcmVtaXhDb250ZXh0IHx8ICFnZXRLZXkpIHJldHVybiBudWxsO1xuICAgICAgbGV0IHVzZXJLZXkgPSBnZXRTY3JvbGxSZXN0b3JhdGlvbktleShcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGJhc2VuYW1lLFxuICAgICAgICBnZXRLZXlcbiAgICAgICk7XG4gICAgICByZXR1cm4gdXNlcktleSAhPT0gbG9jYXRpb24ua2V5ID8gdXNlcktleSA6IG51bGw7XG4gICAgfSxcbiAgICAvLyBOYWgsIHdlIG9ubHkgbmVlZCB0aGlzIHRoZSBmaXJzdCB0aW1lIGZvciB0aGUgU1NSIHJlbmRlclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbXVxuICApO1xuICBpZiAoIXJlbWl4Q29udGV4dCB8fCByZW1peENvbnRleHQuaXNTcGFNb2RlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGV0IHJlc3RvcmVTY3JvbGwgPSAoKHN0b3JhZ2VLZXkyLCByZXN0b3JlS2V5KSA9PiB7XG4gICAgaWYgKCF3aW5kb3cuaGlzdG9yeS5zdGF0ZSB8fCAhd2luZG93Lmhpc3Rvcnkuc3RhdGUua2V5KSB7XG4gICAgICBsZXQga2V5ID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzMikuc2xpY2UoMik7XG4gICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoeyBrZXkgfSwgXCJcIik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBsZXQgcG9zaXRpb25zID0gSlNPTi5wYXJzZShzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKHN0b3JhZ2VLZXkyKSB8fCBcInt9XCIpO1xuICAgICAgbGV0IHN0b3JlZFkgPSBwb3NpdGlvbnNbcmVzdG9yZUtleSB8fCB3aW5kb3cuaGlzdG9yeS5zdGF0ZS5rZXldO1xuICAgICAgaWYgKHR5cGVvZiBzdG9yZWRZID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCBzdG9yZWRZKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHN0b3JhZ2VLZXkyKTtcbiAgICB9XG4gIH0pLnRvU3RyaW5nKCk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QxMC5jcmVhdGVFbGVtZW50KFxuICAgIFwic2NyaXB0XCIsXG4gICAge1xuICAgICAgLi4ucHJvcHMsXG4gICAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6IHRydWUsXG4gICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgICBfX2h0bWw6IGAoJHtyZXN0b3JlU2Nyb2xsfSkoJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBzdG9yYWdlS2V5IHx8IFNDUk9MTF9SRVNUT1JBVElPTl9TVE9SQUdFX0tFWVxuICAgICAgICApfSwgJHtKU09OLnN0cmluZ2lmeShzc3JLZXkpfSlgXG4gICAgICB9XG4gICAgfVxuICApO1xufVxuU2Nyb2xsUmVzdG9yYXRpb24uZGlzcGxheU5hbWUgPSBcIlNjcm9sbFJlc3RvcmF0aW9uXCI7XG5mdW5jdGlvbiBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yMihob29rTmFtZSkge1xuICByZXR1cm4gYCR7aG9va05hbWV9IG11c3QgYmUgdXNlZCB3aXRoaW4gYSBkYXRhIHJvdXRlci4gIFNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9lbi9tYWluL3JvdXRlcnMvcGlja2luZy1hLXJvdXRlci5gO1xufVxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlckNvbnRleHQzKGhvb2tOYW1lKSB7XG4gIGxldCBjdHggPSBSZWFjdDEwLnVzZUNvbnRleHQoRGF0YVJvdXRlckNvbnRleHQpO1xuICBpbnZhcmlhbnQoY3R4LCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yMihob29rTmFtZSkpO1xuICByZXR1cm4gY3R4O1xufVxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlclN0YXRlMihob29rTmFtZSkge1xuICBsZXQgc3RhdGUgPSBSZWFjdDEwLnVzZUNvbnRleHQoRGF0YVJvdXRlclN0YXRlQ29udGV4dCk7XG4gIGludmFyaWFudChzdGF0ZSwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcjIoaG9va05hbWUpKTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gdXNlTGlua0NsaWNrSGFuZGxlcih0bywge1xuICB0YXJnZXQsXG4gIHJlcGxhY2U6IHJlcGxhY2VQcm9wLFxuICBzdGF0ZSxcbiAgcHJldmVudFNjcm9sbFJlc2V0LFxuICByZWxhdGl2ZSxcbiAgdmlld1RyYW5zaXRpb25cbn0gPSB7fSkge1xuICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgcGF0aCA9IHVzZVJlc29sdmVkUGF0aCh0bywgeyByZWxhdGl2ZSB9KTtcbiAgcmV0dXJuIFJlYWN0MTAudXNlQ2FsbGJhY2soXG4gICAgKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoc2hvdWxkUHJvY2Vzc0xpbmtDbGljayhldmVudCwgdGFyZ2V0KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBsZXQgcmVwbGFjZTIgPSByZXBsYWNlUHJvcCAhPT0gdm9pZCAwID8gcmVwbGFjZVByb3AgOiBjcmVhdGVQYXRoKGxvY2F0aW9uKSA9PT0gY3JlYXRlUGF0aChwYXRoKTtcbiAgICAgICAgbmF2aWdhdGUodG8sIHtcbiAgICAgICAgICByZXBsYWNlOiByZXBsYWNlMixcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgICAgcmVsYXRpdmUsXG4gICAgICAgICAgdmlld1RyYW5zaXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbXG4gICAgICBsb2NhdGlvbixcbiAgICAgIG5hdmlnYXRlLFxuICAgICAgcGF0aCxcbiAgICAgIHJlcGxhY2VQcm9wLFxuICAgICAgc3RhdGUsXG4gICAgICB0YXJnZXQsXG4gICAgICB0byxcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIHJlbGF0aXZlLFxuICAgICAgdmlld1RyYW5zaXRpb25cbiAgICBdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VTZWFyY2hQYXJhbXMoZGVmYXVsdEluaXQpIHtcbiAgd2FybmluZyhcbiAgICB0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSBcInVuZGVmaW5lZFwiLFxuICAgIGBZb3UgY2Fubm90IHVzZSB0aGUgXFxgdXNlU2VhcmNoUGFyYW1zXFxgIGhvb2sgaW4gYSBicm93c2VyIHRoYXQgZG9lcyBub3Qgc3VwcG9ydCB0aGUgVVJMU2VhcmNoUGFyYW1zIEFQSS4gSWYgeW91IG5lZWQgdG8gc3VwcG9ydCBJbnRlcm5ldCBFeHBsb3JlciAxMSwgd2UgcmVjb21tZW5kIHlvdSBsb2FkIGEgcG9seWZpbGwgc3VjaCBhcyBodHRwczovL2dpdGh1Yi5jb20vdW5nYXAvdXJsLXNlYXJjaC1wYXJhbXMuYFxuICApO1xuICBsZXQgZGVmYXVsdFNlYXJjaFBhcmFtc1JlZiA9IFJlYWN0MTAudXNlUmVmKGNyZWF0ZVNlYXJjaFBhcmFtcyhkZWZhdWx0SW5pdCkpO1xuICBsZXQgaGFzU2V0U2VhcmNoUGFyYW1zUmVmID0gUmVhY3QxMC51c2VSZWYoZmFsc2UpO1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgc2VhcmNoUGFyYW1zID0gUmVhY3QxMC51c2VNZW1vKFxuICAgICgpID0+IChcbiAgICAgIC8vIE9ubHkgbWVyZ2UgaW4gdGhlIGRlZmF1bHRzIGlmIHdlIGhhdmVuJ3QgeWV0IGNhbGxlZCBzZXRTZWFyY2hQYXJhbXMuXG4gICAgICAvLyBPbmNlIHdlIGNhbGwgdGhhdCB3ZSB3YW50IHRob3NlIHRvIHRha2UgcHJlY2VkZW5jZSwgb3RoZXJ3aXNlIHlvdSBjYW4ndFxuICAgICAgLy8gcmVtb3ZlIGEgcGFyYW0gd2l0aCBzZXRTZWFyY2hQYXJhbXMoe30pIGlmIGl0IGhhcyBhbiBpbml0aWFsIHZhbHVlXG4gICAgICBnZXRTZWFyY2hQYXJhbXNGb3JMb2NhdGlvbihcbiAgICAgICAgbG9jYXRpb24uc2VhcmNoLFxuICAgICAgICBoYXNTZXRTZWFyY2hQYXJhbXNSZWYuY3VycmVudCA/IG51bGwgOiBkZWZhdWx0U2VhcmNoUGFyYW1zUmVmLmN1cnJlbnRcbiAgICAgIClcbiAgICApLFxuICAgIFtsb2NhdGlvbi5zZWFyY2hdXG4gICk7XG4gIGxldCBuYXZpZ2F0ZSA9IHVzZU5hdmlnYXRlKCk7XG4gIGxldCBzZXRTZWFyY2hQYXJhbXMgPSBSZWFjdDEwLnVzZUNhbGxiYWNrKFxuICAgIChuZXh0SW5pdCwgbmF2aWdhdGVPcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBuZXdTZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXMoXG4gICAgICAgIHR5cGVvZiBuZXh0SW5pdCA9PT0gXCJmdW5jdGlvblwiID8gbmV4dEluaXQoc2VhcmNoUGFyYW1zKSA6IG5leHRJbml0XG4gICAgICApO1xuICAgICAgaGFzU2V0U2VhcmNoUGFyYW1zUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgbmF2aWdhdGUoXCI/XCIgKyBuZXdTZWFyY2hQYXJhbXMsIG5hdmlnYXRlT3B0aW9ucyk7XG4gICAgfSxcbiAgICBbbmF2aWdhdGUsIHNlYXJjaFBhcmFtc11cbiAgKTtcbiAgcmV0dXJuIFtzZWFyY2hQYXJhbXMsIHNldFNlYXJjaFBhcmFtc107XG59XG52YXIgZmV0Y2hlcklkID0gMDtcbnZhciBnZXRVbmlxdWVGZXRjaGVySWQgPSAoKSA9PiBgX18ke1N0cmluZygrK2ZldGNoZXJJZCl9X19gO1xuZnVuY3Rpb24gdXNlU3VibWl0KCkge1xuICBsZXQgeyByb3V0ZXIgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0MyhcInVzZVN1Ym1pdFwiIC8qIFVzZVN1Ym1pdCAqLyk7XG4gIGxldCB7IGJhc2VuYW1lIH0gPSBSZWFjdDEwLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgY3VycmVudFJvdXRlSWQgPSB1c2VSb3V0ZUlkKCk7XG4gIHJldHVybiBSZWFjdDEwLnVzZUNhbGxiYWNrKFxuICAgIGFzeW5jICh0YXJnZXQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgbGV0IHsgYWN0aW9uLCBtZXRob2QsIGVuY1R5cGUsIGZvcm1EYXRhLCBib2R5IH0gPSBnZXRGb3JtU3VibWlzc2lvbkluZm8oXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgYmFzZW5hbWVcbiAgICAgICk7XG4gICAgICBpZiAob3B0aW9ucy5uYXZpZ2F0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGtleSA9IG9wdGlvbnMuZmV0Y2hlcktleSB8fCBnZXRVbmlxdWVGZXRjaGVySWQoKTtcbiAgICAgICAgYXdhaXQgcm91dGVyLmZldGNoKGtleSwgY3VycmVudFJvdXRlSWQsIG9wdGlvbnMuYWN0aW9uIHx8IGFjdGlvbiwge1xuICAgICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0aW9ucy5wcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgICAgZm9ybURhdGEsXG4gICAgICAgICAgYm9keSxcbiAgICAgICAgICBmb3JtTWV0aG9kOiBvcHRpb25zLm1ldGhvZCB8fCBtZXRob2QsXG4gICAgICAgICAgZm9ybUVuY1R5cGU6IG9wdGlvbnMuZW5jVHlwZSB8fCBlbmNUeXBlLFxuICAgICAgICAgIGZsdXNoU3luYzogb3B0aW9ucy5mbHVzaFN5bmNcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCByb3V0ZXIubmF2aWdhdGUob3B0aW9ucy5hY3Rpb24gfHwgYWN0aW9uLCB7XG4gICAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRpb25zLnByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgICBmb3JtRGF0YSxcbiAgICAgICAgICBib2R5LFxuICAgICAgICAgIGZvcm1NZXRob2Q6IG9wdGlvbnMubWV0aG9kIHx8IG1ldGhvZCxcbiAgICAgICAgICBmb3JtRW5jVHlwZTogb3B0aW9ucy5lbmNUeXBlIHx8IGVuY1R5cGUsXG4gICAgICAgICAgcmVwbGFjZTogb3B0aW9ucy5yZXBsYWNlLFxuICAgICAgICAgIHN0YXRlOiBvcHRpb25zLnN0YXRlLFxuICAgICAgICAgIGZyb21Sb3V0ZUlkOiBjdXJyZW50Um91dGVJZCxcbiAgICAgICAgICBmbHVzaFN5bmM6IG9wdGlvbnMuZmx1c2hTeW5jLFxuICAgICAgICAgIHZpZXdUcmFuc2l0aW9uOiBvcHRpb25zLnZpZXdUcmFuc2l0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgW3JvdXRlciwgYmFzZW5hbWUsIGN1cnJlbnRSb3V0ZUlkXVxuICApO1xufVxuZnVuY3Rpb24gdXNlRm9ybUFjdGlvbihhY3Rpb24sIHsgcmVsYXRpdmUgfSA9IHt9KSB7XG4gIGxldCB7IGJhc2VuYW1lIH0gPSBSZWFjdDEwLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgcm91dGVDb250ZXh0ID0gUmVhY3QxMC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGludmFyaWFudChyb3V0ZUNvbnRleHQsIFwidXNlRm9ybUFjdGlvbiBtdXN0IGJlIHVzZWQgaW5zaWRlIGEgUm91dGVDb250ZXh0XCIpO1xuICBsZXQgW21hdGNoXSA9IHJvdXRlQ29udGV4dC5tYXRjaGVzLnNsaWNlKC0xKTtcbiAgbGV0IHBhdGggPSB7IC4uLnVzZVJlc29sdmVkUGF0aChhY3Rpb24gPyBhY3Rpb24gOiBcIi5cIiwgeyByZWxhdGl2ZSB9KSB9O1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBpZiAoYWN0aW9uID09IG51bGwpIHtcbiAgICBwYXRoLnNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaDtcbiAgICBsZXQgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXRoLnNlYXJjaCk7XG4gICAgbGV0IGluZGV4VmFsdWVzID0gcGFyYW1zLmdldEFsbChcImluZGV4XCIpO1xuICAgIGxldCBoYXNOYWtlZEluZGV4UGFyYW0gPSBpbmRleFZhbHVlcy5zb21lKCh2KSA9PiB2ID09PSBcIlwiKTtcbiAgICBpZiAoaGFzTmFrZWRJbmRleFBhcmFtKSB7XG4gICAgICBwYXJhbXMuZGVsZXRlKFwiaW5kZXhcIik7XG4gICAgICBpbmRleFZhbHVlcy5maWx0ZXIoKHYpID0+IHYpLmZvckVhY2goKHYpID0+IHBhcmFtcy5hcHBlbmQoXCJpbmRleFwiLCB2KSk7XG4gICAgICBsZXQgcXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgICAgIHBhdGguc2VhcmNoID0gcXMgPyBgPyR7cXN9YCA6IFwiXCI7XG4gICAgfVxuICB9XG4gIGlmICgoIWFjdGlvbiB8fCBhY3Rpb24gPT09IFwiLlwiKSAmJiBtYXRjaC5yb3V0ZS5pbmRleCkge1xuICAgIHBhdGguc2VhcmNoID0gcGF0aC5zZWFyY2ggPyBwYXRoLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgXCI/aW5kZXgmXCIpIDogXCI/aW5kZXhcIjtcbiAgfVxuICBpZiAoYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgcGF0aC5wYXRobmFtZSA9IHBhdGgucGF0aG5hbWUgPT09IFwiL1wiID8gYmFzZW5hbWUgOiBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRoLnBhdGhuYW1lXSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVBhdGgocGF0aCk7XG59XG5mdW5jdGlvbiB1c2VGZXRjaGVyKHtcbiAga2V5XG59ID0ge30pIHtcbiAgbGV0IHsgcm91dGVyIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dDMoXCJ1c2VGZXRjaGVyXCIgLyogVXNlRmV0Y2hlciAqLyk7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZTIoXCJ1c2VGZXRjaGVyXCIgLyogVXNlRmV0Y2hlciAqLyk7XG4gIGxldCBmZXRjaGVyRGF0YSA9IFJlYWN0MTAudXNlQ29udGV4dChGZXRjaGVyc0NvbnRleHQpO1xuICBsZXQgcm91dGUgPSBSZWFjdDEwLnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHJvdXRlSWQgPSByb3V0ZS5tYXRjaGVzW3JvdXRlLm1hdGNoZXMubGVuZ3RoIC0gMV0/LnJvdXRlLmlkO1xuICBpbnZhcmlhbnQoZmV0Y2hlckRhdGEsIGB1c2VGZXRjaGVyIG11c3QgYmUgdXNlZCBpbnNpZGUgYSBGZXRjaGVyc0NvbnRleHRgKTtcbiAgaW52YXJpYW50KHJvdXRlLCBgdXNlRmV0Y2hlciBtdXN0IGJlIHVzZWQgaW5zaWRlIGEgUm91dGVDb250ZXh0YCk7XG4gIGludmFyaWFudChcbiAgICByb3V0ZUlkICE9IG51bGwsXG4gICAgYHVzZUZldGNoZXIgY2FuIG9ubHkgYmUgdXNlZCBvbiByb3V0ZXMgdGhhdCBjb250YWluIGEgdW5pcXVlIFwiaWRcImBcbiAgKTtcbiAgbGV0IGRlZmF1bHRLZXkgPSBSZWFjdDEwLnVzZUlkKCk7XG4gIGxldCBbZmV0Y2hlcktleSwgc2V0RmV0Y2hlcktleV0gPSBSZWFjdDEwLnVzZVN0YXRlKGtleSB8fCBkZWZhdWx0S2V5KTtcbiAgaWYgKGtleSAmJiBrZXkgIT09IGZldGNoZXJLZXkpIHtcbiAgICBzZXRGZXRjaGVyS2V5KGtleSk7XG4gIH1cbiAgUmVhY3QxMC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJvdXRlci5nZXRGZXRjaGVyKGZldGNoZXJLZXkpO1xuICAgIHJldHVybiAoKSA9PiByb3V0ZXIuZGVsZXRlRmV0Y2hlcihmZXRjaGVyS2V5KTtcbiAgfSwgW3JvdXRlciwgZmV0Y2hlcktleV0pO1xuICBsZXQgbG9hZCA9IFJlYWN0MTAudXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKGhyZWYyLCBvcHRzKSA9PiB7XG4gICAgICBpbnZhcmlhbnQocm91dGVJZCwgXCJObyByb3V0ZUlkIGF2YWlsYWJsZSBmb3IgZmV0Y2hlci5sb2FkKClcIik7XG4gICAgICBhd2FpdCByb3V0ZXIuZmV0Y2goZmV0Y2hlcktleSwgcm91dGVJZCwgaHJlZjIsIG9wdHMpO1xuICAgIH0sXG4gICAgW2ZldGNoZXJLZXksIHJvdXRlSWQsIHJvdXRlcl1cbiAgKTtcbiAgbGV0IHN1Ym1pdEltcGwgPSB1c2VTdWJtaXQoKTtcbiAgbGV0IHN1Ym1pdCA9IFJlYWN0MTAudXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKHRhcmdldCwgb3B0cykgPT4ge1xuICAgICAgYXdhaXQgc3VibWl0SW1wbCh0YXJnZXQsIHtcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgbmF2aWdhdGU6IGZhbHNlLFxuICAgICAgICBmZXRjaGVyS2V5XG4gICAgICB9KTtcbiAgICB9LFxuICAgIFtmZXRjaGVyS2V5LCBzdWJtaXRJbXBsXVxuICApO1xuICBsZXQgRmV0Y2hlckZvcm0gPSBSZWFjdDEwLnVzZU1lbW8oKCkgPT4ge1xuICAgIGxldCBGZXRjaGVyRm9ybTIgPSBSZWFjdDEwLmZvcndhcmRSZWYoXG4gICAgICAocHJvcHMsIHJlZikgPT4ge1xuICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0MTAuY3JlYXRlRWxlbWVudChGb3JtLCB7IC4uLnByb3BzLCBuYXZpZ2F0ZTogZmFsc2UsIGZldGNoZXJLZXksIHJlZiB9KTtcbiAgICAgIH1cbiAgICApO1xuICAgIEZldGNoZXJGb3JtMi5kaXNwbGF5TmFtZSA9IFwiZmV0Y2hlci5Gb3JtXCI7XG4gICAgcmV0dXJuIEZldGNoZXJGb3JtMjtcbiAgfSwgW2ZldGNoZXJLZXldKTtcbiAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoZmV0Y2hlcktleSkgfHwgSURMRV9GRVRDSEVSO1xuICBsZXQgZGF0YTIgPSBmZXRjaGVyRGF0YS5nZXQoZmV0Y2hlcktleSk7XG4gIGxldCBmZXRjaGVyV2l0aENvbXBvbmVudHMgPSBSZWFjdDEwLnVzZU1lbW8oXG4gICAgKCkgPT4gKHtcbiAgICAgIEZvcm06IEZldGNoZXJGb3JtLFxuICAgICAgc3VibWl0LFxuICAgICAgbG9hZCxcbiAgICAgIC4uLmZldGNoZXIsXG4gICAgICBkYXRhOiBkYXRhMlxuICAgIH0pLFxuICAgIFtGZXRjaGVyRm9ybSwgc3VibWl0LCBsb2FkLCBmZXRjaGVyLCBkYXRhMl1cbiAgKTtcbiAgcmV0dXJuIGZldGNoZXJXaXRoQ29tcG9uZW50cztcbn1cbmZ1bmN0aW9uIHVzZUZldGNoZXJzKCkge1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUyKFwidXNlRmV0Y2hlcnNcIiAvKiBVc2VGZXRjaGVycyAqLyk7XG4gIHJldHVybiBBcnJheS5mcm9tKHN0YXRlLmZldGNoZXJzLmVudHJpZXMoKSkubWFwKChba2V5LCBmZXRjaGVyXSkgPT4gKHtcbiAgICAuLi5mZXRjaGVyLFxuICAgIGtleVxuICB9KSk7XG59XG52YXIgU0NST0xMX1JFU1RPUkFUSU9OX1NUT1JBR0VfS0VZID0gXCJyZWFjdC1yb3V0ZXItc2Nyb2xsLXBvc2l0aW9uc1wiO1xudmFyIHNhdmVkU2Nyb2xsUG9zaXRpb25zID0ge307XG5mdW5jdGlvbiBnZXRTY3JvbGxSZXN0b3JhdGlvbktleShsb2NhdGlvbiwgbWF0Y2hlcywgYmFzZW5hbWUsIGdldEtleSkge1xuICBsZXQga2V5ID0gbnVsbDtcbiAgaWYgKGdldEtleSkge1xuICAgIGlmIChiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICAgIGtleSA9IGdldEtleShcbiAgICAgICAge1xuICAgICAgICAgIC4uLmxvY2F0aW9uLFxuICAgICAgICAgIHBhdGhuYW1lOiBzdHJpcEJhc2VuYW1lKGxvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgbG9jYXRpb24ucGF0aG5hbWVcbiAgICAgICAgfSxcbiAgICAgICAgbWF0Y2hlc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5ID0gZ2V0S2V5KGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICB9XG4gIH1cbiAgaWYgKGtleSA9PSBudWxsKSB7XG4gICAga2V5ID0gbG9jYXRpb24ua2V5O1xuICB9XG4gIHJldHVybiBrZXk7XG59XG5mdW5jdGlvbiB1c2VTY3JvbGxSZXN0b3JhdGlvbih7XG4gIGdldEtleSxcbiAgc3RvcmFnZUtleVxufSA9IHt9KSB7XG4gIGxldCB7IHJvdXRlciB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQzKFwidXNlU2Nyb2xsUmVzdG9yYXRpb25cIiAvKiBVc2VTY3JvbGxSZXN0b3JhdGlvbiAqLyk7XG4gIGxldCB7IHJlc3RvcmVTY3JvbGxQb3NpdGlvbiwgcHJldmVudFNjcm9sbFJlc2V0IH0gPSB1c2VEYXRhUm91dGVyU3RhdGUyKFxuICAgIFwidXNlU2Nyb2xsUmVzdG9yYXRpb25cIiAvKiBVc2VTY3JvbGxSZXN0b3JhdGlvbiAqL1xuICApO1xuICBsZXQgeyBiYXNlbmFtZSB9ID0gUmVhY3QxMC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IG1hdGNoZXMgPSB1c2VNYXRjaGVzKCk7XG4gIGxldCBuYXZpZ2F0aW9uID0gdXNlTmF2aWdhdGlvbigpO1xuICBSZWFjdDEwLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcIm1hbnVhbFwiO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwiYXV0b1wiO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgdXNlUGFnZUhpZGUoXG4gICAgUmVhY3QxMC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICBpZiAobmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJpZGxlXCIpIHtcbiAgICAgICAgbGV0IGtleSA9IGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5KGxvY2F0aW9uLCBtYXRjaGVzLCBiYXNlbmFtZSwgZ2V0S2V5KTtcbiAgICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnNba2V5XSA9IHdpbmRvdy5zY3JvbGxZO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcbiAgICAgICAgICBzdG9yYWdlS2V5IHx8IFNDUk9MTF9SRVNUT1JBVElPTl9TVE9SQUdFX0tFWSxcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeShzYXZlZFNjcm9sbFBvc2l0aW9ucylcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgYEZhaWxlZCB0byBzYXZlIHNjcm9sbCBwb3NpdGlvbnMgaW4gc2Vzc2lvblN0b3JhZ2UsIDxTY3JvbGxSZXN0b3JhdGlvbiAvPiB3aWxsIG5vdCB3b3JrIHByb3Blcmx5ICgke2Vycm9yfSkuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcImF1dG9cIjtcbiAgICB9LCBbbmF2aWdhdGlvbi5zdGF0ZSwgZ2V0S2V5LCBiYXNlbmFtZSwgbG9jYXRpb24sIG1hdGNoZXMsIHN0b3JhZ2VLZXldKVxuICApO1xuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgUmVhY3QxMC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHNlc3Npb25Qb3NpdGlvbnMgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFxuICAgICAgICAgIHN0b3JhZ2VLZXkgfHwgU0NST0xMX1JFU1RPUkFUSU9OX1NUT1JBR0VfS0VZXG4gICAgICAgICk7XG4gICAgICAgIGlmIChzZXNzaW9uUG9zaXRpb25zKSB7XG4gICAgICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnMgPSBKU09OLnBhcnNlKHNlc3Npb25Qb3NpdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICB9XG4gICAgfSwgW3N0b3JhZ2VLZXldKTtcbiAgICBSZWFjdDEwLnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICBsZXQgZGlzYWJsZVNjcm9sbFJlc3RvcmF0aW9uID0gcm91dGVyPy5lbmFibGVTY3JvbGxSZXN0b3JhdGlvbihcbiAgICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnMsXG4gICAgICAgICgpID0+IHdpbmRvdy5zY3JvbGxZLFxuICAgICAgICBnZXRLZXkgPyAobG9jYXRpb24yLCBtYXRjaGVzMikgPT4gZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkobG9jYXRpb24yLCBtYXRjaGVzMiwgYmFzZW5hbWUsIGdldEtleSkgOiB2b2lkIDBcbiAgICAgICk7XG4gICAgICByZXR1cm4gKCkgPT4gZGlzYWJsZVNjcm9sbFJlc3RvcmF0aW9uICYmIGRpc2FibGVTY3JvbGxSZXN0b3JhdGlvbigpO1xuICAgIH0sIFtyb3V0ZXIsIGJhc2VuYW1lLCBnZXRLZXldKTtcbiAgICBSZWFjdDEwLnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAocmVzdG9yZVNjcm9sbFBvc2l0aW9uID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHJlc3RvcmVTY3JvbGxQb3NpdGlvbiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgcmVzdG9yZVNjcm9sbFBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGxvY2F0aW9uLmhhc2gpIHtcbiAgICAgICAgbGV0IGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXG4gICAgICAgICAgZGVjb2RlVVJJQ29tcG9uZW50KGxvY2F0aW9uLmhhc2guc2xpY2UoMSkpXG4gICAgICAgICk7XG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgIGVsLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJldmVudFNjcm9sbFJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICB9LCBbbG9jYXRpb24sIHJlc3RvcmVTY3JvbGxQb3NpdGlvbiwgcHJldmVudFNjcm9sbFJlc2V0XSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVzZUJlZm9yZVVubG9hZChjYWxsYmFjaywgb3B0aW9ucykge1xuICBsZXQgeyBjYXB0dXJlIH0gPSBvcHRpb25zIHx8IHt9O1xuICBSZWFjdDEwLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IG9wdHMgPSBjYXB0dXJlICE9IG51bGwgPyB7IGNhcHR1cmUgfSA6IHZvaWQgMDtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICB9O1xuICB9LCBbY2FsbGJhY2ssIGNhcHR1cmVdKTtcbn1cbmZ1bmN0aW9uIHVzZVBhZ2VIaWRlKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIGxldCB7IGNhcHR1cmUgfSA9IG9wdGlvbnMgfHwge307XG4gIFJlYWN0MTAudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgb3B0cyA9IGNhcHR1cmUgIT0gbnVsbCA/IHsgY2FwdHVyZSB9IDogdm9pZCAwO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICB9O1xuICB9LCBbY2FsbGJhY2ssIGNhcHR1cmVdKTtcbn1cbmZ1bmN0aW9uIHVzZVByb21wdCh7XG4gIHdoZW4sXG4gIG1lc3NhZ2Vcbn0pIHtcbiAgbGV0IGJsb2NrZXIgPSB1c2VCbG9ja2VyKHdoZW4pO1xuICBSZWFjdDEwLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiKSB7XG4gICAgICBsZXQgcHJvY2VlZCA9IHdpbmRvdy5jb25maXJtKG1lc3NhZ2UpO1xuICAgICAgaWYgKHByb2NlZWQpIHtcbiAgICAgICAgc2V0VGltZW91dChibG9ja2VyLnByb2NlZWQsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmxvY2tlci5yZXNldCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2Jsb2NrZXIsIG1lc3NhZ2VdKTtcbiAgUmVhY3QxMC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChibG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIiAmJiAhd2hlbikge1xuICAgICAgYmxvY2tlci5yZXNldCgpO1xuICAgIH1cbiAgfSwgW2Jsb2NrZXIsIHdoZW5dKTtcbn1cbmZ1bmN0aW9uIHVzZVZpZXdUcmFuc2l0aW9uU3RhdGUodG8sIG9wdHMgPSB7fSkge1xuICBsZXQgdnRDb250ZXh0ID0gUmVhY3QxMC51c2VDb250ZXh0KFZpZXdUcmFuc2l0aW9uQ29udGV4dCk7XG4gIGludmFyaWFudChcbiAgICB2dENvbnRleHQgIT0gbnVsbCxcbiAgICBcImB1c2VWaWV3VHJhbnNpdGlvblN0YXRlYCBtdXN0IGJlIHVzZWQgd2l0aGluIGByZWFjdC1yb3V0ZXItZG9tYCdzIGBSb3V0ZXJQcm92aWRlcmAuICBEaWQgeW91IGFjY2lkZW50YWxseSBpbXBvcnQgYFJvdXRlclByb3ZpZGVyYCBmcm9tIGByZWFjdC1yb3V0ZXJgP1wiXG4gICk7XG4gIGxldCB7IGJhc2VuYW1lIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dDMoXG4gICAgXCJ1c2VWaWV3VHJhbnNpdGlvblN0YXRlXCIgLyogdXNlVmlld1RyYW5zaXRpb25TdGF0ZSAqL1xuICApO1xuICBsZXQgcGF0aCA9IHVzZVJlc29sdmVkUGF0aCh0bywgeyByZWxhdGl2ZTogb3B0cy5yZWxhdGl2ZSB9KTtcbiAgaWYgKCF2dENvbnRleHQuaXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxldCBjdXJyZW50UGF0aCA9IHN0cmlwQmFzZW5hbWUodnRDb250ZXh0LmN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IHZ0Q29udGV4dC5jdXJyZW50TG9jYXRpb24ucGF0aG5hbWU7XG4gIGxldCBuZXh0UGF0aCA9IHN0cmlwQmFzZW5hbWUodnRDb250ZXh0Lm5leHRMb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IHZ0Q29udGV4dC5uZXh0TG9jYXRpb24ucGF0aG5hbWU7XG4gIHJldHVybiBtYXRjaFBhdGgocGF0aC5wYXRobmFtZSwgbmV4dFBhdGgpICE9IG51bGwgfHwgbWF0Y2hQYXRoKHBhdGgucGF0aG5hbWUsIGN1cnJlbnRQYXRoKSAhPSBudWxsO1xufVxuXG4vLyBsaWIvZG9tL3NlcnZlci50c3hcbnZhciBSZWFjdDExID0gX190b0VTTShyZXF1aXJlKFwicmVhY3RcIikpO1xuZnVuY3Rpb24gU3RhdGljUm91dGVyKHtcbiAgYmFzZW5hbWUsXG4gIGNoaWxkcmVuLFxuICBsb2NhdGlvbjogbG9jYXRpb25Qcm9wID0gXCIvXCJcbn0pIHtcbiAgaWYgKHR5cGVvZiBsb2NhdGlvblByb3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICBsb2NhdGlvblByb3AgPSBwYXJzZVBhdGgobG9jYXRpb25Qcm9wKTtcbiAgfVxuICBsZXQgYWN0aW9uID0gXCJQT1BcIiAvKiBQb3AgKi87XG4gIGxldCBsb2NhdGlvbiA9IHtcbiAgICBwYXRobmFtZTogbG9jYXRpb25Qcm9wLnBhdGhuYW1lIHx8IFwiL1wiLFxuICAgIHNlYXJjaDogbG9jYXRpb25Qcm9wLnNlYXJjaCB8fCBcIlwiLFxuICAgIGhhc2g6IGxvY2F0aW9uUHJvcC5oYXNoIHx8IFwiXCIsXG4gICAgc3RhdGU6IGxvY2F0aW9uUHJvcC5zdGF0ZSAhPSBudWxsID8gbG9jYXRpb25Qcm9wLnN0YXRlIDogbnVsbCxcbiAgICBrZXk6IGxvY2F0aW9uUHJvcC5rZXkgfHwgXCJkZWZhdWx0XCJcbiAgfTtcbiAgbGV0IHN0YXRpY05hdmlnYXRvciA9IGdldFN0YXRlbGVzc05hdmlnYXRvcigpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0MTEuY3JlYXRlRWxlbWVudChcbiAgICBSb3V0ZXIsXG4gICAge1xuICAgICAgYmFzZW5hbWUsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgbmF2aWdhdGlvblR5cGU6IGFjdGlvbixcbiAgICAgIG5hdmlnYXRvcjogc3RhdGljTmF2aWdhdG9yLFxuICAgICAgc3RhdGljOiB0cnVlXG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gU3RhdGljUm91dGVyUHJvdmlkZXIoe1xuICBjb250ZXh0LFxuICByb3V0ZXIsXG4gIGh5ZHJhdGU6IGh5ZHJhdGUyID0gdHJ1ZSxcbiAgbm9uY2Vcbn0pIHtcbiAgaW52YXJpYW50KFxuICAgIHJvdXRlciAmJiBjb250ZXh0LFxuICAgIFwiWW91IG11c3QgcHJvdmlkZSBgcm91dGVyYCBhbmQgYGNvbnRleHRgIHRvIDxTdGF0aWNSb3V0ZXJQcm92aWRlcj5cIlxuICApO1xuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSB7XG4gICAgcm91dGVyLFxuICAgIG5hdmlnYXRvcjogZ2V0U3RhdGVsZXNzTmF2aWdhdG9yKCksXG4gICAgc3RhdGljOiB0cnVlLFxuICAgIHN0YXRpY0NvbnRleHQ6IGNvbnRleHQsXG4gICAgYmFzZW5hbWU6IGNvbnRleHQuYmFzZW5hbWUgfHwgXCIvXCJcbiAgfTtcbiAgbGV0IGZldGNoZXJzQ29udGV4dCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGxldCBoeWRyYXRlU2NyaXB0ID0gXCJcIjtcbiAgaWYgKGh5ZHJhdGUyICE9PSBmYWxzZSkge1xuICAgIGxldCBkYXRhMiA9IHtcbiAgICAgIGxvYWRlckRhdGE6IGNvbnRleHQubG9hZGVyRGF0YSxcbiAgICAgIGFjdGlvbkRhdGE6IGNvbnRleHQuYWN0aW9uRGF0YSxcbiAgICAgIGVycm9yczogc2VyaWFsaXplRXJyb3JzKGNvbnRleHQuZXJyb3JzKVxuICAgIH07XG4gICAgbGV0IGpzb24gPSBodG1sRXNjYXBlKEpTT04uc3RyaW5naWZ5KEpTT04uc3RyaW5naWZ5KGRhdGEyKSkpO1xuICAgIGh5ZHJhdGVTY3JpcHQgPSBgd2luZG93Ll9fc3RhdGljUm91dGVySHlkcmF0aW9uRGF0YSA9IEpTT04ucGFyc2UoJHtqc29ufSk7YDtcbiAgfVxuICBsZXQgeyBzdGF0ZSB9ID0gZGF0YVJvdXRlckNvbnRleHQucm91dGVyO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0MTEuY3JlYXRlRWxlbWVudChSZWFjdDExLkZyYWdtZW50LCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMS5jcmVhdGVFbGVtZW50KERhdGFSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBkYXRhUm91dGVyQ29udGV4dCB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMS5jcmVhdGVFbGVtZW50KERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHN0YXRlIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDExLmNyZWF0ZUVsZW1lbnQoRmV0Y2hlcnNDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBmZXRjaGVyc0NvbnRleHQgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0MTEuY3JlYXRlRWxlbWVudChWaWV3VHJhbnNpdGlvbkNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHsgaXNUcmFuc2l0aW9uaW5nOiBmYWxzZSB9IH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDExLmNyZWF0ZUVsZW1lbnQoXG4gICAgUm91dGVyLFxuICAgIHtcbiAgICAgIGJhc2VuYW1lOiBkYXRhUm91dGVyQ29udGV4dC5iYXNlbmFtZSxcbiAgICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5oaXN0b3J5QWN0aW9uLFxuICAgICAgbmF2aWdhdG9yOiBkYXRhUm91dGVyQ29udGV4dC5uYXZpZ2F0b3IsXG4gICAgICBzdGF0aWM6IGRhdGFSb3V0ZXJDb250ZXh0LnN0YXRpY1xuICAgIH0sXG4gICAgLyogQF9fUFVSRV9fICovIFJlYWN0MTEuY3JlYXRlRWxlbWVudChcbiAgICAgIERhdGFSb3V0ZXMyLFxuICAgICAge1xuICAgICAgICByb3V0ZXM6IHJvdXRlci5yb3V0ZXMsXG4gICAgICAgIGZ1dHVyZTogcm91dGVyLmZ1dHVyZSxcbiAgICAgICAgc3RhdGVcbiAgICAgIH1cbiAgICApXG4gICkpKSkpLCBoeWRyYXRlU2NyaXB0ID8gLyogQF9fUFVSRV9fICovIFJlYWN0MTEuY3JlYXRlRWxlbWVudChcbiAgICBcInNjcmlwdFwiLFxuICAgIHtcbiAgICAgIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogdHJ1ZSxcbiAgICAgIG5vbmNlLFxuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHsgX19odG1sOiBoeWRyYXRlU2NyaXB0IH1cbiAgICB9XG4gICkgOiBudWxsKTtcbn1cbmZ1bmN0aW9uIERhdGFSb3V0ZXMyKHtcbiAgcm91dGVzLFxuICBmdXR1cmUsXG4gIHN0YXRlXG59KSB7XG4gIHJldHVybiB1c2VSb3V0ZXNJbXBsKHJvdXRlcywgdm9pZCAwLCBzdGF0ZSwgZnV0dXJlKTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUVycm9ycyhlcnJvcnMpIHtcbiAgaWYgKCFlcnJvcnMpIHJldHVybiBudWxsO1xuICBsZXQgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGVycm9ycyk7XG4gIGxldCBzZXJpYWxpemVkID0ge307XG4gIGZvciAobGV0IFtrZXksIHZhbF0gb2YgZW50cmllcykge1xuICAgIGlmIChpc1JvdXRlRXJyb3JSZXNwb25zZSh2YWwpKSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSB7IC4uLnZhbCwgX190eXBlOiBcIlJvdXRlRXJyb3JSZXNwb25zZVwiIH07XG4gICAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0ge1xuICAgICAgICBtZXNzYWdlOiB2YWwubWVzc2FnZSxcbiAgICAgICAgX190eXBlOiBcIkVycm9yXCIsXG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBzdWJjbGFzcyAoaS5lLiwgUmVmZXJlbmNlRXJyb3IpLCBzZW5kIHVwIHRoZSB0eXBlIHNvIHdlXG4gICAgICAgIC8vIGNhbiByZS1jcmVhdGUgdGhlIHNhbWUgdHlwZSBkdXJpbmcgaHlkcmF0aW9uLlxuICAgICAgICAuLi52YWwubmFtZSAhPT0gXCJFcnJvclwiID8ge1xuICAgICAgICAgIF9fc3ViVHlwZTogdmFsLm5hbWVcbiAgICAgICAgfSA6IHt9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZXJpYWxpemVkO1xufVxuZnVuY3Rpb24gZ2V0U3RhdGVsZXNzTmF2aWdhdG9yKCkge1xuICByZXR1cm4ge1xuICAgIGNyZWF0ZUhyZWYsXG4gICAgZW5jb2RlTG9jYXRpb24sXG4gICAgcHVzaCh0bykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLnB1c2goKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgZW52aXJvbm1lbnQuIFRoaXMgZXJyb3Igd2FzIHByb2JhYmx5IHRyaWdnZXJlZCB3aGVuIHlvdSBkaWQgYSBcXGBuYXZpZ2F0ZSgke0pTT04uc3RyaW5naWZ5KHRvKX0pXFxgIHNvbWV3aGVyZSBpbiB5b3VyIGFwcC5gXG4gICAgICApO1xuICAgIH0sXG4gICAgcmVwbGFjZSh0bykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLnJlcGxhY2UoKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgZW52aXJvbm1lbnQuIFRoaXMgZXJyb3Igd2FzIHByb2JhYmx5IHRyaWdnZXJlZCB3aGVuIHlvdSBkaWQgYSBcXGBuYXZpZ2F0ZSgke0pTT04uc3RyaW5naWZ5KHRvKX0sIHsgcmVwbGFjZTogdHJ1ZSB9KVxcYCBzb21ld2hlcmUgaW4geW91ciBhcHAuYFxuICAgICAgKTtcbiAgICB9LFxuICAgIGdvKGRlbHRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBZb3UgY2Fubm90IHVzZSBuYXZpZ2F0b3IuZ28oKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgZW52aXJvbm1lbnQuIFRoaXMgZXJyb3Igd2FzIHByb2JhYmx5IHRyaWdnZXJlZCB3aGVuIHlvdSBkaWQgYSBcXGBuYXZpZ2F0ZSgke2RlbHRhfSlcXGAgc29tZXdoZXJlIGluIHlvdXIgYXBwLmBcbiAgICAgICk7XG4gICAgfSxcbiAgICBiYWNrKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLmJhY2soKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgZW52aXJvbm1lbnQuYFxuICAgICAgKTtcbiAgICB9LFxuICAgIGZvcndhcmQoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBZb3UgY2Fubm90IHVzZSBuYXZpZ2F0b3IuZm9yd2FyZCgpIG9uIHRoZSBzZXJ2ZXIgYmVjYXVzZSBpdCBpcyBhIHN0YXRlbGVzcyBlbnZpcm9ubWVudC5gXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY0hhbmRsZXIyKHJvdXRlcywgb3B0cykge1xuICByZXR1cm4gY3JlYXRlU3RhdGljSGFuZGxlcihyb3V0ZXMsIHtcbiAgICAuLi5vcHRzLFxuICAgIG1hcFJvdXRlUHJvcGVydGllc1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY1JvdXRlcihyb3V0ZXMsIGNvbnRleHQsIG9wdHMgPSB7fSkge1xuICBsZXQgbWFuaWZlc3QgPSB7fTtcbiAgbGV0IGRhdGFSb3V0ZXMgPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKFxuICAgIHJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgdm9pZCAwLFxuICAgIG1hbmlmZXN0XG4gICk7XG4gIGxldCBtYXRjaGVzID0gY29udGV4dC5tYXRjaGVzLm1hcCgobWF0Y2gpID0+IHtcbiAgICBsZXQgcm91dGUgPSBtYW5pZmVzdFttYXRjaC5yb3V0ZS5pZF0gfHwgbWF0Y2gucm91dGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLm1hdGNoLFxuICAgICAgcm91dGVcbiAgICB9O1xuICB9KTtcbiAgbGV0IG1zZyA9IChtZXRob2QpID0+IGBZb3UgY2Fubm90IHVzZSByb3V0ZXIuJHttZXRob2R9KCkgb24gdGhlIHNlcnZlciBiZWNhdXNlIGl0IGlzIGEgc3RhdGVsZXNzIGVudmlyb25tZW50YDtcbiAgcmV0dXJuIHtcbiAgICBnZXQgYmFzZW5hbWUoKSB7XG4gICAgICByZXR1cm4gY29udGV4dC5iYXNlbmFtZTtcbiAgICB9LFxuICAgIGdldCBmdXR1cmUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1bnN0YWJsZV9taWRkbGV3YXJlOiBmYWxzZSxcbiAgICAgICAgLi4ub3B0cz8uZnV0dXJlXG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGlzdG9yeUFjdGlvbjogXCJQT1BcIiAvKiBQb3AgKi8sXG4gICAgICAgIGxvY2F0aW9uOiBjb250ZXh0LmxvY2F0aW9uLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhOiBjb250ZXh0LmxvYWRlckRhdGEsXG4gICAgICAgIGFjdGlvbkRhdGE6IGNvbnRleHQuYWN0aW9uRGF0YSxcbiAgICAgICAgZXJyb3JzOiBjb250ZXh0LmVycm9ycyxcbiAgICAgICAgaW5pdGlhbGl6ZWQ6IHRydWUsXG4gICAgICAgIG5hdmlnYXRpb246IElETEVfTkFWSUdBVElPTixcbiAgICAgICAgcmVzdG9yZVNjcm9sbFBvc2l0aW9uOiBudWxsLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IGZhbHNlLFxuICAgICAgICByZXZhbGlkYXRpb246IFwiaWRsZVwiLFxuICAgICAgICBmZXRjaGVyczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgICAgYmxvY2tlcnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKClcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXQgcm91dGVzKCkge1xuICAgICAgcmV0dXJuIGRhdGFSb3V0ZXM7XG4gICAgfSxcbiAgICBnZXQgd2luZG93KCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9LFxuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICB0aHJvdyBtc2coXCJpbml0aWFsaXplXCIpO1xuICAgIH0sXG4gICAgc3Vic2NyaWJlKCkge1xuICAgICAgdGhyb3cgbXNnKFwic3Vic2NyaWJlXCIpO1xuICAgIH0sXG4gICAgZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24oKSB7XG4gICAgICB0aHJvdyBtc2coXCJlbmFibGVTY3JvbGxSZXN0b3JhdGlvblwiKTtcbiAgICB9LFxuICAgIG5hdmlnYXRlKCkge1xuICAgICAgdGhyb3cgbXNnKFwibmF2aWdhdGVcIik7XG4gICAgfSxcbiAgICBmZXRjaCgpIHtcbiAgICAgIHRocm93IG1zZyhcImZldGNoXCIpO1xuICAgIH0sXG4gICAgcmV2YWxpZGF0ZSgpIHtcbiAgICAgIHRocm93IG1zZyhcInJldmFsaWRhdGVcIik7XG4gICAgfSxcbiAgICBjcmVhdGVIcmVmLFxuICAgIGVuY29kZUxvY2F0aW9uLFxuICAgIGdldEZldGNoZXIoKSB7XG4gICAgICByZXR1cm4gSURMRV9GRVRDSEVSO1xuICAgIH0sXG4gICAgZGVsZXRlRmV0Y2hlcigpIHtcbiAgICAgIHRocm93IG1zZyhcImRlbGV0ZUZldGNoZXJcIik7XG4gICAgfSxcbiAgICBkaXNwb3NlKCkge1xuICAgICAgdGhyb3cgbXNnKFwiZGlzcG9zZVwiKTtcbiAgICB9LFxuICAgIGdldEJsb2NrZXIoKSB7XG4gICAgICByZXR1cm4gSURMRV9CTE9DS0VSO1xuICAgIH0sXG4gICAgZGVsZXRlQmxvY2tlcigpIHtcbiAgICAgIHRocm93IG1zZyhcImRlbGV0ZUJsb2NrZXJcIik7XG4gICAgfSxcbiAgICBwYXRjaFJvdXRlcygpIHtcbiAgICAgIHRocm93IG1zZyhcInBhdGNoUm91dGVzXCIpO1xuICAgIH0sXG4gICAgX2ludGVybmFsRmV0Y2hDb250cm9sbGVyczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICBfaW50ZXJuYWxTZXRSb3V0ZXMoKSB7XG4gICAgICB0aHJvdyBtc2coXCJfaW50ZXJuYWxTZXRSb3V0ZXNcIik7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSHJlZih0bykge1xuICByZXR1cm4gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUxvY2F0aW9uKHRvKSB7XG4gIGxldCBocmVmMiA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gIGhyZWYyID0gaHJlZjIucmVwbGFjZSgvICQvLCBcIiUyMFwiKTtcbiAgbGV0IGVuY29kZWQgPSBBQlNPTFVURV9VUkxfUkVHRVgzLnRlc3QoaHJlZjIpID8gbmV3IFVSTChocmVmMikgOiBuZXcgVVJMKGhyZWYyLCBcImh0dHA6Ly9sb2NhbGhvc3RcIik7XG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWU6IGVuY29kZWQucGF0aG5hbWUsXG4gICAgc2VhcmNoOiBlbmNvZGVkLnNlYXJjaCxcbiAgICBoYXNoOiBlbmNvZGVkLmhhc2hcbiAgfTtcbn1cbnZhciBBQlNPTFVURV9VUkxfUkVHRVgzID0gL14oPzpbYS16XVthLXowLTkrLi1dKjp8XFwvXFwvKS9pO1xudmFyIEVTQ0FQRV9MT09LVVAyID0ge1xuICBcIiZcIjogXCJcXFxcdTAwMjZcIixcbiAgXCI+XCI6IFwiXFxcXHUwMDNlXCIsXG4gIFwiPFwiOiBcIlxcXFx1MDAzY1wiLFxuICBcIlxcdTIwMjhcIjogXCJcXFxcdTIwMjhcIixcbiAgXCJcXHUyMDI5XCI6IFwiXFxcXHUyMDI5XCJcbn07XG52YXIgRVNDQVBFX1JFR0VYMiA9IC9bJj48XFx1MjAyOFxcdTIwMjldL2c7XG5mdW5jdGlvbiBodG1sRXNjYXBlKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoRVNDQVBFX1JFR0VYMiwgKG1hdGNoKSA9PiBFU0NBUEVfTE9PS1VQMlttYXRjaF0pO1xufVxuXG4vLyBsaWIvZG9tL3Nzci9zZXJ2ZXIudHN4XG52YXIgUmVhY3QxMiA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpKTtcbmZ1bmN0aW9uIFNlcnZlclJvdXRlcih7XG4gIGNvbnRleHQsXG4gIHVybCxcbiAgbm9uY2Vcbn0pIHtcbiAgaWYgKHR5cGVvZiB1cmwgPT09IFwic3RyaW5nXCIpIHtcbiAgICB1cmwgPSBuZXcgVVJMKHVybCk7XG4gIH1cbiAgbGV0IHsgbWFuaWZlc3QsIHJvdXRlTW9kdWxlcywgY3JpdGljYWxDc3MsIHNlcnZlckhhbmRvZmZTdHJpbmcgfSA9IGNvbnRleHQ7XG4gIGxldCByb3V0ZXMgPSBjcmVhdGVTZXJ2ZXJSb3V0ZXMoXG4gICAgbWFuaWZlc3Qucm91dGVzLFxuICAgIHJvdXRlTW9kdWxlcyxcbiAgICBjb250ZXh0LmZ1dHVyZSxcbiAgICBjb250ZXh0LmlzU3BhTW9kZVxuICApO1xuICBjb250ZXh0LnN0YXRpY0hhbmRsZXJDb250ZXh0LmxvYWRlckRhdGEgPSB7XG4gICAgLi4uY29udGV4dC5zdGF0aWNIYW5kbGVyQ29udGV4dC5sb2FkZXJEYXRhXG4gIH07XG4gIGZvciAobGV0IG1hdGNoIG9mIGNvbnRleHQuc3RhdGljSGFuZGxlckNvbnRleHQubWF0Y2hlcykge1xuICAgIGxldCByb3V0ZUlkID0gbWF0Y2gucm91dGUuaWQ7XG4gICAgbGV0IHJvdXRlID0gcm91dGVNb2R1bGVzW3JvdXRlSWRdO1xuICAgIGxldCBtYW5pZmVzdFJvdXRlID0gY29udGV4dC5tYW5pZmVzdC5yb3V0ZXNbcm91dGVJZF07XG4gICAgaWYgKHJvdXRlICYmIG1hbmlmZXN0Um91dGUgJiYgc2hvdWxkSHlkcmF0ZVJvdXRlTG9hZGVyKFxuICAgICAgcm91dGVJZCxcbiAgICAgIHJvdXRlLmNsaWVudExvYWRlcixcbiAgICAgIG1hbmlmZXN0Um91dGUuaGFzTG9hZGVyLFxuICAgICAgY29udGV4dC5pc1NwYU1vZGVcbiAgICApICYmIChyb3V0ZS5IeWRyYXRlRmFsbGJhY2sgfHwgIW1hbmlmZXN0Um91dGUuaGFzTG9hZGVyKSkge1xuICAgICAgZGVsZXRlIGNvbnRleHQuc3RhdGljSGFuZGxlckNvbnRleHQubG9hZGVyRGF0YVtyb3V0ZUlkXTtcbiAgICB9XG4gIH1cbiAgbGV0IHJvdXRlciA9IGNyZWF0ZVN0YXRpY1JvdXRlcihyb3V0ZXMsIGNvbnRleHQuc3RhdGljSGFuZGxlckNvbnRleHQpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0MTIuY3JlYXRlRWxlbWVudChSZWFjdDEyLkZyYWdtZW50LCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMi5jcmVhdGVFbGVtZW50KFxuICAgIEZyYW1ld29ya0NvbnRleHQuUHJvdmlkZXIsXG4gICAge1xuICAgICAgdmFsdWU6IHtcbiAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgIHJvdXRlTW9kdWxlcyxcbiAgICAgICAgY3JpdGljYWxDc3MsXG4gICAgICAgIHNlcnZlckhhbmRvZmZTdHJpbmcsXG4gICAgICAgIGZ1dHVyZTogY29udGV4dC5mdXR1cmUsXG4gICAgICAgIHNzcjogY29udGV4dC5zc3IsXG4gICAgICAgIGlzU3BhTW9kZTogY29udGV4dC5pc1NwYU1vZGUsXG4gICAgICAgIHJvdXRlRGlzY292ZXJ5OiBjb250ZXh0LnJvdXRlRGlzY292ZXJ5LFxuICAgICAgICBzZXJpYWxpemVFcnJvcjogY29udGV4dC5zZXJpYWxpemVFcnJvcixcbiAgICAgICAgcmVuZGVyTWV0YTogY29udGV4dC5yZW5kZXJNZXRhXG4gICAgICB9XG4gICAgfSxcbiAgICAvKiBAX19QVVJFX18gKi8gUmVhY3QxMi5jcmVhdGVFbGVtZW50KFJlbWl4RXJyb3JCb3VuZGFyeSwgeyBsb2NhdGlvbjogcm91dGVyLnN0YXRlLmxvY2F0aW9uIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEyLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBTdGF0aWNSb3V0ZXJQcm92aWRlcixcbiAgICAgIHtcbiAgICAgICAgcm91dGVyLFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0LnN0YXRpY0hhbmRsZXJDb250ZXh0LFxuICAgICAgICBoeWRyYXRlOiBmYWxzZVxuICAgICAgfVxuICAgICkpXG4gICksIGNvbnRleHQuc2VydmVySGFuZG9mZlN0cmVhbSA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEyLmNyZWF0ZUVsZW1lbnQoUmVhY3QxMi5TdXNwZW5zZSwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0MTIuY3JlYXRlRWxlbWVudChcbiAgICBTdHJlYW1UcmFuc2ZlcixcbiAgICB7XG4gICAgICBjb250ZXh0LFxuICAgICAgaWRlbnRpZmllcjogMCxcbiAgICAgIHJlYWRlcjogY29udGV4dC5zZXJ2ZXJIYW5kb2ZmU3RyZWFtLmdldFJlYWRlcigpLFxuICAgICAgdGV4dERlY29kZXI6IG5ldyBUZXh0RGVjb2RlcigpLFxuICAgICAgbm9uY2VcbiAgICB9XG4gICkpIDogbnVsbCk7XG59XG5cbi8vIGxpYi9kb20vc3NyL3JvdXRlcy10ZXN0LXN0dWIudHN4XG52YXIgUmVhY3QxMyA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpKTtcbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlc1N0dWIocm91dGVzLCB1bnN0YWJsZV9nZXRDb250ZXh0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBSb3V0ZXNUZXN0U3R1Yih7XG4gICAgaW5pdGlhbEVudHJpZXMsXG4gICAgaW5pdGlhbEluZGV4LFxuICAgIGh5ZHJhdGlvbkRhdGEsXG4gICAgZnV0dXJlXG4gIH0pIHtcbiAgICBsZXQgcm91dGVyUmVmID0gUmVhY3QxMy51c2VSZWYoKTtcbiAgICBsZXQgcmVtaXhDb250ZXh0UmVmID0gUmVhY3QxMy51c2VSZWYoKTtcbiAgICBpZiAocm91dGVyUmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgcmVtaXhDb250ZXh0UmVmLmN1cnJlbnQgPSB7XG4gICAgICAgIGZ1dHVyZToge1xuICAgICAgICAgIHVuc3RhYmxlX3N1YlJlc291cmNlSW50ZWdyaXR5OiBmdXR1cmU/LnVuc3RhYmxlX3N1YlJlc291cmNlSW50ZWdyaXR5ID09PSB0cnVlLFxuICAgICAgICAgIHVuc3RhYmxlX21pZGRsZXdhcmU6IGZ1dHVyZT8udW5zdGFibGVfbWlkZGxld2FyZSA9PT0gdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBtYW5pZmVzdDoge1xuICAgICAgICAgIHJvdXRlczoge30sXG4gICAgICAgICAgZW50cnk6IHsgaW1wb3J0czogW10sIG1vZHVsZTogXCJcIiB9LFxuICAgICAgICAgIHVybDogXCJcIixcbiAgICAgICAgICB2ZXJzaW9uOiBcIlwiXG4gICAgICAgIH0sXG4gICAgICAgIHJvdXRlTW9kdWxlczoge30sXG4gICAgICAgIHNzcjogZmFsc2UsXG4gICAgICAgIGlzU3BhTW9kZTogZmFsc2UsXG4gICAgICAgIHJvdXRlRGlzY292ZXJ5OiB7IG1vZGU6IFwibGF6eVwiLCBtYW5pZmVzdFBhdGg6IFwiL19fbWFuaWZlc3RcIiB9XG4gICAgICB9O1xuICAgICAgbGV0IHBhdGNoZWQgPSBwcm9jZXNzUm91dGVzKFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGBTdHViUm91dGVPYmplY3RgIGlzIHN0cmljdGVyIGFib3V0IGBsb2FkZXJgL2BhY3Rpb25gXG4gICAgICAgIC8vIHR5cGVzIGNvbXBhcmVkIHRvIGBBZ25vc3RpY1JvdXRlT2JqZWN0YFxuICAgICAgICBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKHJvdXRlcywgKHIpID0+IHIpLFxuICAgICAgICByZW1peENvbnRleHRSZWYuY3VycmVudC5tYW5pZmVzdCxcbiAgICAgICAgcmVtaXhDb250ZXh0UmVmLmN1cnJlbnQucm91dGVNb2R1bGVzXG4gICAgICApO1xuICAgICAgcm91dGVyUmVmLmN1cnJlbnQgPSBjcmVhdGVNZW1vcnlSb3V0ZXIocGF0Y2hlZCwge1xuICAgICAgICB1bnN0YWJsZV9nZXRDb250ZXh0LFxuICAgICAgICBpbml0aWFsRW50cmllcyxcbiAgICAgICAgaW5pdGlhbEluZGV4LFxuICAgICAgICBoeWRyYXRpb25EYXRhXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEzLmNyZWF0ZUVsZW1lbnQoRnJhbWV3b3JrQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogcmVtaXhDb250ZXh0UmVmLmN1cnJlbnQgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0MTMuY3JlYXRlRWxlbWVudChSb3V0ZXJQcm92aWRlciwgeyByb3V0ZXI6IHJvdXRlclJlZi5jdXJyZW50IH0pKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NSb3V0ZXMocm91dGVzLCBtYW5pZmVzdCwgcm91dGVNb2R1bGVzLCBwYXJlbnRJZCkge1xuICByZXR1cm4gcm91dGVzLm1hcCgocm91dGUpID0+IHtcbiAgICBpZiAoIXJvdXRlLmlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiRXhwZWN0ZWQgYSByb3V0ZS5pZCBpbiBAcmVtaXgtcnVuL3Rlc3RpbmcgcHJvY2Vzc1JvdXRlcygpIGZ1bmN0aW9uXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGxldCBuZXdSb3V0ZSA9IHtcbiAgICAgIGlkOiByb3V0ZS5pZCxcbiAgICAgIHBhdGg6IHJvdXRlLnBhdGgsXG4gICAgICBpbmRleDogcm91dGUuaW5kZXgsXG4gICAgICBDb21wb25lbnQ6IHJvdXRlLkNvbXBvbmVudCA/IHdpdGhDb21wb25lbnRQcm9wcyhyb3V0ZS5Db21wb25lbnQpIDogdm9pZCAwLFxuICAgICAgSHlkcmF0ZUZhbGxiYWNrOiByb3V0ZS5IeWRyYXRlRmFsbGJhY2sgPyB3aXRoSHlkcmF0ZUZhbGxiYWNrUHJvcHMocm91dGUuSHlkcmF0ZUZhbGxiYWNrKSA6IHZvaWQgMCxcbiAgICAgIEVycm9yQm91bmRhcnk6IHJvdXRlLkVycm9yQm91bmRhcnkgPyB3aXRoRXJyb3JCb3VuZGFyeVByb3BzKHJvdXRlLkVycm9yQm91bmRhcnkpIDogdm9pZCAwLFxuICAgICAgYWN0aW9uOiByb3V0ZS5hY3Rpb24sXG4gICAgICBsb2FkZXI6IHJvdXRlLmxvYWRlcixcbiAgICAgIGhhbmRsZTogcm91dGUuaGFuZGxlLFxuICAgICAgc2hvdWxkUmV2YWxpZGF0ZTogcm91dGUuc2hvdWxkUmV2YWxpZGF0ZVxuICAgIH07XG4gICAgbGV0IGVudHJ5Um91dGUgPSB7XG4gICAgICBpZDogcm91dGUuaWQsXG4gICAgICBwYXRoOiByb3V0ZS5wYXRoLFxuICAgICAgaW5kZXg6IHJvdXRlLmluZGV4LFxuICAgICAgcGFyZW50SWQsXG4gICAgICBoYXNBY3Rpb246IHJvdXRlLmFjdGlvbiAhPSBudWxsLFxuICAgICAgaGFzTG9hZGVyOiByb3V0ZS5sb2FkZXIgIT0gbnVsbCxcbiAgICAgIC8vIFdoZW4gdGVzdGluZyByb3V0ZXMsIHlvdSBzaG91bGQgYmUgc3R1YmJpbmcgbG9hZGVyL2FjdGlvbi9taWRkbGV3YXJlLFxuICAgICAgLy8gbm90IHRyeWluZyB0byByZS1pbXBsZW1lbnQgdGhlIGZ1bGwgbG9hZGVyL2NsaWVudExvYWRlci9TU1IvaHlkcmF0aW9uXG4gICAgICAvLyBmbG93LiBUaGF0IGlzIGJldHRlciB0ZXN0ZWQgdmlhIEUyRSB0ZXN0cy5cbiAgICAgIGhhc0NsaWVudEFjdGlvbjogZmFsc2UsXG4gICAgICBoYXNDbGllbnRMb2FkZXI6IGZhbHNlLFxuICAgICAgaGFzQ2xpZW50TWlkZGxld2FyZTogZmFsc2UsXG4gICAgICBoYXNFcnJvckJvdW5kYXJ5OiByb3V0ZS5FcnJvckJvdW5kYXJ5ICE9IG51bGwsXG4gICAgICAvLyBhbnkgbmVlZCBmb3IgdGhlc2U/XG4gICAgICBtb2R1bGU6IFwiYnVpbGQvc3R1Yi1wYXRoLXRvLW1vZHVsZS5qc1wiLFxuICAgICAgY2xpZW50QWN0aW9uTW9kdWxlOiB2b2lkIDAsXG4gICAgICBjbGllbnRMb2FkZXJNb2R1bGU6IHZvaWQgMCxcbiAgICAgIGNsaWVudE1pZGRsZXdhcmVNb2R1bGU6IHZvaWQgMCxcbiAgICAgIGh5ZHJhdGVGYWxsYmFja01vZHVsZTogdm9pZCAwXG4gICAgfTtcbiAgICBtYW5pZmVzdC5yb3V0ZXNbbmV3Um91dGUuaWRdID0gZW50cnlSb3V0ZTtcbiAgICByb3V0ZU1vZHVsZXNbcm91dGUuaWRdID0ge1xuICAgICAgZGVmYXVsdDogbmV3Um91dGUuQ29tcG9uZW50IHx8IE91dGxldCxcbiAgICAgIEVycm9yQm91bmRhcnk6IG5ld1JvdXRlLkVycm9yQm91bmRhcnkgfHwgdm9pZCAwLFxuICAgICAgaGFuZGxlOiByb3V0ZS5oYW5kbGUsXG4gICAgICBsaW5rczogcm91dGUubGlua3MsXG4gICAgICBtZXRhOiByb3V0ZS5tZXRhLFxuICAgICAgc2hvdWxkUmV2YWxpZGF0ZTogcm91dGUuc2hvdWxkUmV2YWxpZGF0ZVxuICAgIH07XG4gICAgaWYgKHJvdXRlLmNoaWxkcmVuKSB7XG4gICAgICBuZXdSb3V0ZS5jaGlsZHJlbiA9IHByb2Nlc3NSb3V0ZXMoXG4gICAgICAgIHJvdXRlLmNoaWxkcmVuLFxuICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgcm91dGVNb2R1bGVzLFxuICAgICAgICBuZXdSb3V0ZS5pZFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1JvdXRlO1xuICB9KTtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL2Nvb2tpZXMudHNcbnZhciBpbXBvcnRfY29va2llID0gcmVxdWlyZShcImNvb2tpZVwiKTtcblxuLy8gbGliL3NlcnZlci1ydW50aW1lL2NyeXB0by50c1xudmFyIGVuY29kZXIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRleHRFbmNvZGVyKCk7XG52YXIgc2lnbiA9IGFzeW5jICh2YWx1ZSwgc2VjcmV0KSA9PiB7XG4gIGxldCBkYXRhMiA9IGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgbGV0IGtleSA9IGF3YWl0IGNyZWF0ZUtleTIoc2VjcmV0LCBbXCJzaWduXCJdKTtcbiAgbGV0IHNpZ25hdHVyZSA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuc2lnbihcIkhNQUNcIiwga2V5LCBkYXRhMik7XG4gIGxldCBoYXNoID0gYnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLm5ldyBVaW50OEFycmF5KHNpZ25hdHVyZSkpKS5yZXBsYWNlKFxuICAgIC89KyQvLFxuICAgIFwiXCJcbiAgKTtcbiAgcmV0dXJuIHZhbHVlICsgXCIuXCIgKyBoYXNoO1xufTtcbnZhciB1bnNpZ24gPSBhc3luYyAoY29va2llLCBzZWNyZXQpID0+IHtcbiAgbGV0IGluZGV4ID0gY29va2llLmxhc3RJbmRleE9mKFwiLlwiKTtcbiAgbGV0IHZhbHVlID0gY29va2llLnNsaWNlKDAsIGluZGV4KTtcbiAgbGV0IGhhc2ggPSBjb29raWUuc2xpY2UoaW5kZXggKyAxKTtcbiAgbGV0IGRhdGEyID0gZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICBsZXQga2V5ID0gYXdhaXQgY3JlYXRlS2V5MihzZWNyZXQsIFtcInZlcmlmeVwiXSk7XG4gIGxldCBzaWduYXR1cmUgPSBieXRlU3RyaW5nVG9VaW50OEFycmF5KGF0b2IoaGFzaCkpO1xuICBsZXQgdmFsaWQgPSBhd2FpdCBjcnlwdG8uc3VidGxlLnZlcmlmeShcIkhNQUNcIiwga2V5LCBzaWduYXR1cmUsIGRhdGEyKTtcbiAgcmV0dXJuIHZhbGlkID8gdmFsdWUgOiBmYWxzZTtcbn07XG52YXIgY3JlYXRlS2V5MiA9IGFzeW5jIChzZWNyZXQsIHVzYWdlcykgPT4gY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXG4gIFwicmF3XCIsXG4gIGVuY29kZXIuZW5jb2RlKHNlY3JldCksXG4gIHsgbmFtZTogXCJITUFDXCIsIGhhc2g6IFwiU0hBLTI1NlwiIH0sXG4gIGZhbHNlLFxuICB1c2FnZXNcbik7XG5mdW5jdGlvbiBieXRlU3RyaW5nVG9VaW50OEFycmF5KGJ5dGVTdHJpbmcpIHtcbiAgbGV0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZVN0cmluZy5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVTdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICBhcnJheVtpXSA9IGJ5dGVTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9jb29raWVzLnRzXG52YXIgY3JlYXRlQ29va2llID0gKG5hbWUsIGNvb2tpZU9wdGlvbnMgPSB7fSkgPT4ge1xuICBsZXQgeyBzZWNyZXRzID0gW10sIC4uLm9wdGlvbnMgfSA9IHtcbiAgICBwYXRoOiBcIi9cIixcbiAgICBzYW1lU2l0ZTogXCJsYXhcIixcbiAgICAuLi5jb29raWVPcHRpb25zXG4gIH07XG4gIHdhcm5PbmNlQWJvdXRFeHBpcmVzQ29va2llKG5hbWUsIG9wdGlvbnMuZXhwaXJlcyk7XG4gIHJldHVybiB7XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9LFxuICAgIGdldCBpc1NpZ25lZCgpIHtcbiAgICAgIHJldHVybiBzZWNyZXRzLmxlbmd0aCA+IDA7XG4gICAgfSxcbiAgICBnZXQgZXhwaXJlcygpIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb3B0aW9ucy5tYXhBZ2UgIT09IFwidW5kZWZpbmVkXCIgPyBuZXcgRGF0ZShEYXRlLm5vdygpICsgb3B0aW9ucy5tYXhBZ2UgKiAxZTMpIDogb3B0aW9ucy5leHBpcmVzO1xuICAgIH0sXG4gICAgYXN5bmMgcGFyc2UoY29va2llSGVhZGVyLCBwYXJzZU9wdGlvbnMpIHtcbiAgICAgIGlmICghY29va2llSGVhZGVyKSByZXR1cm4gbnVsbDtcbiAgICAgIGxldCBjb29raWVzID0gKDAsIGltcG9ydF9jb29raWUucGFyc2UpKGNvb2tpZUhlYWRlciwgeyAuLi5vcHRpb25zLCAuLi5wYXJzZU9wdGlvbnMgfSk7XG4gICAgICBpZiAobmFtZSBpbiBjb29raWVzKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGNvb2tpZXNbbmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgIT09IFwiXCIpIHtcbiAgICAgICAgICBsZXQgZGVjb2RlZCA9IGF3YWl0IGRlY29kZUNvb2tpZVZhbHVlKHZhbHVlLCBzZWNyZXRzKTtcbiAgICAgICAgICByZXR1cm4gZGVjb2RlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICBhc3luYyBzZXJpYWxpemUodmFsdWUsIHNlcmlhbGl6ZU9wdGlvbnMpIHtcbiAgICAgIHJldHVybiAoMCwgaW1wb3J0X2Nvb2tpZS5zZXJpYWxpemUpKFxuICAgICAgICBuYW1lLFxuICAgICAgICB2YWx1ZSA9PT0gXCJcIiA/IFwiXCIgOiBhd2FpdCBlbmNvZGVDb29raWVWYWx1ZSh2YWx1ZSwgc2VjcmV0cyksXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIC4uLnNlcmlhbGl6ZU9wdGlvbnNcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gIH07XG59O1xudmFyIGlzQ29va2llID0gKG9iamVjdCkgPT4ge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgdHlwZW9mIG9iamVjdC5uYW1lID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBvYmplY3QuaXNTaWduZWQgPT09IFwiYm9vbGVhblwiICYmIHR5cGVvZiBvYmplY3QucGFyc2UgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqZWN0LnNlcmlhbGl6ZSA9PT0gXCJmdW5jdGlvblwiO1xufTtcbmFzeW5jIGZ1bmN0aW9uIGVuY29kZUNvb2tpZVZhbHVlKHZhbHVlLCBzZWNyZXRzKSB7XG4gIGxldCBlbmNvZGVkID0gZW5jb2RlRGF0YSh2YWx1ZSk7XG4gIGlmIChzZWNyZXRzLmxlbmd0aCA+IDApIHtcbiAgICBlbmNvZGVkID0gYXdhaXQgc2lnbihlbmNvZGVkLCBzZWNyZXRzWzBdKTtcbiAgfVxuICByZXR1cm4gZW5jb2RlZDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGRlY29kZUNvb2tpZVZhbHVlKHZhbHVlLCBzZWNyZXRzKSB7XG4gIGlmIChzZWNyZXRzLmxlbmd0aCA+IDApIHtcbiAgICBmb3IgKGxldCBzZWNyZXQgb2Ygc2VjcmV0cykge1xuICAgICAgbGV0IHVuc2lnbmVkVmFsdWUgPSBhd2FpdCB1bnNpZ24odmFsdWUsIHNlY3JldCk7XG4gICAgICBpZiAodW5zaWduZWRWYWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZURhdGEodW5zaWduZWRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBkZWNvZGVEYXRhKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGVuY29kZURhdGEodmFsdWUpIHtcbiAgcmV0dXJuIGJ0b2EobXlVbmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkodmFsdWUpKSkpO1xufVxuZnVuY3Rpb24gZGVjb2RlRGF0YSh2YWx1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKGRlY29kZVVSSUNvbXBvbmVudChteUVzY2FwZShhdG9iKHZhbHVlKSkpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn1cbmZ1bmN0aW9uIG15RXNjYXBlKHZhbHVlKSB7XG4gIGxldCBzdHIgPSB2YWx1ZS50b1N0cmluZygpO1xuICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgbGV0IGluZGV4ID0gMDtcbiAgbGV0IGNociwgY29kZTtcbiAgd2hpbGUgKGluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgIGNociA9IHN0ci5jaGFyQXQoaW5kZXgrKyk7XG4gICAgaWYgKC9bXFx3KitcXC0uL0BdLy5leGVjKGNocikpIHtcbiAgICAgIHJlc3VsdCArPSBjaHI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUgPSBjaHIuY2hhckNvZGVBdCgwKTtcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHJlc3VsdCArPSBcIiVcIiArIGhleChjb2RlLCAyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCArPSBcIiV1XCIgKyBoZXgoY29kZSwgNCkudG9VcHBlckNhc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGhleChjb2RlLCBsZW5ndGgpIHtcbiAgbGV0IHJlc3VsdCA9IGNvZGUudG9TdHJpbmcoMTYpO1xuICB3aGlsZSAocmVzdWx0Lmxlbmd0aCA8IGxlbmd0aCkgcmVzdWx0ID0gXCIwXCIgKyByZXN1bHQ7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBteVVuZXNjYXBlKHZhbHVlKSB7XG4gIGxldCBzdHIgPSB2YWx1ZS50b1N0cmluZygpO1xuICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgbGV0IGluZGV4ID0gMDtcbiAgbGV0IGNociwgcGFydDtcbiAgd2hpbGUgKGluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgIGNociA9IHN0ci5jaGFyQXQoaW5kZXgrKyk7XG4gICAgaWYgKGNociA9PT0gXCIlXCIpIHtcbiAgICAgIGlmIChzdHIuY2hhckF0KGluZGV4KSA9PT0gXCJ1XCIpIHtcbiAgICAgICAgcGFydCA9IHN0ci5zbGljZShpbmRleCArIDEsIGluZGV4ICsgNSk7XG4gICAgICAgIGlmICgvXltcXGRhLWZdezR9JC9pLmV4ZWMocGFydCkpIHtcbiAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChwYXJ0LCAxNikpO1xuICAgICAgICAgIGluZGV4ICs9IDU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnQgPSBzdHIuc2xpY2UoaW5kZXgsIGluZGV4ICsgMik7XG4gICAgICAgIGlmICgvXltcXGRhLWZdezJ9JC9pLmV4ZWMocGFydCkpIHtcbiAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChwYXJ0LCAxNikpO1xuICAgICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0ICs9IGNocjtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gd2Fybk9uY2VBYm91dEV4cGlyZXNDb29raWUobmFtZSwgZXhwaXJlcykge1xuICB3YXJuT25jZShcbiAgICAhZXhwaXJlcyxcbiAgICBgVGhlIFwiJHtuYW1lfVwiIGNvb2tpZSBoYXMgYW4gXCJleHBpcmVzXCIgcHJvcGVydHkgc2V0LiBUaGlzIHdpbGwgY2F1c2UgdGhlIGV4cGlyZXMgdmFsdWUgdG8gbm90IGJlIHVwZGF0ZWQgd2hlbiB0aGUgc2Vzc2lvbiBpcyBjb21taXR0ZWQuIEluc3RlYWQsIHlvdSBzaG91bGQgc2V0IHRoZSBleHBpcmVzIHZhbHVlIHdoZW4gc2VyaWFsaXppbmcgdGhlIGNvb2tpZS4gWW91IGNhbiB1c2UgXFxgY29tbWl0U2Vzc2lvbihzZXNzaW9uLCB7IGV4cGlyZXMgfSlcXGAgaWYgdXNpbmcgYSBzZXNzaW9uIHN0b3JhZ2Ugb2JqZWN0LCBvciBcXGBjb29raWUuc2VyaWFsaXplKFwidmFsdWVcIiwgeyBleHBpcmVzIH0pXFxgIGlmIHlvdSdyZSB1c2luZyB0aGUgY29va2llIGRpcmVjdGx5LmBcbiAgKTtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL2VudHJ5LnRzXG5mdW5jdGlvbiBjcmVhdGVFbnRyeVJvdXRlTW9kdWxlcyhtYW5pZmVzdCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMobWFuaWZlc3QpLnJlZHVjZSgobWVtbzIsIHJvdXRlSWQpID0+IHtcbiAgICBsZXQgcm91dGUgPSBtYW5pZmVzdFtyb3V0ZUlkXTtcbiAgICBpZiAocm91dGUpIHtcbiAgICAgIG1lbW8yW3JvdXRlSWRdID0gcm91dGUubW9kdWxlO1xuICAgIH1cbiAgICByZXR1cm4gbWVtbzI7XG4gIH0sIHt9KTtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL21vZGUudHNcbnZhciBTZXJ2ZXJNb2RlID0gLyogQF9fUFVSRV9fICovICgoU2VydmVyTW9kZTIpID0+IHtcbiAgU2VydmVyTW9kZTJbXCJEZXZlbG9wbWVudFwiXSA9IFwiZGV2ZWxvcG1lbnRcIjtcbiAgU2VydmVyTW9kZTJbXCJQcm9kdWN0aW9uXCJdID0gXCJwcm9kdWN0aW9uXCI7XG4gIFNlcnZlck1vZGUyW1wiVGVzdFwiXSA9IFwidGVzdFwiO1xuICByZXR1cm4gU2VydmVyTW9kZTI7XG59KShTZXJ2ZXJNb2RlIHx8IHt9KTtcbmZ1bmN0aW9uIGlzU2VydmVyTW9kZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IFwiZGV2ZWxvcG1lbnRcIiAvKiBEZXZlbG9wbWVudCAqLyB8fCB2YWx1ZSA9PT0gXCJwcm9kdWN0aW9uXCIgLyogUHJvZHVjdGlvbiAqLyB8fCB2YWx1ZSA9PT0gXCJ0ZXN0XCIgLyogVGVzdCAqLztcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL2Vycm9ycy50c1xuZnVuY3Rpb24gc2FuaXRpemVFcnJvcihlcnJvciwgc2VydmVyTW9kZSkge1xuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBzZXJ2ZXJNb2RlICE9PSBcImRldmVsb3BtZW50XCIgLyogRGV2ZWxvcG1lbnQgKi8pIHtcbiAgICBsZXQgc2FuaXRpemVkID0gbmV3IEVycm9yKFwiVW5leHBlY3RlZCBTZXJ2ZXIgRXJyb3JcIik7XG4gICAgc2FuaXRpemVkLnN0YWNrID0gdm9pZCAwO1xuICAgIHJldHVybiBzYW5pdGl6ZWQ7XG4gIH1cbiAgcmV0dXJuIGVycm9yO1xufVxuZnVuY3Rpb24gc2FuaXRpemVFcnJvcnMoZXJyb3JzLCBzZXJ2ZXJNb2RlKSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhlcnJvcnMpLnJlZHVjZSgoYWNjLCBbcm91dGVJZCwgZXJyb3JdKSA9PiB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYWNjLCB7IFtyb3V0ZUlkXTogc2FuaXRpemVFcnJvcihlcnJvciwgc2VydmVyTW9kZSkgfSk7XG4gIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUVycm9yKGVycm9yLCBzZXJ2ZXJNb2RlKSB7XG4gIGxldCBzYW5pdGl6ZWQgPSBzYW5pdGl6ZUVycm9yKGVycm9yLCBzZXJ2ZXJNb2RlKTtcbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlOiBzYW5pdGl6ZWQubWVzc2FnZSxcbiAgICBzdGFjazogc2FuaXRpemVkLnN0YWNrXG4gIH07XG59XG5mdW5jdGlvbiBzZXJpYWxpemVFcnJvcnMyKGVycm9ycywgc2VydmVyTW9kZSkge1xuICBpZiAoIWVycm9ycykgcmV0dXJuIG51bGw7XG4gIGxldCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoZXJyb3JzKTtcbiAgbGV0IHNlcmlhbGl6ZWQgPSB7fTtcbiAgZm9yIChsZXQgW2tleSwgdmFsXSBvZiBlbnRyaWVzKSB7XG4gICAgaWYgKGlzUm91dGVFcnJvclJlc3BvbnNlKHZhbCkpIHtcbiAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IHsgLi4udmFsLCBfX3R5cGU6IFwiUm91dGVFcnJvclJlc3BvbnNlXCIgfTtcbiAgICB9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBsZXQgc2FuaXRpemVkID0gc2FuaXRpemVFcnJvcih2YWwsIHNlcnZlck1vZGUpO1xuICAgICAgc2VyaWFsaXplZFtrZXldID0ge1xuICAgICAgICBtZXNzYWdlOiBzYW5pdGl6ZWQubWVzc2FnZSxcbiAgICAgICAgc3RhY2s6IHNhbml0aXplZC5zdGFjayxcbiAgICAgICAgX190eXBlOiBcIkVycm9yXCIsXG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBzdWJjbGFzcyAoaS5lLiwgUmVmZXJlbmNlRXJyb3IpLCBzZW5kIHVwIHRoZSB0eXBlIHNvIHdlXG4gICAgICAgIC8vIGNhbiByZS1jcmVhdGUgdGhlIHNhbWUgdHlwZSBkdXJpbmcgaHlkcmF0aW9uLiAgVGhpcyB3aWxsIG9ubHkgYXBwbHlcbiAgICAgICAgLy8gaW4gZGV2IG1vZGUgc2luY2UgYWxsIHByb2R1Y3Rpb24gZXJyb3JzIGFyZSBzYW5pdGl6ZWQgdG8gbm9ybWFsXG4gICAgICAgIC8vIEVycm9yIGluc3RhbmNlc1xuICAgICAgICAuLi5zYW5pdGl6ZWQubmFtZSAhPT0gXCJFcnJvclwiID8ge1xuICAgICAgICAgIF9fc3ViVHlwZTogc2FuaXRpemVkLm5hbWVcbiAgICAgICAgfSA6IHt9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZXJpYWxpemVkO1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvcm91dGVNYXRjaGluZy50c1xuZnVuY3Rpb24gbWF0Y2hTZXJ2ZXJSb3V0ZXMocm91dGVzLCBwYXRobmFtZSwgYmFzZW5hbWUpIHtcbiAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhcbiAgICByb3V0ZXMsXG4gICAgcGF0aG5hbWUsXG4gICAgYmFzZW5hbWVcbiAgKTtcbiAgaWYgKCFtYXRjaGVzKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIG1hdGNoZXMubWFwKChtYXRjaCkgPT4gKHtcbiAgICBwYXJhbXM6IG1hdGNoLnBhcmFtcyxcbiAgICBwYXRobmFtZTogbWF0Y2gucGF0aG5hbWUsXG4gICAgcm91dGU6IG1hdGNoLnJvdXRlXG4gIH0pKTtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL2RhdGEudHNcbmFzeW5jIGZ1bmN0aW9uIGNhbGxSb3V0ZUhhbmRsZXIoaGFuZGxlciwgYXJncykge1xuICBsZXQgcmVzdWx0ID0gYXdhaXQgaGFuZGxlcih7XG4gICAgcmVxdWVzdDogc3RyaXBSb3V0ZXNQYXJhbShzdHJpcEluZGV4UGFyYW0yKGFyZ3MucmVxdWVzdCkpLFxuICAgIHBhcmFtczogYXJncy5wYXJhbXMsXG4gICAgY29udGV4dDogYXJncy5jb250ZXh0XG4gIH0pO1xuICBpZiAoaXNEYXRhV2l0aFJlc3BvbnNlSW5pdChyZXN1bHQpICYmIHJlc3VsdC5pbml0ICYmIHJlc3VsdC5pbml0LnN0YXR1cyAmJiBpc1JlZGlyZWN0U3RhdHVzQ29kZShyZXN1bHQuaW5pdC5zdGF0dXMpKSB7XG4gICAgdGhyb3cgbmV3IFJlc3BvbnNlKG51bGwsIHJlc3VsdC5pbml0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gc3RyaXBJbmRleFBhcmFtMihyZXF1ZXN0KSB7XG4gIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgbGV0IGluZGV4VmFsdWVzID0gdXJsLnNlYXJjaFBhcmFtcy5nZXRBbGwoXCJpbmRleFwiKTtcbiAgdXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoXCJpbmRleFwiKTtcbiAgbGV0IGluZGV4VmFsdWVzVG9LZWVwID0gW107XG4gIGZvciAobGV0IGluZGV4VmFsdWUgb2YgaW5kZXhWYWx1ZXMpIHtcbiAgICBpZiAoaW5kZXhWYWx1ZSkge1xuICAgICAgaW5kZXhWYWx1ZXNUb0tlZXAucHVzaChpbmRleFZhbHVlKTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgdG9LZWVwIG9mIGluZGV4VmFsdWVzVG9LZWVwKSB7XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJpbmRleFwiLCB0b0tlZXApO1xuICB9XG4gIGxldCBpbml0ID0ge1xuICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgYm9keTogcmVxdWVzdC5ib2R5LFxuICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyxcbiAgICBzaWduYWw6IHJlcXVlc3Quc2lnbmFsXG4gIH07XG4gIGlmIChpbml0LmJvZHkpIHtcbiAgICBpbml0LmR1cGxleCA9IFwiaGFsZlwiO1xuICB9XG4gIHJldHVybiBuZXcgUmVxdWVzdCh1cmwuaHJlZiwgaW5pdCk7XG59XG5mdW5jdGlvbiBzdHJpcFJvdXRlc1BhcmFtKHJlcXVlc3QpIHtcbiAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZShcIl9yb3V0ZXNcIik7XG4gIGxldCBpbml0ID0ge1xuICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgYm9keTogcmVxdWVzdC5ib2R5LFxuICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyxcbiAgICBzaWduYWw6IHJlcXVlc3Quc2lnbmFsXG4gIH07XG4gIGlmIChpbml0LmJvZHkpIHtcbiAgICBpbml0LmR1cGxleCA9IFwiaGFsZlwiO1xuICB9XG4gIHJldHVybiBuZXcgUmVxdWVzdCh1cmwuaHJlZiwgaW5pdCk7XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9pbnZhcmlhbnQudHNcbmZ1bmN0aW9uIGludmFyaWFudDModmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgXCJUaGUgZm9sbG93aW5nIGVycm9yIGlzIGEgYnVnIGluIFJlYWN0IFJvdXRlcjsgcGxlYXNlIG9wZW4gYW4gaXNzdWUhIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vcmVhY3Qtcm91dGVyL2lzc3Vlcy9uZXcvY2hvb3NlXCJcbiAgICApO1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvZGV2LnRzXG52YXIgZ2xvYmFsRGV2U2VydmVySG9va3NLZXkgPSBcIl9fcmVhY3RSb3V0ZXJEZXZTZXJ2ZXJIb29rc1wiO1xuZnVuY3Rpb24gc2V0RGV2U2VydmVySG9va3MoZGV2U2VydmVySG9va3MpIHtcbiAgZ2xvYmFsVGhpc1tnbG9iYWxEZXZTZXJ2ZXJIb29rc0tleV0gPSBkZXZTZXJ2ZXJIb29rcztcbn1cbmZ1bmN0aW9uIGdldERldlNlcnZlckhvb2tzKCkge1xuICByZXR1cm4gZ2xvYmFsVGhpc1tnbG9iYWxEZXZTZXJ2ZXJIb29rc0tleV07XG59XG5mdW5jdGlvbiBnZXRCdWlsZFRpbWVIZWFkZXIocmVxdWVzdCwgaGVhZGVyTmFtZSkge1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Py5JU19SUl9CVUlMRF9SRVFVRVNUID09PSBcInllc1wiKSB7XG4gICAgICAgIHJldHVybiByZXF1ZXN0LmhlYWRlcnMuZ2V0KGhlYWRlck5hbWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9yb3V0ZXMudHNcbmZ1bmN0aW9uIGdyb3VwUm91dGVzQnlQYXJlbnRJZDIobWFuaWZlc3QpIHtcbiAgbGV0IHJvdXRlcyA9IHt9O1xuICBPYmplY3QudmFsdWVzKG1hbmlmZXN0KS5mb3JFYWNoKChyb3V0ZSkgPT4ge1xuICAgIGlmIChyb3V0ZSkge1xuICAgICAgbGV0IHBhcmVudElkID0gcm91dGUucGFyZW50SWQgfHwgXCJcIjtcbiAgICAgIGlmICghcm91dGVzW3BhcmVudElkXSkge1xuICAgICAgICByb3V0ZXNbcGFyZW50SWRdID0gW107XG4gICAgICB9XG4gICAgICByb3V0ZXNbcGFyZW50SWRdLnB1c2gocm91dGUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByb3V0ZXM7XG59XG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXMobWFuaWZlc3QsIHBhcmVudElkID0gXCJcIiwgcm91dGVzQnlQYXJlbnRJZCA9IGdyb3VwUm91dGVzQnlQYXJlbnRJZDIobWFuaWZlc3QpKSB7XG4gIHJldHVybiAocm91dGVzQnlQYXJlbnRJZFtwYXJlbnRJZF0gfHwgW10pLm1hcCgocm91dGUpID0+ICh7XG4gICAgLi4ucm91dGUsXG4gICAgY2hpbGRyZW46IGNyZWF0ZVJvdXRlcyhtYW5pZmVzdCwgcm91dGUuaWQsIHJvdXRlc0J5UGFyZW50SWQpXG4gIH0pKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY0hhbmRsZXJEYXRhUm91dGVzKG1hbmlmZXN0LCBmdXR1cmUsIHBhcmVudElkID0gXCJcIiwgcm91dGVzQnlQYXJlbnRJZCA9IGdyb3VwUm91dGVzQnlQYXJlbnRJZDIobWFuaWZlc3QpKSB7XG4gIHJldHVybiAocm91dGVzQnlQYXJlbnRJZFtwYXJlbnRJZF0gfHwgW10pLm1hcCgocm91dGUpID0+IHtcbiAgICBsZXQgY29tbW9uUm91dGUgPSB7XG4gICAgICAvLyBBbHdheXMgaW5jbHVkZSByb290IGR1ZSB0byBkZWZhdWx0IGJvdW5kYXJpZXNcbiAgICAgIGhhc0Vycm9yQm91bmRhcnk6IHJvdXRlLmlkID09PSBcInJvb3RcIiB8fCByb3V0ZS5tb2R1bGUuRXJyb3JCb3VuZGFyeSAhPSBudWxsLFxuICAgICAgaWQ6IHJvdXRlLmlkLFxuICAgICAgcGF0aDogcm91dGUucGF0aCxcbiAgICAgIHVuc3RhYmxlX21pZGRsZXdhcmU6IHJvdXRlLm1vZHVsZS51bnN0YWJsZV9taWRkbGV3YXJlLFxuICAgICAgLy8gTmVlZCB0byB1c2UgUlIncyB2ZXJzaW9uIGluIHRoZSBwYXJhbSB0eXBlZCBoZXJlIHRvIHBlcm1pdCB0aGUgb3B0aW9uYWxcbiAgICAgIC8vIGNvbnRleHQgZXZlbiB0aG91Z2ggd2Uga25vdyBpdCdsbCBhbHdheXMgYmUgcHJvdmlkZWQgaW4gcmVtaXhcbiAgICAgIGxvYWRlcjogcm91dGUubW9kdWxlLmxvYWRlciA/IGFzeW5jIChhcmdzKSA9PiB7XG4gICAgICAgIGxldCBwcmVSZW5kZXJlZERhdGEgPSBnZXRCdWlsZFRpbWVIZWFkZXIoXG4gICAgICAgICAgYXJncy5yZXF1ZXN0LFxuICAgICAgICAgIFwiWC1SZWFjdC1Sb3V0ZXItUHJlcmVuZGVyLURhdGFcIlxuICAgICAgICApO1xuICAgICAgICBpZiAocHJlUmVuZGVyZWREYXRhICE9IG51bGwpIHtcbiAgICAgICAgICBsZXQgZW5jb2RlZCA9IHByZVJlbmRlcmVkRGF0YSA/IGRlY29kZVVSSShwcmVSZW5kZXJlZERhdGEpIDogcHJlUmVuZGVyZWREYXRhO1xuICAgICAgICAgIGludmFyaWFudDMoZW5jb2RlZCwgXCJNaXNzaW5nIHByZXJlbmRlcmVkIGRhdGEgZm9yIHJvdXRlXCIpO1xuICAgICAgICAgIGxldCB1aW50OGFycmF5ID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGVuY29kZWQpO1xuICAgICAgICAgIGxldCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodWludDhhcnJheSk7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsZXQgZGVjb2RlZCA9IGF3YWl0IGRlY29kZVZpYVR1cmJvU3RyZWFtKHN0cmVhbSwgZ2xvYmFsKTtcbiAgICAgICAgICBsZXQgZGF0YTIgPSBkZWNvZGVkLnZhbHVlO1xuICAgICAgICAgIGlmIChkYXRhMiAmJiBTaW5nbGVGZXRjaFJlZGlyZWN0U3ltYm9sIGluIGRhdGEyKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gZGF0YTJbU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbF07XG4gICAgICAgICAgICBsZXQgaW5pdCA9IHsgc3RhdHVzOiByZXN1bHQuc3RhdHVzIH07XG4gICAgICAgICAgICBpZiAocmVzdWx0LnJlbG9hZCkge1xuICAgICAgICAgICAgICB0aHJvdyByZWRpcmVjdERvY3VtZW50KHJlc3VsdC5yZWRpcmVjdCwgaW5pdCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5yZXBsYWNlKSB7XG4gICAgICAgICAgICAgIHRocm93IHJlcGxhY2UocmVzdWx0LnJlZGlyZWN0LCBpbml0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IHJlZGlyZWN0KHJlc3VsdC5yZWRpcmVjdCwgaW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGludmFyaWFudDMoXG4gICAgICAgICAgICAgIGRhdGEyICYmIHJvdXRlLmlkIGluIGRhdGEyLFxuICAgICAgICAgICAgICBcIlVuYWJsZSB0byBkZWNvZGUgcHJlcmVuZGVyZWQgZGF0YVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGRhdGEyW3JvdXRlLmlkXTtcbiAgICAgICAgICAgIGludmFyaWFudDMoXG4gICAgICAgICAgICAgIFwiZGF0YVwiIGluIHJlc3VsdCxcbiAgICAgICAgICAgICAgXCJVbmFibGUgdG8gcHJvY2VzcyBwcmVyZW5kZXJlZCBkYXRhXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB2YWwgPSBhd2FpdCBjYWxsUm91dGVIYW5kbGVyKHJvdXRlLm1vZHVsZS5sb2FkZXIsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfSA6IHZvaWQgMCxcbiAgICAgIGFjdGlvbjogcm91dGUubW9kdWxlLmFjdGlvbiA/IChhcmdzKSA9PiBjYWxsUm91dGVIYW5kbGVyKHJvdXRlLm1vZHVsZS5hY3Rpb24sIGFyZ3MpIDogdm9pZCAwLFxuICAgICAgaGFuZGxlOiByb3V0ZS5tb2R1bGUuaGFuZGxlXG4gICAgfTtcbiAgICByZXR1cm4gcm91dGUuaW5kZXggPyB7XG4gICAgICBpbmRleDogdHJ1ZSxcbiAgICAgIC4uLmNvbW1vblJvdXRlXG4gICAgfSA6IHtcbiAgICAgIGNhc2VTZW5zaXRpdmU6IHJvdXRlLmNhc2VTZW5zaXRpdmUsXG4gICAgICBjaGlsZHJlbjogY3JlYXRlU3RhdGljSGFuZGxlckRhdGFSb3V0ZXMoXG4gICAgICAgIG1hbmlmZXN0LFxuICAgICAgICBmdXR1cmUsXG4gICAgICAgIHJvdXRlLmlkLFxuICAgICAgICByb3V0ZXNCeVBhcmVudElkXG4gICAgICApLFxuICAgICAgLi4uY29tbW9uUm91dGVcbiAgICB9O1xuICB9KTtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL21hcmt1cC50c1xudmFyIEVTQ0FQRV9MT09LVVAzID0ge1xuICBcIiZcIjogXCJcXFxcdTAwMjZcIixcbiAgXCI+XCI6IFwiXFxcXHUwMDNlXCIsXG4gIFwiPFwiOiBcIlxcXFx1MDAzY1wiLFxuICBcIlxcdTIwMjhcIjogXCJcXFxcdTIwMjhcIixcbiAgXCJcXHUyMDI5XCI6IFwiXFxcXHUyMDI5XCJcbn07XG52YXIgRVNDQVBFX1JFR0VYMyA9IC9bJj48XFx1MjAyOFxcdTIwMjldL2c7XG5mdW5jdGlvbiBlc2NhcGVIdG1sMihodG1sKSB7XG4gIHJldHVybiBodG1sLnJlcGxhY2UoRVNDQVBFX1JFR0VYMywgKG1hdGNoKSA9PiBFU0NBUEVfTE9PS1VQM1ttYXRjaF0pO1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvc2VydmVySGFuZG9mZi50c1xuZnVuY3Rpb24gY3JlYXRlU2VydmVySGFuZG9mZlN0cmluZyhzZXJ2ZXJIYW5kb2ZmKSB7XG4gIHJldHVybiBlc2NhcGVIdG1sMihKU09OLnN0cmluZ2lmeShzZXJ2ZXJIYW5kb2ZmKSk7XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9oZWFkZXJzLnRzXG52YXIgaW1wb3J0X3NldF9jb29raWVfcGFyc2VyID0gcmVxdWlyZShcInNldC1jb29raWUtcGFyc2VyXCIpO1xuZnVuY3Rpb24gZ2V0RG9jdW1lbnRIZWFkZXJzKGJ1aWxkLCBjb250ZXh0KSB7XG4gIHJldHVybiBnZXREb2N1bWVudEhlYWRlcnNJbXBsKGNvbnRleHQsIChtKSA9PiB7XG4gICAgbGV0IHJvdXRlID0gYnVpbGQucm91dGVzW20ucm91dGUuaWRdO1xuICAgIGludmFyaWFudDMocm91dGUsIGBSb3V0ZSB3aXRoIGlkIFwiJHttLnJvdXRlLmlkfVwiIG5vdCBmb3VuZCBpbiBidWlsZGApO1xuICAgIHJldHVybiByb3V0ZS5tb2R1bGUuaGVhZGVycztcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXREb2N1bWVudEhlYWRlcnNJbXBsKGNvbnRleHQsIGdldFJvdXRlSGVhZGVyc0ZuKSB7XG4gIGxldCBib3VuZGFyeUlkeCA9IGNvbnRleHQuZXJyb3JzID8gY29udGV4dC5tYXRjaGVzLmZpbmRJbmRleCgobSkgPT4gY29udGV4dC5lcnJvcnNbbS5yb3V0ZS5pZF0pIDogLTE7XG4gIGxldCBtYXRjaGVzID0gYm91bmRhcnlJZHggPj0gMCA/IGNvbnRleHQubWF0Y2hlcy5zbGljZSgwLCBib3VuZGFyeUlkeCArIDEpIDogY29udGV4dC5tYXRjaGVzO1xuICBsZXQgZXJyb3JIZWFkZXJzO1xuICBpZiAoYm91bmRhcnlJZHggPj0gMCkge1xuICAgIGxldCB7IGFjdGlvbkhlYWRlcnMsIGFjdGlvbkRhdGEsIGxvYWRlckhlYWRlcnMsIGxvYWRlckRhdGEgfSA9IGNvbnRleHQ7XG4gICAgY29udGV4dC5tYXRjaGVzLnNsaWNlKGJvdW5kYXJ5SWR4KS5zb21lKChtYXRjaCkgPT4ge1xuICAgICAgbGV0IGlkID0gbWF0Y2gucm91dGUuaWQ7XG4gICAgICBpZiAoYWN0aW9uSGVhZGVyc1tpZF0gJiYgKCFhY3Rpb25EYXRhIHx8ICFhY3Rpb25EYXRhLmhhc093blByb3BlcnR5KGlkKSkpIHtcbiAgICAgICAgZXJyb3JIZWFkZXJzID0gYWN0aW9uSGVhZGVyc1tpZF07XG4gICAgICB9IGVsc2UgaWYgKGxvYWRlckhlYWRlcnNbaWRdICYmICFsb2FkZXJEYXRhLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICBlcnJvckhlYWRlcnMgPSBsb2FkZXJIZWFkZXJzW2lkXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlcnJvckhlYWRlcnMgIT0gbnVsbDtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbWF0Y2hlcy5yZWR1Y2UoKHBhcmVudEhlYWRlcnMsIG1hdGNoLCBpZHgpID0+IHtcbiAgICBsZXQgeyBpZCB9ID0gbWF0Y2gucm91dGU7XG4gICAgbGV0IGxvYWRlckhlYWRlcnMgPSBjb250ZXh0LmxvYWRlckhlYWRlcnNbaWRdIHx8IG5ldyBIZWFkZXJzKCk7XG4gICAgbGV0IGFjdGlvbkhlYWRlcnMgPSBjb250ZXh0LmFjdGlvbkhlYWRlcnNbaWRdIHx8IG5ldyBIZWFkZXJzKCk7XG4gICAgbGV0IGluY2x1ZGVFcnJvckhlYWRlcnMgPSBlcnJvckhlYWRlcnMgIT0gbnVsbCAmJiBpZHggPT09IG1hdGNoZXMubGVuZ3RoIC0gMTtcbiAgICBsZXQgaW5jbHVkZUVycm9yQ29va2llcyA9IGluY2x1ZGVFcnJvckhlYWRlcnMgJiYgZXJyb3JIZWFkZXJzICE9PSBsb2FkZXJIZWFkZXJzICYmIGVycm9ySGVhZGVycyAhPT0gYWN0aW9uSGVhZGVycztcbiAgICBsZXQgaGVhZGVyc0ZuID0gZ2V0Um91dGVIZWFkZXJzRm4obWF0Y2gpO1xuICAgIGlmIChoZWFkZXJzRm4gPT0gbnVsbCkge1xuICAgICAgbGV0IGhlYWRlcnMyID0gbmV3IEhlYWRlcnMocGFyZW50SGVhZGVycyk7XG4gICAgICBpZiAoaW5jbHVkZUVycm9yQ29va2llcykge1xuICAgICAgICBwcmVwZW5kQ29va2llcyhlcnJvckhlYWRlcnMsIGhlYWRlcnMyKTtcbiAgICAgIH1cbiAgICAgIHByZXBlbmRDb29raWVzKGFjdGlvbkhlYWRlcnMsIGhlYWRlcnMyKTtcbiAgICAgIHByZXBlbmRDb29raWVzKGxvYWRlckhlYWRlcnMsIGhlYWRlcnMyKTtcbiAgICAgIHJldHVybiBoZWFkZXJzMjtcbiAgICB9XG4gICAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhcbiAgICAgIHR5cGVvZiBoZWFkZXJzRm4gPT09IFwiZnVuY3Rpb25cIiA/IGhlYWRlcnNGbih7XG4gICAgICAgIGxvYWRlckhlYWRlcnMsXG4gICAgICAgIHBhcmVudEhlYWRlcnMsXG4gICAgICAgIGFjdGlvbkhlYWRlcnMsXG4gICAgICAgIGVycm9ySGVhZGVyczogaW5jbHVkZUVycm9ySGVhZGVycyA/IGVycm9ySGVhZGVycyA6IHZvaWQgMFxuICAgICAgfSkgOiBoZWFkZXJzRm5cbiAgICApO1xuICAgIGlmIChpbmNsdWRlRXJyb3JDb29raWVzKSB7XG4gICAgICBwcmVwZW5kQ29va2llcyhlcnJvckhlYWRlcnMsIGhlYWRlcnMpO1xuICAgIH1cbiAgICBwcmVwZW5kQ29va2llcyhhY3Rpb25IZWFkZXJzLCBoZWFkZXJzKTtcbiAgICBwcmVwZW5kQ29va2llcyhsb2FkZXJIZWFkZXJzLCBoZWFkZXJzKTtcbiAgICBwcmVwZW5kQ29va2llcyhwYXJlbnRIZWFkZXJzLCBoZWFkZXJzKTtcbiAgICByZXR1cm4gaGVhZGVycztcbiAgfSwgbmV3IEhlYWRlcnMoKSk7XG59XG5mdW5jdGlvbiBwcmVwZW5kQ29va2llcyhwYXJlbnRIZWFkZXJzLCBjaGlsZEhlYWRlcnMpIHtcbiAgbGV0IHBhcmVudFNldENvb2tpZVN0cmluZyA9IHBhcmVudEhlYWRlcnMuZ2V0KFwiU2V0LUNvb2tpZVwiKTtcbiAgaWYgKHBhcmVudFNldENvb2tpZVN0cmluZykge1xuICAgIGxldCBjb29raWVzID0gKDAsIGltcG9ydF9zZXRfY29va2llX3BhcnNlci5zcGxpdENvb2tpZXNTdHJpbmcpKHBhcmVudFNldENvb2tpZVN0cmluZyk7XG4gICAgbGV0IGNoaWxkQ29va2llcyA9IG5ldyBTZXQoY2hpbGRIZWFkZXJzLmdldFNldENvb2tpZSgpKTtcbiAgICBjb29raWVzLmZvckVhY2goKGNvb2tpZSkgPT4ge1xuICAgICAgaWYgKCFjaGlsZENvb2tpZXMuaGFzKGNvb2tpZSkpIHtcbiAgICAgICAgY2hpbGRIZWFkZXJzLmFwcGVuZChcIlNldC1Db29raWVcIiwgY29va2llKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvc2luZ2xlLWZldGNoLnRzXG52YXIgU0VSVkVSX05PX0JPRFlfU1RBVFVTX0NPREVTID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICAuLi5OT19CT0RZX1NUQVRVU19DT0RFUyxcbiAgMzA0XG5dKTtcbmFzeW5jIGZ1bmN0aW9uIHNpbmdsZUZldGNoQWN0aW9uKGJ1aWxkLCBzZXJ2ZXJNb2RlLCBzdGF0aWNIYW5kbGVyLCByZXF1ZXN0LCBoYW5kbGVyVXJsLCBsb2FkQ29udGV4dCwgaGFuZGxlRXJyb3IpIHtcbiAgdHJ5IHtcbiAgICBsZXQgcmVzcG9uZDIgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICBsZXQgaGVhZGVycyA9IGdldERvY3VtZW50SGVhZGVycyhidWlsZCwgY29udGV4dCk7XG4gICAgICBpZiAoaXNSZWRpcmVjdFN0YXR1c0NvZGUoY29udGV4dC5zdGF0dXNDb2RlKSAmJiBoZWFkZXJzLmhhcyhcIkxvY2F0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZVNpbmdsZUZldGNoUmVzcG9uc2UocmVxdWVzdCwgYnVpbGQsIHNlcnZlck1vZGUsIHtcbiAgICAgICAgICByZXN1bHQ6IGdldFNpbmdsZUZldGNoUmVkaXJlY3QoXG4gICAgICAgICAgICBjb250ZXh0LnN0YXR1c0NvZGUsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgYnVpbGQuYmFzZW5hbWVcbiAgICAgICAgICApLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgc3RhdHVzOiBTSU5HTEVfRkVUQ0hfUkVESVJFQ1RfU1RBVFVTXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRleHQuZXJyb3JzKSB7XG4gICAgICAgIE9iamVjdC52YWx1ZXMoY29udGV4dC5lcnJvcnMpLmZvckVhY2goKGVycikgPT4ge1xuICAgICAgICAgIGlmICghaXNSb3V0ZUVycm9yUmVzcG9uc2UoZXJyKSB8fCBlcnIuZXJyb3IpIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29udGV4dC5lcnJvcnMgPSBzYW5pdGl6ZUVycm9ycyhjb250ZXh0LmVycm9ycywgc2VydmVyTW9kZSk7XG4gICAgICB9XG4gICAgICBsZXQgc2luZ2xlRmV0Y2hSZXN1bHQ7XG4gICAgICBpZiAoY29udGV4dC5lcnJvcnMpIHtcbiAgICAgICAgc2luZ2xlRmV0Y2hSZXN1bHQgPSB7IGVycm9yOiBPYmplY3QudmFsdWVzKGNvbnRleHQuZXJyb3JzKVswXSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2luZ2xlRmV0Y2hSZXN1bHQgPSB7XG4gICAgICAgICAgZGF0YTogT2JqZWN0LnZhbHVlcyhjb250ZXh0LmFjdGlvbkRhdGEgfHwge30pWzBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2VuZXJhdGVTaW5nbGVGZXRjaFJlc3BvbnNlKHJlcXVlc3QsIGJ1aWxkLCBzZXJ2ZXJNb2RlLCB7XG4gICAgICAgIHJlc3VsdDogc2luZ2xlRmV0Y2hSZXN1bHQsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIHN0YXR1czogY29udGV4dC5zdGF0dXNDb2RlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHZhciByZXNwb25kID0gcmVzcG9uZDI7XG4gICAgbGV0IGhhbmRsZXJSZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaGFuZGxlclVybCwge1xuICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgIGJvZHk6IHJlcXVlc3QuYm9keSxcbiAgICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyxcbiAgICAgIHNpZ25hbDogcmVxdWVzdC5zaWduYWwsXG4gICAgICAuLi5yZXF1ZXN0LmJvZHkgPyB7IGR1cGxleDogXCJoYWxmXCIgfSA6IHZvaWQgMFxuICAgIH0pO1xuICAgIGxldCByZXN1bHQgPSBhd2FpdCBzdGF0aWNIYW5kbGVyLnF1ZXJ5KGhhbmRsZXJSZXF1ZXN0LCB7XG4gICAgICByZXF1ZXN0Q29udGV4dDogbG9hZENvbnRleHQsXG4gICAgICBza2lwTG9hZGVyRXJyb3JCdWJibGluZzogdHJ1ZSxcbiAgICAgIHNraXBSZXZhbGlkYXRpb246IHRydWUsXG4gICAgICB1bnN0YWJsZV9yZXNwb25kOiByZXNwb25kMlxuICAgIH0pO1xuICAgIGlmICghaXNSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgICByZXN1bHQgPSByZXNwb25kMihyZXN1bHQpO1xuICAgIH1cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiBnZW5lcmF0ZVNpbmdsZUZldGNoUmVzcG9uc2UocmVxdWVzdCwgYnVpbGQsIHNlcnZlck1vZGUsIHtcbiAgICAgICAgcmVzdWx0OiBnZXRTaW5nbGVGZXRjaFJlZGlyZWN0KFxuICAgICAgICAgIHJlc3VsdC5zdGF0dXMsXG4gICAgICAgICAgcmVzdWx0LmhlYWRlcnMsXG4gICAgICAgICAgYnVpbGQuYmFzZW5hbWVcbiAgICAgICAgKSxcbiAgICAgICAgaGVhZGVyczogcmVzdWx0LmhlYWRlcnMsXG4gICAgICAgIHN0YXR1czogU0lOR0xFX0ZFVENIX1JFRElSRUNUX1NUQVRVU1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiBnZW5lcmF0ZVNpbmdsZUZldGNoUmVzcG9uc2UocmVxdWVzdCwgYnVpbGQsIHNlcnZlck1vZGUsIHtcbiAgICAgIHJlc3VsdDogeyBlcnJvciB9LFxuICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMoKSxcbiAgICAgIHN0YXR1czogNTAwXG4gICAgfSk7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHNpbmdsZUZldGNoTG9hZGVycyhidWlsZCwgc2VydmVyTW9kZSwgc3RhdGljSGFuZGxlciwgcmVxdWVzdCwgaGFuZGxlclVybCwgbG9hZENvbnRleHQsIGhhbmRsZUVycm9yKSB7XG4gIHRyeSB7XG4gICAgbGV0IHJlc3BvbmQyID0gZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgbGV0IGhlYWRlcnMgPSBnZXREb2N1bWVudEhlYWRlcnMoYnVpbGQsIGNvbnRleHQpO1xuICAgICAgaWYgKGlzUmVkaXJlY3RTdGF0dXNDb2RlKGNvbnRleHQuc3RhdHVzQ29kZSkgJiYgaGVhZGVycy5oYXMoXCJMb2NhdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gZ2VuZXJhdGVTaW5nbGVGZXRjaFJlc3BvbnNlKHJlcXVlc3QsIGJ1aWxkLCBzZXJ2ZXJNb2RlLCB7XG4gICAgICAgICAgcmVzdWx0OiB7XG4gICAgICAgICAgICBbU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbF06IGdldFNpbmdsZUZldGNoUmVkaXJlY3QoXG4gICAgICAgICAgICAgIGNvbnRleHQuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgYnVpbGQuYmFzZW5hbWVcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgc3RhdHVzOiBTSU5HTEVfRkVUQ0hfUkVESVJFQ1RfU1RBVFVTXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRleHQuZXJyb3JzKSB7XG4gICAgICAgIE9iamVjdC52YWx1ZXMoY29udGV4dC5lcnJvcnMpLmZvckVhY2goKGVycikgPT4ge1xuICAgICAgICAgIGlmICghaXNSb3V0ZUVycm9yUmVzcG9uc2UoZXJyKSB8fCBlcnIuZXJyb3IpIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29udGV4dC5lcnJvcnMgPSBzYW5pdGl6ZUVycm9ycyhjb250ZXh0LmVycm9ycywgc2VydmVyTW9kZSk7XG4gICAgICB9XG4gICAgICBsZXQgcmVzdWx0cyA9IHt9O1xuICAgICAgbGV0IGxvYWRlZE1hdGNoZXMgPSBuZXcgU2V0KFxuICAgICAgICBjb250ZXh0Lm1hdGNoZXMuZmlsdGVyKFxuICAgICAgICAgIChtKSA9PiBsb2FkUm91dGVJZHMgPyBsb2FkUm91dGVJZHMuaGFzKG0ucm91dGUuaWQpIDogbS5yb3V0ZS5sb2FkZXIgIT0gbnVsbFxuICAgICAgICApLm1hcCgobSkgPT4gbS5yb3V0ZS5pZClcbiAgICAgICk7XG4gICAgICBpZiAoY29udGV4dC5lcnJvcnMpIHtcbiAgICAgICAgZm9yIChsZXQgW2lkLCBlcnJvcl0gb2YgT2JqZWN0LmVudHJpZXMoY29udGV4dC5lcnJvcnMpKSB7XG4gICAgICAgICAgcmVzdWx0c1tpZF0gPSB7IGVycm9yIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IFtpZCwgZGF0YTJdIG9mIE9iamVjdC5lbnRyaWVzKGNvbnRleHQubG9hZGVyRGF0YSkpIHtcbiAgICAgICAgaWYgKCEoaWQgaW4gcmVzdWx0cykgJiYgbG9hZGVkTWF0Y2hlcy5oYXMoaWQpKSB7XG4gICAgICAgICAgcmVzdWx0c1tpZF0gPSB7IGRhdGE6IGRhdGEyIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBnZW5lcmF0ZVNpbmdsZUZldGNoUmVzcG9uc2UocmVxdWVzdCwgYnVpbGQsIHNlcnZlck1vZGUsIHtcbiAgICAgICAgcmVzdWx0OiByZXN1bHRzLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBzdGF0dXM6IGNvbnRleHQuc3RhdHVzQ29kZVxuICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgcmVzcG9uZCA9IHJlc3BvbmQyO1xuICAgIGxldCBoYW5kbGVyUmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGhhbmRsZXJVcmwsIHtcbiAgICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyxcbiAgICAgIHNpZ25hbDogcmVxdWVzdC5zaWduYWxcbiAgICB9KTtcbiAgICBsZXQgcm91dGVzUGFyYW0gPSBuZXcgVVJMKHJlcXVlc3QudXJsKS5zZWFyY2hQYXJhbXMuZ2V0KFwiX3JvdXRlc1wiKTtcbiAgICBsZXQgbG9hZFJvdXRlSWRzID0gcm91dGVzUGFyYW0gPyBuZXcgU2V0KHJvdXRlc1BhcmFtLnNwbGl0KFwiLFwiKSkgOiBudWxsO1xuICAgIGxldCByZXN1bHQgPSBhd2FpdCBzdGF0aWNIYW5kbGVyLnF1ZXJ5KGhhbmRsZXJSZXF1ZXN0LCB7XG4gICAgICByZXF1ZXN0Q29udGV4dDogbG9hZENvbnRleHQsXG4gICAgICBmaWx0ZXJNYXRjaGVzVG9Mb2FkOiAobSkgPT4gIWxvYWRSb3V0ZUlkcyB8fCBsb2FkUm91dGVJZHMuaGFzKG0ucm91dGUuaWQpLFxuICAgICAgc2tpcExvYWRlckVycm9yQnViYmxpbmc6IHRydWUsXG4gICAgICB1bnN0YWJsZV9yZXNwb25kOiByZXNwb25kMlxuICAgIH0pO1xuICAgIGlmICghaXNSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgICByZXN1bHQgPSByZXNwb25kMihyZXN1bHQpO1xuICAgIH1cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiBnZW5lcmF0ZVNpbmdsZUZldGNoUmVzcG9uc2UocmVxdWVzdCwgYnVpbGQsIHNlcnZlck1vZGUsIHtcbiAgICAgICAgcmVzdWx0OiB7XG4gICAgICAgICAgW1NpbmdsZUZldGNoUmVkaXJlY3RTeW1ib2xdOiBnZXRTaW5nbGVGZXRjaFJlZGlyZWN0KFxuICAgICAgICAgICAgcmVzdWx0LnN0YXR1cyxcbiAgICAgICAgICAgIHJlc3VsdC5oZWFkZXJzLFxuICAgICAgICAgICAgYnVpbGQuYmFzZW5hbWVcbiAgICAgICAgICApXG4gICAgICAgIH0sXG4gICAgICAgIGhlYWRlcnM6IHJlc3VsdC5oZWFkZXJzLFxuICAgICAgICBzdGF0dXM6IFNJTkdMRV9GRVRDSF9SRURJUkVDVF9TVEFUVVNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGhhbmRsZUVycm9yKGVycm9yKTtcbiAgICByZXR1cm4gZ2VuZXJhdGVTaW5nbGVGZXRjaFJlc3BvbnNlKHJlcXVlc3QsIGJ1aWxkLCBzZXJ2ZXJNb2RlLCB7XG4gICAgICByZXN1bHQ6IHsgcm9vdDogeyBlcnJvciB9IH0sXG4gICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycygpLFxuICAgICAgc3RhdHVzOiA1MDBcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZ2VuZXJhdGVTaW5nbGVGZXRjaFJlc3BvbnNlKHJlcXVlc3QsIGJ1aWxkLCBzZXJ2ZXJNb2RlLCB7XG4gIHJlc3VsdCxcbiAgaGVhZGVycyxcbiAgc3RhdHVzXG59KSB7XG4gIGxldCByZXN1bHRIZWFkZXJzID0gbmV3IEhlYWRlcnMoaGVhZGVycyk7XG4gIHJlc3VsdEhlYWRlcnMuc2V0KFwiWC1SZW1peC1SZXNwb25zZVwiLCBcInllc1wiKTtcbiAgaWYgKFNFUlZFUl9OT19CT0RZX1NUQVRVU19DT0RFUy5oYXMoc3RhdHVzKSkge1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwgeyBzdGF0dXMsIGhlYWRlcnM6IHJlc3VsdEhlYWRlcnMgfSk7XG4gIH1cbiAgcmVzdWx0SGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJ0ZXh0L3gtc2NyaXB0XCIpO1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKFxuICAgIGVuY29kZVZpYVR1cmJvU3RyZWFtKFxuICAgICAgcmVzdWx0LFxuICAgICAgcmVxdWVzdC5zaWduYWwsXG4gICAgICBidWlsZC5lbnRyeS5tb2R1bGUuc3RyZWFtVGltZW91dCxcbiAgICAgIHNlcnZlck1vZGVcbiAgICApLFxuICAgIHtcbiAgICAgIHN0YXR1czogc3RhdHVzIHx8IDIwMCxcbiAgICAgIGhlYWRlcnM6IHJlc3VsdEhlYWRlcnNcbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBnZXRTaW5nbGVGZXRjaFJlZGlyZWN0KHN0YXR1cywgaGVhZGVycywgYmFzZW5hbWUpIHtcbiAgbGV0IHJlZGlyZWN0MiA9IGhlYWRlcnMuZ2V0KFwiTG9jYXRpb25cIik7XG4gIGlmIChiYXNlbmFtZSkge1xuICAgIHJlZGlyZWN0MiA9IHN0cmlwQmFzZW5hbWUocmVkaXJlY3QyLCBiYXNlbmFtZSkgfHwgcmVkaXJlY3QyO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVkaXJlY3Q6IHJlZGlyZWN0MixcbiAgICBzdGF0dXMsXG4gICAgcmV2YWxpZGF0ZTogKFxuICAgICAgLy8gVGVjaG5pY2FsbHkgWC1SZW1peC1SZXZhbGlkYXRlIGlzbid0IG5lZWRlZCBoZXJlIC0gdGhhdCB3YXMgYW4gaW1wbGVtZW50YXRpb25cbiAgICAgIC8vIGRldGFpbCBvZiA/X2RhdGEgcmVxdWVzdHMgYXMgb3VyIHdheSB0byB0ZWxsIHRoZSBmcm9udCBlbmQgdG8gcmV2YWxpZGF0ZSB3aGVuXG4gICAgICAvLyB3ZSBkaWRuJ3QgaGF2ZSBhIHJlc3BvbnNlIGJvZHkgdG8gaW5jbHVkZSB0aGF0IGluZm9ybWF0aW9uIGluLlxuICAgICAgLy8gV2l0aCBzaW5nbGUgZmV0Y2gsIHdlIHRlbGwgdGhlIGZyb250IGVuZCB2aWEgdGhpcyByZXZhbGlkYXRlIGJvb2xlYW4gZmllbGQuXG4gICAgICAvLyBIb3dldmVyLCB3ZSdyZSByZXNwZWN0aW5nIGl0IGZvciBub3cgYmVjYXVzZSBpdCBtYXkgYmUgc29tZXRoaW5nIGZvbGtzIGhhdmVcbiAgICAgIC8vIHVzZWQgaW4gdGhlaXIgb3duIHJlc3BvbnNlc1xuICAgICAgLy8gVE9ETyh2Myk6IENvbnNpZGVyIHJlbW92aW5nIG9yIG1ha2luZyB0aGlzIG9mZmljaWFsIHB1YmxpYyBBUElcbiAgICAgIGhlYWRlcnMuaGFzKFwiWC1SZW1peC1SZXZhbGlkYXRlXCIpIHx8IGhlYWRlcnMuaGFzKFwiU2V0LUNvb2tpZVwiKVxuICAgICksXG4gICAgcmVsb2FkOiBoZWFkZXJzLmhhcyhcIlgtUmVtaXgtUmVsb2FkLURvY3VtZW50XCIpLFxuICAgIHJlcGxhY2U6IGhlYWRlcnMuaGFzKFwiWC1SZW1peC1SZXBsYWNlXCIpXG4gIH07XG59XG5mdW5jdGlvbiBlbmNvZGVWaWFUdXJib1N0cmVhbShkYXRhMiwgcmVxdWVzdFNpZ25hbCwgc3RyZWFtVGltZW91dCwgc2VydmVyTW9kZSkge1xuICBsZXQgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgbGV0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoXG4gICAgKCkgPT4gY29udHJvbGxlci5hYm9ydChuZXcgRXJyb3IoXCJTZXJ2ZXIgVGltZW91dFwiKSksXG4gICAgdHlwZW9mIHN0cmVhbVRpbWVvdXQgPT09IFwibnVtYmVyXCIgPyBzdHJlYW1UaW1lb3V0IDogNDk1MFxuICApO1xuICByZXF1ZXN0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiBjbGVhclRpbWVvdXQodGltZW91dElkKSk7XG4gIHJldHVybiBlbmNvZGUoZGF0YTIsIHtcbiAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgIHBsdWdpbnM6IFtcbiAgICAgICh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIGxldCB7IG5hbWUsIG1lc3NhZ2UsIHN0YWNrIH0gPSBzZXJ2ZXJNb2RlID09PSBcInByb2R1Y3Rpb25cIiAvKiBQcm9kdWN0aW9uICovID8gc2FuaXRpemVFcnJvcih2YWx1ZSwgc2VydmVyTW9kZSkgOiB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gW1wiU2FuaXRpemVkRXJyb3JcIiwgbmFtZSwgbWVzc2FnZSwgc3RhY2tdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yUmVzcG9uc2VJbXBsKSB7XG4gICAgICAgICAgbGV0IHsgZGF0YTogZGF0YTMsIHN0YXR1cywgc3RhdHVzVGV4dCB9ID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIFtcIkVycm9yUmVzcG9uc2VcIiwgZGF0YTMsIHN0YXR1cywgc3RhdHVzVGV4dF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBTaW5nbGVGZXRjaFJlZGlyZWN0U3ltYm9sIGluIHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIFtcIlNpbmdsZUZldGNoUmVkaXJlY3RcIiwgdmFsdWVbU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbF1dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgXSxcbiAgICBwb3N0UGx1Z2luczogW1xuICAgICAgKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICghdmFsdWUpIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIikgcmV0dXJuO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIFwiU2luZ2xlRmV0Y2hDbGFzc0luc3RhbmNlXCIsXG4gICAgICAgICAgT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHZhbHVlKSlcbiAgICAgICAgXTtcbiAgICAgIH0sXG4gICAgICAoKSA9PiBbXCJTaW5nbGVGZXRjaEZhbGxiYWNrXCJdXG4gICAgXVxuICB9KTtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL3NlcnZlci50c1xuZnVuY3Rpb24gZGVyaXZlKGJ1aWxkLCBtb2RlKSB7XG4gIGxldCByb3V0ZXMgPSBjcmVhdGVSb3V0ZXMoYnVpbGQucm91dGVzKTtcbiAgbGV0IGRhdGFSb3V0ZXMgPSBjcmVhdGVTdGF0aWNIYW5kbGVyRGF0YVJvdXRlcyhidWlsZC5yb3V0ZXMsIGJ1aWxkLmZ1dHVyZSk7XG4gIGxldCBzZXJ2ZXJNb2RlID0gaXNTZXJ2ZXJNb2RlKG1vZGUpID8gbW9kZSA6IFwicHJvZHVjdGlvblwiIC8qIFByb2R1Y3Rpb24gKi87XG4gIGxldCBzdGF0aWNIYW5kbGVyID0gY3JlYXRlU3RhdGljSGFuZGxlcihkYXRhUm91dGVzLCB7XG4gICAgYmFzZW5hbWU6IGJ1aWxkLmJhc2VuYW1lXG4gIH0pO1xuICBsZXQgZXJyb3JIYW5kbGVyID0gYnVpbGQuZW50cnkubW9kdWxlLmhhbmRsZUVycm9yIHx8ICgoZXJyb3IsIHsgcmVxdWVzdCB9KSA9PiB7XG4gICAgaWYgKHNlcnZlck1vZGUgIT09IFwidGVzdFwiIC8qIFRlc3QgKi8gJiYgIXJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVGhpcyBpcyBcInByaXZhdGVcIiBmcm9tIHVzZXJzIGJ1dCBpbnRlbmRlZCBmb3IgaW50ZXJuYWwgdXNlXG4gICAgICAgIGlzUm91dGVFcnJvclJlc3BvbnNlKGVycm9yKSAmJiBlcnJvci5lcnJvciA/IGVycm9yLmVycm9yIDogZXJyb3JcbiAgICAgICk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICByb3V0ZXMsXG4gICAgZGF0YVJvdXRlcyxcbiAgICBzZXJ2ZXJNb2RlLFxuICAgIHN0YXRpY0hhbmRsZXIsXG4gICAgZXJyb3JIYW5kbGVyXG4gIH07XG59XG52YXIgY3JlYXRlUmVxdWVzdEhhbmRsZXIgPSAoYnVpbGQsIG1vZGUpID0+IHtcbiAgbGV0IF9idWlsZDtcbiAgbGV0IHJvdXRlcztcbiAgbGV0IHNlcnZlck1vZGU7XG4gIGxldCBzdGF0aWNIYW5kbGVyO1xuICBsZXQgZXJyb3JIYW5kbGVyO1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gcmVxdWVzdEhhbmRsZXIocmVxdWVzdCwgaW5pdGlhbENvbnRleHQpIHtcbiAgICBfYnVpbGQgPSB0eXBlb2YgYnVpbGQgPT09IFwiZnVuY3Rpb25cIiA/IGF3YWl0IGJ1aWxkKCkgOiBidWlsZDtcbiAgICBpZiAodHlwZW9mIGJ1aWxkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGxldCBkZXJpdmVkID0gZGVyaXZlKF9idWlsZCwgbW9kZSk7XG4gICAgICByb3V0ZXMgPSBkZXJpdmVkLnJvdXRlcztcbiAgICAgIHNlcnZlck1vZGUgPSBkZXJpdmVkLnNlcnZlck1vZGU7XG4gICAgICBzdGF0aWNIYW5kbGVyID0gZGVyaXZlZC5zdGF0aWNIYW5kbGVyO1xuICAgICAgZXJyb3JIYW5kbGVyID0gZGVyaXZlZC5lcnJvckhhbmRsZXI7XG4gICAgfSBlbHNlIGlmICghcm91dGVzIHx8ICFzZXJ2ZXJNb2RlIHx8ICFzdGF0aWNIYW5kbGVyIHx8ICFlcnJvckhhbmRsZXIpIHtcbiAgICAgIGxldCBkZXJpdmVkID0gZGVyaXZlKF9idWlsZCwgbW9kZSk7XG4gICAgICByb3V0ZXMgPSBkZXJpdmVkLnJvdXRlcztcbiAgICAgIHNlcnZlck1vZGUgPSBkZXJpdmVkLnNlcnZlck1vZGU7XG4gICAgICBzdGF0aWNIYW5kbGVyID0gZGVyaXZlZC5zdGF0aWNIYW5kbGVyO1xuICAgICAgZXJyb3JIYW5kbGVyID0gZGVyaXZlZC5lcnJvckhhbmRsZXI7XG4gICAgfVxuICAgIGxldCBwYXJhbXMgPSB7fTtcbiAgICBsZXQgbG9hZENvbnRleHQ7XG4gICAgbGV0IGhhbmRsZUVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICBpZiAobW9kZSA9PT0gXCJkZXZlbG9wbWVudFwiIC8qIERldmVsb3BtZW50ICovKSB7XG4gICAgICAgIGdldERldlNlcnZlckhvb2tzKCk/LnByb2Nlc3NSZXF1ZXN0RXJyb3I/LihlcnJvcik7XG4gICAgICB9XG4gICAgICBlcnJvckhhbmRsZXIoZXJyb3IsIHtcbiAgICAgICAgY29udGV4dDogbG9hZENvbnRleHQsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgcmVxdWVzdFxuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAoX2J1aWxkLmZ1dHVyZS51bnN0YWJsZV9taWRkbGV3YXJlKSB7XG4gICAgICBpZiAoaW5pdGlhbENvbnRleHQgPT0gbnVsbCkge1xuICAgICAgICBsb2FkQ29udGV4dCA9IG5ldyB1bnN0YWJsZV9Sb3V0ZXJDb250ZXh0UHJvdmlkZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbG9hZENvbnRleHQgPSBuZXcgdW5zdGFibGVfUm91dGVyQ29udGV4dFByb3ZpZGVyKFxuICAgICAgICAgICAgaW5pdGlhbENvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgbGV0IGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgYFVuYWJsZSB0byBjcmVhdGUgaW5pdGlhbCBcXGB1bnN0YWJsZV9Sb3V0ZXJDb250ZXh0UHJvdmlkZXJcXGAgaW5zdGFuY2UuIFBsZWFzZSBjb25maXJtIHlvdSBhcmUgcmV0dXJuaW5nIGFuIGluc3RhbmNlIG9mIFxcYE1hcDx1bnN0YWJsZV9yb3V0ZXJDb250ZXh0LCB1bmtub3duPlxcYCBmcm9tIHlvdXIgXFxgZ2V0TG9hZENvbnRleHRcXGAgZnVuY3Rpb24uXG5cbkVycm9yOiAke2UgaW5zdGFuY2VvZiBFcnJvciA/IGUudG9TdHJpbmcoKSA6IGV9YFxuICAgICAgICAgICk7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIHJldHVybiByZXR1cm5MYXN0UmVzb3J0RXJyb3JSZXNwb25zZShlcnJvciwgc2VydmVyTW9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9hZENvbnRleHQgPSBpbml0aWFsQ29udGV4dCB8fCB7fTtcbiAgICB9XG4gICAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgIGxldCBub3JtYWxpemVkQmFzZW5hbWUgPSBfYnVpbGQuYmFzZW5hbWUgfHwgXCIvXCI7XG4gICAgbGV0IG5vcm1hbGl6ZWRQYXRoID0gdXJsLnBhdGhuYW1lO1xuICAgIGlmIChzdHJpcEJhc2VuYW1lKG5vcm1hbGl6ZWRQYXRoLCBub3JtYWxpemVkQmFzZW5hbWUpID09PSBcIi9fcm9vdC5kYXRhXCIpIHtcbiAgICAgIG5vcm1hbGl6ZWRQYXRoID0gbm9ybWFsaXplZEJhc2VuYW1lO1xuICAgIH0gZWxzZSBpZiAobm9ybWFsaXplZFBhdGguZW5kc1dpdGgoXCIuZGF0YVwiKSkge1xuICAgICAgbm9ybWFsaXplZFBhdGggPSBub3JtYWxpemVkUGF0aC5yZXBsYWNlKC9cXC5kYXRhJC8sIFwiXCIpO1xuICAgIH1cbiAgICBpZiAoc3RyaXBCYXNlbmFtZShub3JtYWxpemVkUGF0aCwgbm9ybWFsaXplZEJhc2VuYW1lKSAhPT0gXCIvXCIgJiYgbm9ybWFsaXplZFBhdGguZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgICBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZWRQYXRoLnNsaWNlKDAsIC0xKTtcbiAgICB9XG4gICAgbGV0IGlzU3BhTW9kZSA9IGdldEJ1aWxkVGltZUhlYWRlcihyZXF1ZXN0LCBcIlgtUmVhY3QtUm91dGVyLVNQQS1Nb2RlXCIpID09PSBcInllc1wiO1xuICAgIGlmICghX2J1aWxkLnNzcikge1xuICAgICAgaWYgKF9idWlsZC5wcmVyZW5kZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlzU3BhTW9kZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCFfYnVpbGQucHJlcmVuZGVyLmluY2x1ZGVzKG5vcm1hbGl6ZWRQYXRoKSAmJiAhX2J1aWxkLnByZXJlbmRlci5pbmNsdWRlcyhub3JtYWxpemVkUGF0aCArIFwiL1wiKSkge1xuICAgICAgICBpZiAodXJsLnBhdGhuYW1lLmVuZHNXaXRoKFwiLmRhdGFcIikpIHtcbiAgICAgICAgICBlcnJvckhhbmRsZXIoXG4gICAgICAgICAgICBuZXcgRXJyb3JSZXNwb25zZUltcGwoXG4gICAgICAgICAgICAgIDQwNCxcbiAgICAgICAgICAgICAgXCJOb3QgRm91bmRcIixcbiAgICAgICAgICAgICAgYFJlZnVzaW5nIHRvIFNTUiB0aGUgcGF0aCBcXGAke25vcm1hbGl6ZWRQYXRofVxcYCBiZWNhdXNlIFxcYHNzcjpmYWxzZVxcYCBpcyBzZXQgYW5kIHRoZSBwYXRoIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgXFxgcHJlcmVuZGVyXFxgIGNvbmZpZywgc28gaW4gcHJvZHVjdGlvbiB0aGUgcGF0aCB3aWxsIGJlIGEgNDA0LmBcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnRleHQ6IGxvYWRDb250ZXh0LFxuICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgIHJlcXVlc3RcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoXCJOb3QgRm91bmRcIiwge1xuICAgICAgICAgICAgc3RhdHVzOiA0MDQsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiBcIk5vdCBGb3VuZFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNTcGFNb2RlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbWFuaWZlc3RVcmwgPSBnZXRNYW5pZmVzdFBhdGgoXG4gICAgICBfYnVpbGQucm91dGVEaXNjb3ZlcnkubWFuaWZlc3RQYXRoLFxuICAgICAgbm9ybWFsaXplZEJhc2VuYW1lXG4gICAgKTtcbiAgICBpZiAodXJsLnBhdGhuYW1lID09PSBtYW5pZmVzdFVybCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHJlcyA9IGF3YWl0IGhhbmRsZU1hbmlmZXN0UmVxdWVzdChfYnVpbGQsIHJvdXRlcywgdXJsKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSk7XG4gICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoXCJVbmtub3duIFNlcnZlciBFcnJvclwiLCB7IHN0YXR1czogNTAwIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoU2VydmVyUm91dGVzKHJvdXRlcywgbm9ybWFsaXplZFBhdGgsIF9idWlsZC5iYXNlbmFtZSk7XG4gICAgaWYgKG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHBhcmFtcywgbWF0Y2hlc1swXS5wYXJhbXMpO1xuICAgIH1cbiAgICBsZXQgcmVzcG9uc2U7XG4gICAgaWYgKHVybC5wYXRobmFtZS5lbmRzV2l0aChcIi5kYXRhXCIpKSB7XG4gICAgICBsZXQgaGFuZGxlclVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgICAgaGFuZGxlclVybC5wYXRobmFtZSA9IG5vcm1hbGl6ZWRQYXRoO1xuICAgICAgbGV0IHNpbmdsZUZldGNoTWF0Y2hlcyA9IG1hdGNoU2VydmVyUm91dGVzKFxuICAgICAgICByb3V0ZXMsXG4gICAgICAgIGhhbmRsZXJVcmwucGF0aG5hbWUsXG4gICAgICAgIF9idWlsZC5iYXNlbmFtZVxuICAgICAgKTtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlU2luZ2xlRmV0Y2hSZXF1ZXN0KFxuICAgICAgICBzZXJ2ZXJNb2RlLFxuICAgICAgICBfYnVpbGQsXG4gICAgICAgIHN0YXRpY0hhbmRsZXIsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGhhbmRsZXJVcmwsXG4gICAgICAgIGxvYWRDb250ZXh0LFxuICAgICAgICBoYW5kbGVFcnJvclxuICAgICAgKTtcbiAgICAgIGlmIChfYnVpbGQuZW50cnkubW9kdWxlLmhhbmRsZURhdGFSZXF1ZXN0KSB7XG4gICAgICAgIHJlc3BvbnNlID0gYXdhaXQgX2J1aWxkLmVudHJ5Lm1vZHVsZS5oYW5kbGVEYXRhUmVxdWVzdChyZXNwb25zZSwge1xuICAgICAgICAgIGNvbnRleHQ6IGxvYWRDb250ZXh0LFxuICAgICAgICAgIHBhcmFtczogc2luZ2xlRmV0Y2hNYXRjaGVzID8gc2luZ2xlRmV0Y2hNYXRjaGVzWzBdLnBhcmFtcyA6IHt9LFxuICAgICAgICAgIHJlcXVlc3RcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc1JlZGlyZWN0UmVzcG9uc2UocmVzcG9uc2UpKSB7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGdldFNpbmdsZUZldGNoUmVkaXJlY3QoXG4gICAgICAgICAgICByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgX2J1aWxkLmJhc2VuYW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09IFwiR0VUXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgW1NpbmdsZUZldGNoUmVkaXJlY3RTeW1ib2xdOiByZXN1bHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnMocmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICAgICAgaGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJ0ZXh0L3gtc2NyaXB0XCIpO1xuICAgICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoXG4gICAgICAgICAgICBlbmNvZGVWaWFUdXJib1N0cmVhbShcbiAgICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgICByZXF1ZXN0LnNpZ25hbCxcbiAgICAgICAgICAgICAgX2J1aWxkLmVudHJ5Lm1vZHVsZS5zdHJlYW1UaW1lb3V0LFxuICAgICAgICAgICAgICBzZXJ2ZXJNb2RlXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzdGF0dXM6IFNJTkdMRV9GRVRDSF9SRURJUkVDVF9TVEFUVVMsXG4gICAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNTcGFNb2RlICYmIG1hdGNoZXMgJiYgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLm1vZHVsZS5kZWZhdWx0ID09IG51bGwgJiYgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLm1vZHVsZS5FcnJvckJvdW5kYXJ5ID09IG51bGwpIHtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlUmVzb3VyY2VSZXF1ZXN0KFxuICAgICAgICBzZXJ2ZXJNb2RlLFxuICAgICAgICBfYnVpbGQsXG4gICAgICAgIHN0YXRpY0hhbmRsZXIsXG4gICAgICAgIG1hdGNoZXMuc2xpY2UoLTEpWzBdLnJvdXRlLmlkLFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBsb2FkQ29udGV4dCxcbiAgICAgICAgaGFuZGxlRXJyb3JcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB7IHBhdGhuYW1lIH0gPSB1cmw7XG4gICAgICBsZXQgY3JpdGljYWxDc3MgPSB2b2lkIDA7XG4gICAgICBpZiAoX2J1aWxkLnVuc3RhYmxlX2dldENyaXRpY2FsQ3NzKSB7XG4gICAgICAgIGNyaXRpY2FsQ3NzID0gYXdhaXQgX2J1aWxkLnVuc3RhYmxlX2dldENyaXRpY2FsQ3NzKHsgcGF0aG5hbWUgfSk7XG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09IFwiZGV2ZWxvcG1lbnRcIiAvKiBEZXZlbG9wbWVudCAqLyAmJiBnZXREZXZTZXJ2ZXJIb29rcygpPy5nZXRDcml0aWNhbENzcykge1xuICAgICAgICBjcml0aWNhbENzcyA9IGF3YWl0IGdldERldlNlcnZlckhvb2tzKCk/LmdldENyaXRpY2FsQ3NzPy4ocGF0aG5hbWUpO1xuICAgICAgfVxuICAgICAgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVEb2N1bWVudFJlcXVlc3QoXG4gICAgICAgIHNlcnZlck1vZGUsXG4gICAgICAgIF9idWlsZCxcbiAgICAgICAgc3RhdGljSGFuZGxlcixcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgbG9hZENvbnRleHQsXG4gICAgICAgIGhhbmRsZUVycm9yLFxuICAgICAgICBpc1NwYU1vZGUsXG4gICAgICAgIGNyaXRpY2FsQ3NzXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09IFwiSEVBRFwiKSB7XG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH07XG59O1xuYXN5bmMgZnVuY3Rpb24gaGFuZGxlTWFuaWZlc3RSZXF1ZXN0KGJ1aWxkLCByb3V0ZXMsIHVybCkge1xuICBpZiAoYnVpbGQuYXNzZXRzLnZlcnNpb24gIT09IHVybC5zZWFyY2hQYXJhbXMuZ2V0KFwidmVyc2lvblwiKSkge1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiWC1SZW1peC1SZWxvYWQtRG9jdW1lbnRcIjogXCJ0cnVlXCJcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBsZXQgcGF0Y2hlcyA9IHt9O1xuICBpZiAodXJsLnNlYXJjaFBhcmFtcy5oYXMoXCJwXCIpKSB7XG4gICAgbGV0IHBhdGhzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmdldEFsbChcInBcIikuZm9yRWFjaCgocGF0aCkgPT4ge1xuICAgICAgaWYgKCFwYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgIHBhdGggPSBgLyR7cGF0aH1gO1xuICAgICAgfVxuICAgICAgbGV0IHNlZ21lbnRzID0gcGF0aC5zcGxpdChcIi9cIikuc2xpY2UoMSk7XG4gICAgICBzZWdtZW50cy5mb3JFYWNoKChfLCBpKSA9PiB7XG4gICAgICAgIGxldCBwYXJ0aWFsUGF0aCA9IHNlZ21lbnRzLnNsaWNlKDAsIGkgKyAxKS5qb2luKFwiL1wiKTtcbiAgICAgICAgcGF0aHMuYWRkKGAvJHtwYXJ0aWFsUGF0aH1gKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGZvciAobGV0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgIGxldCBtYXRjaGVzID0gbWF0Y2hTZXJ2ZXJSb3V0ZXMocm91dGVzLCBwYXRoLCBidWlsZC5iYXNlbmFtZSk7XG4gICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICBmb3IgKGxldCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgICAgICAgbGV0IHJvdXRlSWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgICAgICAgICBsZXQgcm91dGUgPSBidWlsZC5hc3NldHMucm91dGVzW3JvdXRlSWRdO1xuICAgICAgICAgIGlmIChyb3V0ZSkge1xuICAgICAgICAgICAgcGF0Y2hlc1tyb3V0ZUlkXSA9IHJvdXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUmVzcG9uc2UuanNvbihwYXRjaGVzLCB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ2FjaGUtQ29udHJvbFwiOiBcInB1YmxpYywgbWF4LWFnZT0zMTUzNjAwMCwgaW1tdXRhYmxlXCJcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbmV3IFJlc3BvbnNlKFwiSW52YWxpZCBSZXF1ZXN0XCIsIHsgc3RhdHVzOiA0MDAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBoYW5kbGVTaW5nbGVGZXRjaFJlcXVlc3Qoc2VydmVyTW9kZSwgYnVpbGQsIHN0YXRpY0hhbmRsZXIsIHJlcXVlc3QsIGhhbmRsZXJVcmwsIGxvYWRDb250ZXh0LCBoYW5kbGVFcnJvcikge1xuICBsZXQgcmVzcG9uc2UgPSByZXF1ZXN0Lm1ldGhvZCAhPT0gXCJHRVRcIiA/IGF3YWl0IHNpbmdsZUZldGNoQWN0aW9uKFxuICAgIGJ1aWxkLFxuICAgIHNlcnZlck1vZGUsXG4gICAgc3RhdGljSGFuZGxlcixcbiAgICByZXF1ZXN0LFxuICAgIGhhbmRsZXJVcmwsXG4gICAgbG9hZENvbnRleHQsXG4gICAgaGFuZGxlRXJyb3JcbiAgKSA6IGF3YWl0IHNpbmdsZUZldGNoTG9hZGVycyhcbiAgICBidWlsZCxcbiAgICBzZXJ2ZXJNb2RlLFxuICAgIHN0YXRpY0hhbmRsZXIsXG4gICAgcmVxdWVzdCxcbiAgICBoYW5kbGVyVXJsLFxuICAgIGxvYWRDb250ZXh0LFxuICAgIGhhbmRsZUVycm9yXG4gICk7XG4gIHJldHVybiByZXNwb25zZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZURvY3VtZW50UmVxdWVzdChzZXJ2ZXJNb2RlLCBidWlsZCwgc3RhdGljSGFuZGxlciwgcmVxdWVzdCwgbG9hZENvbnRleHQsIGhhbmRsZUVycm9yLCBpc1NwYU1vZGUsIGNyaXRpY2FsQ3NzKSB7XG4gIHRyeSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgc3RhdGljSGFuZGxlci5xdWVyeShyZXF1ZXN0LCB7XG4gICAgICByZXF1ZXN0Q29udGV4dDogbG9hZENvbnRleHQsXG4gICAgICB1bnN0YWJsZV9yZXNwb25kOiBidWlsZC5mdXR1cmUudW5zdGFibGVfbWlkZGxld2FyZSA/IChjdHgpID0+IHJlbmRlckh0bWwoY3R4LCBpc1NwYU1vZGUpIDogdm9pZCAwXG4gICAgfSk7XG4gICAgcmV0dXJuIGlzUmVzcG9uc2UocmVzcG9uc2UpID8gcmVzcG9uc2UgOiByZW5kZXJIdG1sKHJlc3BvbnNlLCBpc1NwYU1vZGUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGhhbmRsZUVycm9yKGVycm9yKTtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHsgc3RhdHVzOiA1MDAgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcmVuZGVySHRtbChjb250ZXh0LCBpc1NwYU1vZGUyKSB7XG4gICAgaWYgKGlzUmVzcG9uc2UoY29udGV4dCkpIHtcbiAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgICBsZXQgaGVhZGVycyA9IGdldERvY3VtZW50SGVhZGVycyhidWlsZCwgY29udGV4dCk7XG4gICAgaWYgKFNFUlZFUl9OT19CT0RZX1NUQVRVU19DT0RFUy5oYXMoY29udGV4dC5zdGF0dXNDb2RlKSkge1xuICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7IHN0YXR1czogY29udGV4dC5zdGF0dXNDb2RlLCBoZWFkZXJzIH0pO1xuICAgIH1cbiAgICBpZiAoY29udGV4dC5lcnJvcnMpIHtcbiAgICAgIE9iamVjdC52YWx1ZXMoY29udGV4dC5lcnJvcnMpLmZvckVhY2goKGVycikgPT4ge1xuICAgICAgICBpZiAoIWlzUm91dGVFcnJvclJlc3BvbnNlKGVycikgfHwgZXJyLmVycm9yKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb250ZXh0LmVycm9ycyA9IHNhbml0aXplRXJyb3JzKGNvbnRleHQuZXJyb3JzLCBzZXJ2ZXJNb2RlKTtcbiAgICB9XG4gICAgbGV0IHN0YXRlID0ge1xuICAgICAgbG9hZGVyRGF0YTogY29udGV4dC5sb2FkZXJEYXRhLFxuICAgICAgYWN0aW9uRGF0YTogY29udGV4dC5hY3Rpb25EYXRhLFxuICAgICAgZXJyb3JzOiBzZXJpYWxpemVFcnJvcnMyKGNvbnRleHQuZXJyb3JzLCBzZXJ2ZXJNb2RlKVxuICAgIH07XG4gICAgbGV0IGJhc2VTZXJ2ZXJIYW5kb2ZmID0ge1xuICAgICAgYmFzZW5hbWU6IGJ1aWxkLmJhc2VuYW1lLFxuICAgICAgZnV0dXJlOiBidWlsZC5mdXR1cmUsXG4gICAgICByb3V0ZURpc2NvdmVyeTogYnVpbGQucm91dGVEaXNjb3ZlcnksXG4gICAgICBzc3I6IGJ1aWxkLnNzcixcbiAgICAgIGlzU3BhTW9kZTogaXNTcGFNb2RlMlxuICAgIH07XG4gICAgbGV0IGVudHJ5Q29udGV4dCA9IHtcbiAgICAgIG1hbmlmZXN0OiBidWlsZC5hc3NldHMsXG4gICAgICByb3V0ZU1vZHVsZXM6IGNyZWF0ZUVudHJ5Um91dGVNb2R1bGVzKGJ1aWxkLnJvdXRlcyksXG4gICAgICBzdGF0aWNIYW5kbGVyQ29udGV4dDogY29udGV4dCxcbiAgICAgIGNyaXRpY2FsQ3NzLFxuICAgICAgc2VydmVySGFuZG9mZlN0cmluZzogY3JlYXRlU2VydmVySGFuZG9mZlN0cmluZyh7XG4gICAgICAgIC4uLmJhc2VTZXJ2ZXJIYW5kb2ZmLFxuICAgICAgICBjcml0aWNhbENzc1xuICAgICAgfSksXG4gICAgICBzZXJ2ZXJIYW5kb2ZmU3RyZWFtOiBlbmNvZGVWaWFUdXJib1N0cmVhbShcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHJlcXVlc3Quc2lnbmFsLFxuICAgICAgICBidWlsZC5lbnRyeS5tb2R1bGUuc3RyZWFtVGltZW91dCxcbiAgICAgICAgc2VydmVyTW9kZVxuICAgICAgKSxcbiAgICAgIHJlbmRlck1ldGE6IHt9LFxuICAgICAgZnV0dXJlOiBidWlsZC5mdXR1cmUsXG4gICAgICBzc3I6IGJ1aWxkLnNzcixcbiAgICAgIHJvdXRlRGlzY292ZXJ5OiBidWlsZC5yb3V0ZURpc2NvdmVyeSxcbiAgICAgIGlzU3BhTW9kZTogaXNTcGFNb2RlMixcbiAgICAgIHNlcmlhbGl6ZUVycm9yOiAoZXJyKSA9PiBzZXJpYWxpemVFcnJvcihlcnIsIHNlcnZlck1vZGUpXG4gICAgfTtcbiAgICBsZXQgaGFuZGxlRG9jdW1lbnRSZXF1ZXN0RnVuY3Rpb24gPSBidWlsZC5lbnRyeS5tb2R1bGUuZGVmYXVsdDtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGhhbmRsZURvY3VtZW50UmVxdWVzdEZ1bmN0aW9uKFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBjb250ZXh0LnN0YXR1c0NvZGUsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGVudHJ5Q29udGV4dCxcbiAgICAgICAgbG9hZENvbnRleHRcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgIGxldCBlcnJvckZvclNlY29uZFJlbmRlciA9IGVycm9yO1xuICAgICAgaWYgKGlzUmVzcG9uc2UoZXJyb3IpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IGRhdGEyID0gYXdhaXQgdW53cmFwUmVzcG9uc2UoZXJyb3IpO1xuICAgICAgICAgIGVycm9yRm9yU2Vjb25kUmVuZGVyID0gbmV3IEVycm9yUmVzcG9uc2VJbXBsKFxuICAgICAgICAgICAgZXJyb3Iuc3RhdHVzLFxuICAgICAgICAgICAgZXJyb3Iuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIGRhdGEyXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb250ZXh0ID0gZ2V0U3RhdGljQ29udGV4dEZyb21FcnJvcihcbiAgICAgICAgc3RhdGljSGFuZGxlci5kYXRhUm91dGVzLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBlcnJvckZvclNlY29uZFJlbmRlclxuICAgICAgKTtcbiAgICAgIGlmIChjb250ZXh0LmVycm9ycykge1xuICAgICAgICBjb250ZXh0LmVycm9ycyA9IHNhbml0aXplRXJyb3JzKGNvbnRleHQuZXJyb3JzLCBzZXJ2ZXJNb2RlKTtcbiAgICAgIH1cbiAgICAgIGxldCBzdGF0ZTIgPSB7XG4gICAgICAgIGxvYWRlckRhdGE6IGNvbnRleHQubG9hZGVyRGF0YSxcbiAgICAgICAgYWN0aW9uRGF0YTogY29udGV4dC5hY3Rpb25EYXRhLFxuICAgICAgICBlcnJvcnM6IHNlcmlhbGl6ZUVycm9yczIoY29udGV4dC5lcnJvcnMsIHNlcnZlck1vZGUpXG4gICAgICB9O1xuICAgICAgZW50cnlDb250ZXh0ID0ge1xuICAgICAgICAuLi5lbnRyeUNvbnRleHQsXG4gICAgICAgIHN0YXRpY0hhbmRsZXJDb250ZXh0OiBjb250ZXh0LFxuICAgICAgICBzZXJ2ZXJIYW5kb2ZmU3RyaW5nOiBjcmVhdGVTZXJ2ZXJIYW5kb2ZmU3RyaW5nKGJhc2VTZXJ2ZXJIYW5kb2ZmKSxcbiAgICAgICAgc2VydmVySGFuZG9mZlN0cmVhbTogZW5jb2RlVmlhVHVyYm9TdHJlYW0oXG4gICAgICAgICAgc3RhdGUyLFxuICAgICAgICAgIHJlcXVlc3Quc2lnbmFsLFxuICAgICAgICAgIGJ1aWxkLmVudHJ5Lm1vZHVsZS5zdHJlYW1UaW1lb3V0LFxuICAgICAgICAgIHNlcnZlck1vZGVcbiAgICAgICAgKSxcbiAgICAgICAgcmVuZGVyTWV0YToge31cbiAgICAgIH07XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgaGFuZGxlRG9jdW1lbnRSZXF1ZXN0RnVuY3Rpb24oXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBjb250ZXh0LnN0YXR1c0NvZGUsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBlbnRyeUNvbnRleHQsXG4gICAgICAgICAgbG9hZENvbnRleHRcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgICBoYW5kbGVFcnJvcihlcnJvcjIpO1xuICAgICAgICByZXR1cm4gcmV0dXJuTGFzdFJlc29ydEVycm9yUmVzcG9uc2UoZXJyb3IyLCBzZXJ2ZXJNb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVJlc291cmNlUmVxdWVzdChzZXJ2ZXJNb2RlLCBidWlsZCwgc3RhdGljSGFuZGxlciwgcm91dGVJZCwgcmVxdWVzdCwgbG9hZENvbnRleHQsIGhhbmRsZUVycm9yKSB7XG4gIHRyeSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgc3RhdGljSGFuZGxlci5xdWVyeVJvdXRlKHJlcXVlc3QsIHtcbiAgICAgIHJvdXRlSWQsXG4gICAgICByZXF1ZXN0Q29udGV4dDogbG9hZENvbnRleHQsXG4gICAgICB1bnN0YWJsZV9yZXNwb25kOiBidWlsZC5mdXR1cmUudW5zdGFibGVfbWlkZGxld2FyZSA/IChjdHgpID0+IGN0eCA6IHZvaWQgMFxuICAgIH0pO1xuICAgIGlmIChpc1Jlc3BvbnNlKHJlc3BvbnNlKSkge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlc3BvbnNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIFJlc3BvbnNlLmpzb24ocmVzcG9uc2UpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChpc1Jlc3BvbnNlKGVycm9yKSkge1xuICAgICAgZXJyb3IuaGVhZGVycy5zZXQoXCJYLVJlbWl4LUNhdGNoXCIsIFwieWVzXCIpO1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICBpZiAoaXNSb3V0ZUVycm9yUmVzcG9uc2UoZXJyb3IpKSB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVycm9yUmVzcG9uc2VUb0pzb24oZXJyb3IsIHNlcnZlck1vZGUpO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5tZXNzYWdlID09PSBcIkV4cGVjdGVkIGEgcmVzcG9uc2UgZnJvbSBxdWVyeVJvdXRlXCIpIHtcbiAgICAgIGxldCBuZXdFcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgXCJFeHBlY3RlZCBhIFJlc3BvbnNlIHRvIGJlIHJldHVybmVkIGZyb20gcmVzb3VyY2Ugcm91dGUgaGFuZGxlclwiXG4gICAgICApO1xuICAgICAgaGFuZGxlRXJyb3IobmV3RXJyb3IpO1xuICAgICAgcmV0dXJuIHJldHVybkxhc3RSZXNvcnRFcnJvclJlc3BvbnNlKG5ld0Vycm9yLCBzZXJ2ZXJNb2RlKTtcbiAgICB9XG4gICAgaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiByZXR1cm5MYXN0UmVzb3J0RXJyb3JSZXNwb25zZShlcnJvciwgc2VydmVyTW9kZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9yUmVzcG9uc2VUb0pzb24oZXJyb3JSZXNwb25zZSwgc2VydmVyTW9kZSkge1xuICByZXR1cm4gUmVzcG9uc2UuanNvbihcbiAgICBzZXJpYWxpemVFcnJvcihcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVGhpcyBpcyBcInByaXZhdGVcIiBmcm9tIHVzZXJzIGJ1dCBpbnRlbmRlZCBmb3IgaW50ZXJuYWwgdXNlXG4gICAgICBlcnJvclJlc3BvbnNlLmVycm9yIHx8IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgU2VydmVyIEVycm9yXCIpLFxuICAgICAgc2VydmVyTW9kZVxuICAgICksXG4gICAge1xuICAgICAgc3RhdHVzOiBlcnJvclJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IGVycm9yUmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJYLVJlbWl4LUVycm9yXCI6IFwieWVzXCJcbiAgICAgIH1cbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiByZXR1cm5MYXN0UmVzb3J0RXJyb3JSZXNwb25zZShlcnJvciwgc2VydmVyTW9kZSkge1xuICBsZXQgbWVzc2FnZSA9IFwiVW5leHBlY3RlZCBTZXJ2ZXIgRXJyb3JcIjtcbiAgaWYgKHNlcnZlck1vZGUgIT09IFwicHJvZHVjdGlvblwiIC8qIFByb2R1Y3Rpb24gKi8pIHtcbiAgICBtZXNzYWdlICs9IGBcblxuJHtTdHJpbmcoZXJyb3IpfWA7XG4gIH1cbiAgcmV0dXJuIG5ldyBSZXNwb25zZShtZXNzYWdlLCB7XG4gICAgc3RhdHVzOiA1MDAsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3BsYWluXCJcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gdW53cmFwUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgbGV0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIik7XG4gIHJldHVybiBjb250ZW50VHlwZSAmJiAvXFxiYXBwbGljYXRpb25cXC9qc29uXFxiLy50ZXN0KGNvbnRlbnRUeXBlKSA/IHJlc3BvbnNlLmJvZHkgPT0gbnVsbCA/IG51bGwgOiByZXNwb25zZS5qc29uKCkgOiByZXNwb25zZS50ZXh0KCk7XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9zZXNzaW9ucy50c1xuZnVuY3Rpb24gZmxhc2gobmFtZSkge1xuICByZXR1cm4gYF9fZmxhc2hfJHtuYW1lfV9fYDtcbn1cbnZhciBjcmVhdGVTZXNzaW9uID0gKGluaXRpYWxEYXRhID0ge30sIGlkID0gXCJcIikgPT4ge1xuICBsZXQgbWFwID0gbmV3IE1hcChPYmplY3QuZW50cmllcyhpbml0aWFsRGF0YSkpO1xuICByZXR1cm4ge1xuICAgIGdldCBpZCgpIHtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9LFxuICAgIGdldCBkYXRhKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhtYXApO1xuICAgIH0sXG4gICAgaGFzKG5hbWUpIHtcbiAgICAgIHJldHVybiBtYXAuaGFzKG5hbWUpIHx8IG1hcC5oYXMoZmxhc2gobmFtZSkpO1xuICAgIH0sXG4gICAgZ2V0KG5hbWUpIHtcbiAgICAgIGlmIChtYXAuaGFzKG5hbWUpKSByZXR1cm4gbWFwLmdldChuYW1lKTtcbiAgICAgIGxldCBmbGFzaE5hbWUgPSBmbGFzaChuYW1lKTtcbiAgICAgIGlmIChtYXAuaGFzKGZsYXNoTmFtZSkpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gbWFwLmdldChmbGFzaE5hbWUpO1xuICAgICAgICBtYXAuZGVsZXRlKGZsYXNoTmFtZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfSxcbiAgICBzZXQobmFtZSwgdmFsdWUpIHtcbiAgICAgIG1hcC5zZXQobmFtZSwgdmFsdWUpO1xuICAgIH0sXG4gICAgZmxhc2gobmFtZSwgdmFsdWUpIHtcbiAgICAgIG1hcC5zZXQoZmxhc2gobmFtZSksIHZhbHVlKTtcbiAgICB9LFxuICAgIHVuc2V0KG5hbWUpIHtcbiAgICAgIG1hcC5kZWxldGUobmFtZSk7XG4gICAgfVxuICB9O1xufTtcbnZhciBpc1Nlc3Npb24gPSAob2JqZWN0KSA9PiB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0LmlkID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBvYmplY3QuZGF0YSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygb2JqZWN0LmhhcyA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmplY3QuZ2V0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG9iamVjdC5zZXQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqZWN0LmZsYXNoID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG9iamVjdC51bnNldCA9PT0gXCJmdW5jdGlvblwiO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZVNlc3Npb25TdG9yYWdlKHtcbiAgY29va2llOiBjb29raWVBcmcsXG4gIGNyZWF0ZURhdGEsXG4gIHJlYWREYXRhLFxuICB1cGRhdGVEYXRhLFxuICBkZWxldGVEYXRhXG59KSB7XG4gIGxldCBjb29raWUgPSBpc0Nvb2tpZShjb29raWVBcmcpID8gY29va2llQXJnIDogY3JlYXRlQ29va2llKGNvb2tpZUFyZz8ubmFtZSB8fCBcIl9fc2Vzc2lvblwiLCBjb29raWVBcmcpO1xuICB3YXJuT25jZUFib3V0U2lnbmluZ1Nlc3Npb25Db29raWUoY29va2llKTtcbiAgcmV0dXJuIHtcbiAgICBhc3luYyBnZXRTZXNzaW9uKGNvb2tpZUhlYWRlciwgb3B0aW9ucykge1xuICAgICAgbGV0IGlkID0gY29va2llSGVhZGVyICYmIGF3YWl0IGNvb2tpZS5wYXJzZShjb29raWVIZWFkZXIsIG9wdGlvbnMpO1xuICAgICAgbGV0IGRhdGEyID0gaWQgJiYgYXdhaXQgcmVhZERhdGEoaWQpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVNlc3Npb24oZGF0YTIgfHwge30sIGlkIHx8IFwiXCIpO1xuICAgIH0sXG4gICAgYXN5bmMgY29tbWl0U2Vzc2lvbihzZXNzaW9uLCBvcHRpb25zKSB7XG4gICAgICBsZXQgeyBpZCwgZGF0YTogZGF0YTIgfSA9IHNlc3Npb247XG4gICAgICBsZXQgZXhwaXJlcyA9IG9wdGlvbnM/Lm1heEFnZSAhPSBudWxsID8gbmV3IERhdGUoRGF0ZS5ub3coKSArIG9wdGlvbnMubWF4QWdlICogMWUzKSA6IG9wdGlvbnM/LmV4cGlyZXMgIT0gbnVsbCA/IG9wdGlvbnMuZXhwaXJlcyA6IGNvb2tpZS5leHBpcmVzO1xuICAgICAgaWYgKGlkKSB7XG4gICAgICAgIGF3YWl0IHVwZGF0ZURhdGEoaWQsIGRhdGEyLCBleHBpcmVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkID0gYXdhaXQgY3JlYXRlRGF0YShkYXRhMiwgZXhwaXJlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29va2llLnNlcmlhbGl6ZShpZCwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBhc3luYyBkZXN0cm95U2Vzc2lvbihzZXNzaW9uLCBvcHRpb25zKSB7XG4gICAgICBhd2FpdCBkZWxldGVEYXRhKHNlc3Npb24uaWQpO1xuICAgICAgcmV0dXJuIGNvb2tpZS5zZXJpYWxpemUoXCJcIiwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBtYXhBZ2U6IHZvaWQgMCxcbiAgICAgICAgZXhwaXJlczogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKDApXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB3YXJuT25jZUFib3V0U2lnbmluZ1Nlc3Npb25Db29raWUoY29va2llKSB7XG4gIHdhcm5PbmNlKFxuICAgIGNvb2tpZS5pc1NpZ25lZCxcbiAgICBgVGhlIFwiJHtjb29raWUubmFtZX1cIiBjb29raWUgaXMgbm90IHNpZ25lZCwgYnV0IHNlc3Npb24gY29va2llcyBzaG91bGQgYmUgc2lnbmVkIHRvIHByZXZlbnQgdGFtcGVyaW5nIG9uIHRoZSBjbGllbnQgYmVmb3JlIHRoZXkgYXJlIHNlbnQgYmFjayB0byB0aGUgc2VydmVyLiBTZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZXhwbGFuYXRpb24vc2Vzc2lvbnMtYW5kLWNvb2tpZXMjc2lnbmluZy1jb29raWVzIGZvciBtb3JlIGluZm9ybWF0aW9uLmBcbiAgKTtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL3Nlc3Npb25zL2Nvb2tpZVN0b3JhZ2UudHNcbmZ1bmN0aW9uIGNyZWF0ZUNvb2tpZVNlc3Npb25TdG9yYWdlKHsgY29va2llOiBjb29raWVBcmcgfSA9IHt9KSB7XG4gIGxldCBjb29raWUgPSBpc0Nvb2tpZShjb29raWVBcmcpID8gY29va2llQXJnIDogY3JlYXRlQ29va2llKGNvb2tpZUFyZz8ubmFtZSB8fCBcIl9fc2Vzc2lvblwiLCBjb29raWVBcmcpO1xuICB3YXJuT25jZUFib3V0U2lnbmluZ1Nlc3Npb25Db29raWUoY29va2llKTtcbiAgcmV0dXJuIHtcbiAgICBhc3luYyBnZXRTZXNzaW9uKGNvb2tpZUhlYWRlciwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVNlc3Npb24oXG4gICAgICAgIGNvb2tpZUhlYWRlciAmJiBhd2FpdCBjb29raWUucGFyc2UoY29va2llSGVhZGVyLCBvcHRpb25zKSB8fCB7fVxuICAgICAgKTtcbiAgICB9LFxuICAgIGFzeW5jIGNvbW1pdFNlc3Npb24oc2Vzc2lvbiwgb3B0aW9ucykge1xuICAgICAgbGV0IHNlcmlhbGl6ZWRDb29raWUgPSBhd2FpdCBjb29raWUuc2VyaWFsaXplKHNlc3Npb24uZGF0YSwgb3B0aW9ucyk7XG4gICAgICBpZiAoc2VyaWFsaXplZENvb2tpZS5sZW5ndGggPiA0MDk2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkNvb2tpZSBsZW5ndGggd2lsbCBleGNlZWQgYnJvd3NlciBtYXhpbXVtLiBMZW5ndGg6IFwiICsgc2VyaWFsaXplZENvb2tpZS5sZW5ndGhcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXJpYWxpemVkQ29va2llO1xuICAgIH0sXG4gICAgYXN5bmMgZGVzdHJveVNlc3Npb24oX3Nlc3Npb24sIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBjb29raWUuc2VyaWFsaXplKFwiXCIsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgbWF4QWdlOiB2b2lkIDAsXG4gICAgICAgIGV4cGlyZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgwKVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvc2Vzc2lvbnMvbWVtb3J5U3RvcmFnZS50c1xuZnVuY3Rpb24gY3JlYXRlTWVtb3J5U2Vzc2lvblN0b3JhZ2UoeyBjb29raWUgfSA9IHt9KSB7XG4gIGxldCBtYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICByZXR1cm4gY3JlYXRlU2Vzc2lvblN0b3JhZ2Uoe1xuICAgIGNvb2tpZSxcbiAgICBhc3luYyBjcmVhdGVEYXRhKGRhdGEyLCBleHBpcmVzKSB7XG4gICAgICBsZXQgaWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTApO1xuICAgICAgbWFwLnNldChpZCwgeyBkYXRhOiBkYXRhMiwgZXhwaXJlcyB9KTtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9LFxuICAgIGFzeW5jIHJlYWREYXRhKGlkKSB7XG4gICAgICBpZiAobWFwLmhhcyhpZCkpIHtcbiAgICAgICAgbGV0IHsgZGF0YTogZGF0YTIsIGV4cGlyZXMgfSA9IG1hcC5nZXQoaWQpO1xuICAgICAgICBpZiAoIWV4cGlyZXMgfHwgZXhwaXJlcyA+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGEyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBpcmVzKSBtYXAuZGVsZXRlKGlkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgYXN5bmMgdXBkYXRlRGF0YShpZCwgZGF0YTIsIGV4cGlyZXMpIHtcbiAgICAgIG1hcC5zZXQoaWQsIHsgZGF0YTogZGF0YTIsIGV4cGlyZXMgfSk7XG4gICAgfSxcbiAgICBhc3luYyBkZWxldGVEYXRhKGlkKSB7XG4gICAgICBtYXAuZGVsZXRlKGlkKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBsaWIvaHJlZi50c1xuZnVuY3Rpb24gaHJlZihwYXRoLCAuLi5hcmdzKSB7XG4gIGxldCBwYXJhbXMgPSBhcmdzWzBdO1xuICByZXR1cm4gcGF0aC5zcGxpdChcIi9cIikubWFwKChzZWdtZW50KSA9PiB7XG4gICAgaWYgKHNlZ21lbnQgPT09IFwiKlwiKSB7XG4gICAgICByZXR1cm4gcGFyYW1zID8gcGFyYW1zW1wiKlwiXSA6IHZvaWQgMDtcbiAgICB9XG4gICAgY29uc3QgbWF0Y2ggPSBzZWdtZW50Lm1hdGNoKC9eOihbXFx3LV0rKShcXD8pPy8pO1xuICAgIGlmICghbWF0Y2gpIHJldHVybiBzZWdtZW50O1xuICAgIGNvbnN0IHBhcmFtID0gbWF0Y2hbMV07XG4gICAgY29uc3QgdmFsdWUgPSBwYXJhbXMgPyBwYXJhbXNbcGFyYW1dIDogdm9pZCAwO1xuICAgIGNvbnN0IGlzUmVxdWlyZWQgPSBtYXRjaFsyXSA9PT0gdm9pZCAwO1xuICAgIGlmIChpc1JlcXVpcmVkICYmIHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBgUGF0aCAnJHtwYXRofScgcmVxdWlyZXMgcGFyYW0gJyR7cGFyYW19JyBidXQgaXQgd2FzIG5vdCBwcm92aWRlZGBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSkuZmlsdGVyKChzZWdtZW50KSA9PiBzZWdtZW50ICE9PSB2b2lkIDApLmpvaW4oXCIvXCIpO1xufVxuXG4vLyBsaWIvZG9tL3Nzci9lcnJvcnMudHNcbmZ1bmN0aW9uIGRlc2VyaWFsaXplRXJyb3JzMihlcnJvcnMpIHtcbiAgaWYgKCFlcnJvcnMpIHJldHVybiBudWxsO1xuICBsZXQgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGVycm9ycyk7XG4gIGxldCBzZXJpYWxpemVkID0ge307XG4gIGZvciAobGV0IFtrZXksIHZhbF0gb2YgZW50cmllcykge1xuICAgIGlmICh2YWwgJiYgdmFsLl9fdHlwZSA9PT0gXCJSb3V0ZUVycm9yUmVzcG9uc2VcIikge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0gbmV3IEVycm9yUmVzcG9uc2VJbXBsKFxuICAgICAgICB2YWwuc3RhdHVzLFxuICAgICAgICB2YWwuc3RhdHVzVGV4dCxcbiAgICAgICAgdmFsLmRhdGEsXG4gICAgICAgIHZhbC5pbnRlcm5hbCA9PT0gdHJ1ZVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHZhbCAmJiB2YWwuX190eXBlID09PSBcIkVycm9yXCIpIHtcbiAgICAgIGlmICh2YWwuX19zdWJUeXBlKSB7XG4gICAgICAgIGxldCBFcnJvckNvbnN0cnVjdG9yID0gd2luZG93W3ZhbC5fX3N1YlR5cGVdO1xuICAgICAgICBpZiAodHlwZW9mIEVycm9yQ29uc3RydWN0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3JDb25zdHJ1Y3Rvcih2YWwubWVzc2FnZSk7XG4gICAgICAgICAgICBlcnJvci5zdGFjayA9IHZhbC5zdGFjaztcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IGVycm9yO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzZXJpYWxpemVkW2tleV0gPT0gbnVsbCkge1xuICAgICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3IodmFsLm1lc3NhZ2UpO1xuICAgICAgICBlcnJvci5zdGFjayA9IHZhbC5zdGFjaztcbiAgICAgICAgc2VyaWFsaXplZFtrZXldID0gZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59XG5cbi8vIGxpYi9kb20vc3NyL2h5ZHJhdGlvbi50c3hcbmZ1bmN0aW9uIGdldEh5ZHJhdGlvbkRhdGEoc3RhdGUsIHJvdXRlcywgZ2V0Um91dGVJbmZvLCBsb2NhdGlvbiwgYmFzZW5hbWUsIGlzU3BhTW9kZSkge1xuICBsZXQgaHlkcmF0aW9uRGF0YSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBsb2FkZXJEYXRhOiB7IC4uLnN0YXRlLmxvYWRlckRhdGEgfVxuICB9O1xuICBsZXQgaW5pdGlhbE1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uLCBiYXNlbmFtZSk7XG4gIGlmIChpbml0aWFsTWF0Y2hlcykge1xuICAgIGZvciAobGV0IG1hdGNoIG9mIGluaXRpYWxNYXRjaGVzKSB7XG4gICAgICBsZXQgcm91dGVJZCA9IG1hdGNoLnJvdXRlLmlkO1xuICAgICAgbGV0IHJvdXRlSW5mbyA9IGdldFJvdXRlSW5mbyhyb3V0ZUlkKTtcbiAgICAgIGlmIChzaG91bGRIeWRyYXRlUm91dGVMb2FkZXIoXG4gICAgICAgIHJvdXRlSWQsXG4gICAgICAgIHJvdXRlSW5mby5jbGllbnRMb2FkZXIsXG4gICAgICAgIHJvdXRlSW5mby5oYXNMb2FkZXIsXG4gICAgICAgIGlzU3BhTW9kZVxuICAgICAgKSAmJiAocm91dGVJbmZvLmhhc0h5ZHJhdGVGYWxsYmFjayB8fCAhcm91dGVJbmZvLmhhc0xvYWRlcikpIHtcbiAgICAgICAgZGVsZXRlIGh5ZHJhdGlvbkRhdGEubG9hZGVyRGF0YVtyb3V0ZUlkXTtcbiAgICAgIH0gZWxzZSBpZiAoIXJvdXRlSW5mby5oYXNMb2FkZXIpIHtcbiAgICAgICAgaHlkcmF0aW9uRGF0YS5sb2FkZXJEYXRhW3JvdXRlSWRdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGh5ZHJhdGlvbkRhdGE7XG59XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgQXdhaXQsXG4gIEJyb3dzZXJSb3V0ZXIsXG4gIEZvcm0sXG4gIEhhc2hSb3V0ZXIsXG4gIElETEVfQkxPQ0tFUixcbiAgSURMRV9GRVRDSEVSLFxuICBJRExFX05BVklHQVRJT04sXG4gIExpbmssXG4gIExpbmtzLFxuICBNZW1vcnlSb3V0ZXIsXG4gIE1ldGEsXG4gIE5hdkxpbmssXG4gIE5hdmlnYXRlLFxuICBOYXZpZ2F0aW9uVHlwZSxcbiAgT3V0bGV0LFxuICBQcmVmZXRjaFBhZ2VMaW5rcyxcbiAgUm91dGUsXG4gIFJvdXRlcixcbiAgUm91dGVyUHJvdmlkZXIsXG4gIFJvdXRlcyxcbiAgU2NyaXB0cyxcbiAgU2Nyb2xsUmVzdG9yYXRpb24sXG4gIFNlcnZlclJvdXRlcixcbiAgU3RhdGljUm91dGVyLFxuICBTdGF0aWNSb3V0ZXJQcm92aWRlcixcbiAgVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0LFxuICBVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCxcbiAgVU5TQUZFX0Vycm9yUmVzcG9uc2VJbXBsLFxuICBVTlNBRkVfRmV0Y2hlcnNDb250ZXh0LFxuICBVTlNBRkVfRnJhbWV3b3JrQ29udGV4dCxcbiAgVU5TQUZFX0xvY2F0aW9uQ29udGV4dCxcbiAgVU5TQUZFX05hdmlnYXRpb25Db250ZXh0LFxuICBVTlNBRkVfUmVtaXhFcnJvckJvdW5kYXJ5LFxuICBVTlNBRkVfUm91dGVDb250ZXh0LFxuICBVTlNBRkVfU2VydmVyTW9kZSxcbiAgVU5TQUZFX1NpbmdsZUZldGNoUmVkaXJlY3RTeW1ib2wsXG4gIFVOU0FGRV9WaWV3VHJhbnNpdGlvbkNvbnRleHQsXG4gIFVOU0FGRV9jcmVhdGVCcm93c2VySGlzdG9yeSxcbiAgVU5TQUZFX2NyZWF0ZUNsaWVudFJvdXRlcyxcbiAgVU5TQUZFX2NyZWF0ZUNsaWVudFJvdXRlc1dpdGhITVJSZXZhbGlkYXRpb25PcHRPdXQsXG4gIFVOU0FGRV9jcmVhdGVSb3V0ZXIsXG4gIFVOU0FGRV9kZWNvZGVWaWFUdXJib1N0cmVhbSxcbiAgVU5TQUZFX2Rlc2VyaWFsaXplRXJyb3JzLFxuICBVTlNBRkVfZ2V0SHlkcmF0aW9uRGF0YSxcbiAgVU5TQUZFX2dldFBhdGNoUm91dGVzT25OYXZpZ2F0aW9uRnVuY3Rpb24sXG4gIFVOU0FGRV9nZXRUdXJib1N0cmVhbVNpbmdsZUZldGNoRGF0YVN0cmF0ZWd5LFxuICBVTlNBRkVfaHlkcmF0aW9uUm91dGVQcm9wZXJ0aWVzLFxuICBVTlNBRkVfaW52YXJpYW50LFxuICBVTlNBRkVfbWFwUm91dGVQcm9wZXJ0aWVzLFxuICBVTlNBRkVfc2hvdWxkSHlkcmF0ZVJvdXRlTG9hZGVyLFxuICBVTlNBRkVfdXNlRm9nT0ZXYXJEaXNjb3ZlcnksXG4gIFVOU0FGRV91c2VTY3JvbGxSZXN0b3JhdGlvbixcbiAgVU5TQUZFX3dpdGhDb21wb25lbnRQcm9wcyxcbiAgVU5TQUZFX3dpdGhFcnJvckJvdW5kYXJ5UHJvcHMsXG4gIFVOU0FGRV93aXRoSHlkcmF0ZUZhbGxiYWNrUHJvcHMsXG4gIGNyZWF0ZUJyb3dzZXJSb3V0ZXIsXG4gIGNyZWF0ZUNvb2tpZSxcbiAgY3JlYXRlQ29va2llU2Vzc2lvblN0b3JhZ2UsXG4gIGNyZWF0ZUhhc2hSb3V0ZXIsXG4gIGNyZWF0ZU1lbW9yeVJvdXRlcixcbiAgY3JlYXRlTWVtb3J5U2Vzc2lvblN0b3JhZ2UsXG4gIGNyZWF0ZVBhdGgsXG4gIGNyZWF0ZVJlcXVlc3RIYW5kbGVyLFxuICBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4sXG4gIGNyZWF0ZVJvdXRlc0Zyb21FbGVtZW50cyxcbiAgY3JlYXRlUm91dGVzU3R1YixcbiAgY3JlYXRlU2VhcmNoUGFyYW1zLFxuICBjcmVhdGVTZXNzaW9uLFxuICBjcmVhdGVTZXNzaW9uU3RvcmFnZSxcbiAgY3JlYXRlU3RhdGljSGFuZGxlcixcbiAgY3JlYXRlU3RhdGljUm91dGVyLFxuICBkYXRhLFxuICBnZW5lcmF0ZVBhdGgsXG4gIGhyZWYsXG4gIGlzQ29va2llLFxuICBpc1JvdXRlRXJyb3JSZXNwb25zZSxcbiAgaXNTZXNzaW9uLFxuICBtYXRjaFBhdGgsXG4gIG1hdGNoUm91dGVzLFxuICBwYXJzZVBhdGgsXG4gIHJlZGlyZWN0LFxuICByZWRpcmVjdERvY3VtZW50LFxuICByZW5kZXJNYXRjaGVzLFxuICByZXBsYWNlLFxuICByZXNvbHZlUGF0aCxcbiAgdW5zdGFibGVfSGlzdG9yeVJvdXRlcixcbiAgdW5zdGFibGVfUm91dGVyQ29udGV4dFByb3ZpZGVyLFxuICB1bnN0YWJsZV9jcmVhdGVDb250ZXh0LFxuICB1bnN0YWJsZV9zZXREZXZTZXJ2ZXJIb29rcyxcbiAgdW5zdGFibGVfdXNlUHJvbXB0LFxuICB1c2VBY3Rpb25EYXRhLFxuICB1c2VBc3luY0Vycm9yLFxuICB1c2VBc3luY1ZhbHVlLFxuICB1c2VCZWZvcmVVbmxvYWQsXG4gIHVzZUJsb2NrZXIsXG4gIHVzZUZldGNoZXIsXG4gIHVzZUZldGNoZXJzLFxuICB1c2VGb3JtQWN0aW9uLFxuICB1c2VIcmVmLFxuICB1c2VJblJvdXRlckNvbnRleHQsXG4gIHVzZUxpbmtDbGlja0hhbmRsZXIsXG4gIHVzZUxvYWRlckRhdGEsXG4gIHVzZUxvY2F0aW9uLFxuICB1c2VNYXRjaCxcbiAgdXNlTWF0Y2hlcyxcbiAgdXNlTmF2aWdhdGUsXG4gIHVzZU5hdmlnYXRpb24sXG4gIHVzZU5hdmlnYXRpb25UeXBlLFxuICB1c2VPdXRsZXQsXG4gIHVzZU91dGxldENvbnRleHQsXG4gIHVzZVBhcmFtcyxcbiAgdXNlUmVzb2x2ZWRQYXRoLFxuICB1c2VSZXZhbGlkYXRvcixcbiAgdXNlUm91dGVFcnJvcixcbiAgdXNlUm91dGVMb2FkZXJEYXRhLFxuICB1c2VSb3V0ZXMsXG4gIHVzZVNlYXJjaFBhcmFtcyxcbiAgdXNlU3VibWl0LFxuICB1c2VWaWV3VHJhbnNpdGlvblN0YXRlXG59KTtcbiJdLCJuYW1lcyI6WyJfX2NyZWF0ZSIsIk9iamVjdCIsImNyZWF0ZSIsIl9fZGVmUHJvcCIsImRlZmluZVByb3BlcnR5IiwiX19nZXRPd25Qcm9wRGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZ2V0T3duUHJvcE5hbWVzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIl9fZ2V0UHJvdG9PZiIsImdldFByb3RvdHlwZU9mIiwiX19oYXNPd25Qcm9wIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJfX3R5cGVFcnJvciIsIm1zZyIsIlR5cGVFcnJvciIsIl9fZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImdldCIsImVudW1lcmFibGUiLCJfX2NvcHlQcm9wcyIsInRvIiwiZnJvbSIsImV4Y2VwdCIsImRlc2MiLCJrZXkiLCJjYWxsIiwiX190b0VTTSIsIm1vZCIsImlzTm9kZU1vZGUiLCJfX2VzTW9kdWxlIiwidmFsdWUiLCJfX3RvQ29tbW9uSlMiLCJfX2FjY2Vzc0NoZWNrIiwib2JqIiwibWVtYmVyIiwiaGFzIiwiX19wcml2YXRlR2V0IiwiZ2V0dGVyIiwiX19wcml2YXRlQWRkIiwiV2Vha1NldCIsImFkZCIsInNldCIsInJlYWN0X3JvdXRlcl9leHBvcnRzIiwiQXdhaXQiLCJCcm93c2VyUm91dGVyIiwiRm9ybSIsIkhhc2hSb3V0ZXIiLCJJRExFX0JMT0NLRVIiLCJJRExFX0ZFVENIRVIiLCJJRExFX05BVklHQVRJT04iLCJMaW5rIiwiTGlua3MiLCJNZW1vcnlSb3V0ZXIiLCJNZXRhIiwiTmF2TGluayIsIk5hdmlnYXRlIiwiTmF2aWdhdGlvblR5cGUiLCJBY3Rpb24iLCJPdXRsZXQiLCJQcmVmZXRjaFBhZ2VMaW5rcyIsIlJvdXRlIiwiUm91dGVyIiwiUm91dGVyUHJvdmlkZXIiLCJSb3V0ZXMiLCJTY3JpcHRzIiwiU2Nyb2xsUmVzdG9yYXRpb24iLCJTZXJ2ZXJSb3V0ZXIiLCJTdGF0aWNSb3V0ZXIiLCJTdGF0aWNSb3V0ZXJQcm92aWRlciIsIlVOU0FGRV9EYXRhUm91dGVyQ29udGV4dCIsIkRhdGFSb3V0ZXJDb250ZXh0IiwiVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQiLCJEYXRhUm91dGVyU3RhdGVDb250ZXh0IiwiVU5TQUZFX0Vycm9yUmVzcG9uc2VJbXBsIiwiRXJyb3JSZXNwb25zZUltcGwiLCJVTlNBRkVfRmV0Y2hlcnNDb250ZXh0IiwiRmV0Y2hlcnNDb250ZXh0IiwiVU5TQUZFX0ZyYW1ld29ya0NvbnRleHQiLCJGcmFtZXdvcmtDb250ZXh0IiwiVU5TQUZFX0xvY2F0aW9uQ29udGV4dCIsIkxvY2F0aW9uQ29udGV4dCIsIlVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCIsIk5hdmlnYXRpb25Db250ZXh0IiwiVU5TQUZFX1JlbWl4RXJyb3JCb3VuZGFyeSIsIlJlbWl4RXJyb3JCb3VuZGFyeSIsIlVOU0FGRV9Sb3V0ZUNvbnRleHQiLCJSb3V0ZUNvbnRleHQiLCJVTlNBRkVfU2VydmVyTW9kZSIsIlNlcnZlck1vZGUiLCJVTlNBRkVfU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbCIsIlNpbmdsZUZldGNoUmVkaXJlY3RTeW1ib2wiLCJVTlNBRkVfVmlld1RyYW5zaXRpb25Db250ZXh0IiwiVmlld1RyYW5zaXRpb25Db250ZXh0IiwiVU5TQUZFX2NyZWF0ZUJyb3dzZXJIaXN0b3J5IiwiY3JlYXRlQnJvd3Nlckhpc3RvcnkiLCJVTlNBRkVfY3JlYXRlQ2xpZW50Um91dGVzIiwiY3JlYXRlQ2xpZW50Um91dGVzIiwiVU5TQUZFX2NyZWF0ZUNsaWVudFJvdXRlc1dpdGhITVJSZXZhbGlkYXRpb25PcHRPdXQiLCJjcmVhdGVDbGllbnRSb3V0ZXNXaXRoSE1SUmV2YWxpZGF0aW9uT3B0T3V0IiwiVU5TQUZFX2NyZWF0ZVJvdXRlciIsImNyZWF0ZVJvdXRlciIsIlVOU0FGRV9kZWNvZGVWaWFUdXJib1N0cmVhbSIsImRlY29kZVZpYVR1cmJvU3RyZWFtIiwiVU5TQUZFX2Rlc2VyaWFsaXplRXJyb3JzIiwiZGVzZXJpYWxpemVFcnJvcnMyIiwiVU5TQUZFX2dldEh5ZHJhdGlvbkRhdGEiLCJnZXRIeWRyYXRpb25EYXRhIiwiVU5TQUZFX2dldFBhdGNoUm91dGVzT25OYXZpZ2F0aW9uRnVuY3Rpb24iLCJnZXRQYXRjaFJvdXRlc09uTmF2aWdhdGlvbkZ1bmN0aW9uIiwiVU5TQUZFX2dldFR1cmJvU3RyZWFtU2luZ2xlRmV0Y2hEYXRhU3RyYXRlZ3kiLCJnZXRUdXJib1N0cmVhbVNpbmdsZUZldGNoRGF0YVN0cmF0ZWd5IiwiVU5TQUZFX2h5ZHJhdGlvblJvdXRlUHJvcGVydGllcyIsImh5ZHJhdGlvblJvdXRlUHJvcGVydGllcyIsIlVOU0FGRV9pbnZhcmlhbnQiLCJpbnZhcmlhbnQiLCJVTlNBRkVfbWFwUm91dGVQcm9wZXJ0aWVzIiwibWFwUm91dGVQcm9wZXJ0aWVzIiwiVU5TQUZFX3Nob3VsZEh5ZHJhdGVSb3V0ZUxvYWRlciIsInNob3VsZEh5ZHJhdGVSb3V0ZUxvYWRlciIsIlVOU0FGRV91c2VGb2dPRldhckRpc2NvdmVyeSIsInVzZUZvZ09GV2FyRGlzY292ZXJ5IiwiVU5TQUZFX3VzZVNjcm9sbFJlc3RvcmF0aW9uIiwidXNlU2Nyb2xsUmVzdG9yYXRpb24iLCJVTlNBRkVfd2l0aENvbXBvbmVudFByb3BzIiwid2l0aENvbXBvbmVudFByb3BzIiwiVU5TQUZFX3dpdGhFcnJvckJvdW5kYXJ5UHJvcHMiLCJ3aXRoRXJyb3JCb3VuZGFyeVByb3BzIiwiVU5TQUZFX3dpdGhIeWRyYXRlRmFsbGJhY2tQcm9wcyIsIndpdGhIeWRyYXRlRmFsbGJhY2tQcm9wcyIsImNyZWF0ZUJyb3dzZXJSb3V0ZXIiLCJjcmVhdGVDb29raWUiLCJjcmVhdGVDb29raWVTZXNzaW9uU3RvcmFnZSIsImNyZWF0ZUhhc2hSb3V0ZXIiLCJjcmVhdGVNZW1vcnlSb3V0ZXIiLCJjcmVhdGVNZW1vcnlTZXNzaW9uU3RvcmFnZSIsImNyZWF0ZVBhdGgiLCJjcmVhdGVSZXF1ZXN0SGFuZGxlciIsImNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbiIsImNyZWF0ZVJvdXRlc0Zyb21FbGVtZW50cyIsImNyZWF0ZVJvdXRlc1N0dWIiLCJjcmVhdGVTZWFyY2hQYXJhbXMiLCJjcmVhdGVTZXNzaW9uIiwiY3JlYXRlU2Vzc2lvblN0b3JhZ2UiLCJjcmVhdGVTdGF0aWNIYW5kbGVyIiwiY3JlYXRlU3RhdGljSGFuZGxlcjIiLCJjcmVhdGVTdGF0aWNSb3V0ZXIiLCJkYXRhIiwiZ2VuZXJhdGVQYXRoIiwiaHJlZiIsImlzQ29va2llIiwiaXNSb3V0ZUVycm9yUmVzcG9uc2UiLCJpc1Nlc3Npb24iLCJtYXRjaFBhdGgiLCJtYXRjaFJvdXRlcyIsInBhcnNlUGF0aCIsInJlZGlyZWN0IiwicmVkaXJlY3REb2N1bWVudCIsInJlbmRlck1hdGNoZXMiLCJyZXBsYWNlIiwicmVzb2x2ZVBhdGgiLCJ1bnN0YWJsZV9IaXN0b3J5Um91dGVyIiwiSGlzdG9yeVJvdXRlciIsInVuc3RhYmxlX1JvdXRlckNvbnRleHRQcm92aWRlciIsInVuc3RhYmxlX2NyZWF0ZUNvbnRleHQiLCJ1bnN0YWJsZV9zZXREZXZTZXJ2ZXJIb29rcyIsInNldERldlNlcnZlckhvb2tzIiwidW5zdGFibGVfdXNlUHJvbXB0IiwidXNlUHJvbXB0IiwidXNlQWN0aW9uRGF0YSIsInVzZUFzeW5jRXJyb3IiLCJ1c2VBc3luY1ZhbHVlIiwidXNlQmVmb3JlVW5sb2FkIiwidXNlQmxvY2tlciIsInVzZUZldGNoZXIiLCJ1c2VGZXRjaGVycyIsInVzZUZvcm1BY3Rpb24iLCJ1c2VIcmVmIiwidXNlSW5Sb3V0ZXJDb250ZXh0IiwidXNlTGlua0NsaWNrSGFuZGxlciIsInVzZUxvYWRlckRhdGEiLCJ1c2VMb2NhdGlvbiIsInVzZU1hdGNoIiwidXNlTWF0Y2hlcyIsInVzZU5hdmlnYXRlIiwidXNlTmF2aWdhdGlvbiIsInVzZU5hdmlnYXRpb25UeXBlIiwidXNlT3V0bGV0IiwidXNlT3V0bGV0Q29udGV4dCIsInVzZVBhcmFtcyIsInVzZVJlc29sdmVkUGF0aCIsInVzZVJldmFsaWRhdG9yIiwidXNlUm91dGVFcnJvciIsInVzZVJvdXRlTG9hZGVyRGF0YSIsInVzZVJvdXRlcyIsInVzZVNlYXJjaFBhcmFtcyIsInVzZVN1Ym1pdCIsInVzZVZpZXdUcmFuc2l0aW9uU3RhdGUiLCJtb2R1bGUiLCJleHBvcnRzIiwiQWN0aW9uMiIsIlBvcFN0YXRlRXZlbnRUeXBlIiwiY3JlYXRlTWVtb3J5SGlzdG9yeSIsIm9wdGlvbnMiLCJpbml0aWFsRW50cmllcyIsImluaXRpYWxJbmRleCIsInY1Q29tcGF0IiwiZW50cmllcyIsIm1hcCIsImVudHJ5IiwiaW5kZXgyIiwiY3JlYXRlTWVtb3J5TG9jYXRpb24iLCJzdGF0ZSIsImluZGV4IiwiY2xhbXBJbmRleCIsImxlbmd0aCIsImFjdGlvbiIsImxpc3RlbmVyIiwibiIsIk1hdGgiLCJtaW4iLCJtYXgiLCJnZXRDdXJyZW50TG9jYXRpb24iLCJsb2NhdGlvbiIsImNyZWF0ZUxvY2F0aW9uIiwicGF0aG5hbWUiLCJ3YXJuaW5nIiwiY2hhckF0IiwiSlNPTiIsInN0cmluZ2lmeSIsImNyZWF0ZUhyZWYyIiwiaGlzdG9yeSIsImNyZWF0ZUhyZWYiLCJjcmVhdGVVUkwiLCJVUkwiLCJlbmNvZGVMb2NhdGlvbiIsInBhdGgiLCJzZWFyY2giLCJoYXNoIiwicHVzaCIsIm5leHRMb2NhdGlvbiIsInNwbGljZSIsImRlbHRhIiwiZ28iLCJuZXh0SW5kZXgiLCJsaXN0ZW4iLCJmbiIsImNyZWF0ZUJyb3dzZXJMb2NhdGlvbiIsIndpbmRvdzIiLCJnbG9iYWxIaXN0b3J5IiwidXNyIiwiY3JlYXRlQnJvd3NlckhyZWYiLCJnZXRVcmxCYXNlZEhpc3RvcnkiLCJjcmVhdGVIYXNoSGlzdG9yeSIsImNyZWF0ZUhhc2hMb2NhdGlvbiIsInN1YnN0cmluZyIsInN0YXJ0c1dpdGgiLCJjcmVhdGVIYXNoSHJlZiIsImJhc2UiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJocmVmMiIsImdldEF0dHJpYnV0ZSIsInVybCIsImhhc2hJbmRleCIsImluZGV4T2YiLCJzbGljZSIsInZhbGlkYXRlSGFzaExvY2F0aW9uIiwibWVzc2FnZSIsIkVycm9yIiwiY29uZCIsImNvbnNvbGUiLCJ3YXJuIiwiZSIsImNyZWF0ZUtleSIsInJhbmRvbSIsInRvU3RyaW5nIiwiZ2V0SGlzdG9yeVN0YXRlIiwiaWR4IiwiY3VycmVudCIsInBhcnNlZFBhdGgiLCJzZWFyY2hJbmRleCIsImdldExvY2F0aW9uIiwidmFsaWRhdGVMb2NhdGlvbiIsIndpbmRvdyIsImRlZmF1bHRWaWV3IiwiZ2V0SW5kZXgiLCJyZXBsYWNlU3RhdGUiLCJoYW5kbGVQb3AiLCJoaXN0b3J5U3RhdGUiLCJwdXNoU3RhdGUiLCJlcnJvciIsIkRPTUV4Y2VwdGlvbiIsImFzc2lnbiIsInJlcGxhY2UyIiwiY3JlYXRlQnJvd3NlclVSTEltcGwiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImlzQWJzb2x1dGUiLCJvcmlnaW4iLCJkZWZhdWx0VmFsdWUiLCJfbWFwIiwiY29uc3RydWN0b3IiLCJpbml0IiwiTWFwIiwiY29udGV4dCIsIldlYWtNYXAiLCJ1bnN1cHBvcnRlZExhenlSb3V0ZU9iamVjdEtleXMiLCJTZXQiLCJpc1Vuc3VwcG9ydGVkTGF6eVJvdXRlT2JqZWN0S2V5IiwidW5zdXBwb3J0ZWRMYXp5Um91dGVGdW5jdGlvbktleXMiLCJpc1Vuc3VwcG9ydGVkTGF6eVJvdXRlRnVuY3Rpb25LZXkiLCJpc0luZGV4Um91dGUiLCJyb3V0ZSIsImNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMiLCJyb3V0ZXMiLCJtYXBSb3V0ZVByb3BlcnRpZXMyIiwicGFyZW50UGF0aCIsIm1hbmlmZXN0IiwidHJlZVBhdGgiLCJTdHJpbmciLCJpZCIsImpvaW4iLCJjaGlsZHJlbiIsImluZGV4Um91dGUiLCJwYXRoT3JMYXlvdXRSb3V0ZSIsImxvY2F0aW9uQXJnIiwiYmFzZW5hbWUiLCJtYXRjaFJvdXRlc0ltcGwiLCJhbGxvd1BhcnRpYWwiLCJzdHJpcEJhc2VuYW1lIiwiYnJhbmNoZXMiLCJmbGF0dGVuUm91dGVzIiwicmFua1JvdXRlQnJhbmNoZXMiLCJtYXRjaGVzIiwiaSIsImRlY29kZWQiLCJkZWNvZGVQYXRoIiwibWF0Y2hSb3V0ZUJyYW5jaCIsImNvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoIiwibWF0Y2giLCJsb2FkZXJEYXRhIiwicGFyYW1zIiwiaGFuZGxlIiwicGFyZW50c01ldGEiLCJmbGF0dGVuUm91dGUiLCJyZWxhdGl2ZVBhdGgiLCJtZXRhIiwiY2FzZVNlbnNpdGl2ZSIsImNoaWxkcmVuSW5kZXgiLCJqb2luUGF0aHMiLCJyb3V0ZXNNZXRhIiwiY29uY2F0Iiwic2NvcmUiLCJjb21wdXRlU2NvcmUiLCJmb3JFYWNoIiwiaW5jbHVkZXMiLCJleHBsb2RlZCIsImV4cGxvZGVPcHRpb25hbFNlZ21lbnRzIiwic2VnbWVudHMiLCJzcGxpdCIsImZpcnN0IiwicmVzdCIsImlzT3B0aW9uYWwiLCJlbmRzV2l0aCIsInJlcXVpcmVkIiwicmVzdEV4cGxvZGVkIiwicmVzdWx0Iiwic3VicGF0aCIsInNvcnQiLCJhIiwiYiIsImNvbXBhcmVJbmRleGVzIiwicGFyYW1SZSIsImR5bmFtaWNTZWdtZW50VmFsdWUiLCJpbmRleFJvdXRlVmFsdWUiLCJlbXB0eVNlZ21lbnRWYWx1ZSIsInN0YXRpY1NlZ21lbnRWYWx1ZSIsInNwbGF0UGVuYWx0eSIsImlzU3BsYXQiLCJzIiwiaW5pdGlhbFNjb3JlIiwic29tZSIsImZpbHRlciIsInJlZHVjZSIsInNlZ21lbnQiLCJ0ZXN0Iiwic2libGluZ3MiLCJldmVyeSIsImJyYW5jaCIsIm1hdGNoZWRQYXJhbXMiLCJtYXRjaGVkUGF0aG5hbWUiLCJlbmQiLCJyZW1haW5pbmdQYXRobmFtZSIsInBhdGhuYW1lQmFzZSIsIm5vcm1hbGl6ZVBhdGhuYW1lIiwib3JpZ2luYWxQYXRoIiwicHJlZml4Iiwic3RyaW5naWZ5MiIsInAiLCJhcnJheSIsImlzTGFzdFNlZ21lbnQiLCJzdGFyIiwia2V5TWF0Y2giLCJvcHRpb25hbCIsInBhcmFtIiwicGF0dGVybiIsIm1hdGNoZXIiLCJjb21waWxlZFBhcmFtcyIsImNvbXBpbGVQYXRoIiwiY2FwdHVyZUdyb3VwcyIsIm1lbW8yIiwicGFyYW1OYW1lIiwic3BsYXRWYWx1ZSIsInJlZ2V4cFNvdXJjZSIsIl8iLCJSZWdFeHAiLCJ2IiwiZGVjb2RlVVJJQ29tcG9uZW50IiwidG9Mb3dlckNhc2UiLCJzdGFydEluZGV4IiwibmV4dENoYXIiLCJmcm9tUGF0aG5hbWUiLCJ0b1BhdGhuYW1lIiwicmVzb2x2ZVBhdGhuYW1lIiwibm9ybWFsaXplU2VhcmNoIiwibm9ybWFsaXplSGFzaCIsInJlbGF0aXZlU2VnbWVudHMiLCJwb3AiLCJnZXRJbnZhbGlkUGF0aEVycm9yIiwiY2hhciIsImZpZWxkIiwiZGVzdCIsImdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzIiwiZ2V0UmVzb2x2ZVRvTWF0Y2hlcyIsInBhdGhNYXRjaGVzIiwicmVzb2x2ZVRvIiwidG9BcmciLCJyb3V0ZVBhdGhuYW1lcyIsImxvY2F0aW9uUGF0aG5hbWUiLCJpc1BhdGhSZWxhdGl2ZSIsImlzRW1wdHlQYXRoIiwicm91dGVQYXRobmFtZUluZGV4IiwidG9TZWdtZW50cyIsInNoaWZ0IiwiaGFzRXhwbGljaXRUcmFpbGluZ1NsYXNoIiwiaGFzQ3VycmVudFRyYWlsaW5nU2xhc2giLCJwYXRocyIsIkRhdGFXaXRoUmVzcG9uc2VJbml0IiwiZGF0YTIiLCJ0eXBlIiwic3RhdHVzIiwicmVzcG9uc2VJbml0IiwiaGVhZGVycyIsIkhlYWRlcnMiLCJSZXNwb25zZSIsInJlc3BvbnNlIiwic3RhdHVzVGV4dCIsImludGVybmFsIiwidmFsaWRNdXRhdGlvbk1ldGhvZHNBcnIiLCJ2YWxpZE11dGF0aW9uTWV0aG9kcyIsInZhbGlkUmVxdWVzdE1ldGhvZHNBcnIiLCJ2YWxpZFJlcXVlc3RNZXRob2RzIiwicmVkaXJlY3RTdGF0dXNDb2RlcyIsInJlZGlyZWN0UHJlc2VydmVNZXRob2RTdGF0dXNDb2RlcyIsImZvcm1NZXRob2QiLCJmb3JtQWN0aW9uIiwiZm9ybUVuY1R5cGUiLCJmb3JtRGF0YSIsImpzb24iLCJ0ZXh0IiwicHJvY2VlZCIsInJlc2V0IiwiQUJTT0xVVEVfVVJMX1JFR0VYIiwiZGVmYXVsdE1hcFJvdXRlUHJvcGVydGllcyIsImhhc0Vycm9yQm91bmRhcnkiLCJCb29sZWFuIiwiVFJBTlNJVElPTlNfU1RPUkFHRV9LRVkiLCJSZXNldExvYWRlckRhdGFTeW1ib2wiLCJTeW1ib2wiLCJyb3V0ZXJXaW5kb3ciLCJpc0Jyb3dzZXIyIiwiY3JlYXRlRWxlbWVudCIsImh5ZHJhdGlvblJvdXRlUHJvcGVydGllczIiLCJkYXRhUm91dGVzIiwiaW5GbGlnaHREYXRhUm91dGVzIiwiZGF0YVN0cmF0ZWd5SW1wbCIsImRhdGFTdHJhdGVneSIsImRlZmF1bHREYXRhU3RyYXRlZ3lXaXRoTWlkZGxld2FyZSIsImZ1dHVyZSIsInVuc3RhYmxlX21pZGRsZXdhcmUiLCJ1bmxpc3Rlbkhpc3RvcnkiLCJzdWJzY3JpYmVycyIsInNhdmVkU2Nyb2xsUG9zaXRpb25zMiIsImdldFNjcm9sbFJlc3RvcmF0aW9uS2V5MiIsImdldFNjcm9sbFBvc2l0aW9uIiwiaW5pdGlhbFNjcm9sbFJlc3RvcmVkIiwiaHlkcmF0aW9uRGF0YSIsImluaXRpYWxNYXRjaGVzIiwiaW5pdGlhbE1hdGNoZXNJc0ZPVyIsImluaXRpYWxFcnJvcnMiLCJpbml0aWFsaXplZCIsInBhdGNoUm91dGVzT25OYXZpZ2F0aW9uIiwiZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvciIsImdldFNob3J0Q2lyY3VpdE1hdGNoZXMiLCJmb2dPZldhciIsImNoZWNrRm9nT2ZXYXIiLCJhY3RpdmUiLCJtIiwibGF6eSIsImxvYWRlciIsImVycm9ycyIsImZpbmRJbmRleCIsInNob3VsZExvYWRSb3V0ZU9uSHlkcmF0aW9uIiwicm91dGVyIiwiaGlzdG9yeUFjdGlvbiIsIm5hdmlnYXRpb24iLCJyZXN0b3JlU2Nyb2xsUG9zaXRpb24iLCJwcmV2ZW50U2Nyb2xsUmVzZXQiLCJyZXZhbGlkYXRpb24iLCJhY3Rpb25EYXRhIiwiZmV0Y2hlcnMiLCJibG9ja2VycyIsInBlbmRpbmdBY3Rpb24iLCJwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0IiwicGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyIiwicGVuZGluZ1ZpZXdUcmFuc2l0aW9uRW5hYmxlZCIsImFwcGxpZWRWaWV3VHJhbnNpdGlvbnMiLCJyZW1vdmVQYWdlSGlkZUV2ZW50TGlzdGVuZXIiLCJpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24iLCJpc1JldmFsaWRhdGlvblJlcXVpcmVkIiwiY2FuY2VsbGVkRmV0Y2hlckxvYWRzIiwiZmV0Y2hDb250cm9sbGVycyIsImluY3JlbWVudGluZ0xvYWRJZCIsInBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkIiwiZmV0Y2hSZWxvYWRJZHMiLCJmZXRjaFJlZGlyZWN0SWRzIiwiZmV0Y2hMb2FkTWF0Y2hlcyIsImFjdGl2ZUZldGNoZXJzIiwiZmV0Y2hlcnNRdWV1ZWRGb3JEZWxldGlvbiIsImJsb2NrZXJGdW5jdGlvbnMiLCJ1bmJsb2NrQmxvY2tlckhpc3RvcnlVcGRhdGUiLCJwZW5kaW5nUmV2YWxpZGF0aW9uRGZkIiwiaW5pdGlhbGl6ZSIsInNpemUiLCJibG9ja2VyS2V5Iiwic2hvdWxkQmxvY2tOYXZpZ2F0aW9uIiwiY3VycmVudExvY2F0aW9uIiwibmV4dEhpc3RvcnlVcGRhdGVQcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ1cGRhdGVCbG9ja2VyIiwidGhlbiIsInVwZGF0ZVN0YXRlIiwic3RhcnROYXZpZ2F0aW9uIiwicmVzdG9yZUFwcGxpZWRUcmFuc2l0aW9ucyIsIl9zYXZlQXBwbGllZFRyYW5zaXRpb25zIiwicGVyc2lzdEFwcGxpZWRUcmFuc2l0aW9ucyIsImluaXRpYWxIeWRyYXRpb24iLCJkaXNwb3NlIiwiY2xlYXIiLCJhYm9ydCIsImRlbGV0ZUZldGNoZXIiLCJkZWxldGVCbG9ja2VyIiwic3Vic2NyaWJlIiwiZGVsZXRlIiwibmV3U3RhdGUiLCJvcHRzIiwidW5tb3VudGVkRmV0Y2hlcnMiLCJtb3VudGVkRmV0Y2hlcnMiLCJmZXRjaGVyIiwic3Vic2NyaWJlciIsImRlbGV0ZWRGZXRjaGVycyIsInZpZXdUcmFuc2l0aW9uT3B0cyIsImZsdXNoU3luYyIsImNvbXBsZXRlTmF2aWdhdGlvbiIsImlzQWN0aW9uUmVsb2FkIiwiaXNNdXRhdGlvbk1ldGhvZCIsIl9pc1JlZGlyZWN0Iiwia2V5cyIsIm1lcmdlTG9hZGVyRGF0YSIsImsiLCJwcmlvclBhdGhzIiwidG9QYXRocyIsImdldFNhdmVkU2Nyb2xsUG9zaXRpb24iLCJuYXZpZ2F0ZSIsIm5vcm1hbGl6ZWRQYXRoIiwibm9ybWFsaXplVG8iLCJmcm9tUm91dGVJZCIsInJlbGF0aXZlIiwic3VibWlzc2lvbiIsIm5vcm1hbGl6ZU5hdmlnYXRlT3B0aW9ucyIsInVzZXJSZXBsYWNlIiwicGVuZGluZ0Vycm9yIiwiZW5hYmxlVmlld1RyYW5zaXRpb24iLCJ2aWV3VHJhbnNpdGlvbiIsInJldmFsaWRhdGUiLCJjcmVhdGVEZWZlcnJlZCIsImludGVycnVwdEFjdGl2ZUxvYWRzIiwicHJvbWlzZSIsInN0YXJ0VW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiIsIm92ZXJyaWRlTmF2aWdhdGlvbiIsInNhdmVTY3JvbGxQb3NpdGlvbiIsInJvdXRlc1RvVXNlIiwibG9hZGluZ05hdmlnYXRpb24iLCJpc0hhc2hDaGFuZ2VPbmx5Iiwibm90Rm91bmRNYXRjaGVzIiwiaGFuZGxlTmF2aWdhdGlvbmFsNDA0IiwiQWJvcnRDb250cm9sbGVyIiwicmVxdWVzdCIsImNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0Iiwic2lnbmFsIiwic2NvcGVkQ29udGV4dCIsInVuc3RhYmxlX2dldENvbnRleHQiLCJwZW5kaW5nQWN0aW9uUmVzdWx0IiwiZmluZE5lYXJlc3RCb3VuZGFyeSIsImFjdGlvblJlc3VsdCIsImhhbmRsZUFjdGlvbiIsInNob3J0Q2lyY3VpdGVkIiwicm91dGVJZCIsImlzRXJyb3JSZXN1bHQiLCJnZXRMb2FkaW5nTmF2aWdhdGlvbiIsInVwZGF0ZWRNYXRjaGVzIiwiaGFuZGxlTG9hZGVycyIsImZldGNoZXJTdWJtaXNzaW9uIiwiZ2V0QWN0aW9uRGF0YUZvckNvbW1pdCIsImlzRm9nT2ZXYXIiLCJnZXRTdWJtaXR0aW5nTmF2aWdhdGlvbiIsImRpc2NvdmVyUmVzdWx0IiwiZGlzY292ZXJSb3V0ZXMiLCJib3VuZGFyeUlkIiwicGFydGlhbE1hdGNoZXMiLCJhY3Rpb25NYXRjaCIsImdldFRhcmdldE1hdGNoIiwibWV0aG9kIiwiZHNNYXRjaGVzIiwiZ2V0VGFyZ2V0ZWREYXRhU3RyYXRlZ3lNYXRjaGVzIiwicmVzdWx0cyIsImNhbGxEYXRhU3RyYXRlZ3kiLCJhYm9ydGVkIiwiaXNSZWRpcmVjdFJlc3VsdCIsImxvY2F0aW9uMiIsIm5vcm1hbGl6ZVJlZGlyZWN0TG9jYXRpb24iLCJzdGFydFJlZGlyZWN0TmF2aWdhdGlvbiIsImJvdW5kYXJ5TWF0Y2giLCJhY3RpdmVTdWJtaXNzaW9uIiwiZ2V0U3VibWlzc2lvbkZyb21OYXZpZ2F0aW9uIiwic2hvdWxkVXBkYXRlTmF2aWdhdGlvblN0YXRlIiwiZ2V0VXBkYXRlZEFjdGlvbkRhdGEiLCJyZXZhbGlkYXRpbmdGZXRjaGVycyIsImdldE1hdGNoZXNUb0xvYWQiLCJzaG91bGRMb2FkIiwidXBkYXRlZEZldGNoZXJzMiIsIm1hcmtGZXRjaFJlZGlyZWN0c0RvbmUiLCJ1cGRhdGVzIiwiZ2V0VXBkYXRlZFJldmFsaWRhdGluZ0ZldGNoZXJzIiwicmYiLCJhYm9ydEZldGNoZXIiLCJjb250cm9sbGVyIiwiYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zIiwiZiIsImxvYWRlclJlc3VsdHMiLCJmZXRjaGVyUmVzdWx0cyIsImNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YSIsInJlZGlyZWN0MiIsImZpbmRSZWRpcmVjdCIsInByb2Nlc3NMb2FkZXJEYXRhIiwidXBkYXRlZEZldGNoZXJzIiwiZGlkQWJvcnRGZXRjaExvYWRzIiwiYWJvcnRTdGFsZUZldGNoTG9hZHMiLCJzaG91bGRVcGRhdGVGZXRjaGVycyIsInJldmFsaWRhdGluZ0ZldGNoZXIiLCJnZXRMb2FkaW5nRmV0Y2hlciIsImZldGNoMiIsInNldEZldGNoZXJFcnJvciIsImhhbmRsZUZldGNoZXJBY3Rpb24iLCJoYW5kbGVGZXRjaGVyTG9hZGVyIiwicmVxdWVzdE1hdGNoZXMiLCJkZXRlY3RBbmRIYW5kbGU0MDVFcnJvciIsImV4aXN0aW5nRmV0Y2hlciIsInVwZGF0ZUZldGNoZXJTdGF0ZSIsImdldFN1Ym1pdHRpbmdGZXRjaGVyIiwiYWJvcnRDb250cm9sbGVyIiwiZmV0Y2hSZXF1ZXN0Iiwib3JpZ2luYXRpbmdMb2FkSWQiLCJmZXRjaE1hdGNoZXMiLCJhY3Rpb25SZXN1bHRzIiwiZ2V0RG9uZUZldGNoZXIiLCJyZXZhbGlkYXRpb25SZXF1ZXN0IiwibG9hZElkIiwibG9hZEZldGNoZXIiLCJzdGFsZUtleSIsImV4aXN0aW5nRmV0Y2hlcjIiLCJyIiwiZG9uZUZldGNoZXIiLCJpc05hdmlnYXRpb24iLCJyZWRpcmVjdExvY2F0aW9uIiwiaXNEb2N1bWVudFJlbG9hZCIsInJlZGlyZWN0TmF2aWdhdGlvblR5cGUiLCJmZXRjaGVyS2V5IiwiZGF0YVJlc3VsdHMiLCJjYWxsRGF0YVN0cmF0ZWd5SW1wbCIsImlzUmVkaXJlY3REYXRhU3RyYXRlZ3lSZXN1bHQiLCJub3JtYWxpemVSZWxhdGl2ZVJvdXRpbmdSZWRpcmVjdFJlc3BvbnNlIiwiY29udmVydERhdGFTdHJhdGVneVJlc3VsdFRvRGF0YVJlc3VsdCIsImZldGNoZXJzVG9Mb2FkIiwibG9hZGVyUmVzdWx0c1Byb21pc2UiLCJmZXRjaGVyUmVzdWx0c1Byb21pc2UiLCJhY2MiLCJnZXRGZXRjaGVyIiwicXVldWVGZXRjaGVyRm9yRGVsZXRpb24iLCJjb3VudCIsIm1hcmtGZXRjaGVyc0RvbmUiLCJkb25lS2V5cyIsImxhbmRlZElkIiwieWVldGVkS2V5cyIsImdldEJsb2NrZXIiLCJibG9ja2VyIiwibmV3QmxvY2tlciIsIkFycmF5IiwiYmxvY2tlckZ1bmN0aW9uIiwiZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24iLCJwb3NpdGlvbnMiLCJnZXRQb3NpdGlvbiIsImdldEtleSIsInkiLCJnZXRTY3JvbGxLZXkiLCJmb2dNYXRjaGVzIiwiaXNOb25ITVIiLCJsb2NhbE1hbmlmZXN0IiwicGF0Y2giLCJwYXRjaFJvdXRlc0ltcGwiLCJuZXdNYXRjaGVzIiwibmV3UGFydGlhbE1hdGNoZXMiLCJfaW50ZXJuYWxTZXRSb3V0ZXMiLCJuZXdSb3V0ZXMiLCJwYXRjaFJvdXRlcyIsImZldGNoIiwiX2ludGVybmFsRmV0Y2hDb250cm9sbGVycyIsInF1ZXJ5IiwicmVxdWVzdENvbnRleHQiLCJmaWx0ZXJNYXRjaGVzVG9Mb2FkIiwic2tpcExvYWRlckVycm9yQnViYmxpbmciLCJza2lwUmV2YWxpZGF0aW9uIiwidW5zdGFibGVfcmVzcG9uZCIsInJlc3BvbmQiLCJpc1ZhbGlkTWV0aG9kIiwibWV0aG9kTm90QWxsb3dlZE1hdGNoZXMiLCJzdGF0aWNDb250ZXh0Iiwic3RhdHVzQ29kZSIsImxvYWRlckhlYWRlcnMiLCJhY3Rpb25IZWFkZXJzIiwibG9hZExhenlNaWRkbGV3YXJlRm9yTWF0Y2hlcyIsInJlbmRlcmVkU3RhdGljQ29udGV4dCIsInJ1bk1pZGRsZXdhcmVQaXBlbGluZSIsInJlc3VsdDIiLCJxdWVyeUltcGwiLCJpc1Jlc3BvbnNlIiwicmVzIiwiZ2V0U3RhdGljQ29udGV4dEZyb21FcnJvciIsImJvdW5kYXJ5Um91dGVJZCIsImZpbmQiLCJxdWVyeVJvdXRlIiwiZXJyb3IyIiwidmFsdWVzIiwicm91dGVNYXRjaCIsInN1Ym1pdCIsImxvYWRSb3V0ZURhdGEiLCJpc0RhdGFTdHJhdGVneVJlc3VsdCIsImlzUmVkaXJlY3RSZXNwb25zZSIsImlzUm91dGVSZXF1ZXN0IiwidGhyb3dTdGF0aWNIYW5kbGVyQWJvcnRlZEVycm9yIiwiTG9jYXRpb24iLCJsb2FkZXJSZXF1ZXN0IiwiUmVxdWVzdCIsImhhbmRsZXJDb250ZXh0MiIsImhhbmRsZXJDb250ZXh0IiwibWF4SWR4IiwiZ2V0RGF0YVN0cmF0ZWd5TWF0Y2giLCJwcm9jZXNzUm91dGVMb2FkZXJEYXRhIiwiZGVmYXVsdERhdGFTdHJhdGVneSIsImVycm9yQm91bmRhcnlJZCIsIl9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkIiwicmVhc29uIiwiaXNTdWJtaXNzaW9uTmF2aWdhdGlvbiIsImJvZHkiLCJjb250ZXh0dWFsTWF0Y2hlcyIsImFjdGl2ZVJvdXRlTWF0Y2giLCJuYWtlZEluZGV4IiwiaGFzTmFrZWRJbmRleFF1ZXJ5IiwiVVJMU2VhcmNoUGFyYW1zIiwiaW5kZXhWYWx1ZXMiLCJnZXRBbGwiLCJhcHBlbmQiLCJxcyIsImlzRmV0Y2hlciIsImdldEludmFsaWRCb2R5RXJyb3IiLCJyYXdGb3JtTWV0aG9kIiwidG9VcHBlckNhc2UiLCJzdHJpcEhhc2hGcm9tUGF0aCIsIkZvcm1EYXRhIiwicGFyc2UiLCJzZWFyY2hQYXJhbXMiLCJjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyIsImNvbnZlcnRTZWFyY2hQYXJhbXNUb0Zvcm1EYXRhIiwibGF6eVJvdXRlUHJvcGVydGllc1RvU2tpcCIsImhhc1BhdGNoUm91dGVzT25OYXZpZ2F0aW9uIiwiY3VycmVudFVybCIsIm5leHRVcmwiLCJhY3Rpb25TdGF0dXMiLCJzaG91bGRTa2lwUmV2YWxpZGF0aW9uIiwiYmFzZVNob3VsZFJldmFsaWRhdGVBcmdzIiwiY3VycmVudFBhcmFtcyIsIm5leHRQYXJhbXMiLCJmb3JjZVNob3VsZExvYWQiLCJpc05ld0xvYWRlciIsImRlZmF1bHRTaG91bGRSZXZhbGlkYXRlIiwiaXNOZXdSb3V0ZUluc3RhbmNlIiwic2hvdWxkUmV2YWxpZGF0ZUFyZ3MiLCJzaG91bGRSZXZhbGlkYXRlTG9hZGVyIiwiaXNNaWRJbml0aWFsTG9hZCIsImZldGNoZXJNYXRjaGVzIiwiZmV0Y2hlck1hdGNoIiwiZmV0Y2hDb250cm9sbGVyIiwiZmV0Y2hlckRzTWF0Y2hlcyIsImhhc0RhdGEiLCJoYXNFcnJvciIsImh5ZHJhdGUiLCJjdXJyZW50TG9hZGVyRGF0YSIsImN1cnJlbnRNYXRjaCIsImlzTmV3IiwiaXNNaXNzaW5nRGF0YSIsImN1cnJlbnRQYXRoIiwibG9hZGVyTWF0Y2giLCJhcmciLCJzaG91bGRSZXZhbGlkYXRlIiwicm91dGVDaG9pY2UiLCJjaGlsZHJlblRvUGF0Y2giLCJ1bmlxdWVDaGlsZHJlbiIsIm5ld1JvdXRlIiwiZXhpc3RpbmdSb3V0ZSIsImlzU2FtZVJvdXRlIiwiYUNoaWxkIiwiYkNoaWxkIiwibGF6eVJvdXRlUHJvcGVydHlDYWNoZSIsImxvYWRMYXp5Um91dGVQcm9wZXJ0eSIsInJvdXRlVG9VcGRhdGUiLCJsYXp5Rm4iLCJjYWNoZSIsImNhY2hlZFByb21pc2UiLCJwcm9wZXJ0eVByb21pc2UiLCJpc1Vuc3VwcG9ydGVkIiwic3RhdGljUm91dGVWYWx1ZSIsImlzU3RhdGljYWxseURlZmluZWQiLCJsYXp5Um91dGVGdW5jdGlvbkNhY2hlIiwibG9hZExhenlSb3V0ZSIsImxhenlSb3V0ZVByb21pc2UiLCJsYXp5SGFuZGxlclByb21pc2UiLCJsYXp5Um91dGVQcm9taXNlMiIsImxhenlSb3V0ZSIsInJvdXRlVXBkYXRlcyIsImxhenlSb3V0ZVByb3BlcnR5IiwibGF6eVZhbHVlIiwiY2F0Y2giLCJsYXp5S2V5cyIsImxhenlQcm9wZXJ0eVByb21pc2VzIiwiaXNOb25OdWxsYWJsZSIsInByb21pc2VzIiwiYXJncyIsIm1hdGNoZXNUb0xvYWQiLCJrZXllZFJlc3VsdHMiLCJwcm9wYWdhdGVSZXN1bHQiLCJoYW5kbGVyIiwiZXJyb3JIYW5kbGVyIiwibWlkZGxld2FyZVN0YXRlIiwiaGFuZGxlclJlc3VsdCIsInR1cGxlcyIsImZsYXRNYXAiLCJjYWxsUm91dGVNaWRkbGV3YXJlIiwibWlkZGxld2FyZUVycm9yIiwibWlkZGxld2FyZXMiLCJ0dXBsZSIsIm1pZGRsZXdhcmUiLCJuZXh0Q2FsbGVkIiwibmV4dFJlc3VsdCIsIm5leHQiLCJnZXREYXRhU3RyYXRlZ3lNYXRjaExhenlQcm9taXNlcyIsImxhenlNaWRkbGV3YXJlUHJvbWlzZSIsImxhenlSb3V0ZVByb21pc2VzIiwidW5zdGFibGVfc2hvdWxkUmV2YWxpZGF0ZUFyZ3MiLCJpc1VzaW5nTmV3QXBpIiwiX2xhenlQcm9taXNlcyIsInVuc3RhYmxlX3Nob3VsZENhbGxIYW5kbGVyIiwiaGFuZGxlck92ZXJyaWRlIiwiY2FsbExvYWRlck9yQWN0aW9uIiwidGFyZ2V0TWF0Y2giLCJpc1N0YXRpY0hhbmRsZXIiLCJkYXRhU3RyYXRlZ3lBcmdzIiwidW5zdGFibGVfcnVuQ2xpZW50TWlkZGxld2FyZSIsImNiIiwidHlwZWREYXRhU3RyYXRlZ3lBcmdzIiwib25SZWplY3QiLCJpc0FjdGlvbiIsInJ1bkhhbmRsZXIiLCJyZWplY3QiLCJhYm9ydFByb21pc2UiLCJhY3R1YWxIYW5kbGVyIiwiY3R4IiwiaGFuZGxlclByb21pc2UiLCJ2YWwiLCJyYWNlIiwiaGFuZGxlckVycm9yIiwiaGFuZGxlcjIiLCJkYXRhU3RyYXRlZ3lSZXN1bHQiLCJjb250ZW50VHlwZSIsImlzRGF0YVdpdGhSZXNwb25zZUluaXQiLCJ0cmltbWVkTWF0Y2hlcyIsIm5vcm1hbGl6ZWRMb2NhdGlvbiIsInByb3RvY29sIiwiaXNTYW1lQmFzZW5hbWUiLCJmb3VuZEVycm9yIiwibmV3TG9hZGVyRGF0YSIsIm1lcmdlZExvYWRlckRhdGEiLCJtZXJnZWQiLCJlbGlnaWJsZU1hdGNoZXMiLCJyZXZlcnNlIiwiZXJyb3JNZXNzYWdlIiwiaXNSZWRpcmVjdFN0YXR1c0NvZGUiLCJfd2luZG93IiwidHJhbnNpdGlvbnMiLCJzZXNzaW9uUG9zaXRpb25zIiwic2Vzc2lvblN0b3JhZ2UiLCJnZXRJdGVtIiwiaXNBcnJheSIsInNldEl0ZW0iLCJyZWoiLCJSZWFjdDMiLCJyZXF1aXJlIiwiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwiZGlzcGxheU5hbWUiLCJpc1RyYW5zaXRpb25pbmciLCJBd2FpdENvbnRleHQiLCJvdXRsZXQiLCJpc0RhdGFSb3V0ZSIsIlJvdXRlRXJyb3JDb250ZXh0IiwiRU5BQkxFX0RFVl9XQVJOSU5HUyIsIlJlYWN0MiIsIm5hdmlnYXRvciIsInVzZUNvbnRleHQiLCJqb2luZWRQYXRobmFtZSIsIm5hdmlnYXRpb25UeXBlIiwidXNlTWVtbyIsIm5hdmlnYXRlRWZmZWN0V2FybmluZyIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJpc1N0YXRpYyIsInN0YXRpYyIsInVzZUxheW91dEVmZmVjdCIsInVzZU5hdmlnYXRlU3RhYmxlIiwidXNlTmF2aWdhdGVVbnN0YWJsZSIsImRhdGFSb3V0ZXJDb250ZXh0Iiwicm91dGVQYXRobmFtZXNKc29uIiwiYWN0aXZlUmVmIiwidXNlUmVmIiwidXNlQ2FsbGJhY2siLCJPdXRsZXRDb250ZXh0IiwiUHJvdmlkZXIiLCJ1c2VSb3V0ZXNJbXBsIiwiZGF0YVJvdXRlclN0YXRlIiwicGFyZW50TWF0Y2hlcyIsInBhcmVudFBhcmFtcyIsInBhcmVudFBhdGhuYW1lIiwicGFyZW50UGF0aG5hbWVCYXNlIiwicGFyZW50Um91dGUiLCJ3YXJuaW5nT25jZSIsImxvY2F0aW9uRnJvbUNvbnRleHQiLCJwYXJzZWRMb2NhdGlvbkFyZyIsInBhcmVudFNlZ21lbnRzIiwiZWxlbWVudCIsIkNvbXBvbmVudCIsInJlbmRlcmVkTWF0Y2hlcyIsIl9yZW5kZXJNYXRjaGVzIiwiRGVmYXVsdEVycm9yQ29tcG9uZW50Iiwic3RhY2siLCJsaWdodGdyZXkiLCJwcmVTdHlsZXMiLCJwYWRkaW5nIiwiYmFja2dyb3VuZENvbG9yIiwiY29kZVN0eWxlcyIsImRldkluZm8iLCJGcmFnbWVudCIsInN0eWxlIiwiZm9udFN0eWxlIiwiZGVmYXVsdEVycm9yRWxlbWVudCIsIlJlbmRlckVycm9yQm91bmRhcnkiLCJwcm9wcyIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsImNvbXBvbmVudERpZENhdGNoIiwiZXJyb3JJbmZvIiwicmVuZGVyIiwicm91dGVDb250ZXh0IiwiY29tcG9uZW50IiwiUmVuZGVyZWRSb3V0ZSIsImVycm9yRWxlbWVudCIsIkVycm9yQm91bmRhcnkiLCJlcnJvckluZGV4IiwicmVuZGVyRmFsbGJhY2siLCJmYWxsYmFja0luZGV4IiwiSHlkcmF0ZUZhbGxiYWNrIiwiaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCIsImVycm9yczIiLCJuZWVkc1RvUnVuTG9hZGVyIiwicmVkdWNlUmlnaHQiLCJzaG91bGRSZW5kZXJIeWRyYXRlRmFsbGJhY2siLCJtYXRjaGVzMiIsImdldENoaWxkcmVuIiwiZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvciIsImhvb2tOYW1lIiwidXNlRGF0YVJvdXRlckNvbnRleHQiLCJ1c2VEYXRhUm91dGVyU3RhdGUiLCJ1c2VSb3V0ZUNvbnRleHQiLCJ1c2VDdXJyZW50Um91dGVJZCIsInRoaXNSb3V0ZSIsInVzZVJvdXRlSWQiLCJfZGF0YSIsIl9lcnJvciIsImJsb2NrZXJJZCIsInNob3VsZEJsb2NrIiwic2V0QmxvY2tlcktleSIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiYWxyZWFkeVdhcm5lZCIsImFscmVhZHlXYXJuZWQyIiwid2Fybk9uY2UiLCJjb25kaXRpb24iLCJEZWZlcnJlZCIsInJlYWN0RG9tRmx1c2hTeW5jSW1wbCIsInNldFN0YXRlSW1wbCIsInBlbmRpbmdTdGF0ZSIsInNldFBlbmRpbmdTdGF0ZSIsInZ0Q29udGV4dCIsInNldFZ0Q29udGV4dCIsInJlbmRlckRmZCIsInNldFJlbmRlckRmZCIsInRyYW5zaXRpb24iLCJzZXRUcmFuc2l0aW9uIiwiaW50ZXJydXB0aW9uIiwic2V0SW50ZXJydXB0aW9uIiwiZmV0Y2hlckRhdGEiLCJzZXRTdGF0ZSIsImlzVmlld1RyYW5zaXRpb25BdmFpbGFibGUiLCJzdGFydFZpZXdUcmFuc2l0aW9uIiwic3RhcnRUcmFuc2l0aW9uIiwic2tpcFRyYW5zaXRpb24iLCJ0IiwiZmluaXNoZWQiLCJmaW5hbGx5IiwicmVuZGVyUHJvbWlzZSIsInRyYW5zaXRpb24yIiwic3RhdGUyIiwiTWVtb2l6ZWREYXRhUm91dGVzIiwibWVtbyIsIkRhdGFSb3V0ZXMiLCJoaXN0b3J5UmVmIiwianNvblBhdGgiLCJfcHJvcHMiLCJiYXNlbmFtZVByb3AiLCJsb2NhdGlvblByb3AiLCJzdGF0aWNQcm9wIiwibmF2aWdhdGlvbkNvbnRleHQiLCJsb2NhdGlvbkNvbnRleHQiLCJ0cmFpbGluZ1BhdGhuYW1lIiwiQXdhaXRFcnJvckJvdW5kYXJ5IiwiUmVzb2x2ZUF3YWl0IiwicmVuZGVyRXJyb3IiLCJfdHJhY2tlZCIsInRvUmVuZGVyIiwiQ2hpbGRyZW4iLCJpc1ZhbGlkRWxlbWVudCIsImFwcGx5IiwiQ29tcG9uZW50NCIsIldpdGhDb21wb25lbnRQcm9wcyIsIldpdGhIeWRyYXRlRmFsbGJhY2tQcm9wcyIsIldpdGhFcnJvckJvdW5kYXJ5UHJvcHMiLCJSZWFjdDEwIiwiZGVmYXVsdE1ldGhvZCIsImRlZmF1bHRFbmNUeXBlIiwiaXNIdG1sRWxlbWVudCIsIm9iamVjdCIsInRhZ05hbWUiLCJpc0J1dHRvbkVsZW1lbnQiLCJpc0Zvcm1FbGVtZW50IiwiaXNJbnB1dEVsZW1lbnQiLCJpc01vZGlmaWVkRXZlbnQiLCJldmVudCIsIm1ldGFLZXkiLCJhbHRLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJzaG91bGRQcm9jZXNzTGlua0NsaWNrIiwiYnV0dG9uIiwiZ2V0U2VhcmNoUGFyYW1zRm9yTG9jYXRpb24iLCJsb2NhdGlvblNlYXJjaCIsImRlZmF1bHRTZWFyY2hQYXJhbXMiLCJfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlciIsImlzRm9ybURhdGFTdWJtaXR0ZXJTdXBwb3J0ZWQiLCJzdXBwb3J0ZWRGb3JtRW5jVHlwZXMiLCJnZXRGb3JtRW5jVHlwZSIsImVuY1R5cGUiLCJnZXRGb3JtU3VibWlzc2lvbkluZm8iLCJhdHRyIiwiZm9ybSIsIlJlYWN0OSIsImludmFyaWFudDIiLCJsb2FkUm91dGVNb2R1bGUiLCJyb3V0ZU1vZHVsZXNDYWNoZSIsInJvdXRlTW9kdWxlIiwiX19yZWFjdFJvdXRlckNvbnRleHQiLCJpc1NwYU1vZGUiLCJyZWxvYWQiLCJnZXRLZXllZExpbmtzRm9yTWF0Y2hlcyIsInJvdXRlTW9kdWxlcyIsImRlc2NyaXB0b3JzIiwibW9kdWxlMiIsImNzcyIsInJlbCIsImxpbmtzIiwiZmxhdCIsInByZWxvYWRzIiwiZ2V0TW9kdWxlTGlua0hyZWZzIiwiZGVkdXBlTGlua0Rlc2NyaXB0b3JzIiwiZ2V0Um91dGVDc3NEZXNjcmlwdG9ycyIsInByZWZldGNoUm91dGVDc3MiLCJwcmVmZXRjaFN0eWxlTGluayIsInByZWZldGNoU3R5bGVMaW5rcyIsImlzUHJlbG9hZFN1cHBvcnRlZCIsInN0eWxlTGlua3MiLCJkZXNjcmlwdG9yIiwiaXNQYWdlTGlua0Rlc2NyaXB0b3IiLCJhcyIsIm1lZGlhIiwibWF0Y2hNZWRpYSIsImxpbmsiLCJyZW1vdmVMaW5rIiwiaGVhZCIsImNvbnRhaW5zIiwicmVtb3ZlQ2hpbGQiLCJvbmxvYWQiLCJvbmVycm9yIiwiYXBwZW5kQ2hpbGQiLCJwYWdlIiwiaXNIdG1sTGlua0Rlc2NyaXB0b3IiLCJpbWFnZVNyY1NldCIsImltYWdlU2l6ZXMiLCJnZXRLZXllZFByZWZldGNoTGlua3MiLCJnZXROZXdNYXRjaGVzRm9yTGlua3MiLCJuZXh0TWF0Y2hlcyIsImN1cnJlbnRNYXRjaGVzIiwibW9kZSIsIm1hdGNoUGF0aENoYW5nZWQiLCJtYW5pZmVzdFJvdXRlIiwiaGFzTG9hZGVyIiwiaW5jbHVkZUh5ZHJhdGVGYWxsYmFjayIsImRlZHVwZUhyZWZzIiwiaHJlZnMiLCJjbGllbnRBY3Rpb25Nb2R1bGUiLCJjbGllbnRMb2FkZXJNb2R1bGUiLCJoeWRyYXRlRmFsbGJhY2tNb2R1bGUiLCJpbXBvcnRzIiwic29ydEtleXMiLCJzb3J0ZWQiLCJwcmVsb2Fkc1NldCIsImRlZHVwZWQiLCJhbHJlYWR5TW9kdWxlUHJlbG9hZCIsIl9pc1ByZWxvYWRTdXBwb3J0ZWQiLCJlbCIsInJlbExpc3QiLCJzdXBwb3J0cyIsIkVTQ0FQRV9MT09LVVAiLCJFU0NBUEVfUkVHRVgiLCJlc2NhcGVIdG1sIiwiaHRtbCIsImNyZWF0ZUh0bWwiLCJfX2h0bWwiLCJSZWFjdDQiLCJIT0xFIiwiTkFOIiwiTkVHQVRJVkVfSU5GSU5JVFkiLCJORUdBVElWRV9aRVJPIiwiTlVMTCIsIlBPU0lUSVZFX0lORklOSVRZIiwiVU5ERUZJTkVEIiwiVFlQRV9CSUdJTlQiLCJUWVBFX0RBVEUiLCJUWVBFX0VSUk9SIiwiVFlQRV9NQVAiLCJUWVBFX05VTExfT0JKRUNUIiwiVFlQRV9QUk9NSVNFIiwiVFlQRV9SRUdFWFAiLCJUWVBFX1NFVCIsIlRZUEVfU1lNQk9MIiwiVFlQRV9VUkwiLCJUWVBFX1BSRVZJT1VTX1JFU09MVkVEIiwiRGVmZXJyZWQyIiwiY3JlYXRlTGluZVNwbGl0dGluZ1RyYW5zZm9ybSIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsImxlZnRvdmVyIiwiVHJhbnNmb3JtU3RyZWFtIiwidHJhbnNmb3JtIiwiY2h1bmsiLCJzdHIiLCJkZWNvZGUiLCJzdHJlYW0iLCJwYXJ0cyIsInBhcnQiLCJlbnF1ZXVlIiwiZmx1c2giLCJmbGF0dGVuIiwiaW5wdXQiLCJpbmRpY2VzIiwiZXhpc3RpbmciLCJOdW1iZXIiLCJpc05hTiIsImRlZmVycmVkIiwicGx1Z2lucyIsInBvc3RQbHVnaW5zIiwic3RyaW5naWZpZWQiLCJpbnB1dDIiLCJwYXJ0c0Zvck9iaiIsImtleUZvciIsInBsdWdpbkhhbmRsZWQiLCJwbHVnaW4iLCJwbHVnaW5SZXN1bHQiLCJwbHVnaW5JZGVudGlmaWVyIiwiRGF0ZSIsImdldFRpbWUiLCJzb3VyY2UiLCJmbGFncyIsImlzUGxhaW5PYmplY3QiLCJvYmplY3RQcm90b05hbWVzIiwidGhpbmciLCJwcm90byIsImdsb2JhbE9iaiIsImdsb2JhbFRoaXMiLCJ1bmZsYXR0ZW4iLCJwYXJzZWQiLCJoeWRyYXRlZCIsIlN5bnRheEVycm9yIiwicG9zdFJ1biIsIk5hTiIsIkluZmluaXR5IiwiYyIsIkJpZ0ludCIsImZvciIsIm5ld1NldCIsImQiLCJlcnJvclR5cGUiLCJ2YWxzIiwidjIiLCJyZWFkYWJsZSIsImRvbmUiLCJyZWFkZXIiLCJwaXBlVGhyb3VnaCIsImdldFJlYWRlciIsImRlY29kZUluaXRpYWwiLCJkb25lUHJvbWlzZSIsImRlY29kZURlZmVycmVkIiwiY2xvc2VkIiwicmVhZCIsImxpbmUiLCJjb2xvbkluZGV4IiwiZGVmZXJyZWRJZCIsImxpbmVEYXRhIiwianNvbkxpbmUiLCJlbmNvZGUiLCJlbmNvZGVyMiIsInRleHRFbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJsYXN0U2VudEluZGV4IiwiUmVhZGFibGVTdHJlYW0iLCJzdGFydCIsInNlZW5Qcm9taXNlcyIsInJhY2VEb25lIiwicmFjZVByb21pc2UiLCJyZWplY3RQcm9taXNlIiwicmVzb2x2ZWQiLCJpZDIiLCJjbG9zZSIsImNyZWF0ZVJlcXVlc3RJbml0IiwiU2luZ2xlRmV0Y2hOb1Jlc3VsdEVycm9yIiwiU0lOR0xFX0ZFVENIX1JFRElSRUNUX1NUQVRVUyIsIk5PX0JPRFlfU1RBVFVTX0NPREVTIiwiU3RyZWFtVHJhbnNmZXIiLCJpZGVudGlmaWVyIiwidGV4dERlY29kZXIiLCJub25jZSIsInJlbmRlck1ldGEiLCJkaWRSZW5kZXJTY3JpcHRzIiwic3RyZWFtQ2FjaGUiLCJzY3JpcHRUYWciLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsIlN1c3BlbnNlIiwiZ2V0Um91dGVyIiwic3NyIiwiZ2V0U2luZ2xlRmV0Y2hEYXRhU3RyYXRlZ3lJbXBsIiwiaGFzQ2xpZW50TG9hZGVyIiwiaGFzU2hvdWxkUmV2YWxpZGF0ZSIsImZldGNoQW5kRGVjb2RlVmlhVHVyYm9TdHJlYW0iLCJnZXRSb3V0ZUluZm8iLCJmZXRjaEFuZERlY29kZSIsInNpbmdsZUZldGNoQWN0aW9uU3RyYXRlZ3kiLCJmb3VuZFJldmFsaWRhdGluZ1NlcnZlckxvYWRlciIsIm5vblNzclN0cmF0ZWd5Iiwic2luZ2xlRmV0Y2hMb2FkZXJGZXRjaGVyU3RyYXRlZ3kiLCJzaW5nbGVGZXRjaExvYWRlck5hdmlnYXRpb25TdHJhdGVneSIsInVud3JhcFNpbmdsZUZldGNoUmVzdWx0Iiwicm91dGVzUGFyYW1zIiwiZm91bmRPcHRPdXRSb3V0ZSIsInJvdXRlRGZkcyIsImNyZWF0ZURlZmVycmVkMiIsInNpbmdsZUZldGNoRGZkIiwicmVzb2x2ZVByb21pc2UiLCJzaG91bGRDYWxsIiwiaXNJbml0aWFsTG9hZCIsIl9fcmVhY3RSb3V0ZXJIZHJBY3RpdmUiLCJ0YXJnZXRSb3V0ZXMiLCJidWJibGVNaWRkbGV3YXJlRXJyb3JzIiwic2luZ2xlRmV0Y2hQcm9taXNlIiwiZmV0Y2hlZERhdGEiLCJyb3V0ZVJlc3VsdCIsInN0cmlwSW5kZXhQYXJhbSIsImluZGV4VmFsdWVzVG9LZWVwIiwiaW5kZXhWYWx1ZSIsInRvS2VlcCIsInNpbmdsZUZldGNoVXJsIiwicmVxVXJsIiwidHlwZWQiLCJnbG9iYWwyIiwiQ29uc3RydWN0b3IiLCJSZWFjdDgiLCJSZWFjdDciLCJSZWFjdDUiLCJSZW1peFJvb3REZWZhdWx0RXJyb3JCb3VuZGFyeSIsImlzT3V0c2lkZVJlbWl4QXBwIiwiaGV5RGV2ZWxvcGVyIiwiQm91bmRhcnlTaGVsbCIsInRpdGxlIiwiZm9udFNpemUiLCJlcnJvckluc3RhbmNlIiwiZXJyb3JTdHJpbmciLCJiYWNrZ3JvdW5kIiwiY29sb3IiLCJvdmVyZmxvdyIsInJlbmRlclNjcmlwdHMiLCJ1c2VGcmFtZXdvcmtDb250ZXh0Iiwicm9vdCIsIkxheW91dCIsImxhbmciLCJjaGFyU2V0IiwiY29udGVudCIsImZvbnRGYW1pbHkiLCJSZWFjdDYiLCJSZW1peFJvb3REZWZhdWx0SHlkcmF0ZUZhbGxiYWNrIiwiZ3JvdXBSb3V0ZXNCeVBhcmVudElkIiwicGFyZW50SWQiLCJnZXRSb3V0ZUNvbXBvbmVudHMiLCJnZXRSb3V0ZU1vZHVsZUNvbXBvbmVudCIsImNyZWF0ZVNlcnZlclJvdXRlcyIsInJvdXRlc0J5UGFyZW50SWQiLCJzcGFNb2RlTGF6eVByb21pc2UiLCJkYXRhUm91dGUiLCJuZWVkc1JldmFsaWRhdGlvbiIsImluaXRpYWxTdGF0ZSIsInByZXZlbnRJbnZhbGlkU2VydmVySGFuZGxlckNhbGwiLCJoYXNBY3Rpb24iLCJub0FjdGlvbkRlZmluZWRFcnJvciIsImFydGljbGUiLCJmZXRjaFNlcnZlckhhbmRsZXIiLCJzaW5nbGVGZXRjaCIsImZldGNoU2VydmVyTG9hZGVyIiwiZmV0Y2hTZXJ2ZXJBY3Rpb24iLCJwcmVmZXRjaE1vZHVsZSIsIm1vZHVsZVBhdGgiLCJwcmVmZXRjaFJvdXRlTW9kdWxlQ2h1bmtzIiwicm91dGUyIiwicHJlZmV0Y2hTdHlsZXNBbmRDYWxsSGFuZGxlciIsImNhY2hlZE1vZHVsZSIsImxpbmtQcmVmZXRjaFByb21pc2UiLCJ1bnN0YWJsZV9jbGllbnRNaWRkbGV3YXJlIiwiZ2V0U2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uIiwiaGFzSW5pdGlhbERhdGEiLCJpbml0aWFsRGF0YSIsImhhc0luaXRpYWxFcnJvciIsImluaXRpYWxFcnJvciIsImlzSHlkcmF0aW9uUmVxdWVzdCIsImNsaWVudExvYWRlciIsInNlcnZlckxvYWRlciIsImNsaWVudEFjdGlvbiIsInNlcnZlckFjdGlvbiIsImhhc0NsaWVudEFjdGlvbiIsImdldExhenlSb3V0ZSIsInNldFRpbWVvdXQiLCJyb3V0ZU1vZHVsZVByb21pc2UiLCJsb2FkUm91dGVNb2R1bGVXaXRoQmxvY2tpbmdMaW5rcyIsImNsaWVudEFjdGlvblByb21pc2UiLCJoYXNDbGllbnRNaWRkbGV3YXJlIiwiY2xpZW50TWlkZGxld2FyZU1vZHVsZSIsIndyYXBTaG91bGRSZXZhbGlkYXRlRm9ySGRyIiwibXlQYXJhbXMiLCJkaWRQYXJhbXNDaGFuZ2UiLCJyb3V0ZVNob3VsZFJldmFsaWRhdGUiLCJoYW5kbGVkUmV2YWxpZGF0aW9uIiwicHJlZmV0Y2hSb3V0ZUNzc1Byb21pc2UiLCJkZWZhdWx0IiwiaXNFbXB0eU9iamVjdCIsIm5leHRQYXRocyIsImRpc2NvdmVyZWRQYXRoc01heFNpemUiLCJkaXNjb3ZlcmVkUGF0aHMiLCJVUkxfTElNSVQiLCJpc0ZvZ09mV2FyRW5hYmxlZCIsInJvdXRlRGlzY292ZXJ5IiwiZ2V0UGFydGlhbE1hbmlmZXN0Iiwic3JpIiwicm91dGVJZHMiLCJpbml0aWFsUm91dGVzIiwiZmV0Y2hBbmRBcHBseU1hbmlmZXN0UGF0Y2hlcyIsIm1hbmlmZXN0UGF0aCIsImNvbm5lY3Rpb24iLCJzYXZlRGF0YSIsInJlZ2lzdGVyRWxlbWVudCIsImZldGNoUGF0Y2hlcyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJsYXp5UGF0aHMiLCJkZWJvdW5jZWRGZXRjaFBhdGNoZXMiLCJkZWJvdW5jZSIsIm9ic2VydmVyIiwiTXV0YXRpb25PYnNlcnZlciIsIm9ic2VydmUiLCJkb2N1bWVudEVsZW1lbnQiLCJzdWJ0cmVlIiwiY2hpbGRMaXN0IiwiYXR0cmlidXRlcyIsImF0dHJpYnV0ZUZpbHRlciIsImRpc2Nvbm5lY3QiLCJnZXRNYW5pZmVzdFBhdGgiLCJfbWFuaWZlc3RQYXRoIiwiTUFOSUZFU1RfVkVSU0lPTl9TVE9SQUdFX0tFWSIsImVycm9yUmVsb2FkUGF0aCIsInZlcnNpb24iLCJzZXJ2ZXJQYXRjaGVzIiwib2siLCJyZW1vdmVJdGVtIiwia25vd25Sb3V0ZXMiLCJwYXRjaGVzIiwiYWRkVG9GaWZvUXVldWUiLCJwYXJlbnRJZHMiLCJxdWV1ZSIsImNhbGxiYWNrIiwid2FpdCIsInRpbWVvdXRJZCIsImNsZWFyVGltZW91dCIsInVzZURhdGFSb3V0ZXJDb250ZXh0MiIsInVzZURhdGFSb3V0ZXJTdGF0ZUNvbnRleHQiLCJ1c2VQcmVmZXRjaEJlaGF2aW9yIiwicHJlZmV0Y2giLCJ0aGVpckVsZW1lbnRQcm9wcyIsImZyYW1ld29ya0NvbnRleHQiLCJtYXliZVByZWZldGNoIiwic2V0TWF5YmVQcmVmZXRjaCIsInNob3VsZFByZWZldGNoIiwic2V0U2hvdWxkUHJlZmV0Y2giLCJvbkZvY3VzIiwib25CbHVyIiwib25Nb3VzZUVudGVyIiwib25Nb3VzZUxlYXZlIiwib25Ub3VjaFN0YXJ0IiwicmVmIiwiaXNJbnRlcnNlY3RpbmciLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsInRocmVzaG9sZCIsInNldEludGVudCIsImNhbmNlbEludGVudCIsImNvbXBvc2VFdmVudEhhbmRsZXJzIiwidGhlaXJIYW5kbGVyIiwib3VySGFuZGxlciIsImRlZmF1bHRQcmV2ZW50ZWQiLCJnZXRBY3RpdmVNYXRjaGVzIiwiaXNIeWRyYXRlZCIsImVycm9ySWR4IiwiY3JpdGljYWxDc3MiLCJyb3V0ZXJNYXRjaGVzIiwia2V5ZWRMaW5rcyIsImRhdGFMaW5rUHJvcHMiLCJQcmVmZXRjaFBhZ2VMaW5rc0ltcGwiLCJ1c2VLZXllZFByZWZldGNoTGlua3MiLCJrZXllZFByZWZldGNoTGlua3MiLCJzZXRLZXllZFByZWZldGNoTGlua3MiLCJpbnRlcnJ1cHRlZCIsImxpbmtQcm9wcyIsIm5ld01hdGNoZXNGb3JEYXRhIiwibmV3TWF0Y2hlc0ZvckFzc2V0cyIsImRhdGFIcmVmcyIsIm0yIiwibW9kdWxlSHJlZnMiLCJfbWF0Y2hlcyIsImxlYWZNZXRhIiwiX21hdGNoIiwicm91dGVNZXRhIiwibWV0YVByb3BzIiwiaXNWYWxpZE1ldGFUYWciLCJDb21wIiwiY2hhcnNldCIsImVyciIsInNlcnZlckhhbmRvZmZTdHJpbmciLCJlbmFibGVGb2dPZldhciIsImluaXRpYWxTY3JpcHRzIiwic3RyZWFtU2NyaXB0IiwiY29udGV4dFNjcmlwdCIsInJvdXRlTW9kdWxlc1NjcmlwdCIsImhtciIsInJ1bnRpbWUiLCJyb3V0ZUluZGV4Iiwicm91dGVWYXJOYW1lIiwibWFuaWZlc3RFbnRyeSIsImNodW5rcyIsInZhck5hbWUiLCJjaHVua0ltcG9ydHNTbmlwcGV0IiwibWVyZ2VkQ2h1bmtzU25pcHBldCIsInN1cHByZXNzSHlkcmF0aW9uV2FybmluZyIsImFzeW5jIiwiZGVkdXBlIiwiaW50ZWdyaXR5IiwiY3Jvc3NPcmlnaW4iLCJtZXJnZVJlZnMiLCJyZWZzIiwiaXNCcm93c2VyIiwiX19yZWFjdFJvdXRlclZlcnNpb24iLCJwYXJzZUh5ZHJhdGlvbkRhdGEiLCJfX3N0YXRpY1JvdXRlckh5ZHJhdGlvbkRhdGEiLCJkZXNlcmlhbGl6ZUVycm9ycyIsInNlcmlhbGl6ZWQiLCJfX3R5cGUiLCJfX3N1YlR5cGUiLCJFcnJvckNvbnN0cnVjdG9yIiwiQUJTT0xVVEVfVVJMX1JFR0VYMiIsImZvcndhcmRSZWYiLCJMaW5rV2l0aFJlZiIsIm9uQ2xpY2siLCJkaXNjb3ZlciIsInJlbG9hZERvY3VtZW50IiwiZm9yd2FyZGVkUmVmIiwiYWJzb2x1dGVIcmVmIiwiaXNFeHRlcm5hbCIsInRhcmdldFVybCIsInByZWZldGNoUmVmIiwicHJlZmV0Y2hIYW5kbGVycyIsImludGVybmFsT25DbGljayIsImhhbmRsZUNsaWNrIiwiTmF2TGlua1dpdGhSZWYiLCJhcmlhQ3VycmVudFByb3AiLCJjbGFzc05hbWUiLCJjbGFzc05hbWVQcm9wIiwic3R5bGVQcm9wIiwicm91dGVyU3RhdGUiLCJuZXh0TG9jYXRpb25QYXRobmFtZSIsImVuZFNsYXNoUG9zaXRpb24iLCJpc0FjdGl2ZSIsImlzUGVuZGluZyIsInJlbmRlclByb3BzIiwiYXJpYUN1cnJlbnQiLCJvblN1Ym1pdCIsInN1Ym1pdEhhbmRsZXIiLCJwcmV2ZW50RGVmYXVsdCIsInN1Ym1pdHRlciIsIm5hdGl2ZUV2ZW50Iiwic3VibWl0TWV0aG9kIiwiY3VycmVudFRhcmdldCIsInN0b3JhZ2VLZXkiLCJyZW1peENvbnRleHQiLCJzc3JLZXkiLCJ1c2VyS2V5IiwiZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkiLCJyZXN0b3JlU2Nyb2xsIiwic3RvcmFnZUtleTIiLCJyZXN0b3JlS2V5Iiwic3RvcmVkWSIsInNjcm9sbFRvIiwiU0NST0xMX1JFU1RPUkFUSU9OX1NUT1JBR0VfS0VZIiwiZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcjIiLCJ1c2VEYXRhUm91dGVyQ29udGV4dDMiLCJ1c2VEYXRhUm91dGVyU3RhdGUyIiwicmVwbGFjZVByb3AiLCJkZWZhdWx0SW5pdCIsImRlZmF1bHRTZWFyY2hQYXJhbXNSZWYiLCJoYXNTZXRTZWFyY2hQYXJhbXNSZWYiLCJzZXRTZWFyY2hQYXJhbXMiLCJuZXh0SW5pdCIsIm5hdmlnYXRlT3B0aW9ucyIsIm5ld1NlYXJjaFBhcmFtcyIsImZldGNoZXJJZCIsImdldFVuaXF1ZUZldGNoZXJJZCIsImN1cnJlbnRSb3V0ZUlkIiwiaGFzTmFrZWRJbmRleFBhcmFtIiwiZGVmYXVsdEtleSIsInVzZUlkIiwic2V0RmV0Y2hlcktleSIsImxvYWQiLCJzdWJtaXRJbXBsIiwiRmV0Y2hlckZvcm0iLCJGZXRjaGVyRm9ybTIiLCJmZXRjaGVyV2l0aENvbXBvbmVudHMiLCJzYXZlZFNjcm9sbFBvc2l0aW9ucyIsInNjcm9sbFJlc3RvcmF0aW9uIiwidXNlUGFnZUhpZGUiLCJzY3JvbGxZIiwiZGlzYWJsZVNjcm9sbFJlc3RvcmF0aW9uIiwiZ2V0RWxlbWVudEJ5SWQiLCJzY3JvbGxJbnRvVmlldyIsImNhcHR1cmUiLCJ3aGVuIiwiY29uZmlybSIsIm5leHRQYXRoIiwiUmVhY3QxMSIsInN0YXRpY05hdmlnYXRvciIsImdldFN0YXRlbGVzc05hdmlnYXRvciIsImh5ZHJhdGUyIiwiZmV0Y2hlcnNDb250ZXh0IiwiaHlkcmF0ZVNjcmlwdCIsInNlcmlhbGl6ZUVycm9ycyIsImh0bWxFc2NhcGUiLCJEYXRhUm91dGVzMiIsImJhY2siLCJmb3J3YXJkIiwiZW5jb2RlZCIsIkFCU09MVVRFX1VSTF9SRUdFWDMiLCJFU0NBUEVfTE9PS1VQMiIsIkVTQ0FQRV9SRUdFWDIiLCJSZWFjdDEyIiwic3RhdGljSGFuZGxlckNvbnRleHQiLCJzZXJpYWxpemVFcnJvciIsInNlcnZlckhhbmRvZmZTdHJlYW0iLCJSZWFjdDEzIiwiUm91dGVzVGVzdFN0dWIiLCJyb3V0ZXJSZWYiLCJyZW1peENvbnRleHRSZWYiLCJ1bnN0YWJsZV9zdWJSZXNvdXJjZUludGVncml0eSIsInBhdGNoZWQiLCJwcm9jZXNzUm91dGVzIiwiZW50cnlSb3V0ZSIsImltcG9ydF9jb29raWUiLCJlbmNvZGVyIiwic2lnbiIsInNlY3JldCIsImNyZWF0ZUtleTIiLCJzaWduYXR1cmUiLCJjcnlwdG8iLCJzdWJ0bGUiLCJidG9hIiwiZnJvbUNoYXJDb2RlIiwiVWludDhBcnJheSIsInVuc2lnbiIsImNvb2tpZSIsImxhc3RJbmRleE9mIiwiYnl0ZVN0cmluZ1RvVWludDhBcnJheSIsImF0b2IiLCJ2YWxpZCIsInZlcmlmeSIsInVzYWdlcyIsImltcG9ydEtleSIsImJ5dGVTdHJpbmciLCJjaGFyQ29kZUF0IiwiY29va2llT3B0aW9ucyIsInNlY3JldHMiLCJzYW1lU2l0ZSIsIndhcm5PbmNlQWJvdXRFeHBpcmVzQ29va2llIiwiZXhwaXJlcyIsImlzU2lnbmVkIiwibWF4QWdlIiwibm93IiwiY29va2llSGVhZGVyIiwicGFyc2VPcHRpb25zIiwiY29va2llcyIsImRlY29kZUNvb2tpZVZhbHVlIiwic2VyaWFsaXplIiwic2VyaWFsaXplT3B0aW9ucyIsImVuY29kZUNvb2tpZVZhbHVlIiwiZW5jb2RlRGF0YSIsInVuc2lnbmVkVmFsdWUiLCJkZWNvZGVEYXRhIiwibXlVbmVzY2FwZSIsImVuY29kZVVSSUNvbXBvbmVudCIsIm15RXNjYXBlIiwiY2hyIiwiY29kZSIsImV4ZWMiLCJoZXgiLCJwYXJzZUludCIsImNyZWF0ZUVudHJ5Um91dGVNb2R1bGVzIiwiU2VydmVyTW9kZTIiLCJpc1NlcnZlck1vZGUiLCJzYW5pdGl6ZUVycm9yIiwic2VydmVyTW9kZSIsInNhbml0aXplZCIsInNhbml0aXplRXJyb3JzIiwic2VyaWFsaXplRXJyb3JzMiIsIm1hdGNoU2VydmVyUm91dGVzIiwiY2FsbFJvdXRlSGFuZGxlciIsInN0cmlwUm91dGVzUGFyYW0iLCJzdHJpcEluZGV4UGFyYW0yIiwiZHVwbGV4IiwiaW52YXJpYW50MyIsImdsb2JhbERldlNlcnZlckhvb2tzS2V5IiwiZGV2U2VydmVySG9va3MiLCJnZXREZXZTZXJ2ZXJIb29rcyIsImdldEJ1aWxkVGltZUhlYWRlciIsImhlYWRlck5hbWUiLCJwcm9jZXNzIiwiZW52IiwiSVNfUlJfQlVJTERfUkVRVUVTVCIsImdyb3VwUm91dGVzQnlQYXJlbnRJZDIiLCJjcmVhdGVSb3V0ZXMiLCJjcmVhdGVTdGF0aWNIYW5kbGVyRGF0YVJvdXRlcyIsImNvbW1vblJvdXRlIiwicHJlUmVuZGVyZWREYXRhIiwiZGVjb2RlVVJJIiwidWludDhhcnJheSIsImdsb2JhbCIsIkVTQ0FQRV9MT09LVVAzIiwiRVNDQVBFX1JFR0VYMyIsImVzY2FwZUh0bWwyIiwiY3JlYXRlU2VydmVySGFuZG9mZlN0cmluZyIsInNlcnZlckhhbmRvZmYiLCJpbXBvcnRfc2V0X2Nvb2tpZV9wYXJzZXIiLCJnZXREb2N1bWVudEhlYWRlcnMiLCJidWlsZCIsImdldERvY3VtZW50SGVhZGVyc0ltcGwiLCJnZXRSb3V0ZUhlYWRlcnNGbiIsImJvdW5kYXJ5SWR4IiwiZXJyb3JIZWFkZXJzIiwicGFyZW50SGVhZGVycyIsImluY2x1ZGVFcnJvckhlYWRlcnMiLCJpbmNsdWRlRXJyb3JDb29raWVzIiwiaGVhZGVyc0ZuIiwiaGVhZGVyczIiLCJwcmVwZW5kQ29va2llcyIsImNoaWxkSGVhZGVycyIsInBhcmVudFNldENvb2tpZVN0cmluZyIsInNwbGl0Q29va2llc1N0cmluZyIsImNoaWxkQ29va2llcyIsImdldFNldENvb2tpZSIsIlNFUlZFUl9OT19CT0RZX1NUQVRVU19DT0RFUyIsInNpbmdsZUZldGNoQWN0aW9uIiwic3RhdGljSGFuZGxlciIsImhhbmRsZXJVcmwiLCJsb2FkQ29udGV4dCIsImhhbmRsZUVycm9yIiwicmVzcG9uZDIiLCJnZW5lcmF0ZVNpbmdsZUZldGNoUmVzcG9uc2UiLCJnZXRTaW5nbGVGZXRjaFJlZGlyZWN0Iiwic2luZ2xlRmV0Y2hSZXN1bHQiLCJoYW5kbGVyUmVxdWVzdCIsInNpbmdsZUZldGNoTG9hZGVycyIsImxvYWRlZE1hdGNoZXMiLCJsb2FkUm91dGVJZHMiLCJyb3V0ZXNQYXJhbSIsInJlc3VsdEhlYWRlcnMiLCJlbmNvZGVWaWFUdXJib1N0cmVhbSIsInN0cmVhbVRpbWVvdXQiLCJyZXF1ZXN0U2lnbmFsIiwiZGF0YTMiLCJmcm9tRW50cmllcyIsImRlcml2ZSIsIl9idWlsZCIsInJlcXVlc3RIYW5kbGVyIiwiaW5pdGlhbENvbnRleHQiLCJkZXJpdmVkIiwicHJvY2Vzc1JlcXVlc3RFcnJvciIsInJldHVybkxhc3RSZXNvcnRFcnJvclJlc3BvbnNlIiwibm9ybWFsaXplZEJhc2VuYW1lIiwicHJlcmVuZGVyIiwibWFuaWZlc3RVcmwiLCJoYW5kbGVNYW5pZmVzdFJlcXVlc3QiLCJzaW5nbGVGZXRjaE1hdGNoZXMiLCJoYW5kbGVTaW5nbGVGZXRjaFJlcXVlc3QiLCJoYW5kbGVEYXRhUmVxdWVzdCIsImhhbmRsZVJlc291cmNlUmVxdWVzdCIsInVuc3RhYmxlX2dldENyaXRpY2FsQ3NzIiwiZ2V0Q3JpdGljYWxDc3MiLCJoYW5kbGVEb2N1bWVudFJlcXVlc3QiLCJhc3NldHMiLCJwYXJ0aWFsUGF0aCIsInJlbmRlckh0bWwiLCJpc1NwYU1vZGUyIiwiYmFzZVNlcnZlckhhbmRvZmYiLCJlbnRyeUNvbnRleHQiLCJoYW5kbGVEb2N1bWVudFJlcXVlc3RGdW5jdGlvbiIsImVycm9yRm9yU2Vjb25kUmVuZGVyIiwidW53cmFwUmVzcG9uc2UiLCJlcnJvclJlc3BvbnNlVG9Kc29uIiwibmV3RXJyb3IiLCJlcnJvclJlc3BvbnNlIiwiZmxhc2giLCJmbGFzaE5hbWUiLCJ1bnNldCIsImNvb2tpZUFyZyIsImNyZWF0ZURhdGEiLCJyZWFkRGF0YSIsInVwZGF0ZURhdGEiLCJkZWxldGVEYXRhIiwid2Fybk9uY2VBYm91dFNpZ25pbmdTZXNzaW9uQ29va2llIiwiZ2V0U2Vzc2lvbiIsImNvbW1pdFNlc3Npb24iLCJzZXNzaW9uIiwiZGVzdHJveVNlc3Npb24iLCJzZXJpYWxpemVkQ29va2llIiwiX3Nlc3Npb24iLCJpc1JlcXVpcmVkIiwicm91dGVJbmZvIiwiaGFzSHlkcmF0ZUZhbGxiYWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-router/dist/development/index.js\n");

/***/ })

};
;